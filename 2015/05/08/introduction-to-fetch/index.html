<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>fetch API 简介 | bubkoo</title><meta name="author" content="bubkoo"><meta name="description" content="十多年来，我们一直使用 XMLHttpRequest（XHR）来发送异步请求，XHR 很实用，但并不是一个设计优良的 API，在设计上并不符合职责分离原则，输入、输出以及状态都杂糅在同一对象中，并用事件机制来跟踪状态变化。并且，基于事件的模型与最近流行的 Promise 和 generator 异步编程模型不太友好。
Fetch API 旨在修正上述缺陷，它提供了与 HTTP 语义相同的 JS 语法，简单来说，它引入了 fetch() 这个实用的方法来获取网络资源。
在 Fetch 规范中对 API 进行了定义，它结合 ServiceWorkers，尝试做到如下优化：

改善离线体验
保持可扩展性

写这篇文章时，Fetch API 已被 Firefox 39（Nightly）以及 Chrome 42（dev）支持。在 github 上有相应的 polyfill。"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:title" content="fetch API 简介"><meta property="og:site_name" content="bubkoo"><link href="/favicon.ico" rel="icon" type="image/x-ico"><link href="/atom.xml" rel="alternate" title="bubkoo" type="application/atom+xml"><link href="/css/style.css" rel="stylesheet" type="text/css" charset="utf-8"><link href="/fancybox/jquery.fancybox.css" rel="stylesheet" type="text/css" charset="utf-8"><script id="google_analytics">(function (window, document, src, ga) {

  window['GoogleAnalyticsObject'] = ga;

  if (!window[ga]) {
    window[ga] = function () {
      (window[ga].q = window[ga].q || []).push(arguments);
    };
  }

  window[ga].l = 1 * new Date();

  var thisTag = document.getElementById('google_analytics');
  var script  = document.createElement('script');

  script.async = true;
  script.src   = src;

  thisTag.parentNode.insertBefore(script, thisTag);

  setTimeout(function () {
    script.parentNode.removeChild(script);
    thisTag.parentNode.removeChild(thisTag);
  }, 100);

})(window, document, 'https://www.google-analytics.com/analytics.js', 'ga');

ga('create', 'UA-78428859-2', 'auto');
ga('send', 'pageview');</script><script id="baidu_tongji">var _hmt = _hmt || [];
(function () {
  var script  = document.createElement('script');
  var thisTag = document.getElementById('baidu_tongji');

  script.src = '//hm.baidu.com/hm.js?49a1665c33b011585a2a629fdbed5b61';

  thisTag.parentNode.insertBefore(script, thisTag);

  setTimeout(function () {
    script.parentNode.removeChild(script);
    thisTag.parentNode.removeChild(thisTag);
  }, 100);
})();</script><!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]--><script>__start__ = window.performance && performance.timing ? performance.timing.navigationStart : Date.now();</script></head><body><header id="header" hoot="default" hoot-rate="1" class="inner"><div class="f-left"><a href="/" class="site-title">bubkoo</a></div><nav class="f-right"><ul class="site-nav"><li><a href="/">&lt;&gt;</a></li><li><a href="/archives">Archives</a></li><li><a href="https://github.com/bubkoo">Github</a></li></ul></nav></header><div id="container" class="inner"><div id="main"><article class="article post"><div class="article-wrap"><header class="article-header"><span class="article-header-icon icon-black"></span><h1 class="article-header-title">fetch API 简介</h1><time datetime="2015-05-08T11:39:23.000Z" itemprop="datePublished" class="article-header-time"><span class="day">08</span><span class="month">2015年05月</span></time></header><section class="article-gallery"><div class="article-gallery-photos"><img src="http://bubkoo.qiniudn.com/images/introduction-to-fetch-small.png" itemprop="image"></div></section><section class="article-content"><p>十多年来，我们一直使用 XMLHttpRequest（XHR）来发送异步请求，XHR 很实用，但并不是一个设计优良的 API，在设计上并不符合职责分离原则，输入、输出以及状态都杂糅在同一对象中，并用事件机制来跟踪状态变化。并且，基于事件的模型与最近流行的 Promise 和 generator 异步编程模型不太友好。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="external">Fetch API</a> 旨在修正上述缺陷，它提供了与 HTTP 语义相同的 JS 语法，简单来说，它引入了 <code>fetch()</code> 这个实用的方法来获取网络资源。</p>
<p>在 <a href="https://fetch.spec.whatwg.org/" target="_blank" rel="external">Fetch 规范</a>中对 API 进行了定义，它结合 ServiceWorkers，尝试做到如下优化：</p>
<ol>
<li>改善离线体验</li>
<li>保持可扩展性</li>
</ol>
<p>写这篇文章时，Fetch API 已被 Firefox 39（Nightly）以及 Chrome 42（dev）支持。在 github 上有相应的 <a href="https://github.com/github/fetch" target="_blank" rel="external">polyfill</a>。</p>
<a id="more"></a>
<h2 id="特征检查"><a href="#特征检查" class="headerlink" title="特征检查"></a>特征检查</h2><p>可以通过检查 <code>Headers</code>、<code>Request</code>、<code>Response</code> 或 <code>fetch</code> 在 window 或 worker 作用域中是否存在，来检查是否支持 Fetch API。</p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>Fetch API 中最常用的是 <code>fetch()</code> 方法，该方法最简单的形式是，接受一个 URL 参数并返回以一个 promise 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">"/data.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="comment">// res instanceof Response == true.</span></div><div class="line">  <span class="keyword">if</span> (res.ok) &#123;</div><div class="line">    res.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(data.entries);</div><div class="line">    &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Looks like the response wasn't perfect, got status"</span>, res.status);</div><div class="line">  &#125;</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Fetch failed!"</span>, e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果是提交一个POST请求，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">"http://www.example.org/submit.php"</span>, &#123;</div><div class="line">  <span class="attr">method</span>: <span class="string">"POST"</span>,</div><div class="line">  <span class="attr">headers</span>: &#123;</div><div class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">body</span>: <span class="string">"firstName=Nikhil&amp;favColor=blue&amp;password=easytoguess"</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (res.ok) &#123;</div><div class="line">    alert(<span class="string">"Perfect! Your settings are saved."</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.status == <span class="number">401</span>) &#123;</div><div class="line">    alert(<span class="string">"Oops! You are not authorized."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  alert(<span class="string">"Error submitting form!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>fetch()</code> 方法的参数和 <code>Request()</code> 构造函数的参数完全一致，所以你可以传任意复杂的参数来实现更强大的 <code>fetch()</code>，下面将详细介绍。</p>
<h2 id="headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h2><p>Fetch 引入了 3 个接口，分别是 <code>Headers</code>，<code>Request</code> 和 <code>Response</code>。他们直接对应于的 HTTP 中相应的概念，但是基于隐私和安全考虑，也有些区别，例如支持 CORS 规则以及保证 cookies 不能被第三方获取。</p>
<p> <a href="https://fetch.spec.whatwg.org/#headers-class" target="_blank" rel="external">Headers 接口</a>是一个简单的键值对：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> content = <span class="string">"Hello World"</span>;</div><div class="line"><span class="keyword">var</span> reqHeaders = <span class="keyword">new</span> Headers();</div><div class="line">reqHeaders.append(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span></div><div class="line">reqHeaders.append(<span class="string">"Content-Length"</span>, content.length.toString());</div><div class="line">reqHeaders.append(<span class="string">"X-Custom-Header"</span>, <span class="string">"ProcessThisImmediately"</span>);</div></pre></td></tr></table></figure>
<p>也可以给构造函数传一个多维数组或 JS 字面量对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">reqHeaders = <span class="keyword">new</span> Headers(&#123;</div><div class="line">  <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>,</div><div class="line">  <span class="string">"Content-Length"</span>: content.length.toString(),</div><div class="line">  <span class="string">"X-Custom-Header"</span>: <span class="string">"ProcessThisImmediately"</span>,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Headers 的内容可被检索：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(reqHeaders.has(<span class="string">"Content-Type"</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(reqHeaders.has(<span class="string">"Set-Cookie"</span>)); <span class="comment">// false</span></div><div class="line">reqHeaders.set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>);</div><div class="line">reqHeaders.append(<span class="string">"X-Custom-Header"</span>, <span class="string">"AnotherValue"</span>);</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(reqHeaders.get(<span class="string">"Content-Length"</span>)); <span class="comment">// 11</span></div><div class="line"><span class="built_in">console</span>.log(reqHeaders.getAll(<span class="string">"X-Custom-Header"</span>)); <span class="comment">// ["ProcessThisImmediately", "AnotherValue"]</span></div><div class="line"> </div><div class="line">reqHeaders.delete(<span class="string">"X-Custom-Header"</span>);</div><div class="line"><span class="built_in">console</span>.log(reqHeaders.getAll(<span class="string">"X-Custom-Header"</span>)); <span class="comment">// []</span></div></pre></td></tr></table></figure>
<p>一些操作只在 ServiceWorkers 中可用，但这些 API 使得操作 header 更为方便。</p>
<p>由于 header 可以在发送请求时被发送或在收到响应时被接收，并规定了那些参数可写，所以在 <code>Headers</code> 对象中有个一 <code>guard</code> 属性，来指定哪些参数可以被改变。</p>
<p>可能的值如下：</p>
<ul>
<li><code>&quot;none&quot;</code>：默认值</li>
<li><code>&quot;request&quot;</code>：<code>Request.headers</code> 对象只读</li>
<li><code>&quot;request-no-cors&quot;</code>：在 <code>no-cors</code> 模式下，<code>Request.headers</code> 对象只读</li>
<li><code>&quot;response&quot;</code>：<code>Response.headers</code> 对象只读</li>
<li><code>&quot;immutable&quot;</code>：通常在 ServiceWorkers 中使用，所有 Header 对象都为只读</li>
</ul>
<p>在<a href="https://fetch.spec.whatwg.org/" target="_blank" rel="external">规范</a>中对每个 <code>guard</code> 属性值有更详细的描述。例如，当 <code>guard</code> 为 <code>request</code> 时，你将不能添加或修改header 的 <code>Content-Length</code> 属性。</p>
<p>如果使用了一个不合法的 <a href="https://fetch.spec.whatwg.org/#concept-header-name" target="_blank" rel="external">HTTP Header 名</a>，那么 Headers 的方法通常都抛出 TypeError 异常。如果不小心写入了一个只读属性，也会抛出一个 TypeError 异常。除此以外，失败了将不抛出任何异常。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = Response.error();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  res.headers.set(<span class="string">"Origin"</span>, <span class="string">"http://mybank.com"</span>);</div><div class="line">&#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Cannot pretend to be a bank!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>通过构造一个 <code>Request</code> 对象来获取网络资源，构造函数需要 <code>URL</code>、<code>method</code> 和 <code>headers</code> 参数，同时也可以提供请求体（body）、请求模式（mode）、<code>credentials</code> 和 <code>cache hints</code> 等参数。</p>
<p>最简单的形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> Request(<span class="string">"/index.html"</span>);</div><div class="line"><span class="built_in">console</span>.log(req.method); <span class="comment">// "GET"</span></div><div class="line"><span class="built_in">console</span>.log(req.url); <span class="comment">// "http://example.com/index.html"</span></div></pre></td></tr></table></figure>
<p>也可以将一个 <code>Request</code> 对象传给构造函数，这将返回该对象的一个副本（这与 <code>clone()</code> 方法不同，后面将介绍）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> copy = <span class="keyword">new</span> Request(req);</div><div class="line"><span class="built_in">console</span>.log(copy.method); <span class="comment">// "GET"</span></div><div class="line"><span class="built_in">console</span>.log(copy.url); <span class="comment">// "http://example.com/index.html"</span></div></pre></td></tr></table></figure>
<p>同时，这种形式通常只在 ServiceWorkers 中使用。</p>
<p>除 <code>URL</code> 之外的参数只能通过第二个参数传递，该参数是一个键值对：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> uploadReq = <span class="keyword">new</span> Request(<span class="string">"/uploadImage"</span>, &#123;</div><div class="line">  <span class="attr">method</span>: <span class="string">"POST"</span>,</div><div class="line">  <span class="attr">headers</span>: &#123;</div><div class="line">    <span class="string">"Content-Type"</span>: <span class="string">"image/png"</span>,</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">body</span>: <span class="string">"image data"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>mode</code> 参数用来决定是否允许跨域请求，以及哪些 <code>response</code> 属性可读。可选的 <code>mode</code> 值为 <code>&quot;same-origin&quot;</code>、<code>&quot;no-cors&quot;</code>（默认）以及 <code>&quot;cors&quot;</code>。</p>
<h3 id="same-origin"><a href="#same-origin" class="headerlink" title="same-origin"></a>same-origin</h3><p>该模式很简单，如果一个请求是跨域的，那么将返回一个 <code>error</code>，这样确保所有的请求遵守同源策略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arbitraryUrl = <span class="built_in">document</span>.getElementById(<span class="string">"url-input"</span>).value;</div><div class="line">fetch(arbitraryUrl, &#123; <span class="attr">mode</span>: <span class="string">"same-origin"</span> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Response succeeded?"</span>, res.ok);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Please enter a same-origin URL!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="no-cors"><a href="#no-cors" class="headerlink" title="no-cors"></a>no-cors</h3><p>该模式允许来自 CDN 的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的 method 只能是<code>HEAD</code>、<code>GET</code> 或 <code>POST</code>。此外，如果 ServiceWorkers 拦截了这些请求，它不能随意添加或者修改除<a href="https://fetch.spec.whatwg.org/#simple-header" target="_blank" rel="external">这些</a>之外 Header 属性。第三，JS 不能访问 Response 对象中的任何属性，这确保了跨域时 ServiceWorkers 的安全和隐私信息泄漏问题。</p>
<h3 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h3><p>该模式通常用于跨域请求，用来从第三方提供的 API 获取数据。该模式遵守 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS 协议</a>，并只有有限的一些 Header 被暴露给 Response 对象，但是 body 是可读的。例如，获取一个 Flickr <a href="https://www.flickr.com/services/api/flickr.interestingness.getList.html" target="_blank" rel="external">最感兴趣</a>的照片的清单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> URLSearchParams();</div><div class="line">u.append(<span class="string">'method'</span>, <span class="string">'flickr.interestingness.getList'</span>);</div><div class="line">u.append(<span class="string">'api_key'</span>, <span class="string">'&lt;insert api key here&gt;'</span>);</div><div class="line">u.append(<span class="string">'format'</span>, <span class="string">'json'</span>);</div><div class="line">u.append(<span class="string">'nojsoncallback'</span>, <span class="string">'1'</span>);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> apiCall = fetch(<span class="string">'https://api.flickr.com/services/rest?'</span> + u);</div><div class="line"> </div><div class="line">apiCall.then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> response.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</div><div class="line">    <span class="comment">// photo is a list of photos.</span></div><div class="line">    <span class="keyword">return</span> json.photos.photo;</div><div class="line">  &#125;);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">photos</span>) </span>&#123;</div><div class="line">  photos.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">photo</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(photo.title);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>你将无法从 Headers 中读取 <code>Date</code> 属性，因为 Flickr 在 <code>Access-Control-Expose-Headers</code> 中设置了不允许读取它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.headers.get(<span class="string">"Date"</span>); <span class="comment">// null</span></div></pre></td></tr></table></figure>
<p>另外，<code>credentials</code> 属性决定了是否可以跨域访问 cookie 。该属性与 XHR 的<br><code>withCredentials</code> 标志相同，但是只有三个值，分别是 <code>omit</code>（默认）、<code>same-origin</code> 和 <code>include</code>。</p>
<p>Request 对象也提供了客户端缓存机制（caching hints）。这个属性还在安全复审阶段。Firefox 提供了这个属性，但目前还不起作用。</p>
<p>Request 对象还有两个与 ServiceWorks 拦截有关的只读属性。其中一个是<code>referrer</code>，表示该 Request 的来源，可能为空。另外一个是 <code>context</code>，是一个非常大的<a href="https://fetch.spec.whatwg.org/#requestcredentials" target="_blank" rel="external">枚举集合</a>，定义了获得的资源的种类，它可能是 <code>image</code> 当请求来自于 <code>img</code> 标签时，可能是 <code>worker</code> 如果是一个 Worker 脚本，等等。如果使用 <code>fetch()</code> 函数，这个值是 <code>fetch</code>。</p>
<h2 id="response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>Response 对象通常在 <code>fetch()</code> 的回调中获得，也可以通过 JS 构造，不过这通常只在 ServiceWorkers 中使用。</p>
<p>Response 对象中最常见的属性是 <code>status</code>（整数，默认值是 <code>200</code>）和<code>statusText</code>（默认值是 <code>&quot;OK&quot;</code>）。还有一个 <code>ok</code> 属性，这是 <code>status</code> 值为 <code>200~299</code> 时的语法糖。</p>
<p>另外，还有一个 <code>type</code> 属性，它的值可能是 <code>&quot;basic&quot;</code>、<code>&quot;cors&quot;</code>、<code>&quot;default&quot;</code>、<code>&quot;error&quot;</code> 或 <code>&quot;opaque&quot;</code>。</p>
<ul>
<li><code>&quot;basic&quot;</code>：同域的响应，除 <code>Set-Cookie</code> 和 <code>Set-Cookie2</code> 之外的所有 Header 可用</li>
<li><code>&quot;cors&quot;</code>：Response 从一个合法的跨域请求获得，<a href="https://fetch.spec.whatwg.org/#concept-filtered-response-cors" target="_blank" rel="external">某些</a> Header 和 body 可读</li>
<li><code>&quot;error&quot;</code>：网络错误。Response 对象的 <code>status</code> 属性为 <code>0</code>，<code>headers</code> 属性为空并且不可写。当 Response 对象从 <code>Response.error()</code> 中得到时，就是这种类型</li>
<li><code>&quot;opaque&quot;</code>：在 <code>&quot;no-cors&quot;</code> 模式下请求了跨域资源。依靠<a href="https://fetch.spec.whatwg.org/#concept-filtered-response-opaque" target="_blank" rel="external">服务端来做限制</a></li>
</ul>
<p>当 <code>type</code> 属性值为 <code>&quot;error&quot;</code> 时会导致 <code>fetch()</code> 方法的 Promise 被 reject，reject 回调的参数为 TypeError 对象。</p>
<p>还有一些属性只在 ServerWorker 下有效。在 ServerWorker 下返回一个 Response 的正确方式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  event.respondWith(<span class="keyword">new</span> Response(<span class="string">"Response body"</span>, &#123;</div><div class="line">    <span class="attr">headers</span>: &#123; <span class="string">"Content-Type"</span> : <span class="string">"text/plain"</span> &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如你所见，Response 构造函数接收两个参数：返回的 body 和一个键值对对象，通过该对象来设置 <code>status</code>、<code>statusText</code> 和 <code>headers</code> 属性。</p>
<p>静态方法 <code>Response.error()</code> 将返回一个错误响应，<code>Response.redirect(url, status)</code> 将返回一个跳转响应。</p>
<h2 id="处理-body"><a href="#处理-body" class="headerlink" title="处理 body"></a>处理 body</h2><p>在 Request 和 Response 对象中都可能有 <code>body</code> 属性，并且 <code>body</code> 可以是各种类型，比较复杂，所以前面我们故意先跳过它，在这里单独拿出来讲解。</p>
<p><code>body</code> 可以是以下任何一种类型的实例：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="external">ArrayBuffer</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView" target="_blank" rel="external">ArrayBufferView</a> (Uint8Array and friends)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="external">Blob</a>/<a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank" rel="external">File</a></li>
<li>string</li>
<li><a href="https://url.spec.whatwg.org/#interface-urlsearchparams" target="_blank" rel="external">URLSearchParams</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" target="_blank" rel="external">FormData</a> —— 目前不被 Gecko 和 Blink 支持，Firefox 预计在版本 39 和 Fetch 的其他部分一起推出</li>
</ul>
<p>此外，Request 和 Response 都为操作 <code>body</code> 提供了以下方法，这些方法都返回一个使用实际内容 resolve 的 Promise 对象。</p>
<ul>
<li>arrayBuffer()</li>
<li>blob()</li>
<li>json()</li>
<li>text()</li>
<li>formData()</li>
</ul>
<p>所以，在处理非文本的数据方面，Fetch API 比 XHR 更为便利。</p>
<p>设置请求体：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> form = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.getElementById(<span class="string">'login-form'</span>));</div><div class="line">fetch(<span class="string">"/login"</span>, &#123;</div><div class="line">  <span class="attr">method</span>: <span class="string">"POST"</span>,</div><div class="line">  <span class="attr">body</span>: form</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Responses 构造函数的第一个参数是响应体：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = <span class="keyword">new</span> Response(<span class="keyword">new</span> File([<span class="string">"chunk"</span>, <span class="string">"chunk"</span>], <span class="string">"archive.zip"</span>,</div><div class="line">&#123;<span class="attr">type</span>: <span class="string">"application/zip"</span>&#125;)                  	</div><div class="line">);</div></pre></td></tr></table></figure>
<p>Request 和 Response（扩展的 <code>fetch()</code> 方法）都能够<a href="https://fetch.spec.whatwg.org/#concept-bodyinit-extract" target="_blank" rel="external">自动识别</a>自己的内容类型，Request 还可以自动设置 <code>Content-Type</code> 头，如果开发者没有设置它的话。</p>
<h2 id="流和克隆"><a href="#流和克隆" class="headerlink" title="流和克隆"></a>流和克隆</h2><p>非常重要的一点是，Request 和 Response 的 body 只能被读取一次！它们有一个属性叫 <code>bodyUsed</code>，读取一次之后设置为 <code>true</code>，之后就不能再被读取了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = <span class="keyword">new</span> Response(<span class="string">"one time use"</span>);</div><div class="line"><span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">// false</span></div><div class="line">res.text().then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">// true</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">// true</span></div><div class="line"> </div><div class="line">res.text().catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Tried to read already consumed Response"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这样设计的目的是为了之后兼容<a href="https://streams.spec.whatwg.org/" target="_blank" rel="external">基于流</a>的 API，我们的目的是当数据到达时就进行相应的处理，这样就使得 JavaScript 可以处理大文件例如视频，并且可以支持实时压缩和编辑。</p>
<p>有时候，我们希望能多次访问 body，例如，你可能想使用即将支持的 <a href="http://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#cache-objects" target="_blank" rel="external">Cache API</a> 来缓存 Request 和 Response，以便于可以离线使用，Cache 要求 body 能被再次读取。</p>
<p>那么，如何让 body 能被多次读取呢？API 为这两个对象提供了一个 <code>clone()</code> 方法。调用这个方法可以得到一个克隆对象，对象中包含全新的 body。不过要记得，<code>clone()</code> 必须要在使用 body 之前调用，也就是先 <code>clone()</code> 再读使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> sheep = <span class="keyword">new</span> Response(<span class="string">"Dolly"</span>);</div><div class="line">  <span class="built_in">console</span>.log(sheep.bodyUsed); <span class="comment">// false</span></div><div class="line">  <span class="keyword">var</span> clone = sheep.clone();</div><div class="line">  <span class="built_in">console</span>.log(clone.bodyUsed); <span class="comment">// false</span></div><div class="line"> </div><div class="line">  clone.text();</div><div class="line">  <span class="built_in">console</span>.log(sheep.bodyUsed); <span class="comment">// false</span></div><div class="line">  <span class="built_in">console</span>.log(clone.bodyUsed); <span class="comment">// true</span></div><div class="line"> </div><div class="line">  evt.respondWith(cache.add(sheep.clone()).then(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sheep;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="未来的改进"><a href="#未来的改进" class="headerlink" title="未来的改进"></a>未来的改进</h2><p>为了支持流，Fetch 最终将提供可以中断执行和得到读取进度的 API。这些在 XHR 中有，但是想要实现基于 Promise 的 Fetch API 有些麻烦。</p>
<p>你可以加入 <a href="https://whatwg.org/mailing-list" target="_blank" rel="external">WHATWG 的邮件组</a>参与 <a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WHATWG&amp;component=Fetch&amp;resolution=---" target="_blank" rel="external">Fetch</a> 和 <a href="https://github.com/slightlyoff/ServiceWorker/issues" target="_blank" rel="external">ServiceWorker</a> 的讨论，为改进 API 贡献自己的力量。</p>
<p>为了创造更好的互联网而努力！</p>
<p><em>感谢 Andrea Marchesini, Anne van Kesteren 和 Ben Kelly 感谢他们对规范和实现所做的努力。</em><div class="div j-quote"><p><strong>参考资源：</strong></p>
<ul>
<li><a href="https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/" target="_blank" rel="external">This API is so Fetching!</a></li>
<li><a href="http://updates.html5rocks.com/2015/03/introduction-to-fetch" target="_blank" rel="external">Introduction to fetch()</a></li>
<li><a href="http://www.w3ctech.com/topic/854" target="_blank" rel="external">【翻译】这个API很“迷人”——(新的Fetch API)</a></li>
</ul></div></p></section><footer class="article-footer clearfix"><div class="categories"><a href="/categories/javascript/" title="JavaScript">JavaScript</a></div><div class="tags"><a href="/tags/fetch/" title="fetch">fetch</a></div></footer></div><nav class="article-nav clearfix"><a href="/2015/04/17/a-visual-guide-to-css3-flexbox-properties/" class="article-nav-link article-nav-newer"><strong class="article-nav-type">Newer</strong><span class="article-nav-title">弹性盒模型指南</span></a><a href="/2015/06/10/7-essential-javascript-functions/" class="article-nav-link article-nav-older"><strong class="article-nav-type">Older</strong><span class="article-nav-title">几个必备的 JavaScript 函数</span></a></nav></article><section id="article-comment" class="article-comment"><div data-thread-key="http://bubkoo.com/2015/05/08/introduction-to-fetch/" data-title="fetch API 简介" data-url="http://bubkoo.com/2015/05/08/introduction-to-fetch/" class="ds-thread"></div></section></div><aside id="sidebar" role="sidebar"><div class="widget tagcloud"><h3 class="widget-title">标签</h3><div class="widget-content"><a href="/tags/aop/" style="font-size: 10px">AOP</a> <a href="/tags/algorithm/" style="font-size: 18.33px">Algorithm</a> <a href="/tags/analysis/" style="font-size: 10px">Analysis</a> <a href="/tags/angularjs/" style="font-size: 15px">AngularJS</a> <a href="/tags/animation/" style="font-size: 10px">Animation</a> <a href="/tags/architecture/" style="font-size: 16.67px">Architecture</a> <a href="/tags/archives/" style="font-size: 10.83px">Archives</a> <a href="/tags/async/" style="font-size: 12.5px">Async</a> <a href="/tags/backbone/" style="font-size: 10px">Backbone</a> <a href="/tags/browsers/" style="font-size: 10px">Browsers</a> <a href="/tags/css/" style="font-size: 12.5px">CSS</a> <a href="/tags/css3/" style="font-size: 10px">CSS3</a> <a href="/tags/closure/" style="font-size: 10.83px">Closure</a> <a href="/tags/closures/" style="font-size: 10px">Closures</a> <a href="/tags/cookies/" style="font-size: 10px">Cookies</a> <a href="/tags/cross-domain/" style="font-size: 10px">Cross Domain</a> <a href="/tags/custom-elements/" style="font-size: 10.83px">Custom Elements</a> <a href="/tags/d3/" style="font-size: 10px">D3</a> <a href="/tags/debounce/" style="font-size: 10px">Debounce</a> <a href="/tags/debug/" style="font-size: 10.83px">Debug</a> <a href="/tags/dependency/" style="font-size: 10px">Dependency</a> <a href="/tags/document/" style="font-size: 10px">Document</a> <a href="/tags/ecma-262-3/" style="font-size: 15.83px">ECMA-262-3</a> <a href="/tags/ecmascript/" style="font-size: 15.83px">ECMAScript</a> <a href="/tags/es6/" style="font-size: 20px">ES6</a> <a href="/tags/errors/" style="font-size: 10px">Errors</a> <a href="/tags/essential/" style="font-size: 10px">Essential</a> <a href="/tags/evaluation-strategy/" style="font-size: 10px">Evaluation strategy</a> <a href="/tags/event/" style="font-size: 10px">Event</a> <a href="/tags/exceptions/" style="font-size: 10px">Exceptions</a> <a href="/tags/express/" style="font-size: 10px">Express</a> <a href="/tags/flip/" style="font-size: 10px">FLIP</a> <a href="/tags/flexbox/" style="font-size: 10px">Flexbox</a> <a href="/tags/funarg/" style="font-size: 10px">Funarg</a> <a href="/tags/gist/" style="font-size: 10px">Gist</a> <a href="/tags/github/" style="font-size: 10px">Github</a> <a href="/tags/guide/" style="font-size: 10px">Guide</a> <a href="/tags/html/" style="font-size: 10px">HTML</a> <a href="/tags/http/" style="font-size: 10px">HTTP</a> <a href="/tags/hexo/" style="font-size: 10.83px">Hexo</a> <a href="/tags/ie/" style="font-size: 10px">IE</a> <a href="/tags/iife/" style="font-size: 10px">IIFE</a> <a href="/tags/jshint/" style="font-size: 10px">JSHint</a> <a href="/tags/javascript/" style="font-size: 19.17px">JavaScript</a> <a href="/tags/leak/" style="font-size: 10px">Leak</a> <a href="/tags/linting/" style="font-size: 10px">Linting</a> <a href="/tags/mvc/" style="font-size: 10px">MVC</a> <a href="/tags/methodology/" style="font-size: 10px">Methodology</a> <a href="/tags/mock/" style="font-size: 10px">Mock</a> <a href="/tags/modular/" style="font-size: 10px">Modular</a> <a href="/tags/mongodb/" style="font-size: 10px">MongoDB</a> <a href="/tags/oop/" style="font-size: 10.83px">OOP</a> <a href="/tags/partial-application/" style="font-size: 10px">Partial Application</a> <a href="/tags/pattern/" style="font-size: 10px">Pattern</a> <a href="/tags/patterns/" style="font-size: 10px">Patterns</a> <a href="/tags/performance/" style="font-size: 14.17px">Performance</a> <a href="/tags/promise/" style="font-size: 13.33px">Promise</a> <a href="/tags/prototype/" style="font-size: 11.67px">Prototype</a> <a href="/tags/quality/" style="font-size: 10px">Quality</a> <a href="/tags/quiz/" style="font-size: 10px">Quiz</a> <a href="/tags/regex/" style="font-size: 10px">Regex</a> <a href="/tags/requirejs/" style="font-size: 10px">RequireJS</a> <a href="/tags/sass/" style="font-size: 10px">SASS</a> <a href="/tags/svg/" style="font-size: 10px">SVG</a> <a href="/tags/scope/" style="font-size: 10.83px">Scope</a> <a href="/tags/shapes/" style="font-size: 10px">Shapes</a> <a href="/tags/shuffle/" style="font-size: 10px">Shuffle</a> <a href="/tags/sort/" style="font-size: 17.5px">Sort</a> <a href="/tags/source-map/" style="font-size: 10.83px">Source Map</a> <a href="/tags/styling/" style="font-size: 10px">Styling</a> <a href="/tags/sublime-text/" style="font-size: 10px">Sublime Text</a> <a href="/tags/template/" style="font-size: 10px">Template</a> <a href="/tags/throttle/" style="font-size: 10px">Throttle</a> <a href="/tags/timing/" style="font-size: 10px">Timing</a> <a href="/tags/tools/" style="font-size: 12.5px">Tools</a> <a href="/tags/variable-object/" style="font-size: 10px">Variable object</a> <a href="/tags/visualizations/" style="font-size: 10px">Visualizations</a> <a href="/tags/when/" style="font-size: 12.5px">When</a> <a href="/tags/delete/" style="font-size: 10px">delete</a> <a href="/tags/execution-context/" style="font-size: 10px">execution context</a> <a href="/tags/fetch/" style="font-size: 10px">fetch</a> <a href="/tags/function/" style="font-size: 10px">function</a> <a href="/tags/nodejs/" style="font-size: 10px">nodejs</a> <a href="/tags/nodemon/" style="font-size: 10px">nodemon</a> <a href="/tags/npm/" style="font-size: 10px">npm</a> <a href="/tags/nvm/" style="font-size: 10px">nvm</a> <a href="/tags/performance/" style="font-size: 10px">performance</a> <a href="/tags/prebrowsing/" style="font-size: 10px">prebrowsing</a> <a href="/tags/prefetching/" style="font-size: 10px">prefetching</a> <a href="/tags/preloading/" style="font-size: 10px">preloading</a> <a href="/tags/tabindex/" style="font-size: 10px">tabindex</a> <a href="/tags/this/" style="font-size: 10px">this</a> <a href="/tags/ui-router/" style="font-size: 14.17px">ui-router</a></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/01/18/debouncing-throttling-explained-examples/">实例解析防抖和节流函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/08/quick-tip-multiple-versions-node-nvm/">使用 nvm 管理不同版本的 node 与 npm</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/08/15-ways-to-write-self-documenting-javascript/">如何编写更加自解释的代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/31/high-performance-animations/">使用 FLIP 来提高 Web 动画的性能</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/28/styling-broken-images/">定制图片加载失败时的样式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/26/delivering-octicons-with-svg/">使用 SVG 输出 Octicon</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/18/how-to-use-npm-as-a-build-tool/">如何将 npm 作为构建工具使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/what-you-can-do-with-gists-on-github/">任何人都可以使用到的 Gist 服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/19/prefetching-preloading-prebrowsing/">前端性能优化 - 资源预加载</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/18/es6-in-depth-the-future/">深入解析 ES6：未来展望</a></li></ul></div></div></aside><aside id="topic-wrap" class="toc-wrap f-right"><h3 class="toc-wrap-title">内容</h3><div class="toc-tree"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#特征检查"><span class="toc-number">1.</span> <span class="toc-text">特征检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简单示例"><span class="toc-number">2.</span> <span class="toc-text">简单示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#headers"><span class="toc-number">3.</span> <span class="toc-text">Headers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#request"><span class="toc-number">4.</span> <span class="toc-text">Request</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#same-origin"><span class="toc-number">4.1.</span> <span class="toc-text">same-origin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#no-cors"><span class="toc-number">4.2.</span> <span class="toc-text">no-cors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cors"><span class="toc-number">4.3.</span> <span class="toc-text">cors</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#response"><span class="toc-number">5.</span> <span class="toc-text">Response</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理-body"><span class="toc-number">6.</span> <span class="toc-text">处理 body</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流和克隆"><span class="toc-number">7.</span> <span class="toc-text">流和克隆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未来的改进"><span class="toc-number">8.</span> <span class="toc-text">未来的改进</span></a></li></ol></div><div class="toc-progress"></div></aside></div><footer id="footer" class="inner"><span class="copyright">© 2017 bubkoo</span><span class="theme">@<a href="https://github.com/bubkoo/hexo-theme-formula" target="_blank">formula</a></span></footer><img id="go2top" src="/images/top_arrow.png" alt="go2top"><script charset="utf-8" src="/js/lib/jquery-2.1.3.min.js"></script><script charset="utf-8" src="/js/lib/jquery.imagesloaded.min.js"></script><script charset="utf-8" src="/fancybox/jquery.fancybox.pack.js"></script><script charset="utf-8" src="/js/lib/sea.js"></script><script charset="utf-8" src="/js/main.js"></script><script id="redundancy3">var duoshuoQuery = { short_name: 'bubkoo' };
(function () {
  var ds = document.createElement('script');

  ds.type    = 'text/javascript';
  ds.async   = true;
  ds.src     = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';

  (document.getElementsByTagName('head')[0]
  || document.getElementsByTagName('body')[0]).appendChild(ds);

  ds.parentNode.removeChild(ds);

  var script = document.getElementById('redundancy3');
  script && script.parentNode.removeChild(script);
})();</script></body></html>
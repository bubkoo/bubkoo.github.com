<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>自定义元素：在 HTML 中定义新元素 | bubkoo</title><meta name="author" content="bubkoo"><meta name="description" content="引言现在的 web 严重缺乏表现力。你只要瞧一眼“现代”的 web 应用，比如 GMail，就会明白了：

堆砌 &amp;lt;div&amp;gt; 的方式一点都不现代。然而可悲的是，这就是我们构建 web 应用的方式。在现有基础上我们不应该有更高的追求吗？"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:title" content="自定义元素：在 HTML 中定义新元素"><meta property="og:site_name" content="bubkoo"><link href="/favicon.ico" rel="icon" type="image/x-ico"><link href="/atom.xml" rel="alternate" title="bubkoo" type="application/atom+xml"><link href="/css/style.css" rel="stylesheet" type="text/css" charset="utf-8"><link href="/fancybox/jquery.fancybox.css" rel="stylesheet" type="text/css" charset="utf-8"><script id="google_analytics">(function (window, document, src, ga) {

  window['GoogleAnalyticsObject'] = ga;

  if (!window[ga]) {
    window[ga] = function () {
      (window[ga].q = window[ga].q || []).push(arguments);
    };
  }

  window[ga].l = 1 * new Date();

  var thisTag = document.getElementById('google_analytics');
  var script  = document.createElement('script');

  script.async = true;
  script.src   = src;

  thisTag.parentNode.insertBefore(script, thisTag);

  setTimeout(function () {
    script.parentNode.removeChild(script);
    thisTag.parentNode.removeChild(thisTag);
  }, 100);

})(window, document, 'https://www.google-analytics.com/analytics.js', 'ga');

ga('create', 'UA-78428859-2', 'auto');
ga('send', 'pageview');</script><script id="baidu_tongji">var _hmt = _hmt || [];
(function () {
  var script  = document.createElement('script');
  var thisTag = document.getElementById('baidu_tongji');

  script.src = '//hm.baidu.com/hm.js?49a1665c33b011585a2a629fdbed5b61';

  thisTag.parentNode.insertBefore(script, thisTag);

  setTimeout(function () {
    script.parentNode.removeChild(script);
    thisTag.parentNode.removeChild(thisTag);
  }, 100);
})();</script><!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]--><script>__start__ = window.performance && performance.timing ? performance.timing.navigationStart : Date.now();</script></head><body><header id="header" hoot="default" hoot-rate="1" class="inner"><div class="f-left"><a href="/" class="site-title">bubkoo</a></div><nav class="f-right"><ul class="site-nav"><li><a href="/">&lt;&gt;</a></li><li><a href="/archives">Archives</a></li><li><a href="https://github.com/bubkoo">Github</a></li></ul></nav></header><div id="container" class="inner"><div id="main"><article class="article link"><div class="article-wrap"><header class="article-header"><span class="article-header-icon icon-black"></span><h1 class="article-header-title">自定义元素：在 HTML 中定义新元素</h1><time datetime="2015-02-01T16:35:35.000Z" itemprop="datePublished" class="article-header-time"><span class="day">02</span><span class="month">2015年02月</span></time></header><section class="article-content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>现在的 web 严重缺乏表现力。你只要瞧一眼“现代”的 web 应用，比如 GMail，就会明白了：</p>
<p><img src="http://bubkoo.qiniudn.com/gmail-dom.png" alt="现代 web 应用：使用 div 堆砌而成"></p>
<p>堆砌 <code>&lt;div&gt;</code> 的方式一点都不现代。然而可悲的是，这就是我们构建 web 应用的方式。在现有基础上我们不应该有更高的追求吗？</p>
<a id="more"></a>
<h3 id="时髦的标记行动起来"><a href="#时髦的标记，行动起来！" class="headerlink" title="时髦的标记，行动起来！"></a>时髦的标记，行动起来！</h3><p>HTML 为我们提供了一个完美的文档组织工具，然而 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/" target="_blank" rel="external">HTML 规范</a>定义的元素却很有限。</p>
<p>假如 GMail 的标记不那么糟糕，而是像下面这样漂亮，那会怎样？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">hangout-module</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">hangout-chat</span> <span class="attr">from</span>=<span class="string">"Paul, Addy"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">hangout-discussion</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">hangout-message</span> <span class="attr">from</span>=<span class="string">"Paul"</span> <span class="attr">profile</span>=<span class="string">"profile.png"</span></span></div><div class="line">          <span class="attr">profile</span>=<span class="string">"118075919496626375791"</span> <span class="attr">datetime</span>=<span class="string">"2013-07-17T12:02"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Feelin' this Web Components thing.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Heard of it?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">hangout-message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">hangout-discussion</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">hangout-chat</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">hangout-chat</span>&gt;</span>...<span class="tag">&lt;/<span class="name">hangout-chat</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">hangout-module</span>&gt;</span></div></pre></td></tr></table></figure>
<p>真是令人耳目一新！这个应用太合理了，既<strong>有意义</strong>，又<strong>容易理解</strong>。最妙的是，它是<strong>可维护</strong>的，只要查看声明结构就可以清楚地知道它的作用。</p>
<blockquote>
<p>自定义元素，救救我们！就指望你了！</p>
</blockquote>
<h2 id="赶紧开始吧"><a href="#赶紧开始吧" class="headerlink" title="赶紧开始吧"></a>赶紧开始吧</h2><p><a href="http://w3c.github.io/webcomponents/spec/custom/" target="_blank" rel="external">自定义元素</a><strong>允许开发者定义新的 HTML 元素类型</strong>。该规范只是 <a href="http://w3c.github.io/webcomponents/explainer/" target="_blank" rel="external">Web 组件</a>模块提供的众多新 API 中的一个，但它也很可能是最重要的一个。没有自定义元素带来的以下特性，Web 组件都不会存在：</p>
<ol>
<li>定义新的 HTML/DOM 元素</li>
<li>基于其他元素创建扩展元素</li>
<li>给一个标签绑定一组自定义功能</li>
<li>扩展已有 DOM 元素的 API</li>
</ol>
<h3 id="注册新元素"><a href="#注册新元素" class="headerlink" title="注册新元素"></a>注册新元素</h3><p>使用 <code>document.registerElement()</code> 可以创建一个自定义元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo'</span>);</div><div class="line"><span class="built_in">document</span>.body.appendChild(<span class="keyword">new</span> XFoo());</div></pre></td></tr></table></figure>
<p>方法 <code>document.registerElement()</code> 的第一个参数是元素的标签名。规范中规定这个标签名<strong>必须包括一个连字符（-）</strong>。因此，诸如<code>&lt;x-tags&gt;</code>、<code>&lt;my-element&gt;</code> 和 <code>&lt;my-awesome-app&gt;</code>都是合法的标签名，而 <code>&lt;tabs&gt;</code> 和 <code>&lt;foo_bar&gt;</code> 则不是。这个限定使解析器能很容易地区分自定义元素和 HTML 规范定义的元素，同时确保了 HTML 增加新标签时的向前兼容。</p>
<p>第二个参数是一个（可选的）对象，用于描述该元素的<code>prototype</code>。在这里可以为元素添加自定义功能（例如：公开属性和方法）。稍后详述。</p>
<p>自定义元素默认继承自<code>HTMLElement</code>，因此上一个示例等同于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo'</span>, &#123;</div><div class="line">    <span class="attr">prototype</span>: <span class="built_in">Object</span>.create(HTMLElement.prototype)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>调用 <code>document.registerElement(&#39;x-foo&#39;)</code> 向浏览器注册了这个新元素，并返回一个可以用来创建 <code>&lt;x-foo&gt;</code> 元素实例的构造函数。如果你不想使用构造函数，也可以使用其他实例化元素的技术。</p>
<p class="j-warning">提示：如果你不希望将构造函数放在 <code>window</code> 全局对象上，还可以把它放进命名空间：</p>


<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myapp = &#123;&#125;; </div><div class="line">myapp.XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo'</span>);</div></pre></td></tr></table></figure>
<h3 id="扩展原生元素"><a href="#扩展原生元素" class="headerlink" title="扩展原生元素"></a>扩展原生元素</h3><p>假设平淡无奇的原生 <code>&lt;button&gt;</code> 元素不能满足你的需求，你想将其增强为一个“超级按钮”，可以通过创建一个继承 <code>HTMLButtonElement.prototype</code> 的新元素，来扩展 <code>&lt;button&gt;</code> 元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MegaButton = <span class="built_in">document</span>.registerElement(<span class="string">'mega-button'</span>, &#123;</div><div class="line">    <span class="attr">prototype</span>: <span class="built_in">Object</span>.create(HTMLButtonElement.prototype)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p class="j-dot">要创建扩展自<strong>元素 B</strong> 的<strong>元素 A</strong>，<strong>元素 A</strong> 必须继承<strong>元素 B</strong> 的 <code>prototype</code>。</p>

<p>这类自定义元素被称为扩展型自定义元素。它们以继承某个特定 <code>HTMLElement</code> 的方式表达了“元素 X 是一个 Y”：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"mega-button"</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="元素如何提升"><a href="#元素如何提升" class="headerlink" title="元素如何提升"></a>元素如何提升</h3><p>为什么 HTML 解析器对非标准的标签没报错？比如，我们在页面中声明一个 <code>&lt;randomtag&gt;</code>，一切都很和谐。根据 HTML 规范的表述：</p>
<blockquote>
<p>非规范定义的元素必须使用 <code>HTMLUnknownElement</code> 接口。</p>
</blockquote>
<p><code>&lt;randomtag&gt;</code> 是非标准的，它会继承 <code>HTMLUnknownElement</code>。</p>
<p>对自定义元素来说，情况就不一样了。拥有合法元素名的自定义元素将继承<code>HTMLElement</code>。你可以按 Ctrl+Shift+J 打开控制台，运行下面这段代码，得到的结果将是 <code>true</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// “tabs”不是一个合法的自定义元素名</span></div><div class="line"><span class="built_in">document</span>.createElement(<span class="string">'tabs'</span>).__proto__ === HTMLUnknownElement.prototype</div><div class="line"></div><div class="line"><span class="comment">// “x-tabs”是一个合法的自定义元素名</span></div><div class="line"><span class="built_in">document</span>.createElement(<span class="string">'x-tabs'</span>).__proto__ == HTMLElement.prototype</div></pre></td></tr></table></figure>
<p class="j-dot">在不支持 <code>document.registerElement()</code> 的浏览器中，<code>&lt;x-tabs&gt;</code> 仍为 <code>HTMLUnknownElement</code>。</p>

<h3 id="unresolved-元素"><a href="#Unresolved-元素" class="headerlink" title="Unresolved 元素"></a>Unresolved 元素</h3><p>由于自定义元素是通过脚本执行 <code>document.registerElement()</code> 注册的，因此 它们可能在元素定义被注册到浏览器之前就已经声明或创建过了。例如：你可以先在页面中声明 <code>&lt;x-tabs&gt;</code>，以后再调用 <code>document.registerElement(&#39;x-tabs&#39;)</code>。</p>
<p>在被提升到其定义之前，这些元素被称为 unresolved 元素。它们是拥有合法自定义元素名的 HTML 元素，只是还没有注册成为自定义元素。</p>
<p>下面这个表格看起来更直观一些：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">继承自</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">unresolved 元素</td>
<td style="text-align:left"><code>HTMLElement</code></td>
<td style="text-align:left"><code>&lt;x-tabs&gt;</code>、<code>&lt;my-element&gt;</code>、<code>&lt;my-awesome-app&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">未知元素</td>
<td style="text-align:left"><code>HTMLUnknownElement</code></td>
<td style="text-align:left"><code>&lt;tabs&gt;</code>、<code>&lt;foo_bar&gt;</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>把 unresolved 元素想象成尚处于中间状态，它们都是等待被浏览器提升的潜在候选者。浏览器说：“你具备一个新元素的全部特征，我保证会在赋予你定义的时候将你提升为一个元素”。</p>
</blockquote>
<h2 id="实例化元素"><a href="#实例化元素" class="headerlink" title="实例化元素"></a>实例化元素</h2><p>我们创建普通元素用到的一些技术也可以用于自定义元素。和所有标准定义的元素一样，自定义元素既可以在 HTML 中声明，也可以通过 JavaScript 在 DOM 中创建。</p>
<h3 id="实例化自定义标签"><a href="#实例化自定义标签" class="headerlink" title="实例化自定义标签"></a>实例化自定义标签</h3><p>声明元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">x-foo</span>&gt;</span><span class="tag">&lt;/<span class="name">x-foo</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在 JS 中创建 DOM：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xFoo = <span class="built_in">document</span>.createElement(<span class="string">'x-foo'</span>);</div><div class="line">xFoo.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    alert(<span class="string">'Thanks!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用 <code>new</code> 操作符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xFoo = <span class="keyword">new</span> XFoo();</div><div class="line"><span class="built_in">document</span>.body.appendChild(xFoo);</div></pre></td></tr></table></figure>
<h3 id="实例化类型扩展元素"><a href="#实例化类型扩展元素" class="headerlink" title="实例化类型扩展元素"></a>实例化类型扩展元素</h3><p>实例化类型扩展自定义元素的方法和自定义标签惊人地相似。</p>
<p>声明元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- &lt;button&gt; “是一个”超级按钮 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"mega-button"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在 JS 中创建 DOM：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> megaButton = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>, <span class="string">'mega-button'</span>);</div><div class="line"><span class="comment">// megaButton instanceof MegaButton === true</span></div></pre></td></tr></table></figure>
<p>这是接收第二个参数为 <code>is=&quot;&quot;</code> 属性的 <code>document.createElement()</code> 重载版本。</p>
<p>使用 new 操作符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> megaButton = <span class="keyword">new</span> MegaButton();</div><div class="line"><span class="built_in">document</span>.body.appendChild(megaButton);</div></pre></td></tr></table></figure>
<p>现在，我们已经学习了如何使用 <code>document.registerElement()</code> 来向浏览器注册一个新标签。但这还不够，接下来我们要向新标签添加属性和方法。</p>
<h2 id="添加-js-属性和方法"><a href="#添加-JS-属性和方法" class="headerlink" title="添加 JS 属性和方法"></a>添加 JS 属性和方法</h2><p>自定义元素最强大的地方在于，你可以在元素定义中加入属性和方法，给元素绑定特定的功能。你可以把它想象成一种给你的元素创建公开 API 的方法。</p>
<p>这里有一个完整的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XFooProto = <span class="built_in">Object</span>.create(HTMLElement.prototype);</div><div class="line"></div><div class="line"><span class="comment">// 1. 为 x-foo 创建 foo() 方法</span></div><div class="line">XFooProto.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'foo() called'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 2. 定义一个只读的“bar”属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(XFooProto, <span class="string">"bar"</span>, &#123;<span class="attr">value</span>: <span class="number">5</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 3. 注册 x-foo 的定义</span></div><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo'</span>, &#123;<span class="attr">prototype</span>: XFooProto&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 4. 创建一个 x-foo 实例</span></div><div class="line"><span class="keyword">var</span> xfoo = <span class="built_in">document</span>.createElement(<span class="string">'x-foo'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 5. 插入页面</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(xfoo);</div></pre></td></tr></table></figure>
<p>构造 <code>prototype</code> 的方法多种多样，如果你不喜欢上面这种方式，再看一个更简洁的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo'</span>, &#123;</div><div class="line">  <span class="attr">prototype</span>: <span class="built_in">Object</span>.create(HTMLElement.prototype, &#123;</div><div class="line">    <span class="attr">bar</span>: &#123;</div><div class="line">      <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">foo</span>: &#123;</div><div class="line">      <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">'foo() called'</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上两种方式，第一种使用了 ES5 的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external"><code>Object.defineProperty</code></a>，第二种则使用了 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/get" target="_blank" rel="external"><code>get/set</code></a>。</p>
<h3 id="生命周期回调方法"><a href="#生命周期回调方法" class="headerlink" title="生命周期回调方法"></a>生命周期回调方法</h3><p>元素可以定义一些特殊方法，在其生存期内的关键时间点注入它们。这些方法各自有特定的名称和用途，它们被恰如其分地命名为生命周期回调：</p>
<table>
<thead>
<tr>
<th style="text-align:left">回调名称</th>
<th style="text-align:left">调用时间点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>createdCallback</code></td>
<td style="text-align:left">创建元素实例</td>
</tr>
<tr>
<td style="text-align:left"><code>attachedCallback</code></td>
<td style="text-align:left">向文档插入实例</td>
</tr>
<tr>
<td style="text-align:left"><code>detachedCallback</code></td>
<td style="text-align:left">从文档中移除实例</td>
</tr>
<tr>
<td style="text-align:left"><code>attributeChangedCallback(attrName, oldVal, newVal)</code></td>
<td style="text-align:left">添加，移除，或修改一个属性</td>
</tr>
</tbody>
</table>
<p>示例：为 <code>&lt;x-foo&gt;</code> 定义 <code>createdCallback()</code> 和 <code>attachedCallback()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.create(HTMLElement.prototype);</div><div class="line"></div><div class="line">proto.createdCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;;</div><div class="line">proto.attachedCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo'</span>, &#123;<span class="attr">prototype</span>: proto&#125;);</div></pre></td></tr></table></figure>
<p>所有生命周期回调都是可选的，你可以只在需要关注的时间点定义它们。例如：假设你有一个很复杂的元素，它会在 <code>createdCallback()</code> 打开一个 IndexedDB 连接。在将其从 DOM 移除时，<code>detachedCallback()</code> 会做一些必要的清理工作。注意：不要过于依赖这些生命周期方法（比如用户直接关闭浏览器标签），仅将其作为可能的优化点。</p>
<p>另一个生命周期回调的例子是为元素设置默认的事件监听器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">proto.createdCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    alert(<span class="string">'Thanks!'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果你的元素太笨重，是不会有人用它的。生命周期回调可以帮你大忙！</p>
</blockquote>
<h2 id="添加标记"><a href="#添加标记" class="headerlink" title="添加标记"></a>添加标记</h2><p>我们已经创建好了 <code>&lt;x-foo&gt;</code> 并添加了 API，但它还没有任何内容。不如我们给点 HTML 让它渲染？</p>
<p>生命周期回调在这个时候就派上用场了。我们甚至可以用 <code>createdCallback()</code> 给一个元素赋予一些默认的 HTML：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XFooProto = <span class="built_in">Object</span>.create(HTMLElement.prototype);</div><div class="line"></div><div class="line">XFooProto.createdCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.innerHTML = <span class="string">"&lt;b&gt;I'm an x-foo-with-markup!&lt;/b&gt;"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo-with-markup'</span>, &#123;<span class="attr">prototype</span>: XFooProto&#125;);</div></pre></td></tr></table></figure>
<p>实例化这个标签并在 DevTools 中观察（右击，选择“审查元素”），可以看到如下结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">▾<span class="tag">&lt;<span class="name">x-foo-with-markup</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>I'm an x-foo-with-markup!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">x-foo-with-markup</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="用-shadow-dom-封装内部实现"><a href="#用-Shadow-DOM-封装内部实现" class="headerlink" title="用 Shadow DOM 封装内部实现"></a>用 Shadow DOM 封装内部实现</h3><p><a href="http://www.html5rocks.com/tutorials/webcomponents/shadowdom/" target="_blank" rel="external">Shadow DOM</a> 本身是一个封装内容的强大工具，配合使用自定义元素就更神奇了！</p>
<p>Shadow DOM 为自定义元素提供了：</p>
<ol>
<li>一种隐藏内部实现的方法，从而将用户与血淋淋的实现细节隔离开。</li>
<li>简单有效的<a href="http://www.html5rocks.com/tutorials/webcomponents/shadowdom-201/" target="_blank" rel="external">样式隔离</a>。</li>
</ol>
<p>从 Shadow DOM 创建元素，跟创建一个渲染基础标记的元素非常类似，区别在于 <code>createdCallback()</code> 回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XFooProto = <span class="built_in">Object</span>.create(HTMLElement.prototype);</div><div class="line"></div><div class="line">XFooProto.createdCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 1. 为元素附加一个 shadow root。</span></div><div class="line">  <span class="keyword">var</span> shadow = <span class="keyword">this</span>.createShadowRoot();</div><div class="line"></div><div class="line">  <span class="comment">// 2. 填入标记。</span></div><div class="line">  shadow.innerHTML = <span class="string">"&lt;b&gt;I'm in the element's Shadow DOM!&lt;/b&gt;"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo-shadowdom'</span>, &#123;<span class="attr">prototype</span>: XFooProto&#125;);</div></pre></td></tr></table></figure>
<p>我们并没有直接设置 <code>&lt;x-foo-shadowdom&gt;</code> 的 <code>innerHTML</code>，而是为其创建了一个用于填充标记的 Shadow Root。在 DevTools 中，你就会看到一个可以展开的 <code>#shadow-root</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">▾<span class="tag">&lt;<span class="name">x-foo-shadowdom</span>&gt;</span></div><div class="line">   ▾#shadow-root</div><div class="line">     <span class="tag">&lt;<span class="name">b</span>&gt;</span>I'm in the element's Shadow DOM!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">x-foo-shadowdom</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这就是 Shadow Root！</p>
<h3 id="从模板创建元素"><a href="#从模板创建元素" class="headerlink" title="从模板创建元素"></a>从模板创建元素</h3><p><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#the-template-element" target="_blank" rel="external">HTML 模板</a>是另一组跟自定义元素完美融合的新 API。</p>
<p><a href="http://www.html5rocks.com/tutorials/webcomponents/template/" target="_blank" rel="external"><code>&lt;template&gt;</code> 元素</a>可用于声明 DOM 片段。它们可以被解析并在页面加载后插入，以及延迟到运行时才进行实例化。模板是声明自定义元素结构的理想方案。</p>
<p>示例：注册一个由 <code>&lt;template&gt;</code> 和 Shadow DOM 创建的元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"sdtemplate"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: orange; &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>I'm in Shadow DOM. My markup was stamped from a &amp;lt;template&amp;gt;.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.create(HTMLElement.prototype, &#123;</div><div class="line">  <span class="attr">createdCallback</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> t = <span class="built_in">document</span>.querySelector(<span class="string">'#sdtemplate'</span>);</div><div class="line">      <span class="keyword">var</span> clone = <span class="built_in">document</span>.importNode(t.content, <span class="literal">true</span>);</div><div class="line">      <span class="keyword">this</span>.createShadowRoot().appendChild(clone);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">document</span>.registerElement(<span class="string">'x-foo-from-template'</span>, &#123;<span class="attr">prototype</span>: proto&#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>短短几行做了很多事情，我们挨个来看都发生了些什么：</p>
<ol>
<li>在 HTML 中注册了一个新元素：<code>&lt;x-foo-from-template&gt;</code></li>
<li>这个元素的 DOM 是从一个 <code>&lt;template&gt;</code> 创建的</li>
<li>Shadow DOM 隐藏了该元素可怕的细节</li>
<li>Shadow DOM 也对元素的样式进行了隔离（比如 p {color: orange;} 不会把整个页面都搞成橙色）</li>
</ol>
<p>真不错！</p>
<h2 id="为自定义元素增加样式"><a href="#为自定义元素增加样式" class="headerlink" title="为自定义元素增加样式"></a>为自定义元素增加样式</h2><p>和其他 HTML 标签一样，自定义元素也可以用选择器定义样式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-tag">app-panel</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-attr">[is="x-item"]</span> &#123;</div><div class="line">    <span class="attribute">transition</span>: opacity <span class="number">400ms</span> ease-in-out;</div><div class="line">    <span class="attribute">opacity</span>: <span class="number">0.3</span>;</div><div class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-attr">[is="x-item"]</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">    <span class="attribute">opacity</span>: <span class="number">1.0</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">rgb</span>(255, 0, 255);</div><div class="line">    <span class="attribute">color</span>: white;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-tag">app-panel</span> &gt; <span class="selector-attr">[is="x-item"]</span> &#123;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">7px</span>;</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">app-panel</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">is</span>=<span class="string">"x-item"</span>&gt;</span>Do<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">is</span>=<span class="string">"x-item"</span>&gt;</span>Re<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">is</span>=<span class="string">"x-item"</span>&gt;</span>Mi<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">app-panel</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="为使用-shadow-dom-的元素增加样式"><a href="#为使用-Shadow-DOM-的元素增加样式" class="headerlink" title="为使用 Shadow DOM 的元素增加样式"></a>为使用 Shadow DOM 的元素增加样式</h3><p>有了 Shadow DOM 场面就热闹得多了，它可以极大增强自定义元素的能力。</p>
<p>Shadow DOM 为元素增加了样式封装的特性。Shadow Root 中定义的样式不会暴露到宿主外部或对页面产生影响。<strong>对自定义元素来说，元素本身就是宿主</strong>。样式封装的属性也使得自定义元素能够为自己定义默认样式。</p>
<p>Shadow DOM 的样式是一个很大的话题！如果你想更多地了解它，推荐你阅读我写的其他文章：</p>
<ul>
<li>Polymer 文档：<a href="http://www.polymer-project.org/articles/styling-elements.html" target="_blank" rel="external">元素样式指南</a></li>
<li>发表于 <a href="http://www.html5rocks.com/" target="_blank" rel="external">html5rocks</a> 的 <a href="http://www.html5rocks.com/tutorials/webcomponents/shadowdom-201/" target="_blank" rel="external">Shadow DOM 201：CSS 和样式</a></li>
</ul>
<h3 id="使用-unresolved-伪类避免无样式内容闪烁fouc"><a href="#使用-unresolved-伪类避免无样式内容闪烁（FOUC）" class="headerlink" title="使用 :unresolved 伪类避免无样式内容闪烁（FOUC）"></a>使用 :unresolved 伪类避免无样式内容闪烁（FOUC）</h3><p>为了缓解无样式内容闪烁的影响，自定义元素规范提出了一个新的 CSS 伪类 <code>:unresolved</code>。在浏览器调用你的 <code>createdCallback()</code>（见生命周期回调方法一节）之前，这个伪类都可以匹配到 unresolved 元素。一旦产生调用，就意味着元素已经完成提升，成为它被定义的形态，该元素就不再是一个 unresolved 元素了。</p>
<p class="j-dot">Chrome 29 已经原生支持 CSS :unresolved 伪类。</p>

<p>示例：注册后渐显的 <code>&lt;x-foo&gt;</code> 标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-tag">x-foo</span> &#123;</div><div class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</div><div class="line">    <span class="attribute">transition</span>: opacity <span class="number">300ms</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-tag">x-foo</span><span class="selector-pseudo">:unresolved</span> &#123;</div><div class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<p>请记住 <code>:unresolved</code> 伪类只能用于 unresolved 元素，而不能用于继承自 <code>HTMLUnkownElement</code> 的元素（见元素如何提升一节）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="comment">/* 给所有 unresolved 元素添加边框 */</span></div><div class="line">  <span class="selector-pseudo">:unresolved</span> &#123;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> dashed red;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/* unresolved 元素 x-panel 的文本内容为红色 */</span></div><div class="line">  <span class="selector-tag">x-panel</span><span class="selector-pseudo">:unresolved</span> &#123;</div><div class="line">    <span class="attribute">color</span>: red;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/* 定义注册后的 x-panel 文本内容为绿色 */</span></div><div class="line">  <span class="selector-tag">x-panel</span> &#123;</div><div class="line">    <span class="attribute">color</span>: green;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">panel</span>&gt;</span></div><div class="line">  I'm black because :unresolved doesn't apply to "panel".</div><div class="line">  It's not a valid custom element name.</div><div class="line"><span class="tag">&lt;/<span class="name">panel</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">x-panel</span>&gt;</span>I'm red because I match x-panel:unresolved.<span class="tag">&lt;/<span class="name">x-panel</span>&gt;</span></div></pre></td></tr></table></figure>
<p>了解更多 <code>:unresolved</code> 伪类的知识，请看 Polymer 文档<a href="http://www.polymer-project.org/articles/styling-elements.html#preventing-fouc" target="_blank" rel="external">元素样式指南</a>。</p>
<h2 id="历史和浏览器支持"><a href="#历史和浏览器支持" class="headerlink" title="历史和浏览器支持"></a>历史和浏览器支持</h2><h3 id="特性检测"><a href="#特性检测" class="headerlink" title="特性检测"></a>特性检测</h3><p>特性检测就是检查 <code>document.registerElement()</code> 是否存在：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">supportsCustomElements</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'registerElement'</span> <span class="keyword">in</span> <span class="built_in">document</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (supportsCustomElements()) &#123;</div><div class="line">  <span class="comment">// Good to go!</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// Use other libraries to create components.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>Chrome 27 和 Firefox 23 都提供了对 <code>document.registerElement()</code> 的支持，不过之后规范又有一些演化。Chrome 31 将是第一个真正支持新规范的版本。</p>
<p class="j-dot">在 Chrome 31 中使用自定义元素，需要开启 about:flags 中的“实验性 web 平台特性（Experimental Web Platform features）”选项。</p>

<p>在浏览器支持稳定之前，也有一些很好的兼容方案：</p>
<ul>
<li>Google 的 <a href="http://polymer-project.org/" target="_blank" rel="external">Polymer</a> 集成了一个<a href="http://www.polymer-project.org/platform/custom-elements.html" target="_blank" rel="external">兼容方案</a></li>
<li>Mozilla 的 <a href="http://www.x-tags.org/" target="_blank" rel="external">x-tags</a></li>
</ul>
<h3 id="htmlelementelement-怎么了"><a href="#HTMLElementElement-怎么了？" class="headerlink" title="HTMLElementElement 怎么了？"></a>HTMLElementElement 怎么了？</h3><p>一直关注标准的人都知道曾经有一个 <code>&lt;element&gt;</code> 标签。它非常好用，你只要像下面这样就可以声明式地注册一个新元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">"my-element"</span>&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">element</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然而，很不幸，在它的提升过程、边界案例，以及末日般的复杂场景中，需要处理大量的时序问题。<element> 因此被迫搁置。2013 年 8 月，Dimitri Glazkov 在 <a href="http://lists.w3.org/Archives/Public/public-webapps/2013JulSep/0287.html" target="_blank" rel="external">public-webapps</a> 邮件组中宣告移除 <code>&lt;element&gt;</code>。</element></p>
<p>值得注意的是，Polymer 实现了以 <code>&lt;polymer-element&gt;</code> 的形式声明式地注册元素。这是怎么做到的？它用的正是 <code>document.registerElement(&#39;polymer-element&#39;)</code> 以及我在从模板创建元素一节介绍的技术。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>自定义元素为我们提供了一个工具，通过它我们可以扩展 HTML 的词汇，赋予它新的特性，并把不同的 web 平台连接在一起。结合其他新的基本平台，如 Shadow DOM 和 <code>&lt;template&gt;</code>，我们领略了 web 组件的宏伟蓝图。标记语言将再次变得很时髦！</p>
<p>如果你对使用 web 组件感兴趣，建议你看看 <a href="http://polymer-project.org/" target="_blank" rel="external">Polymer</a>，就它已经够你玩的了。</p></section><footer class="article-footer clearfix"><div class="categories"><a href="/categories/html-css/" title="HTML/CSS">HTML/CSS</a></div><div class="tags"><a href="/tags/custom-elements/" title="Custom Elements">Custom Elements</a></div></footer></div><nav class="article-nav clearfix"><a href="/2015/02/02/best-practice-for-creating-custom-elements/" class="article-nav-link article-nav-newer"><strong class="article-nav-type">Newer</strong><span class="article-nav-title">创建自定义元素的最佳实践</span></a><a href="/2015/02/01/using-the-tabindex-attribute/" class="article-nav-link article-nav-older"><strong class="article-nav-type">Older</strong><span class="article-nav-title">说说 tabindex 的那些事儿</span></a></nav></article><section id="article-comment" class="article-comment"><div data-thread-key="http://bubkoo.com/2015/02/02/create-custom-elements/" data-title="自定义元素：在 HTML 中定义新元素" data-url="http://bubkoo.com/2015/02/02/create-custom-elements/" class="ds-thread"></div></section></div><aside id="sidebar" role="sidebar"><div class="widget tagcloud"><h3 class="widget-title">标签</h3><div class="widget-content"><a href="/tags/aop/" style="font-size: 10px">AOP</a> <a href="/tags/algorithm/" style="font-size: 18.33px">Algorithm</a> <a href="/tags/analysis/" style="font-size: 10px">Analysis</a> <a href="/tags/angularjs/" style="font-size: 15px">AngularJS</a> <a href="/tags/animation/" style="font-size: 10px">Animation</a> <a href="/tags/architecture/" style="font-size: 16.67px">Architecture</a> <a href="/tags/archives/" style="font-size: 10.83px">Archives</a> <a href="/tags/async/" style="font-size: 12.5px">Async</a> <a href="/tags/backbone/" style="font-size: 10px">Backbone</a> <a href="/tags/browsers/" style="font-size: 10px">Browsers</a> <a href="/tags/css/" style="font-size: 12.5px">CSS</a> <a href="/tags/css3/" style="font-size: 10px">CSS3</a> <a href="/tags/closure/" style="font-size: 10.83px">Closure</a> <a href="/tags/closures/" style="font-size: 10px">Closures</a> <a href="/tags/cookies/" style="font-size: 10px">Cookies</a> <a href="/tags/cross-domain/" style="font-size: 10px">Cross Domain</a> <a href="/tags/custom-elements/" style="font-size: 10.83px">Custom Elements</a> <a href="/tags/d3/" style="font-size: 10px">D3</a> <a href="/tags/debounce/" style="font-size: 10px">Debounce</a> <a href="/tags/debug/" style="font-size: 10.83px">Debug</a> <a href="/tags/dependency/" style="font-size: 10px">Dependency</a> <a href="/tags/document/" style="font-size: 10px">Document</a> <a href="/tags/ecma-262-3/" style="font-size: 15.83px">ECMA-262-3</a> <a href="/tags/ecmascript/" style="font-size: 15.83px">ECMAScript</a> <a href="/tags/es6/" style="font-size: 20px">ES6</a> <a href="/tags/errors/" style="font-size: 10px">Errors</a> <a href="/tags/essential/" style="font-size: 10px">Essential</a> <a href="/tags/evaluation-strategy/" style="font-size: 10px">Evaluation strategy</a> <a href="/tags/event/" style="font-size: 10px">Event</a> <a href="/tags/exceptions/" style="font-size: 10px">Exceptions</a> <a href="/tags/express/" style="font-size: 10px">Express</a> <a href="/tags/flip/" style="font-size: 10px">FLIP</a> <a href="/tags/flexbox/" style="font-size: 10px">Flexbox</a> <a href="/tags/funarg/" style="font-size: 10px">Funarg</a> <a href="/tags/gist/" style="font-size: 10px">Gist</a> <a href="/tags/github/" style="font-size: 10px">Github</a> <a href="/tags/guide/" style="font-size: 10px">Guide</a> <a href="/tags/html/" style="font-size: 10px">HTML</a> <a href="/tags/http/" style="font-size: 10px">HTTP</a> <a href="/tags/hexo/" style="font-size: 10.83px">Hexo</a> <a href="/tags/ie/" style="font-size: 10px">IE</a> <a href="/tags/iife/" style="font-size: 10px">IIFE</a> <a href="/tags/jshint/" style="font-size: 10px">JSHint</a> <a href="/tags/javascript/" style="font-size: 19.17px">JavaScript</a> <a href="/tags/leak/" style="font-size: 10px">Leak</a> <a href="/tags/linting/" style="font-size: 10px">Linting</a> <a href="/tags/mvc/" style="font-size: 10px">MVC</a> <a href="/tags/methodology/" style="font-size: 10px">Methodology</a> <a href="/tags/mock/" style="font-size: 10px">Mock</a> <a href="/tags/modular/" style="font-size: 10px">Modular</a> <a href="/tags/mongodb/" style="font-size: 10px">MongoDB</a> <a href="/tags/oop/" style="font-size: 10.83px">OOP</a> <a href="/tags/partial-application/" style="font-size: 10px">Partial Application</a> <a href="/tags/pattern/" style="font-size: 10px">Pattern</a> <a href="/tags/patterns/" style="font-size: 10px">Patterns</a> <a href="/tags/performance/" style="font-size: 14.17px">Performance</a> <a href="/tags/promise/" style="font-size: 13.33px">Promise</a> <a href="/tags/prototype/" style="font-size: 11.67px">Prototype</a> <a href="/tags/quality/" style="font-size: 10px">Quality</a> <a href="/tags/quiz/" style="font-size: 10px">Quiz</a> <a href="/tags/regex/" style="font-size: 10px">Regex</a> <a href="/tags/requirejs/" style="font-size: 10px">RequireJS</a> <a href="/tags/sass/" style="font-size: 10px">SASS</a> <a href="/tags/svg/" style="font-size: 10px">SVG</a> <a href="/tags/scope/" style="font-size: 10.83px">Scope</a> <a href="/tags/shapes/" style="font-size: 10px">Shapes</a> <a href="/tags/shuffle/" style="font-size: 10px">Shuffle</a> <a href="/tags/sort/" style="font-size: 17.5px">Sort</a> <a href="/tags/source-map/" style="font-size: 10.83px">Source Map</a> <a href="/tags/styling/" style="font-size: 10px">Styling</a> <a href="/tags/sublime-text/" style="font-size: 10px">Sublime Text</a> <a href="/tags/template/" style="font-size: 10px">Template</a> <a href="/tags/throttle/" style="font-size: 10px">Throttle</a> <a href="/tags/timing/" style="font-size: 10px">Timing</a> <a href="/tags/tools/" style="font-size: 12.5px">Tools</a> <a href="/tags/variable-object/" style="font-size: 10px">Variable object</a> <a href="/tags/visualizations/" style="font-size: 10px">Visualizations</a> <a href="/tags/when/" style="font-size: 12.5px">When</a> <a href="/tags/delete/" style="font-size: 10px">delete</a> <a href="/tags/execution-context/" style="font-size: 10px">execution context</a> <a href="/tags/fetch/" style="font-size: 10px">fetch</a> <a href="/tags/function/" style="font-size: 10px">function</a> <a href="/tags/nodejs/" style="font-size: 10px">nodejs</a> <a href="/tags/nodemon/" style="font-size: 10px">nodemon</a> <a href="/tags/npm/" style="font-size: 10px">npm</a> <a href="/tags/nvm/" style="font-size: 10px">nvm</a> <a href="/tags/performance/" style="font-size: 10px">performance</a> <a href="/tags/prebrowsing/" style="font-size: 10px">prebrowsing</a> <a href="/tags/prefetching/" style="font-size: 10px">prefetching</a> <a href="/tags/preloading/" style="font-size: 10px">preloading</a> <a href="/tags/tabindex/" style="font-size: 10px">tabindex</a> <a href="/tags/this/" style="font-size: 10px">this</a> <a href="/tags/ui-router/" style="font-size: 14.17px">ui-router</a></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/01/18/debouncing-throttling-explained-examples/">实例解析防抖和节流函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/08/quick-tip-multiple-versions-node-nvm/">使用 nvm 管理不同版本的 node 与 npm</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/08/15-ways-to-write-self-documenting-javascript/">如何编写更加自解释的代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/31/high-performance-animations/">使用 FLIP 来提高 Web 动画的性能</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/28/styling-broken-images/">定制图片加载失败时的样式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/26/delivering-octicons-with-svg/">使用 SVG 输出 Octicon</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/18/how-to-use-npm-as-a-build-tool/">如何将 npm 作为构建工具使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/what-you-can-do-with-gists-on-github/">任何人都可以使用到的 Gist 服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/19/prefetching-preloading-prebrowsing/">前端性能优化 - 资源预加载</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/18/es6-in-depth-the-future/">深入解析 ES6：未来展望</a></li></ul></div></div></aside><aside id="topic-wrap" class="toc-wrap f-right"><h3 class="toc-wrap-title">内容</h3><div class="toc-tree"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#时髦的标记行动起来"><span class="toc-number">1.1.</span> <span class="toc-text">时髦的标记，行动起来！</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#赶紧开始吧"><span class="toc-number">2.</span> <span class="toc-text">赶紧开始吧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注册新元素"><span class="toc-number">2.1.</span> <span class="toc-text">注册新元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展原生元素"><span class="toc-number">2.2.</span> <span class="toc-text">扩展原生元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元素如何提升"><span class="toc-number">2.3.</span> <span class="toc-text">元素如何提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unresolved-元素"><span class="toc-number">2.4.</span> <span class="toc-text">Unresolved 元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例化元素"><span class="toc-number">3.</span> <span class="toc-text">实例化元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实例化自定义标签"><span class="toc-number">3.1.</span> <span class="toc-text">实例化自定义标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例化类型扩展元素"><span class="toc-number">3.2.</span> <span class="toc-text">实例化类型扩展元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加-js-属性和方法"><span class="toc-number">4.</span> <span class="toc-text">添加 JS 属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期回调方法"><span class="toc-number">4.1.</span> <span class="toc-text">生命周期回调方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加标记"><span class="toc-number">5.</span> <span class="toc-text">添加标记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用-shadow-dom-封装内部实现"><span class="toc-number">5.1.</span> <span class="toc-text">用 Shadow DOM 封装内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从模板创建元素"><span class="toc-number">5.2.</span> <span class="toc-text">从模板创建元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为自定义元素增加样式"><span class="toc-number">6.</span> <span class="toc-text">为自定义元素增加样式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为使用-shadow-dom-的元素增加样式"><span class="toc-number">6.1.</span> <span class="toc-text">为使用 Shadow DOM 的元素增加样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-unresolved-伪类避免无样式内容闪烁fouc"><span class="toc-number">6.2.</span> <span class="toc-text">使用 :unresolved 伪类避免无样式内容闪烁（FOUC）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#历史和浏览器支持"><span class="toc-number">7.</span> <span class="toc-text">历史和浏览器支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特性检测"><span class="toc-number">7.1.</span> <span class="toc-text">特性检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器支持"><span class="toc-number">7.2.</span> <span class="toc-text">浏览器支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#htmlelementelement-怎么了"><span class="toc-number">7.3.</span> <span class="toc-text">HTMLElementElement 怎么了？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">8.</span> <span class="toc-text">结语</span></a></li></ol></div><div class="toc-progress"></div></aside></div><footer id="footer" class="inner"><span class="copyright">© 2017 bubkoo</span><span class="theme">@<a href="https://github.com/bubkoo/hexo-theme-formula" target="_blank">formula</a></span></footer><img id="go2top" src="/images/top_arrow.png" alt="go2top"><script charset="utf-8" src="/js/lib/jquery-2.1.3.min.js"></script><script charset="utf-8" src="/js/lib/jquery.imagesloaded.min.js"></script><script charset="utf-8" src="/fancybox/jquery.fancybox.pack.js"></script><script charset="utf-8" src="/js/lib/sea.js"></script><script charset="utf-8" src="/js/main.js"></script><script id="redundancy3">var duoshuoQuery = { short_name: 'bubkoo' };
(function () {
  var ds = document.createElement('script');

  ds.type    = 'text/javascript';
  ds.async   = true;
  ds.src     = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';

  (document.getElementsByTagName('head')[0]
  || document.getElementsByTagName('body')[0]).appendChild(ds);

  ds.parentNode.removeChild(ds);

  var script = document.getElementById('redundancy3');
  script && script.parentNode.removeChild(script);
})();</script></body></html>
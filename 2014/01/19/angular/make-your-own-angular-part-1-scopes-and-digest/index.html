<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>【译】构建您自己的 AngularJS，第一部分：scopes 和 digest | bubkoo</title><meta name="author" content="bubkoo"><meta name="description" content="原文链接：Make Your Own AngularJS, Part 1: Scopes And Digest

Angular 是一个成熟和功能强大的 JavaScript 框架，也是一个庞大的框架，要正真有效地使用它，需要掌握许多新概念。在 Web 开发人员涌向 Angular 的同时，许多人都面临着同样的疑问：Digest 到底是做什么的？可以有哪些不同的方式来定义一个指令（directive）？service 和 provider 之间有些什么区别？
Angular官方文档是非常好的学习资源，并且还有越来越多的第三方资源，不过，想要深入了解一个新的框架，没有比分解它，然后研究其内部运作原理更加有效。
在本系列文章中，我将从零开始建立一个 AngularJS 类库，并逐步深入讲解，最后，您将对 Angular 的工作原理有一个全面深刻地理解。
这是本系列的第一部分，我们将分析 Angular 中的 scopes 的工作原理，并且将知道像 $eval、$digest 和 $apply 这些方法到底有些什么作用，Angular 的脏值检查（dirty-checking）貌似很神奇，但是后面您将看到的并非如此。"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:title" content="【译】构建您自己的 AngularJS，第一部分：scopes 和 digest"><meta property="og:site_name" content="bubkoo"><link href="/favicon.ico" rel="icon" type="image/x-ico"><link href="/atom.xml" rel="alternate" title="bubkoo" type="application/atom+xml"><link href="/css/style.css" rel="stylesheet" type="text/css" charset="utf-8"><link href="/fancybox/jquery.fancybox.css" rel="stylesheet" type="text/css" charset="utf-8"><script id="google_analytics">(function (window, document, src, ga) {

  window['GoogleAnalyticsObject'] = ga;

  if (!window[ga]) {
    window[ga] = function () {
      (window[ga].q = window[ga].q || []).push(arguments);
    };
  }

  window[ga].l = 1 * new Date();

  var thisTag = document.getElementById('google_analytics');
  var script  = document.createElement('script');

  script.async = true;
  script.src   = src;

  thisTag.parentNode.insertBefore(script, thisTag);

  setTimeout(function () {
    script.parentNode.removeChild(script);
    thisTag.parentNode.removeChild(thisTag);
  }, 100);

})(window, document, 'https://www.google-analytics.com/analytics.js', 'ga');

ga('create', 'UA-78428859-2', 'auto');
ga('send', 'pageview');</script><script id="baidu_tongji">var _hmt = _hmt || [];
(function () {
  var script  = document.createElement('script');
  var thisTag = document.getElementById('baidu_tongji');

  script.src = '//hm.baidu.com/hm.js?49a1665c33b011585a2a629fdbed5b61';

  thisTag.parentNode.insertBefore(script, thisTag);

  setTimeout(function () {
    script.parentNode.removeChild(script);
    thisTag.parentNode.removeChild(thisTag);
  }, 100);
})();</script><!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]--><script>__start__ = window.performance && performance.timing ? performance.timing.navigationStart : Date.now();</script></head><body><header id="header" hoot="default" hoot-rate="1" class="inner"><div class="f-left"><a href="/" class="site-title">bubkoo</a></div><nav class="f-right"><ul class="site-nav"><li><a href="/">&lt;&gt;</a></li><li><a href="/archives">Archives</a></li><li><a href="https://github.com/bubkoo">Github</a></li></ul></nav></header><div id="container" class="inner"><div id="main"><article class="article post"><div class="article-wrap"><header class="article-header"><span class="article-header-icon icon-black"></span><h1 class="article-header-title">【译】构建您自己的 AngularJS，第一部分：scopes 和 digest</h1><time datetime="2014-01-19T21:26:18.000Z" itemprop="datePublished" class="article-header-time"><span class="day">19</span><span class="month">2014年01月</span></time></header><section class="article-content"><p>原文链接：<a href="http://teropa.info/blog/2013/11/03/make-your-own-angular-part-1-scopes-and-digest.html" target="_blank" rel="external">Make Your Own AngularJS, Part 1: Scopes And Digest</a></p>
<p><img src="http://bubkoo.qiniudn.com/AngularJS-large.png" alt="AngularJS"></p>
<p>Angular 是一个成熟和功能强大的 JavaScript 框架，也是一个庞大的框架，要正真有效地使用它，需要掌握许多新概念。在 Web 开发人员涌向 Angular 的同时，许多人都面临着同样的疑问：Digest 到底是做什么的？可以有哪些不同的方式来定义一个指令（directive）？service 和 provider 之间有些什么区别？</p>
<p><a href="http://docs.angularjs.org/" target="_blank" rel="external">Angular官方文档</a>是非常好的学习资源，并且还有越来越多的<a href="http://syntaxspectrum.com/tag/angularjs/" target="_blank" rel="external">第三方资源</a>，不过，想要深入了解一个新的框架，没有比分解它，然后研究其内部运作原理更加有效。</p>
<p>在本系列文章中，我将从零开始建立一个 AngularJS 类库，并逐步深入讲解，最后，您将对 Angular 的工作原理有一个全面深刻地理解。</p>
<p>这是本系列的第一部分，我们将分析 Angular 中的 scopes 的工作原理，并且将知道像 <code>$eval</code>、<code>$digest</code> 和 <code>$apply</code> 这些方法到底有些什么作用，Angular 的脏值检查（dirty-checking）貌似很神奇，但是后面您将看到的并非如此。</p>
<a id="more"></a>
<h2 id="关于源代码"><a href="#关于源代码" class="headerlink" title="关于源代码"></a>关于源代码</h2><p>您可以在 GitHub 上获取到本项目的<a href="https://github.com/teropa/schmangular.js" target="_blank" rel="external">完整代码</a>，但是我更加鼓励您自己一步一步地跟着教程来构建，并从各个方面去研究每一行代码。同时，我在页面中嵌入了 <a href="http://jsbin.com/" target="_blank" rel="external">JSBins</a>，这样您就可以直接在页面上与代码进行交互。</p>
<p>我将使用 <a href="http://lodash.com/" target="_blank" rel="external">Lo-Dash</a> 来对数组和对象做一些基本操作，Angular 本身并没有使用 Lo-Dash，但是为了更好地达到我们的学习目的，就引入 Lo-Dash 来省去一些重复造轮子的工作。如果您在代码中看到以 <code>_</code> 开始的方法或对象，表示这些方法或对象都是由 Lo-Dash 提供。</p>
<p>在代码中我还使用了 <a href="https://developers.google.com/chrome-developer-tools/docs/console-api#consoleassertexpression_object" target="_blank" rel="external"><code>console.assert</code></a> 方法来做一些随机测试，该方法在现代 JavaScript 环境下应该是可用的。</p>
<p>下面是  Lo-Dash 和 <code>console.assert</code> 方法的使用示例：</p>
<iframe src="http://jsbin.com/UGOVUk/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<h2 id="scope-对象"><a href="#Scope-对象" class="headerlink" title="Scope 对象"></a>Scope 对象</h2><p>Scope 对象其实就是一个普通的 JavaScript 对象，您可以像在其他对象上添加属性那样在 Scope 对象添加一些属性，Scope 对象是由 Scope 构造函数创建，这里我们实现了一个最简单的版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，我们就可以通过 new 操作符来创建一个 Scope 对象了，并且可以在上面添加属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> aScope = <span class="keyword">new</span> Scope();</div><div class="line">aScope.firstName = <span class="string">'Jane'</span>;</div><div class="line">aScope.lastName = <span class="string">'Smith'</span>;</div></pre></td></tr></table></figure>
<p>这些属性并没有什么特别，也不需要调用一些特殊的 setter 方法，并且对属性值的类型也没有限制。其实真正神奇的地方在于两个特殊的方法：<code>$watch</code> 和 <code>$digest</code>。</p>
<h2 id="监视对象属性watch-和-digest"><a href="#监视对象属性：-watch-和-digest" class="headerlink" title="监视对象属性：$watch 和 $digest"></a>监视对象属性：$watch 和 $digest</h2><p><code>$watch</code> 和 <code>$digest</code> 是硬币的正反两面，它们一起构成了 Scope 的核心：数据变化的响应（译者注：双向数据绑定）。</p>
<p>您可以使用 <code>$watch</code> 方法来给 scope 添加一个监视器，当 scope 发生变化时监视器就会收到通知。创建监视器需要给 <code>$watch</code> 传递两个参数：</p>
<ul>
<li>一个监视函数，它指定了您将要监视数据</li>
<li>一个监听回调函数，当监视的数据发生变化时将被调用</li>
</ul>
<p class="dot">作为 Angular 的使用者，您通常会指定 watch 表达式而不是 watch 方法，表达式是一个字符串，比如 “user.firstName”，通常在数据绑定、指示器属性或者 JavaScript 代码中指定。表达式将被 Angular 编译成一个监视函数。在后面的文章中，我们将分析 Angular 如何编译一个表达式，在本文中我们将简单滴直接使用监视函数。</p>

<p>为了实现 <code>$watch</code> 方法，我们需要储存所有注册的监视器，在 Scope 构造函数中添加一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$watchers = [];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>双美元符号 <code>$$</code> 表示该变量是 Angular 框架中的一个私有变量，不能被外部代码调用。</p>
<p>现在我们来定义 <code>$watch</code> 方法，把上面提到的两个函数作为参数，并将它们储存在 <code>$$watchers</code> 数组中。同时，我们希望 Scope 的每一个实例都具有该方法，所以将其定义在 Scope 的原型上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params">watchFn, listenerFn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> watcher = &#123;</div><div class="line">    <span class="attr">watchFn</span>: watchFn,</div><div class="line">    <span class="attr">listenerFn</span>: listenerFn</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.$$watchers.push(watcher);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>硬币的另一面就是 <code>$digest</code> 方法，它将运行所有注册在 scope 上的监视器。这里定义了一个简化的版本，仅仅实现了遍历监视器和调用侦听函数的功能，同样也将其定义在 Scope 的原型上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watch</span>) </span>&#123;</div><div class="line">    watch.listenerFn();</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在，我们来注册一个监视器，然后调用 <code>$digest</code> 方法，来触发所有的侦听函数：</p>
<iframe src="http://jsbin.com/oMaQoxa/2/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 198px"></iframe>

<p>当然，这并不是很有用。我们真正想要的是当监视的值发生改变时，才触发调用侦听函数。</p>
<h2 id="脏值检查"><a href="#脏值检查" class="headerlink" title="脏值检查"></a>脏值检查</h2><p>正如上文所述，监视器中的监视函数应该返回被监视数据的变更情况，通常，被监视的数据是绑定在 Scope 上的数据，为了更方便的访问 Scope 上的数据，监视函数把当前 Scope 作为它的一个参数。例如下面，在监视函数中访问 Scope 上的 <code>firstName</code> 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> scope.firstName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是监控函数的一般形式：从 Scope 中获取一些值，然后返回。</p>
<p><code>$digest</code> 的职责就是调用监视函数，并且将监视函数的返回值与上一次返回值进行比较，如果发现两次的返回值不一样，说明出现了脏值，同时，与监视函数对应的侦听函数将被调用。</p>
<p>想要实现这个功能，<code>$digest</code> 必须记住每个监视函数的上次返回值，既然我们为每一个监视器中都创建了一个对象，那么我们可以很方便地保存上一次监视函数的返回值，下面是为每个监视器检查脏值的 <code>$digest</code> 的新的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watch</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newValue = watch.watchFn(self);</div><div class="line">    <span class="keyword">var</span> oldValue = watch.last;</div><div class="line">    <span class="keyword">if</span> (newValue !== oldValue) &#123;</div><div class="line">      watch.listenerFn(newValue, oldValue, self);</div><div class="line">      watch.last = newValue;</div><div class="line">    &#125;</div><div class="line">  &#125;);  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过循环，调用每个监视器中的监视函数，并将 Scope 作为监视函数的参数，然后将返回值与储存在 <code>last</code> 属性中的上一次返回值进行比较。如果发生改变，我们将调用侦听函数，为了方便，我们把监视函数的新返回值、上一次返回值和 Scope 作为侦听函数的参数。最后，我们将监视函数的新返回值储存在 <code>last</code> 属性中，作为下一次比较的值。</p>
<p>下面的示例演示了当我们调用 <code>$digest</code> 时侦听器是如果工作的：</p>
<iframe src="http://jsbin.com/OsITIZu/5/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<p>现在，我们已经实现了 Angular 中 Scope 的精髓部分：添加监视并在 <code>$digest</code> 中调用它们。</p>
<p>我们已经可以看到 Scope 两个重要的特性：</p>
<ul>
<li>将数据附加到 Scope 上，数据自身不会对性能产生影响，如果没有监视器来监视这个属性，那个这个属性在不在 Scope 上是无关重要的；Angular 并不会遍历 Scope 上的属性，它将遍历所有的观察器。</li>
<li>每个监视函数是在每次 <code>$digest</code> 过程中被调用的。因此，我们要注意观察器的数量以及每个监视函数或者监视表达式的性能。</li>
</ul>
<h2 id="收到-digests-的通知-getting-notified-of-digests"><a href="#收到-Digests-的通知-Getting-Notified-Of-Digests" class="headerlink" title="收到 Digests 的通知 (Getting Notified Of Digests)"></a>收到 Digests 的通知 (Getting Notified Of Digests)</h2><p>如果想在每次 digest 之后都收到通知，我们可以利用监视函数将在每次 digest 过程中都会被调用这个事实，只要注册一个监视函数而没有侦听函数的监视器就可以了。</p>
<p>为了支持这个使用场景，我们需要检查监视器中的侦听函数是否为空，如果为空则将一个空函数赋给侦听函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params">watchFn, listenerFn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> watcher = &#123;</div><div class="line">    <span class="attr">watchFn</span>: watchFn,</div><div class="line">    <span class="attr">listenerFn</span>: listenerFn || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.$$watchers.push(watcher);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果使用了这种方式，需要注意的是，即使没有提供 <code>listenerFn</code>，Angular 也将检查 <code>watchFn</code> 的返回值。如果返回了一个值，该值必须经过脏值检查，所以，为了确保在使用这种模式时不会引起额外的工作，我们在观察函数中不返回任何值。在这种情况下观察函数的返回值将始终是 <code>undefined</code>。</p>
<iframe src="http://jsbin.com/OsITIZu/6/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<p>核心就是现在这样，但我们还远远没有完成。例如，有一个相当典型的场景我们还不支持：监听函数本身也可能改变 Scope 的属性，如果发生这种情况，并且还有另外一个监视函数监视了刚刚改变的属性值，那么就有可能在同一个 <code>digest</code> 过程中不会收到这个改变通知。</p>
<iframe src="http://jsbin.com/eTIpUyE/3/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<p>下面让我们来修复这个问题。</p>
<h2 id="当有脏值时保持-digest-过程-keep-digesting-while-dirty"><a href="#当有脏值时保持-digest-过程-Keep-Digesting-While-Dirty" class="headerlink" title="当有脏值时保持 digest 过程 (Keep Digesting While Dirty)"></a>当有脏值时保持 digest 过程 (Keep Digesting While Dirty)</h2><p>我们需要修改 <code>digest</code> 函数，通过不间断循环遍历所有观察函数，直到所有被监视的值停止改变。 </p>
<p>首先，将现有的 <code>$digest</code> 函数重命名为 <code>$$digestOnce</code>，修改这个函数的实现，让它运行一次所有的观察函数，并返回一个布尔值，表示是否有任何变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$digestOnce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self  = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watch</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newValue = watch.watchFn(self);</div><div class="line">    <span class="keyword">var</span> oldValue = watch.last;</div><div class="line">    <span class="keyword">if</span> (newValue !== oldValue) &#123;</div><div class="line">      watch.listenerFn(newValue, oldValue, self);</div><div class="line">      dirty = <span class="literal">true</span>;</div><div class="line">      watch.last = newValue;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> dirty;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后，重新定义一个 <code>$digest</code> 函数，只要改变还在发生，在函数内部将不断循环调用 <code>$$digestOnce</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    dirty = <span class="keyword">this</span>.$$digestOnce();</div><div class="line">  &#125; <span class="keyword">while</span> (dirty);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在 <code>$digest</code> 函数将至少运行一次所有的观察函数。如果在第一次运行后，有任何的观察值发生了改变，这个过程叫标记为“脏”，然后所有的观察函数将被运行第二遍，这样继续下去，直到有一个完整的过程中所有观察值都没有发生改变，这种情况被认为是稳定的。</p>
<p class="dot">实际上在 Angular 的 Scope 中并没有一个函数叫 <code>$$digestOnce</code>，所有的 digest  循环都是嵌套在 <code>$digest</code> 函数中。我们的目标是清晰地呈现整个过程，所以将内层循环提取到一个单独的函数中。</p>

<p>下面是新的实现代码：</p>
<iframe src="http://jsbin.com/Imoyosa/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<p>现在我们对观察函数有另外一个重要的认识：在一次 digest 过程中观察函数可能被运行多次，这就是为什么人们常说观察函数应该是<a href="http://en.wikipedia.org/wiki/Idempotence" target="_blank" rel="external">幂等</a>的：观察函数应该没有副作用，或者仅发生有限次数的副作用。例如，如果观察函数触发一个 Ajax 请求，这将不确定你的应用程序将发起多少次请求。</p>
<p>在我们现在的实现中有一个明显的遗漏：如果有两个观察函数监视着彼此彼此的变化，这将发生什么？也就是说，如果状态永远不稳定我们将怎么办？下面代码展示了这种情况。代码中 <code>$digest</code> 的调用被注释掉了，去掉注释看看将发生什么：</p>
<iframe src="http://jsbin.com/eKEvOYa/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<p>一段时间之后 JSBin 将强制停止函数的执行（在我的机器上它运行了 100000 次迭代）。如果在像 Node.js 这样的平台上运行这段代码，它会永远运行下去。</p>
<h2 id="丢弃一个不稳定的-digest-过程-giving-up-on-an-unstable-digest"><a href="#丢弃一个不稳定的-Digest-过程-Giving-Up-On-An-Unstable-Digest" class="headerlink" title="丢弃一个不稳定的 Digest 过程 (Giving Up On An Unstable Digest)"></a>丢弃一个不稳定的 Digest 过程 (Giving Up On An Unstable Digest)</h2><p>我们需要做的是，在可接受数量的迭代范围内是保持运行 Digest 过程。如果超出迭代范围后，Scope 任然没有稳定下来，我们必须停止 Digest 过程，因为 Scope 可能永远不会稳定下来。对于这一点，我们不妨抛出一个异常，因为 Scope 的任何状态都不太可能是用户所期待的的结果。</p>
<p>最大数量迭代次数被称作 TTL (Time To Live)，默认情况下是 10 次，这个值看起来很小（我们刚刚运行了 100000 次 digest 过程），但请记住这是一个性能敏感地带，因为 digest 过程将经常发生，并且每次 digest 过程都将循环调用观察函数，超过 10 次的迭代通常是不可能的。</p>
<p class="dot">事实上在 Angular 中 TTL 的值是可以<a href="http://docs.angularjs.org/api/ng.$rootScopeProvider" target="_blank" rel="external">调整</a>的，在后面的文章中，讨论 provider 和依赖注入时我们将再次讨论这个。</p>


<p>接着，在 digest 循环外添加一个循环计数变量，如果计数到达 TTL，我们将抛出一个异常：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ttl = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    dirty = <span class="keyword">this</span>.$$digestOnce();</div><div class="line">    <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (dirty);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个更新版本会导致我们循环引用的观察函数抛出一个异常：</p>
<iframe src="http://jsbin.com/uNapUWe/3/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<p>这些应该已经把 digest 说清楚了。</p>
<p>下面，让我们将注意力转向如何检测值变更上。</p>
<h2 id="基于值的脏值检查-value-based-dirty-checking"><a href="#基于值的脏值检查-Value-Based-Dirty-Checking" class="headerlink" title="基于值的脏值检查 (Value-Based Dirty-Checking)"></a>基于值的脏值检查 (Value-Based Dirty-Checking)</h2><p>现在我们是通过严格相等操作符 <code>===</code> 来比较新值和旧值。这在大多数情况下是不错的，因为这可以检测到所有值类型（Number、String等）的变化，也可以检测到对象和数组改变为另一个新值（译者注：引用类型的引用改变）。但 Angular 还有另一种方式，并可以检测到对象或数组内部的改变。也就是说，必须基于值来做检测，而不是引用。</p>
<p>这种脏值检测机制需要在 <code>$watch</code> 函数上引入一个可选的布尔标志参数，如果标志参数为 <code>true</code>，将基于值来进行脏值检测。让我们来重新定义观察器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params">watchFn, listenerFn, valueEq</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> watcher = &#123;</div><div class="line">    <span class="attr">watchFn</span>: watchFn,</div><div class="line">    <span class="attr">listenerFn</span>: listenerFn,</div><div class="line">    <span class="attr">valueEq</span>: !!valueEq</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.$$watchers.push(watcher);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们做的是将标记添加到观察器，通过 <code>!!</code> 运算强制将其转换为布尔类型。当用户调用 <code>$watch</code> 时并没有提供第三个参数，那么 <code>valueEq</code> 将是 <code>undefined</code>，在 <code>watcher</code> 对象的内部将是 fasle。</p>
<p>基于值的脏值检测意味着我们必须遍历新旧对象或数组中所有的值，如果新旧两个值有任何差异，就表示发现了脏值。如果有其他对象或数组嵌套，也将递归比较其中的值。</p>
<p>Angular 是通过自身的<a href="https://github.com/angular/angular.js/blob/8d4e3fdd31eabadd87db38aa0590253e14791956/src/Angular.js#L812" target="_blank" rel="external">比较函数</a>来进行基于值的比较，我们将使用 <a href="http://lodash.com/docs#isEqual" target="_blank" rel="external">Lo-Dash 提供的一个函数</a>来替代。这里我们定义了一个新的函数，函数包含两个待比较的值和一个布尔标志，并比较相应的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$areEqual = <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, valueEq</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (valueEq) &#123;</div><div class="line">    <span class="keyword">return</span> _.isEqual(newValue, oldValue);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> newValue === oldValue;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>为了得到值改变的通知，我们也需要在观察器中修改储存旧值的方式，储存值的引用并不够，因为如果值的内部发生改变其引用并不会改变，<code>$$areEqual</code> 函数将认为这两个引用是相同的，不能监控到值的变化。因此，我们需要对将要储存的值进行深拷贝，然后再将其储存起来。</p>
<p>和相等检测函数一样，Angular 有一个自身的<a href="https://github.com/angular/angular.js/blob/8d4e3fdd31eabadd87db38aa0590253e14791956/src/Angular.js#L725" target="_blank" rel="external">深拷贝函数</a>，但是我们将使用 <a href="http://lodash.com/docs#cloneDeep" target="_blank" rel="external">Lo-Dash 内部提供的一个函数</a>。让我们来修改一下 <code>$digestOnce</code> 函数，这样在 <code>$digestOnce</code> 函数中将使用新的 <code>$$areEqual</code> 函数，并在需要的时进行深拷贝来储存更新后的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$digestOnce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self  = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watch</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newValue = watch.watchFn(self);</div><div class="line">    <span class="keyword">var</span> oldValue = watch.last;</div><div class="line">    <span class="keyword">if</span> (!self.$$areEqual(newValue, oldValue, watch.valueEq)) &#123;</div><div class="line">      watch.listenerFn(newValue, oldValue, self);</div><div class="line">      dirty = <span class="literal">true</span>;</div><div class="line">      watch.last = (watch.valueEq ? _.cloneDeep(newValue) : newValue);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> dirty;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在，我们可以看到两种脏值检查之间的区别：</p>
<iframe src="http://jsbin.com/ARiWENO/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<p>基于值进行检查明显比仅仅检查引用更复杂，有时可能会很复杂，遍历嵌套的数据结构需要时间，并且进行深拷贝也占用内存，这就是为什么 Angular 默认不是基于值进行脏值检测的原因，用户需要显式地设置标志来启用它。</p>
<p class="dot">Angular 还提供了第三种脏值检测的机制：检测集合。与基于值的脏值检测机制一样，也将检测对象和数组的内部，不一样的是，它是一个浅检测，不递归到更深层次，这使其性能比基于值检测更好。通过调用 <code>$watchCollection</code> 函数来实现这种检测机制，在本系列的后续文章中我们将看到它是如何实现的。</p>

<p>在完成值比较之前，我们还需要处理一个 JavaScript 陷阱。</p>
<h2 id="非数字nan"><a href="#非数字（NaN）" class="headerlink" title="非数字（NaN）"></a>非数字（NaN）</h2><p>在 JavaScript 中 NaN (Not a Number) 与自身并不相等，这听起来可能有点怪，但是确实就是这样。如果我们不在脏值检测函数中对 NaN 进行特殊处理，那么包含 NaN 的观察器将始终是脏的。</p>
<p>在基于值的脏值检测函数中，Lo-Dash 的 <code>isEqual</code> 函数已经为我们处理了这种情况，但是在基于引用的脏值检测函数中我们需要自己来处理，我们需要对 <code>$$areEqual</code> 函数进行微小的修改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$areEqual = <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, valueEq</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (valueEq) &#123;</div><div class="line">    <span class="keyword">return</span> _.isEqual(newValue, oldValue);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> newValue === oldValue ||</div><div class="line">      (<span class="keyword">typeof</span> newValue === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> oldValue === <span class="string">'number'</span> &amp;&amp;</div><div class="line">       <span class="built_in">isNaN</span>(newValue) &amp;&amp; <span class="built_in">isNaN</span>(oldValue));</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样，包含 NaN 的观察器也将符合预期：</p>
<iframe src="http://jsbin.com/ijINaRA/3/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<p>有了脏值检测的实现，现在该将我们的注意力转向应用程序中与 Scope 进行交互的方式上了。</p>
<h2 id="eval-在-scope-上下文中执行代码"><a href="#eval-在-Scope-上下文中执行代码" class="headerlink" title="$eval - 在 Scope 上下文中执行代码"></a>$eval - 在 Scope 上下文中执行代码</h2><p>在 Angular 中有几种方法来容许你在 Scope 上下文中执行代码。其中最简单的就是 <code>$eval</code> 方法，它使用一个函数作为参数，在方法内部该函数将被调用，调用时将 Scope 自身作为一个参数传递给它，然后返回该函数的返回值。<code>$eval</code> 方法也可以有一个可选的第二个参数，该参数将作为第一个参数被调用时的参数。</p>
<p><code>$eval</code> 的实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$<span class="built_in">eval</span> = <span class="function"><span class="keyword">function</span>(<span class="params">expr, locals</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> expr(<span class="keyword">this</span>, locals);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用 <code>$eval</code> 也非常简单：</p>
<iframe src="http://jsbin.com/UzaWUC/3/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<p>那么，为什么要使用这种看似迂回的方式来调用一个函数呢？这是因为 <code>$eval</code> 明确指定了代码在 Scope 的上下文中执行。接下来我们将会看到 <code>$eval</code> 也构建了 <code>$apply</code> 的上下文。</p>
<p>然而，或许使用 <code>$eval</code> 最有趣的地方不是传入函数，而是前面提到过的表达式。就和 <code>$watch</code> 方法一样，你可以给 <code>$eval</code> 方法传递一个字符串表达式，<code>$eval</code> 将编译该字符串然后在 Scope 的上下文中执行。我们将在本系列的后续文章中实现这个。</p>
<h2 id="apply-集成外部代码到-digest-循环"><a href="#apply-集成外部代码到-digest-循环" class="headerlink" title="$apply - 集成外部代码到 digest 循环"></a>$apply - 集成外部代码到 digest 循环</h2><p>或许 Scope 上我们知道最多的是 <code>$apply</code>，它被誉为 Angular 集成外部代码的标准方法，这样说是有原因的。</p>
<p><code>$apply</code> 把一个函数作为参数，接着在其内部使用 <code>$eval</code> 掉用该函数，然后再进行 digest 循环。下面是简单的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$apply = <span class="function"><span class="keyword">function</span>(<span class="params">expr</span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$<span class="built_in">eval</span>(expr);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">this</span>.$digest();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>将 <code>$digest</code> 放在 finally 中，来确保即使函数中发生了异常，也会执行 digest 过程。</p>
<p><code>$apply</code> 的最大创意在于执行一些不受 Angular 管控的代码，这些代码可能修改 Scope 中的某些值， <code>$apply</code> 可以确保观察器可以收到这些改变的通知。当人们提到使用 <code>$apply</code> 来将外部代码集成到 Abgular 的生命周期中时，他们指的就是这个事情，实在没有比这更重要的了。</p>
<p>下面是 <code>$apply</code> 的实例：</p>
<iframe src="http://jsbin.com/UzaWUC/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<h2 id="evalasync-延迟执行"><a href="#evalAsync-延迟执行" class="headerlink" title="$evalAsync - 延迟执行"></a>$evalAsync - 延迟执行</h2><p>在 JavaScript 中延迟执行一段代码很常见 - 把执行延迟到当前执行上下文结束之后的未来某个时间点，通常的方法是通过调用 <code>setTimeout()</code> 函数，传递一个 0 (或很小)延迟参数。</p>
<p>这种模式也适用于 Angular 应用程序，尽管首选的方法是通过使用 <code>$timeout</code> <a href="http://docs.angularjs.org/api/ng.$timeout" target="_blank" rel="external">服务</a>，不同的是，<code>$timeout</code> 将通过 <code>$apply</code> 方法将延迟函数集成到 digest 循环的生命周期中。</p>
<p>但在 Angular 中还有另外一种方式来延迟代码的执行，那就是 <code>Scope.$evalAsync</code> 函数， <code>$evalAsync</code> 接收一个函数作为参数，并使其在当前 digest 循环或下一个 digest 循环之前被执行。例如，你可以在观察函数中延迟执行一段代码，虽然被延迟执行，但任然会在当前 digest 循环中被调用。</p>
<p>首先，我们需要一种方式来储存 <code>$evalAsync</code> 中计划的任务，可以在 Scope 的构造函数中初始化一个数组来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$watchers = [];</div><div class="line">  <span class="keyword">this</span>.$$asyncQueue = [];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，定义 <code>$evalAsync</code> 函数，将需要延迟执行的方法添加到队列中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$evalAsync = <span class="function"><span class="keyword">function</span>(<span class="params">expr</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$asyncQueue.push(&#123;<span class="attr">scope</span>: <span class="keyword">this</span>, <span class="attr">expression</span>: expr&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p class="dot">我们将当前 Scope 显示地设置在延迟队列中的目的在于 Scope 的继承，我们将在本系列的下一篇文章中讨论。</p>

<p>接着，我们在 <code>$digest</code> 函数中使用 <code>$eval</code> 调用延迟队列中的所有被延迟的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ttl = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.$$asyncQueue.length) &#123;</div><div class="line">      <span class="keyword">var</span> asyncTask = <span class="keyword">this</span>.$$asyncQueue.shift();</div><div class="line">      <span class="keyword">this</span>.$<span class="built_in">eval</span>(asyncTask.expression);</div><div class="line">    &#125;</div><div class="line">    dirty = <span class="keyword">this</span>.$$digestOnce();</div><div class="line">    <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (dirty);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个实现确保了：当 Scope 正处于“脏”的状态时你推迟一个函数的执行，这个函数会被延迟，但是还是处于当前的 digest 循环中。</p>
<p>下面是 <code>$evalAsync</code> 的使用实例：</p>
<iframe src="http://jsbin.com/ilepOwI/2/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<h2 id="scope-的阶段状态scope-phases"><a href="#Scope-的阶段状态（Scope-Phases）" class="headerlink" title="Scope 的阶段状态（Scope Phases）"></a>Scope 的阶段状态（Scope Phases）</h2><p><code>$evalAsync</code> 所做的另外一件事是：如果当前没有正在运行的 digest 循环，就延迟执行一个，这样就可以确保，每当调用 <code>$evalAsync</code> 方法时，digest 循环将很快被触发，而不是等待引发一个 digest 循环。</p>
<p><code>$evalAsync</code> 需要一个机制来检查是否已经有一个 digest 循环正在运行，如果已经有一个 digest 循环就不必再执行一个。为此，Angular 引入了 <em>phase</em>，它就是 Scope 上的一个字符串属性，储存了当前正在发生着什么。</p>
<p>在 Scope 的构造函数中引入 <code>$$phase</code> 字段，并初始化为 null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$watchers = [];</div><div class="line">  <span class="keyword">this</span>.$$asyncQueue = [];</div><div class="line">  <span class="keyword">this</span>.$$phase = <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，我们定义了两个方法来控制 phase：一个用于设置，另一个用于清理，同时添加一个额外的检查，以确保我们不会试图设置一个已经激活的 phase：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$beginPhase = <span class="function"><span class="keyword">function</span>(<span class="params">phase</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.$$phase) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">this</span>.$$phase + <span class="string">' already in progress.'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.$$phase = phase;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">Scope.prototype.$clearPhase = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$phase = <span class="literal">null</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在 <code>$digest</code> 方法中，在 digest 循环开始前将 pahse 的值设置为 “$digest” ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ttl = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  <span class="keyword">this</span>.$beginPhase(<span class="string">"$digest"</span>);</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.$$asyncQueue.length) &#123;</div><div class="line">      <span class="keyword">var</span> asyncTask = <span class="keyword">this</span>.$$asyncQueue.shift();</div><div class="line">      <span class="keyword">this</span>.$<span class="built_in">eval</span>(asyncTask.expression);</div><div class="line">    &#125;</div><div class="line">    dirty = <span class="keyword">this</span>.$$digestOnce();</div><div class="line">    <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      <span class="keyword">this</span>.$clearPhase();</div><div class="line">      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (dirty);</div><div class="line">  <span class="keyword">this</span>.$clearPhase();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>把 <code>$apply</code> 函数也修改一下，在其内部设置 phase，这对我们调试非常有帮助：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$apply = <span class="function"><span class="keyword">function</span>(<span class="params">expr</span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">this</span>.$beginPhase(<span class="string">"$apply"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$<span class="built_in">eval</span>(expr);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">this</span>.$clearPhase();</div><div class="line">    <span class="keyword">this</span>.$digest();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后，我们在 <code>$evalAsync</code> 函数中添加 digest 计划任务，它将检查当前 Scope 的 phase，如果 phase 没有被设置（并且没有异步的计划任务），就把这个 digest 列入计划。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$evalAsync = <span class="function"><span class="keyword">function</span>(<span class="params">expr</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">if</span> (!self.$$phase &amp;&amp; !self.$$asyncQueue.length) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (self.$$asyncQueue.length) &#123;</div><div class="line">        self.$digest();</div><div class="line">      &#125;</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line">  self.$$asyncQueue.push(&#123;<span class="attr">scope</span>: self, <span class="attr">expression</span>: expr&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样，不管什么时候调用 <code>$evalAsync</code>，都可以确保一定有一个 digest 将在稍候就发生。</p>
<iframe src="http://jsbin.com/iKeSaGi/2/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe>

<h2 id="postdigest-digest-之后执行代码"><a href="#postDigest-digest-之后执行代码" class="headerlink" title="$$postDigest - digest 之后执行代码"></a>$$postDigest - digest 之后执行代码</h2><p>通过计划执行一个 <code>$$postDigest</code> 函数，也可以把代码附加到 digest 循环中。</p>
<p>双美元符号 <code>$$</code> 表示该函数是 Angular 的一个内部函数，不是应用开发人员应该使用的，但是它确实存在，因此我们也要实现它。</p>
<p>和 <code>$evalAsync</code> 一样，<code>$$postDigest</code> 也是延迟执行一个任务，不同的是，被延迟的任务是在下一次 digest 循环结束之后执行。<code>$$postDigest</code> 并不会引起计划执行一个 digest 循环，所以只有某些其他原因引发 digest 循环后才会调用被延迟的函数，因此，如果在延迟函数内部也修改了 Scope 上的数据，您需要手动调用 <code>$digest</code> 或 <code>$apply</code> 来使得这些变更会被监视到。</p>
<p>首先，我们在 Scope 的构造函数中添加一个 <code>$$postDigest</code> 将要使用到的队列：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$watchers = [];</div><div class="line">  <span class="keyword">this</span>.$$asyncQueue = [];</div><div class="line">  <span class="keyword">this</span>.$$postDigestQueue = [];</div><div class="line">  <span class="keyword">this</span>.$$phase = <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，实现 <code>$$postDigest</code> 函数，它所做的就是将给定的函数添加到队列中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$postDigest = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$postDigestQueue.push(fn);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后，在 <code>$digest</code> 函数中，当 digest 循环结束之后，遍历并调用队列中的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ttl = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  <span class="keyword">this</span>.$beginPhase(<span class="string">"$digest"</span>);</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.$$asyncQueue.length) &#123;</div><div class="line">      <span class="keyword">var</span> asyncTask = <span class="keyword">this</span>.$$asyncQueue.shift();</div><div class="line">      <span class="keyword">this</span>.$<span class="built_in">eval</span>(asyncTask.expression);</div><div class="line">    &#125;</div><div class="line">    dirty = <span class="keyword">this</span>.$$digestOnce();</div><div class="line">    <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      <span class="keyword">this</span>.$clearPhase();</div><div class="line">      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (dirty);</div><div class="line">  <span class="keyword">this</span>.$clearPhase();</div><div class="line"> </div><div class="line">  <span class="keyword">while</span> (<span class="keyword">this</span>.$$postDigestQueue.length) &#123;</div><div class="line">    <span class="keyword">this</span>.$$postDigestQueue.shift()();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样我们就可以使用 <code>$$postDigest</code> 函数了：</p>
<iframe src="http://jsbin.com/IMEhowO/5/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px"></iframe>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>我们现有的实现已经非常接近 Angular 的实际样子了，但是还比较脆弱，这是因为我们还没有花太多心思去做异常处理。</p>
<p>在 Angular 中，Scope 在遇到错误时是非常健壮的： 当在监控函数、<code>$evalAsync</code> 函数或者 <code>$$postDigest</code> 函数中发生异常时，并不会导致 digest 循环的终止。在我们现在实现中，以上任何函数中发生异常都会导致 digest 循环的终止。</p>
<p>不过，这也很容易修复，把上面三个函数的调用都包在 <code>try...catch</code> 中就可以了。</p>
<p class="dot"><br>Angular 实际上是把这些异常抛给了它的 <a href="http://docs.angularjs.org/api/ng.$exceptionHandler" target="_blank" rel="external">$exceptionHandler 服务</a>。但是我们现在还没有实现这个服务，所以就先把这些异常打印到控制台上。<br></p>

<p>对 <code>$evalAsync</code> 和 <code>$$postDigest</code> 的异常处理是在 <code>$digest</code> 函数内部进行的，在延迟函数中抛出的异常将被记录成日志，而后面的延迟函数将继续正常执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ttl = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  <span class="keyword">this</span>.$beginPhase(<span class="string">"$digest"</span>);</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.$$asyncQueue.length) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">var</span> asyncTask = <span class="keyword">this</span>.$$asyncQueue.shift();</div><div class="line">        <span class="keyword">this</span>.$<span class="built_in">eval</span>(asyncTask.expression);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        (<span class="built_in">console</span>.error || <span class="built_in">console</span>.log)(e);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    dirty = <span class="keyword">this</span>.$$digestOnce();</div><div class="line">    <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      <span class="keyword">this</span>.$clearPhase();</div><div class="line">      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (dirty);</div><div class="line">  <span class="keyword">this</span>.$clearPhase();</div><div class="line"> </div><div class="line">  <span class="keyword">while</span> (<span class="keyword">this</span>.$$postDigestQueue.length) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">this</span>.$$postDigestQueue.shift()();</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      (<span class="built_in">console</span>.error || <span class="built_in">console</span>.log)(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对观察函数的异常处理是在 <code>$$digestOnce</code> 函数中进行的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$digestOnce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self  = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watch</span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">var</span> newValue = watch.watchFn(self);</div><div class="line">      <span class="keyword">var</span> oldValue = watch.last;</div><div class="line">      <span class="keyword">if</span> (!self.$$areEqual(newValue, oldValue, watch.valueEq)) &#123;</div><div class="line">        watch.listenerFn(newValue, oldValue, self);</div><div class="line">        dirty = <span class="literal">true</span>;</div><div class="line">        watch.last = (watch.valueEq ? _.cloneDeep(newValue) : newValue);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      (<span class="built_in">console</span>.error || <span class="built_in">console</span>.log)(e);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> dirty;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在我们的 digest 循环碰到异常的时候健壮多了：</p>
<iframe src="http://jsbin.com/IMEhowO/6/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px"></iframe>

<h2 id="销毁监听器"><a href="#销毁监听器" class="headerlink" title="销毁监听器"></a>销毁监听器</h2><p>通常，我们注的监视器都一直存在于 Scope 的生命周期中，很少需要显示地去移除这些监视器。但是在有些场景下，我么需要在 Scope 的生命周期中把某个监听器移除。</p>
<p>Angular 中的 <code>$watch</code> 函数实际上是有返回值的，它返回的是一个函数，当调用该函数时，可以移除刚刚注册的监视器。为了实现我们自己的版本，我们需要返回一个函数来将监视器从 <code>$$watchers</code> 数组中移除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params">watchFn, listenerFn, valueEq</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> watcher = &#123;</div><div class="line">    <span class="attr">watchFn</span>: watchFn,</div><div class="line">    <span class="attr">listenerFn</span>: listenerFn,</div><div class="line">    <span class="attr">valueEq</span>: !!valueEq</div><div class="line">  &#125;;</div><div class="line">  self.$$watchers.push(watcher);</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> index = self.$$watchers.indexOf(watcher);</div><div class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</div><div class="line">      self.$$watchers.splice(index, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在，我们可以储存 <code>$watch</code> 函数的返回值，以后通过调用它来移除这个监视器：</p>
<iframe src="http://jsbin.com/IMEhowO/7/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px"></iframe>

<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>我们已经取得了很大的进展，并且已经实现了一个完美可用的，类似 Angular 这样基于脏检测的 Scope 系统，但是 Angular 中的 Scope 要复杂得多。</p>
<p>更重要的是，在 Angular 里 Scope 对象并不是孤立对象，相反，一个 Scope 对象是可以继承另外一个 Scope 对象的，并且监视器不仅可以监视当前 Scope 对象上的数据变化，还可以监视其父 Scope 对象。概念虽然简单，这却让很多初学者很困惑。所以，本系列的下一篇文章主题就是 Scope 的继承。</p>
<p>随后，我们还会讨论 Angular 的事件系统，这也是在 Scope 上实现的。</p>
<p><img src="http://bubkoo.qiniudn.com/Build%20Your%20Own%20AngularJS.jpg" alt=""></p>
<p><a href="http://teropa.info/build-your-own-angular" target="_blank" rel="external">这里</a>有该书的电子版，不过要花钱。</p></section><footer class="article-footer clearfix"><div class="tags"><a href="/tags/angularjs/" title="AngularJS">AngularJS</a></div></footer></div><nav class="article-nav clearfix"><a href="/2014/01/17/sort-algorithm/archives/" class="article-nav-link article-nav-newer"><strong class="article-nav-type">Newer</strong><span class="article-nav-title">常见排序算法【归档】</span></a><a href="/2014/01/23/deep-in-delete/" class="article-nav-link article-nav-older"><strong class="article-nav-type">Older</strong><span class="article-nav-title">深入理解 JavaScript 中的 delete 操作符</span></a></nav></article><section id="article-comment" class="article-comment"><div data-thread-key="http://bubkoo.com/2014/01/19/angular/make-your-own-angular-part-1-scopes-and-digest/" data-title="【译】构建您自己的 AngularJS，第一部分：scopes 和 digest" data-url="http://bubkoo.com/2014/01/19/angular/make-your-own-angular-part-1-scopes-and-digest/" class="ds-thread"></div></section></div><aside id="sidebar" role="sidebar"><div class="widget tagcloud"><h3 class="widget-title">标签</h3><div class="widget-content"><a href="/tags/aop/" style="font-size: 10px">AOP</a> <a href="/tags/algorithm/" style="font-size: 18.33px">Algorithm</a> <a href="/tags/analysis/" style="font-size: 10px">Analysis</a> <a href="/tags/angularjs/" style="font-size: 15px">AngularJS</a> <a href="/tags/animation/" style="font-size: 10px">Animation</a> <a href="/tags/architecture/" style="font-size: 16.67px">Architecture</a> <a href="/tags/archives/" style="font-size: 10.83px">Archives</a> <a href="/tags/async/" style="font-size: 12.5px">Async</a> <a href="/tags/backbone/" style="font-size: 10px">Backbone</a> <a href="/tags/browsers/" style="font-size: 10px">Browsers</a> <a href="/tags/css/" style="font-size: 12.5px">CSS</a> <a href="/tags/css3/" style="font-size: 10px">CSS3</a> <a href="/tags/closure/" style="font-size: 10.83px">Closure</a> <a href="/tags/closures/" style="font-size: 10px">Closures</a> <a href="/tags/cookies/" style="font-size: 10px">Cookies</a> <a href="/tags/cross-domain/" style="font-size: 10px">Cross Domain</a> <a href="/tags/custom-elements/" style="font-size: 10.83px">Custom Elements</a> <a href="/tags/d3/" style="font-size: 10px">D3</a> <a href="/tags/debounce/" style="font-size: 10px">Debounce</a> <a href="/tags/debug/" style="font-size: 10.83px">Debug</a> <a href="/tags/dependency/" style="font-size: 10px">Dependency</a> <a href="/tags/document/" style="font-size: 10px">Document</a> <a href="/tags/ecma-262-3/" style="font-size: 15.83px">ECMA-262-3</a> <a href="/tags/ecmascript/" style="font-size: 15.83px">ECMAScript</a> <a href="/tags/es6/" style="font-size: 20px">ES6</a> <a href="/tags/errors/" style="font-size: 10px">Errors</a> <a href="/tags/essential/" style="font-size: 10px">Essential</a> <a href="/tags/evaluation-strategy/" style="font-size: 10px">Evaluation strategy</a> <a href="/tags/event/" style="font-size: 10px">Event</a> <a href="/tags/exceptions/" style="font-size: 10px">Exceptions</a> <a href="/tags/express/" style="font-size: 10px">Express</a> <a href="/tags/flip/" style="font-size: 10px">FLIP</a> <a href="/tags/flexbox/" style="font-size: 10px">Flexbox</a> <a href="/tags/funarg/" style="font-size: 10px">Funarg</a> <a href="/tags/gist/" style="font-size: 10px">Gist</a> <a href="/tags/github/" style="font-size: 10px">Github</a> <a href="/tags/guide/" style="font-size: 10px">Guide</a> <a href="/tags/html/" style="font-size: 10px">HTML</a> <a href="/tags/http/" style="font-size: 10px">HTTP</a> <a href="/tags/hexo/" style="font-size: 10.83px">Hexo</a> <a href="/tags/ie/" style="font-size: 10px">IE</a> <a href="/tags/iife/" style="font-size: 10px">IIFE</a> <a href="/tags/jshint/" style="font-size: 10px">JSHint</a> <a href="/tags/javascript/" style="font-size: 19.17px">JavaScript</a> <a href="/tags/leak/" style="font-size: 10px">Leak</a> <a href="/tags/linting/" style="font-size: 10px">Linting</a> <a href="/tags/mvc/" style="font-size: 10px">MVC</a> <a href="/tags/methodology/" style="font-size: 10px">Methodology</a> <a href="/tags/mock/" style="font-size: 10px">Mock</a> <a href="/tags/modular/" style="font-size: 10px">Modular</a> <a href="/tags/mongodb/" style="font-size: 10px">MongoDB</a> <a href="/tags/oop/" style="font-size: 10.83px">OOP</a> <a href="/tags/partial-application/" style="font-size: 10px">Partial Application</a> <a href="/tags/pattern/" style="font-size: 10px">Pattern</a> <a href="/tags/patterns/" style="font-size: 10px">Patterns</a> <a href="/tags/performance/" style="font-size: 14.17px">Performance</a> <a href="/tags/promise/" style="font-size: 13.33px">Promise</a> <a href="/tags/prototype/" style="font-size: 11.67px">Prototype</a> <a href="/tags/quality/" style="font-size: 10px">Quality</a> <a href="/tags/quiz/" style="font-size: 10px">Quiz</a> <a href="/tags/regex/" style="font-size: 10px">Regex</a> <a href="/tags/requirejs/" style="font-size: 10px">RequireJS</a> <a href="/tags/sass/" style="font-size: 10px">SASS</a> <a href="/tags/svg/" style="font-size: 10px">SVG</a> <a href="/tags/scope/" style="font-size: 10.83px">Scope</a> <a href="/tags/shapes/" style="font-size: 10px">Shapes</a> <a href="/tags/shuffle/" style="font-size: 10px">Shuffle</a> <a href="/tags/sort/" style="font-size: 17.5px">Sort</a> <a href="/tags/source-map/" style="font-size: 10.83px">Source Map</a> <a href="/tags/styling/" style="font-size: 10px">Styling</a> <a href="/tags/sublime-text/" style="font-size: 10px">Sublime Text</a> <a href="/tags/template/" style="font-size: 10px">Template</a> <a href="/tags/throttle/" style="font-size: 10px">Throttle</a> <a href="/tags/timing/" style="font-size: 10px">Timing</a> <a href="/tags/tools/" style="font-size: 12.5px">Tools</a> <a href="/tags/variable-object/" style="font-size: 10px">Variable object</a> <a href="/tags/visualizations/" style="font-size: 10px">Visualizations</a> <a href="/tags/when/" style="font-size: 12.5px">When</a> <a href="/tags/delete/" style="font-size: 10px">delete</a> <a href="/tags/execution-context/" style="font-size: 10px">execution context</a> <a href="/tags/fetch/" style="font-size: 10px">fetch</a> <a href="/tags/function/" style="font-size: 10px">function</a> <a href="/tags/nodejs/" style="font-size: 10px">nodejs</a> <a href="/tags/nodemon/" style="font-size: 10px">nodemon</a> <a href="/tags/npm/" style="font-size: 10px">npm</a> <a href="/tags/nvm/" style="font-size: 10px">nvm</a> <a href="/tags/performance/" style="font-size: 10px">performance</a> <a href="/tags/prebrowsing/" style="font-size: 10px">prebrowsing</a> <a href="/tags/prefetching/" style="font-size: 10px">prefetching</a> <a href="/tags/preloading/" style="font-size: 10px">preloading</a> <a href="/tags/tabindex/" style="font-size: 10px">tabindex</a> <a href="/tags/this/" style="font-size: 10px">this</a> <a href="/tags/ui-router/" style="font-size: 14.17px">ui-router</a></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/01/18/debouncing-throttling-explained-examples/">实例解析防抖和节流函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/08/quick-tip-multiple-versions-node-nvm/">使用 nvm 管理不同版本的 node 与 npm</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/08/15-ways-to-write-self-documenting-javascript/">如何编写更加自解释的代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/31/high-performance-animations/">使用 FLIP 来提高 Web 动画的性能</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/28/styling-broken-images/">定制图片加载失败时的样式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/26/delivering-octicons-with-svg/">使用 SVG 输出 Octicon</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/18/how-to-use-npm-as-a-build-tool/">如何将 npm 作为构建工具使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/what-you-can-do-with-gists-on-github/">任何人都可以使用到的 Gist 服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/19/prefetching-preloading-prebrowsing/">前端性能优化 - 资源预加载</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/18/es6-in-depth-the-future/">深入解析 ES6：未来展望</a></li></ul></div></div></aside><aside id="topic-wrap" class="toc-wrap f-right"><h3 class="toc-wrap-title">内容</h3><div class="toc-tree"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于源代码"><span class="toc-number">1.</span> <span class="toc-text">关于源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scope-对象"><span class="toc-number">2.</span> <span class="toc-text">Scope 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#监视对象属性watch-和-digest"><span class="toc-number">3.</span> <span class="toc-text">监视对象属性：$watch 和 $digest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#脏值检查"><span class="toc-number">4.</span> <span class="toc-text">脏值检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#收到-digests-的通知-getting-notified-of-digests"><span class="toc-number">5.</span> <span class="toc-text">收到 Digests 的通知 (Getting Notified Of Digests)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#当有脏值时保持-digest-过程-keep-digesting-while-dirty"><span class="toc-number">6.</span> <span class="toc-text">当有脏值时保持 digest 过程 (Keep Digesting While Dirty)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#丢弃一个不稳定的-digest-过程-giving-up-on-an-unstable-digest"><span class="toc-number">7.</span> <span class="toc-text">丢弃一个不稳定的 Digest 过程 (Giving Up On An Unstable Digest)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于值的脏值检查-value-based-dirty-checking"><span class="toc-number">8.</span> <span class="toc-text">基于值的脏值检查 (Value-Based Dirty-Checking)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非数字nan"><span class="toc-number">9.</span> <span class="toc-text">非数字（NaN）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eval-在-scope-上下文中执行代码"><span class="toc-number">10.</span> <span class="toc-text">$eval - 在 Scope 上下文中执行代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply-集成外部代码到-digest-循环"><span class="toc-number">11.</span> <span class="toc-text">$apply - 集成外部代码到 digest 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#evalasync-延迟执行"><span class="toc-number">12.</span> <span class="toc-text">$evalAsync - 延迟执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scope-的阶段状态scope-phases"><span class="toc-number">13.</span> <span class="toc-text">Scope 的阶段状态（Scope Phases）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#postdigest-digest-之后执行代码"><span class="toc-number">14.</span> <span class="toc-text">$$postDigest - digest 之后执行代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常处理"><span class="toc-number">15.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#销毁监听器"><span class="toc-number">16.</span> <span class="toc-text">销毁监听器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#展望"><span class="toc-number">17.</span> <span class="toc-text">展望</span></a></li></ol></div><div class="toc-progress"></div></aside></div><footer id="footer" class="inner"><span class="copyright">© 2017 bubkoo</span><span class="theme">@<a href="https://github.com/bubkoo/hexo-theme-formula" target="_blank">formula</a></span></footer><img id="go2top" src="/images/top_arrow.png" alt="go2top"><script charset="utf-8" src="/js/lib/jquery-2.1.3.min.js"></script><script charset="utf-8" src="/js/lib/jquery.imagesloaded.min.js"></script><script charset="utf-8" src="/fancybox/jquery.fancybox.pack.js"></script><script charset="utf-8" src="/js/lib/sea.js"></script><script charset="utf-8" src="/js/main.js"></script><script id="redundancy3">var duoshuoQuery = { short_name: 'bubkoo' };
(function () {
  var ds = document.createElement('script');

  ds.type    = 'text/javascript';
  ds.async   = true;
  ds.src     = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';

  (document.getElementsByTagName('head')[0]
  || document.getElementsByTagName('body')[0]).appendChild(ds);

  ds.parentNode.removeChild(ds);

  var script = document.getElementById('redundancy3');
  script && script.parentNode.removeChild(script);
})();</script></body></html>
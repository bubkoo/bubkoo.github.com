<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>JavaScript Promises 教程 | bubkoo</title><meta name="author" content="bubkoo"><meta name="description" content="童鞋们，请准备好迎接 Web 开发历史上一个重大时刻。。。
[鼓声响起]
JavaScript 有了原生的 Promise！
[漫天的烟花绽放，人群沸腾了]
这时候你大概是这三种人之一：

你的身边拥挤着欢呼的人群，但是你却不在其中，甚至你还不大清楚“Promise”是什么。你耸耸肩，烟花的碎屑在你的身边落下。不过不要担心，我也是花了多年的时间才明白 Promise 的意义，你可以从这里开始。
你一挥拳！太赞了对么！你已经用过一些 Promise 的库，但是所有这些第三方实现在 API 上都略有差异，JavaScript 官方的 API 会是什么样子？请看这里！
你早就知道了，看着那些欢呼雀跃的新人你的嘴角泛起一丝不屑的微笑。你可以安静享受一会儿优越感，然后直接去看 API 参考吧。"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:title" content="JavaScript Promises 教程"><meta property="og:site_name" content="bubkoo"><link href="/favicon.ico" rel="icon" type="image/x-ico"><link href="/atom.xml" rel="alternate" title="bubkoo" type="application/atom+xml"><link href="/css/style.css" rel="stylesheet" type="text/css" charset="utf-8"><link href="/fancybox/jquery.fancybox.css" rel="stylesheet" type="text/css" charset="utf-8"><script id="google_analytics">(function (window, document, src, ga) {

  window['GoogleAnalyticsObject'] = ga;

  if (!window[ga]) {
    window[ga] = function () {
      (window[ga].q = window[ga].q || []).push(arguments);
    };
  }

  window[ga].l = 1 * new Date();

  var thisTag = document.getElementById('google_analytics');
  var script  = document.createElement('script');

  script.async = true;
  script.src   = src;

  thisTag.parentNode.insertBefore(script, thisTag);

  setTimeout(function () {
    script.parentNode.removeChild(script);
    thisTag.parentNode.removeChild(thisTag);
  }, 100);

})(window, document, 'https://www.google-analytics.com/analytics.js', 'ga');

ga('create', 'UA-78428859-2', 'auto');
ga('send', 'pageview');</script><script id="baidu_tongji">var _hmt = _hmt || [];
(function () {
  var script  = document.createElement('script');
  var thisTag = document.getElementById('baidu_tongji');

  script.src = '//hm.baidu.com/hm.js?49a1665c33b011585a2a629fdbed5b61';

  thisTag.parentNode.insertBefore(script, thisTag);

  setTimeout(function () {
    script.parentNode.removeChild(script);
    thisTag.parentNode.removeChild(thisTag);
  }, 100);
})();</script><!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]--><script>__start__ = window.performance && performance.timing ? performance.timing.navigationStart : Date.now();</script></head><body><header id="header" hoot="default" hoot-rate="1" class="inner"><div class="f-left"><a href="/" class="site-title">bubkoo</a></div><nav class="f-right"><ul class="site-nav"><li><a href="/">&lt;&gt;</a></li><li><a href="/archives">Archives</a></li><li><a href="https://github.com/bubkoo">Github</a></li></ul></nav></header><div id="container" class="inner"><div id="main"><article class="article link"><div class="article-wrap"><header class="article-header"><span class="article-header-icon icon-black"></span><h1 class="article-header-title">JavaScript Promises 教程</h1><time datetime="2014-03-22T23:57:12.000Z" itemprop="datePublished" class="article-header-time"><span class="day">22</span><span class="month">2014年03月</span></time></header><section class="article-content"><p>童鞋们，请准备好迎接 Web 开发历史上一个重大时刻。。。</p>
<p>[鼓声响起]</p>
<p>JavaScript 有了原生的 Promise！</p>
<p>[漫天的烟花绽放，人群沸腾了]</p>
<p>这时候你大概是这三种人之一：</p>
<ul>
<li>你的身边拥挤着欢呼的人群，但是你却不在其中，甚至你还不大清楚“Promise”是什么。你耸耸肩，烟花的碎屑在你的身边落下。不过不要担心，我也是花了多年的时间才明白 Promise 的意义，你可以<a href="#toc-async">从这里开始</a>。</li>
<li>你一挥拳！太赞了对么！你已经用过一些 Promise 的库，但是所有这些第三方实现在 API 上都略有差异，JavaScript 官方的 API 会是什么样子？请看<a href="#toc-promise-terminology">这里</a>！</li>
<li>你早就知道了，看着那些欢呼雀跃的新人你的嘴角泛起一丝不屑的微笑。你可以安静享受一会儿优越感，然后直接去看 <a href="#toc-api">API 参考</a>吧。</li>
</ul>
<a id="more"></a>
<p><a name="toc-async"></a></p>
<h2 id="他们都在激动什么"><a href="#他们都在激动什么？" class="headerlink" title="他们都在激动什么？"></a>他们都在激动什么？</h2><p>JavaScript 是单线程的，这意味着任何两句代码都不能同时运行，它们得一个接一个来。在浏览器中，JavaScript 和其他任务共享一个线程，不同的浏览器略有差异，共享线程的任务包括重绘、更新样式、用户交互等，所有这些任务操作都会阻塞其他任务。</p>
<p>作为人类，你是多线程的。你可以用多个手指同时敲键盘，也可以一边开车一遍电话。唯一的全局阻塞函数是打喷嚏，打喷嚏期间所有其他事务都会暂停。很烦人对么？尤其是当你开着车打着电话的时候。我们都不喜欢这个时候打喷嚏。</p>
<p>你应该会用事件加回调的办法来处理这类情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img1 = <span class="built_in">document</span>.querySelector(<span class="string">'.img-1'</span>);</div><div class="line">  </div><div class="line">img1.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 啊哈图片加载完成</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">img1.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 哎哟出问题了</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们为请求图片添加了几个监听函数，然后 JavaScript 就停止运行了，直到触发某个监听函数。</p>
<p>上面的例子中唯一的问题是，事件有可能在我们绑定监听器之前就已经发生，所以我们先要检查图片的“complete”属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img1 = <span class="built_in">document</span>.querySelector(<span class="string">'.img-1'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loaded</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 啊哈图片加载完成</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (img1.complete) &#123;</div><div class="line">  loaded();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  img1.addEventListener(<span class="string">'load'</span>, loaded);</div><div class="line">&#125;</div><div class="line"></div><div class="line">img1.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 哎哟出问题了</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这样也还不够，如果在添加监听函数之前图片加载发生错误，我们的监听函数还是白费，不幸的是 DOM 也没有为这个需求提供解决办法。而且，这还只是处理一张图片的情况，如果有一堆图片要处理那就更麻烦了。</p>
<h2 id="事件不是万金油"><a href="#事件不是万金油" class="headerlink" title="事件不是万金油"></a>事件不是万金油</h2><p>事件机制最适合处理同一个对象上反复发生的事情，如 <code>keyup</code>、<code>touchstart</code> 等等。你不需要考虑当绑定监听器之前所发生的事情，当碰到异步请求成功/失败的时候，你想要的通常是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">img1.callThisIfLoadedOrWhenLoaded(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 加载完成</span></div><div class="line">&#125;).orIfFailedCallThis(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 加载失败</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 以及……</span></div><div class="line">whenAllTheseHaveLoaded([img1, img2]).callThis(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 全部加载完成</span></div><div class="line">&#125;).orIfSomeFailedCallThis(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 一个或多个加载失败</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这就是 Promise。如果 HTML 图片元素有一个“ready()”方法的话，我们就可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">img1.ready().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 加载完成</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 加载失败</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 以及……</span></div><div class="line"><span class="built_in">Promise</span>.all([img1.ready(), img2.ready()]).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 全部加载完成</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 一个或多个加载失败</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>基本上 Promise 还是有点像事件回调的，除了：</p>
<ul>
<li>一个 Promise 只能成功或失败一次，并且状态无法改变（不能从成功变为失败，反之亦然）</li>
<li>如果一个 Promise 成功或者失败之后，你为其添加针对成功/失败的回调，则相应的回调函数会立即执行</li>
</ul>
<p>这些特性非常适合处理异步操作的成功/失败情景，你无需再担心事件发生的时间点，而只需对其做出响应。</p>
<p><a name="toc-promise-terminology"></a></p>
<h2 id="promise-相关术语"><a href="#Promise-相关术语" class="headerlink" title="Promise 相关术语"></a>Promise 相关术语</h2><p><a href="https://twitter.com/domenic" target="_blank" rel="external">Domenic Denicola</a> 审阅了本文初稿，给我在术语方面打了个“F”，关了禁闭并且责令我打印 <a href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md" target="_blank" rel="external">States and Fates</a> 一百遍，还写了一封家长信给我父母。即便如此，我还是对术语有些迷糊，不过基本上应该是这样：</p>
<p>一个 Promise 的状态可以是：</p>
<ul>
<li><strong>肯定（fulfilled）</strong> - 该 Promise 对应的操作成功了</li>
<li><strong>否定（rejected）</strong> - 该 Promise 对应的操作失败了</li>
<li><strong>等待（pending）</strong> - 还没有得到肯定或者否定结果，进行中</li>
<li><strong>结束（settled）</strong> - 已经肯定或者否定了</li>
</ul>
<p>规范里还使用 <strong>thenable</strong> 来描述一个对象是否是“类 Promise”（拥有名为“then”的方法）的。这个术语使我想起来前英格兰足球经理 <a href="http://en.wikipedia.org/wiki/Terry_Venables" target="_blank" rel="external">Terry Venables</a> 所以我尽量少用它。</p>
<h2 id="javascript-有了-promise"><a href="#JavaScript-有了-Promise！" class="headerlink" title="JavaScript 有了 Promise！"></a>JavaScript 有了 Promise！</h2><p>其实已经有一些第三方库实现了 Promise 的功能：</p>
<ul>
<li><a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a></li>
<li><a href="https://github.com/cujojs/when" target="_blank" rel="external">when</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx" target="_blank" rel="external">WinJS</a></li>
<li><a href="https://github.com/tildeio/rsvp.js" target="_blank" rel="external">RSVP.js</a></li>
</ul>
<p>上面这些库和 JavaScript 原生 Promise 都遵守一个通用的、标准化的规范：<a href="https://github.com/promises-aplus/promises-spec" target="_blank" rel="external">Promises/A+</a>，jQuery 有个类似的方法叫 <a href="http://api.jquery.com/category/deferred-object/" target="_blank" rel="external">Deferred</a>，但不兼容 Promises/A+ 规范，于是会<a href="https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/" target="_blank" rel="external">有点小问题</a>，使用需谨慎。jQuery 还有一个 <a href="http://api.jquery.com/Types/#Promise" target="_blank" rel="external">Promise 类型</a>，它其实是 Deferred 的缩减版，所以也有同样问题。</p>
<p>尽管 Promise 的各路实现遵循同一规范，但它们的 API 还是各不相同。JavaScript Promise 的 API 比较接近 RSVP.js，如下创建 Promise：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// 做一些异步操作的事情，然后……</span></div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (<span class="comment">/* 一切正常 */</span>) &#123;</div><div class="line">    resolve(<span class="string">"Stuff worked!"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    reject(<span class="built_in">Error</span>(<span class="string">"It broke"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Promise 的构造器接受一个函数作为参数，它会传递给这个回调函数两个变量 <code>resolve</code> 和 <code>reject</code>。在回调函数中做一些异步操作，成功之后调用 <code>resolve</code>，否则调用 <code>reject</code>。</p>
<p>调用 <code>reject</code> 的时候传递给它一个 <code>Error</code> 对象只是个惯例并非必须，这和经典 JavaScript 中的 <code>throw</code> 一样。传递 <code>Error</code> 对象的好处是它包含了调用堆栈，在调试的时候会有点用处。</p>
<p>现在来看看如何使用 Promise：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// “完美！”</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// Error: "出问题了"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>then</code>接受两个参数，成功的时候调用一个，失败的时候调用另一个，两个都是可选的，所以你可以只处理成功的情况或者失败的情况。</p>
<p>JavaScript Promise 最初以“Futures”为名归为 DOM 规范，后来改名为“Promises”，最终纳入 JavaScript 规范。将其加入 JavaScript 而非 DOM 的好处是方便在非浏览器环境中使用，如Node.js（他们会不会在核心API中使用就是另一回事了）。</p>
<p>尽管它被归位 JavaScript 特性，DOM 也很乐意拿过来用。事实上，所有包含异步成功/失败方法的新 DOM API 都会使用 Promise 机制，已经实现的包括 <a href="https://dvcs.w3.org/hg/quota/raw-file/tip/Overview.html#idl-def-StorageQuota" target="_blank" rel="external">Quota Management</a>，<a href="http://dev.w3.org/csswg/css-font-loading/#font-face-set-ready" target="_blank" rel="external">Font Load Events</a>，<a href="https://github.com/slightlyoff/ServiceWorker/blob/cf459d473ae09f6994e8539113d277cbd2bce939/service_worker.ts#L17" target="_blank" rel="external">ServiceWorker</a>，<a href="http://webaudio.github.io/web-midi-api/#widl-Navigator-requestMIDIAccess-Promise-MIDIOptions-options" target="_blank" rel="external">Web MIDI</a>，<a href="https://github.com/whatwg/streams#basereadablestream" target="_blank" rel="external">Streams</a> 等等。</p>
<h2 id="浏览器支持和-polyfill"><a href="#浏览器支持和-Polyfill" class="headerlink" title="浏览器支持和 Polyfill"></a>浏览器支持和 Polyfill</h2><p>目前的浏览器已经（部分）实现了 Promise。</p>
<p>用 Chrome 的话，就像个 Chroman 一样 装上 <a href="https://www.google.com/intl/en/chrome/browser/canary.html" target="_blank" rel="external">Canary</a>，默认即启用了 Promise 支持。如果是 Firefox 拥趸，则可以安装最新的 <a href="http://nightly.mozilla.org/" target="_blank" rel="external">nightly build</a>。</p>
<p>不过这两个浏览器的实现都还不够完整彻底，你可以 在 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=918806" target="_blank" rel="external">bugzilla</a> 上跟踪 Firefox 的最新进展或者到 <a href="http://www.chromestatus.com/features/5681726336532480" target="_blank" rel="external">Chromium Dashboard</a> 查看 Chrome 的实现情况。</p>
<p>要在这两个浏览器上达到兼容标准 Promise，或者在其他浏览器以及 Node.js 中使用 Promise，可以看看这个 <a href="https://github.com/jakearchibald/ES6-Promises/blob/master/README.md" target="_blank" rel="external">polyfill</a>（gzip 压缩之后只有 2K）。</p>
<h2 id="与其他库的兼容性"><a href="#与其他库的兼容性" class="headerlink" title="与其他库的兼容性"></a>与其他库的兼容性</h2><p>JavaScript Promise 的 API 会把任何包含有 then 方法的对象当作“类 Promise”（或者用术语来说就是 thenable）的对象，这些对象经过 <code>Promise.cast</code> 处理之后就和原生的 Promise 实例没有任何区别了。所以如果你使用的库返回一个 Q Promise，那没问题，无缝融入新的 JavaScript Promise。</p>
<p>尽管，如前所述，jQuery 的 Deferred 对象有点……没什么用，不过幸好还可以转换成标准 Promise，最好一拿到对象就马上加以转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsPromise = <span class="built_in">Promise</span>.cast($.ajax(<span class="string">'/whatever.json'</span>));</div></pre></td></tr></table></figure>
<p>这里 jQuery 的 <code>$.ajax</code> 返回一个 <code>Deferred</code> 对象，含有 <code>then</code> 方法，因此通过 <code>Promise.cast</code> 可以将其转换为 JavaScript Promise。不过有时候 <code>Deferred</code> 对象会给它的回调函数传递多个参数，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jqDeferred = $.ajax(<span class="string">'/whatever.json'</span>);</div><div class="line"></div><div class="line">jqDeferred.then(<span class="function"><span class="keyword">function</span>(<span class="params">response, statusText, xhrObj</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">xhrObj, textStatus, err</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>除了第一个参数，其他都会被 JavaScript Promise 忽略掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">jsPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">xhrObj</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>……还好这通常就是你想要的了，至少你能够用这个办法实现想要的。另外还要注意，jQuery 也没有遵循给否定回调函数传递 <code>Error</code> 对象的约定。</p>
<h2 id="复杂的异步代码变得简单了"><a href="#复杂的异步代码变得简单了" class="headerlink" title="复杂的异步代码变得简单了"></a>复杂的异步代码变得简单了</h2><p>OK，现在我们来写点实际的代码。假设我们想要：</p>
<ol>
<li>显示一个加载指示图标</li>
<li>加载一篇小说的 JSON，包含小说名和每一章内容的 URL。</li>
<li>在页面中填上小说名</li>
<li>加载所有章节正文</li>
<li>在页面中添加章节正文</li>
<li>停止加载指示</li>
</ol>
<p>如果在这个过程中发生什么错误，要通知用户，并且把加载指示停掉，不然它就会不停转下去，令人眼晕，或者搞坏界面什么的。</p>
<p>当然，你不会用 JavaScript 去这么繁琐地显示一篇文章，<a href="http://jakearchibald.com/2013/progressive-enhancement-is-faster/" target="_blank" rel="external">直接输出 HTML 要快得多</a>，不过这个流程是非常典型的 API 请求模式：获取多个数据，当它们全部完成之后再做一些事情。</p>
<p>首先，搞定从网络加载数据的步骤：</p>
<h2 id="将-promise-用于-xmlhttprequest"><a href="#将-Promise-用于-XMLHttpRequest" class="headerlink" title="将 Promise 用于 XMLHttpRequest"></a>将 Promise 用于 XMLHttpRequest</h2><p>只要能保持向后兼容，现有 API 都会更新以支持 Promise，<code>XMLHttpRequest</code> 是重点考虑对象之一。不过现在我们先来写个 GET 请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="comment">// 返回一个新的 Promise</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="comment">// 经典 XHR 操作</span></div><div class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    req.open(<span class="string">'GET'</span>, url);</div><div class="line"></div><div class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// 当发生 404 等状况的时候调用此函数</span></div><div class="line">      <span class="comment">// 所以先检查状态码</span></div><div class="line">      <span class="keyword">if</span> (req.status == <span class="number">200</span>) &#123;</div><div class="line">        <span class="comment">// 以响应文本为结果，完成此 Promise</span></div><div class="line">        resolve(req.response);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 否则就以状态码为结果否定掉此 Promise</span></div><div class="line">        <span class="comment">// （提供一个有意义的 Error 对象）</span></div><div class="line">        reject(<span class="built_in">Error</span>(req.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 网络异常的处理方法</span></div><div class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      reject(<span class="built_in">Error</span>(<span class="string">"Network Error"</span>));</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 发出请求</span></div><div class="line">    req.send();</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在可以调用它了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Success!"</span>, response);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(<span class="string">"Failed!"</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>点击<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/story.json" target="_blank" rel="external">这里</a>查看运行结果。现在我们不需要手敲 <code>XMLHttpRequest</code> 就可以直接发起 HTTP 请求，这样感觉好多了，能少看到一次这个狂驼峰命名的 <code>XMLHttpRequest</code> 我的快乐就多一点。</p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p><code>then</code> 的故事还没完，你可以把这些 <code>then</code> 串联起来修改结果或者添加进行更多异步操作。</p>
<h3 id="值的处理"><a href="#值的处理" class="headerlink" title="值的处理"></a>值的处理</h3><p>你可以对结果做些修改然后返回一个新值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(val); <span class="comment">// 1</span></div><div class="line">  <span class="keyword">return</span> val + <span class="number">2</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(val); <span class="comment">// 3</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>回到前面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Success!"</span>, response);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>收到的响应是一个纯文本的 JSON，我们可以修改 <code>get</code> 函数，设置 <code>responseType</code> 为 JSON 来指定服务器响应格式，也可以在 Promise 的世界里搞定这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(response);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Yey JSON!"</span>, response);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>既然 <code>JSON.parse</code> 只接收一个参数，并返回转换后的结果，我们还可以再精简一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="built_in">JSON</span>.parse).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Yey JSON!"</span>, response);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>点击<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/story.json" target="_blank" rel="external">这里</a>查看代码运行结果，打开控制台查看输出结果。事实上，我们可以把 <code>getJSON</code> 函数写得超级简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> get(url).then(<span class="built_in">JSON</span>.parse);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getJSON</code> 会返回一个获取 JSON 并加以解析的 Promise。</p>
<h3 id="队列的异步操作"><a href="#队列的异步操作" class="headerlink" title="队列的异步操作"></a>队列的异步操作</h3><p>你也可以把 <code>then</code> 串联起来依次执行异步操作。</p>
<p>当你从 <code>then</code> 的回调函数返回的时候，这里有点小魔法。如果你返回一个值，它就会被传给下一个 <code>then</code> 的回调；而如果你返回一个“类 Promise”的对象，则下一个 <code>then</code> 就会等待这个 Promise 明确结束（成功/失败）才会执行。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> getJSON(story.chapterUrls[<span class="number">0</span>]);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter1</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Got chapter 1!"</span>, chapter1);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里我们发起一个对“story.json”的异步请求，返回给我们每一章的 URL，然后我们会请求其中的第一个。Promise 开始首次显现出相较于事件回调的优越性了。你甚至可以写一个抓取章节内容的独立函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> storyPromise;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getChapter</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">  storyPromise = storyPromise || getJSON(<span class="string">'story.json'</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> storyPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getJSON(story.chapterUrls[i]);</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 用起来非常简单：</span></div><div class="line">getChapter(<span class="number">0</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(chapter);</div><div class="line">  <span class="keyword">return</span> getChapter(<span class="number">1</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(chapter);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们一开始并不加载 story.json，直到第一次 <code>getChapter</code>，而以后每次 <code>getChapter</code> 的时候都可以重用已经加载完成的 <code>storyPromise</code>，所以 story.json 只需要请求一次。Promise 好棒！</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>前面已经看到，<code>then</code>接受两个参数，一个处理成功，一个处理失败（或者说肯定和否定，按 Promise 术语）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Success!"</span>, response);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Failed!"</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>你还可以使用 <code>catch</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Success!"</span>, response);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Failed!"</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里的 <code>catch</code> 并无任何特殊之处，只是 <code>then(undefined, func)</code> 的语法糖，更直观一点而已。注意上面两段代码的行为不仅相同，后者相当于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Success!"</span>, response);</div><div class="line">&#125;).then(<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Failed!"</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>差异不大，但意义非凡。Promise 被否定之后会跳转到之后第一个配置了否定回调的 <code>then</code>（或 <code>catch</code>，一样的）。对于 <code>then(func1, func2)</code> 来说，必会调用 <code>func1</code> 或 <code>func2</code> 之一，但绝不会两个都调用。而 <code>then(func1).catch(func2)</code> 这样，如果 <code>func1</code> 返回否定的话 <code>func2</code> 也会被调用，因为他们是链式调用中独立的两个步骤。看下面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">asyncThing1().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> asyncThing2();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> asyncThing3();</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> asyncRecovery1();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> asyncThing4();</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> asyncRecovery2();</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Don't worry about it"</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"All done!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这段流程非常像 JavaScript 的 <code>try/catch</code> 组合，<code>try</code> 代码块中发生的错误会立即跳转到 <code>catch</code> 代码块。这是上面那段代码的流程图（我最爱流程图了）：</p>
<div style="max-width: 495px; margin: 10px 0"><br>  <div style="position: relative; padding-top: 93%"><br>    <iframe style="position:absolute;top:0;left:0;width:100%;height:100%;overflow:hidden" src="http://www.html5rocks.com/zh/tutorials/es6/promises/promise-flow.svg" frameborder="0" allowtransparency="true"></iframe><br>  </div><br></div>


<p>绿线是肯定的 Promise 流程，红线是否定的 Promise 流程。</p>
<h3 id="javascript-异常和-promise"><a href="#JavaScript-异常和-Promise" class="headerlink" title="JavaScript 异常和 Promise"></a>JavaScript 异常和 Promise</h3><p>Promise 的否定回调可以由 <code>Promise.reject()</code> 触发，也可以由构造器回调中抛出的错误触发：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsonPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果数据格式不对的话 JSON.parse 会抛出错误</span></div><div class="line">  <span class="comment">// 可以作为隐性的否定结果：</span></div><div class="line">  resolve(<span class="built_in">JSON</span>.parse(<span class="string">"This ain't JSON"</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">jsonPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="comment">// 永远不会发生：</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"It worked!"</span>, data);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// 这才是真相：</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"It failed!"</span>, err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这意味着你可以把所有 Promise 相关操作都放在它的构造函数回调中进行，这样发生任何错误都能捕捉到并且触发 Promise 否定。</p>
<p><code>then</code>回调中抛出的错误也一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'/'</span>).then(<span class="built_in">JSON</span>.parse).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// This never happens, '/' is an HTML page, not JSON</span></div><div class="line">  <span class="comment">// so JSON.parse throws</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"It worked!"</span>, data);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// Instead, this happens:</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"It failed!"</span>, err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="实践错误处理"><a href="#实践错误处理" class="headerlink" title="实践错误处理"></a>实践错误处理</h3><p>回到我们的故事和章节的例子，我们用 <code>catch</code> 来捕捉错误并显示给用户：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> getJSON(story.chapterUrls[<span class="number">0</span>]);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter1</span>) </span>&#123;</div><div class="line">  addHtmlToPage(chapter1.html);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  addTextToPage(<span class="string">"Failed to show chapter"</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果请求 <code>story.chapterUrls[0]</code> 失败（http 500 或者用户掉线什么的）了，它会跳过之后所有针对成功的回调，包括 getJSON 中将响应解析为 JSON 的回调，和这里把第一张内容添加到页面里的回调。JavaScript 的执行会进入 <code>catch</code> 回调。结果就是前面任何章节请求出错，页面上都会显示“Failed to show chapter”。</p>
<p>和 JavaScript 的 <code>try/catch</code> 一样，捕捉到错误之后，接下来的代码会继续执行，按计划把加载指示器给停掉。上面的代码就是下面这段的非阻塞异步版：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">var</span> story = getJSONSync(<span class="string">'story.json'</span>);</div><div class="line">  <span class="keyword">var</span> chapter1 = getJSONSync(story.chapterUrls[<span class="number">0</span>]);</div><div class="line">  addHtmlToPage(chapter1.html);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (e) &#123;</div><div class="line">  addTextToPage(<span class="string">"Failed to show chapter"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div></pre></td></tr></table></figure>
<p>如果只是要捕捉异常做记录输出而不打算在用户界面上对错误进行反馈的话，只要抛出 <code>Error</code> 就行了，这一步可以放在 <code>getJSON</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> get(url).then(<span class="built_in">JSON</span>.parse).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"getJSON failed for"</span>, url, err);</div><div class="line">    <span class="keyword">throw</span> err;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们已经搞定第一章的显示了，接下来搞定全部章节。</p>
<h2 id="并行和串行-鱼与熊掌兼得"><a href="#并行和串行-——-鱼与熊掌兼得" class="headerlink" title="并行和串行 —— 鱼与熊掌兼得"></a>并行和串行 —— 鱼与熊掌兼得</h2><p>异步的思维方式并不符合直觉，如果你觉得起步困难，那就试试先写个同步的方法，就像这个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">var</span> story = getJSONSync(<span class="string">'story.json'</span>);</div><div class="line">  addHtmlToPage(story.heading);</div><div class="line"></div><div class="line">  story.chapterUrls.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">chapterUrl</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> chapter = getJSONSync(chapterUrl);</div><div class="line">    addHtmlToPage(chapter.html);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  addTextToPage(<span class="string">"All done"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (err) &#123;</div><div class="line">  addTextToPage(<span class="string">"Argh, broken: "</span> + err.message);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div></pre></td></tr></table></figure>
<p>它执行起来完全正常（<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/sync-example.html" target="_blank" rel="external">查看示例</a>）！不过它是同步的，在加载内容时会卡住整个浏览器。要让它异步工作的话，我们用 <code>then</code> 把它们一个接一个串起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">  addHtmlToPage(story.heading);</div><div class="line"></div><div class="line">  <span class="comment">// <span class="doctag">TODO:</span> 获取并显示 story.chapterUrls 中的每个 url</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 全部完成啦！</span></div><div class="line">  addTextToPage(<span class="string">"All done"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果过程中有任何不对劲的地方</span></div><div class="line">  addTextToPage(<span class="string">"Argh, broken: "</span> + err.message);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 无论如何要把 spinner 隐藏掉</span></div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>那么我们如何遍历章节的 URL 并且依次请求？这样是不行的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">story.chapterUrls.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">chapterUrl</span>) </span>&#123;</div><div class="line">  <span class="comment">// Fetch chapter</span></div><div class="line">  getJSON(chapterUrl).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">    <span class="comment">// and add it to the page</span></div><div class="line">    addHtmlToPage(chapter.html);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>forEach</code> 没有对异步操作的支持，所以我们的故事章节会按照它们加载完成的顺序显示，基本上《低俗小说》就是这么写出来的。我们不写低俗小说，所以得修正它：</p>
<h3 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h3><p>我们要把章节 URL 数组转换成 Promise 的序列，还是用 <code>then</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从一个完成状态的 Promise 开始</span></div><div class="line"><span class="keyword">var</span> sequence = <span class="built_in">Promise</span>.resolve();</div><div class="line"></div><div class="line"><span class="comment">// 遍历所有章节的 url</span></div><div class="line">story.chapterUrls.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">chapterUrl</span>) </span>&#123;</div><div class="line">  <span class="comment">// 从 sequence 开始把操作接龙起来</span></div><div class="line">  sequence = sequence.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getJSON(chapterUrl);</div><div class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">    addHtmlToPage(chapter.html);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这是我们第一次用到 <code>Promise.resolve</code>，它会依据你传的任何值返回一个 Promise。如果你传给它一个类 Promise 对象（带有 <code>then</code> 方法），它会生成一个带有同样肯定/否定回调的 Promise，基本上就是克隆。如果传给它任何别的值，如 <code>Promise.resolve(&#39;Hello&#39;)</code>，它会创建一个以这个值为完成结果的 Promise，如果不传任何值，则以 <code>undefined</code> 为完成结果。</p>
<p>还有一个对应的 <code>Promise.reject(val)</code>，会创建以你传入的参数（或 <code>undefined</code>）为否定结果的 Promise。</p>
<p>我们可以用 <code>array.reduce</code> 精简一下上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 遍历所有章节的 url</span></div><div class="line">story.chapterUrls.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sequence, chapterUrl</span>) </span>&#123;</div><div class="line">  <span class="comment">// 从 sequence 开始把操作接龙起来</span></div><div class="line">  <span class="keyword">return</span> sequence.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getJSON(chapterUrl);</div><div class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">    addHtmlToPage(chapter.html);</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="built_in">Promise</span>.resolve());</div></pre></td></tr></table></figure>
<p>它和前面的例子功能一样，但是不需要显式声明 <code>sequence</code> 变量。<code>reduce</code> 回调会依次应用在每个数组元素上，第一轮里的“sequence”是 <code>Promise.resolve()</code>，之后的调用里 <code>sequence</code> 就是上次函数执行的的结果。<code>array.reduce</code> 非常适合用于把一组值归并处理为一个值，正是我们现在对 Promise 的用法。</p>
<p>汇总上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">  addHtmlToPage(story.heading);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> story.chapterUrls.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sequence, chapterUrl</span>) </span>&#123;</div><div class="line">    <span class="comment">// 当前一个章节的 Promise 完成之后……</span></div><div class="line">    <span class="keyword">return</span> sequence.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ……获取下一章</span></div><div class="line">      <span class="keyword">return</span> getJSON(chapterUrl);</div><div class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">      <span class="comment">// 并添加到页面</span></div><div class="line">      addHtmlToPage(chapter.html);</div><div class="line">    &#125;);</div><div class="line">  &#125;, <span class="built_in">Promise</span>.resolve());</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 现在全部完成了！</span></div><div class="line">  addTextToPage(<span class="string">"All done"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果过程中发生任何错误</span></div><div class="line">  addTextToPage(<span class="string">"Argh, broken: "</span> + err.message);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 保证 spinner 最终会隐藏</span></div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="http://www.html5rocks.com/zh/tutorials/es6/promises/async-example.html" target="_blank" rel="external">查看代码运行示例</a>，前面的同步代码改造成了完全异步的版本。我们还可以更进一步。现在页面加载的效果是这样：</p>
<p><img src="http://www.html5rocks.com/zh/tutorials/es6/promises/promise1.gif" alt=""></p>
<p>浏览器很擅长同时加载多个文件，我们这种一个接一个下载章节的方法非常低效率。我们希望同时下载所有章节，全部完成后一次搞定，正好就有这么个 API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.all(arrayOfPromises).then(<span class="function"><span class="keyword">function</span>(<span class="params">arrayOfResults</span>) </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Promise.all</code> 接受一个 Promise 数组为参数，创建一个当所有 Promise 都完成之后就完成的 Promise，它的完成结果是一个数组，包含了所有先前传入的那些 Promise 的完成结果，顺序和将它们传入的数组顺序一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">  addHtmlToPage(story.heading);</div><div class="line"></div><div class="line">  <span class="comment">// 接受一个 Promise 数组并等待他们全部完成</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</div><div class="line">    <span class="comment">// 把章节 URL 数组转换成对应的 Promise 数组</span></div><div class="line">    story.chapterUrls.map(getJSON)</div><div class="line">  );</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapters</span>) </span>&#123;</div><div class="line">  <span class="comment">// 现在我们有了顺序的章节 JSON，遍历它们……</span></div><div class="line">  chapters.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">    <span class="comment">// ……并添加到页面中</span></div><div class="line">    addHtmlToPage(chapter.html);</div><div class="line">  &#125;);</div><div class="line">  addTextToPage(<span class="string">"All done"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// 捕获过程中的任何错误</span></div><div class="line">  addTextToPage(<span class="string">"Argh, broken: "</span> + err.message);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>根据连接状况，改进的代码会比顺序加载方式提速数秒（<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/async-all-example.html" target="_blank" rel="external">查看示例</a>），甚至代码行数也更少。章节加载完成的顺序不确定，但它们显示在页面上的顺序准确无误。</p>
<p><img src="http://www.html5rocks.com/zh/tutorials/es6/promises/promise2.gif" alt=""></p>
<p>然而这样还是有提高空间。当第一章内容加载完毕我们可以立即填进页面，这样用户可以在其他加载任务尚未完成之前就开始阅读；当第三章到达的时候我们不动声色，第二章也到达之后我们再把第二章和第三章内容填入页面，以此类推。</p>
<p>为了达到这样的效果，我们同时请求所有的章节内容，然后创建一个序列依次将其填入页面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">  addHtmlToPage(story.heading);</div><div class="line"></div><div class="line">  <span class="comment">// 把章节 URL 数组转换成对应的 Promise 数组</span></div><div class="line">  <span class="comment">// 这样就可以并行加载它们</span></div><div class="line">  <span class="keyword">return</span> story.chapterUrls.map(getJSON)</div><div class="line">    .reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sequence, chapterPromise</span>) </span>&#123;</div><div class="line">      <span class="comment">// 使用 reduce 把这些 Promise 接龙</span></div><div class="line">      <span class="comment">// 以及将章节内容添加到页面</span></div><div class="line">      <span class="keyword">return</span> sequence.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 等待当前 sequence 中所有章节和本章节的数据到达</span></div><div class="line">        <span class="keyword">return</span> chapterPromise;</div><div class="line">      &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">        addHtmlToPage(chapter.html);</div><div class="line">      &#125;);</div><div class="line">    &#125;, <span class="built_in">Promise</span>.resolve());</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  addTextToPage(<span class="string">"All done"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// 捕获过程中的任何错误</span></div><div class="line">  addTextToPage(<span class="string">"Argh, broken: "</span> + err.message);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>哈哈（<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/async-best-example.html" target="_blank" rel="external">查看示例</a>），鱼与熊掌兼得！加载所有内容的时间未变，但用户可以更早看到第一章。</p>
<p><img src="http://www.html5rocks.com/zh/tutorials/es6/promises/promise3.gif" alt=""></p>
<p>这个小例子中各部分章节加载差不多同时完成，逐章显示的策略在章节内容很多的时候优势将会更加显著。</p>
<p>上面的代码如果用 <a href="https://gist.github.com/jakearchibald/0e652d95c07442f205ce" target="_blank" rel="external">Node.js 风格的回调或者事件机制</a>实现的话代码量大约要翻一倍，更重要的是可读性也不如此例。然而，Promise 的厉害不止于此，和其他 ES6 的新功能结合起来还能更加高效……</p>
<h2 id="附赠章节promise-和-generator"><a href="#附赠章节：Promise-和-Generator" class="headerlink" title="附赠章节：Promise 和 Generator"></a>附赠章节：Promise 和 Generator</h2><p>接下来的内容涉及到一大堆 ES6 的新特性，不过对于现在应用 Promise 来说并非必须，把它当作接下来的第二部豪华续集的预告片来看就好了。</p>
<p>ES6 还给我们带来了 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators" target="_blank" rel="external">Generator</a>，允许函数在特定地方像 return 一样退出，但是稍后又能恢复到这个位置和状态上继续执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">addGenerator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    i += <span class="keyword">yield</span> i;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意函数名前的星号，这表示该函数是一个 Generator。关键字 <code>yield</code> 标记了暂停/继续的位置，使用方法像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> adder = addGenerator();</div><div class="line">adder.next().value; <span class="comment">// 0</span></div><div class="line">adder.next(<span class="number">5</span>).value; <span class="comment">// 5</span></div><div class="line">adder.next(<span class="number">5</span>).value; <span class="comment">// 10</span></div><div class="line">adder.next(<span class="number">5</span>).value; <span class="comment">// 15</span></div><div class="line">adder.next(<span class="number">50</span>).value; <span class="comment">// 65</span></div></pre></td></tr></table></figure>
<p>这对 Promise 有什么用呢？你可以用这种暂停/继续的机制写出来和同步代码看上去差不多（理解起来也一样简单）的代码。下面是一个辅助函数（helper function），我们在 <code>yield</code> 位置等待 Promise 完成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">generatorFunc</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">continuer</span>(<span class="params">verb, arg</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      result = generator[verb](arg);</div><div class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (result.done) &#123;</div><div class="line">      <span class="keyword">return</span> result.value;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.cast(result.value).then(onFulfilled, onRejected);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> generator = generatorFunc();</div><div class="line">  <span class="keyword">var</span> onFulfilled = continuer.bind(continuer, <span class="string">"next"</span>);</div><div class="line">  <span class="keyword">var</span> onRejected = continuer.bind(continuer, <span class="string">"throw"</span>);</div><div class="line">  <span class="keyword">return</span> onFulfilled();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码<a href="https://github.com/kriskowal/q/blob/db9220d714b16b96a05e9a037fa44ce581715e41/q.js#L500" target="_blank" rel="external">原样拷贝自 Q</a>，只是改成 JavaScript Promise 的 API。把我们前面的最终方案和 ES6 最新特性结合在一起之后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">spawn(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 'yield' 会执行一个异步的等待，返回这个 Promise 的结果</span></div><div class="line">    <span class="keyword">let</span> story = <span class="keyword">yield</span> getJSON(<span class="string">'story.json'</span>);</div><div class="line">    addHtmlToPage(story.heading);</div><div class="line"></div><div class="line">    <span class="comment">// 把章节 URL 数组转换成对应的 Promise 数组</span></div><div class="line">    <span class="comment">// 以便并行加载</span></div><div class="line">    <span class="keyword">let</span> chapterPromises = story.chapterUrls.map(getJSON);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> chapterPromise <span class="keyword">of</span> chapterPromises) &#123;</div><div class="line">      <span class="comment">// 等待每个章节加载完成，将其添加至页面</span></div><div class="line">      <span class="keyword">let</span> chapter = <span class="keyword">yield</span> chapterPromise;</div><div class="line">      addHtmlToPage(chapter.html);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addTextToPage(<span class="string">"All done"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="comment">// try/catch 即可。否定的 Promise 会在这里抛出。</span></div><div class="line">    addTextToPage(<span class="string">"Argh, broken: "</span> + err.message);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>功能完全一样，读起来要简单得多。这个例子目前可以在 Chrome Canary 中运行（<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/async-generators-example.html" target="_blank" rel="external">查看示例</a>），不过你得先到 <code>about:flags</code> 中开启 Enable experimental JavaScript 选项。</p>
<p>这里用到了一堆 ES6 的新语法：<code>Promise</code>、<code>Generator</code>、<code>let</code>、<code>for-of</code>。当我们把 <code>yield</code> 应用在一个 Promise 上，<code>spawn</code> 辅助函数会等待 Promise 完成，然后才返回最终的值。如果 Promise 给出否定结果，<code>spawn</code> 中的 <code>yield</code> 则会抛出一个异常，我们可以用 <code>try/catch</code> 捕捉到。这样写异步代码真是超级简单！</p>
<p><a name="toc-api"></a></p>
<h2 id="promise-api-参考"><a href="#Promise-API-参考" class="headerlink" title="Promise API 参考"></a>Promise API 参考</h2><p>除非额外注明，最新版的 Chrome（Canary） 和 Firefox（nightly） 均支持下列所有方法。这个 <a href="https://github.com/jakearchibald/ES6-Promises/blob/master/README.md" target="_blank" rel="external">polyfill</a> 则在所有浏览器内实现了同样的接口。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li><p><strong>Promise.cast(promise);</strong></p>
<p>返回一个 Promise（当且仅当 promise.constructor == Promise）</p>
<p><strong>备注</strong>： 目前仅有 Chrome 实现</p>
</li>
</ul>
<ul>
<li><p><strong>Promise.cast(obj);</strong></p>
<p>创建一个以 obj 为成功结果的 Promise。</p>
<p><strong>备注</strong>： 目前仅有 Chrome 实现</p>
</li>
</ul>
<ul>
<li><p><strong>Promise.resolve(thenable);</strong></p>
<p>从 <code>thenable</code> 对象创建一个新的 Promise。一个 <code>thenable</code>（类 Promise）对象是一个带有 <code>then</code> 方法的对象。如果你传入一个原生的 JavaScript Promise 对象，则会创建一个新的 Promise。此方法涵盖了 <code>Promise.cast</code> 的特性，但是不如 <code>Promise.cast</code> 更简单高效。</p>
</li>
</ul>
<ul>
<li><p><strong>Promise.resolve(obj);</strong></p>
<p>创建一个以 <code>obj</code> 为肯定结果的 Promise。这种情况下等同于 <code>Promise.cast(obj)</code>。</p>
</li>
</ul>
<ul>
<li><p><strong>Promise.reject(obj);</strong></p>
<p>创建一个以 <code>obj</code> 为否定结果的 Promise。为了一致性和调试便利（如堆栈追踪），<code>obj</code> 应该是一个 <code>Error</code> 实例对象。</p>
</li>
</ul>
<ul>
<li><p><strong>Promise.all(array);</strong></p>
<p>创建一个 Promise，当且仅当传入数组中的所有 Promise 都肯定之后才肯定，如果遇到数组中的任何一个 Promise 以否定结束，则抛出否定结果。每个数组元素都会首先经过 <code>Promise.cast</code>，所以数组可以包含类 Promise 对象或者其他对象。肯定结果是一个数组，包含传入数组中每个 Promise 的肯定结果（且保持顺序）；否定结果是传入数组中第一个遇到的否定结果。</p>
<p><strong>备注</strong>： 目前仅有 Chrome 实现</p>
</li>
<li><p><strong>Promise.race(array);</strong></p>
<p>创建一个 Promise，当数组中的任意对象肯定时将其结果作为肯定结束，或者当数组中任意对象否定时将其结果作为否定结束。</p>
<p><strong>备注</strong>：我不大确定这个接口是否有用，我更倾向于一个 <code>Promise.all</code> 的对立方法，仅当所有数组元素全部给出否定的时候才抛出否定结果</p>
</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>resolve(thenable)</strong></p>
<p>你的 Promise 将会根据这个 <code>thenable</code> 对象的结果而返回肯定/否定结果</p>
</li>
<li><p><strong>resolve(obj)</strong></p>
<p>你的 Promise 将会以 <code>obj</code> 作为肯定结果完成</p>
</li>
<li><p><strong>reject(obj)</strong></p>
<p>你的 Promise 将会以 <code>obj</code> 作为否定结果完成。出于一致性和调试（如栈追踪）方便，<code>obj</code> 应该是一个 <code>Error</code> 对象的实例。构造器的回调函数中抛出的错误会被立即传递给 <code>reject()</code>。</p>
</li>
</ul>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li><p><strong>promise.then(onFulfilled, onRejected)</strong></p>
<p>当 <code>promise</code> 以肯定结束时会调用 <code>onFulfilled</code>。 当 <code>promise</code> 以否定结束时会调用 <code>onRejected</code>。 这两个参数都是可选的，当任意一个未定义时，对它的调用会跳转到 <code>then</code> 链的下一个 <code>onFulfilled/onRejected</code> 上。 这两个回调函数均只接受一个参数，肯定结果或者否定原因。 当 <code>Promise.resolve</code> 肯定结束之后，<code>then</code> 会返回一个新的 Promise，这个 Promise 相当于你从 onFulfilled/onRejected 中返回的值。如果回调中抛出任何错误，返回的 Promise 也会以此错误作为否定结果结束。</p>
</li>
<li><p><strong>promise.catch(onRejected)</strong></p>
<p><code>promise.then(undefined, onRejected)</code> 的语法糖。</p>
</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>非常感谢 Anne van Kesteren，Domenic Denicola，Tom Ashworth，Remy Sharp，Addy Osmani，Arthur Evans 以及 and Yutaka Hirano 对本文做出的贡献（审阅/纠错或建议）。</p></section><footer class="article-footer clearfix"><div class="categories"><a href="/categories/javascript/" title="JavaScript">JavaScript</a></div><div class="tags"><a href="/tags/promise/" title="Promise">Promise</a></div></footer></div><nav class="article-nav clearfix"><a href="/2014/03/25/mastering-async-error-handling-with-promises/" class="article-nav-link article-nav-newer"><strong class="article-nav-type">Newer</strong><span class="article-nav-title">用 Promises 控制异步错误处理</span></a><a href="/2014/03/20/some-javascript-quiz-from-perfectionkills/" class="article-nav-link article-nav-older"><strong class="article-nav-type">Older</strong><span class="article-nav-title">看看这些题目你会多少？</span></a></nav></article><section id="article-comment" class="article-comment"><div data-thread-key="http://bubkoo.com/2014/03/22/javascript-promises/" data-title="JavaScript Promises 教程" data-url="http://bubkoo.com/2014/03/22/javascript-promises/" class="ds-thread"></div></section></div><aside id="sidebar" role="sidebar"><div class="widget tagcloud"><h3 class="widget-title">标签</h3><div class="widget-content"><a href="/tags/aop/" style="font-size: 10px">AOP</a> <a href="/tags/algorithm/" style="font-size: 18.33px">Algorithm</a> <a href="/tags/analysis/" style="font-size: 10px">Analysis</a> <a href="/tags/angularjs/" style="font-size: 15px">AngularJS</a> <a href="/tags/animation/" style="font-size: 10px">Animation</a> <a href="/tags/architecture/" style="font-size: 16.67px">Architecture</a> <a href="/tags/archives/" style="font-size: 10.83px">Archives</a> <a href="/tags/async/" style="font-size: 12.5px">Async</a> <a href="/tags/backbone/" style="font-size: 10px">Backbone</a> <a href="/tags/browsers/" style="font-size: 10px">Browsers</a> <a href="/tags/css/" style="font-size: 12.5px">CSS</a> <a href="/tags/css3/" style="font-size: 10px">CSS3</a> <a href="/tags/closure/" style="font-size: 10.83px">Closure</a> <a href="/tags/closures/" style="font-size: 10px">Closures</a> <a href="/tags/cookies/" style="font-size: 10px">Cookies</a> <a href="/tags/cross-domain/" style="font-size: 10px">Cross Domain</a> <a href="/tags/custom-elements/" style="font-size: 10.83px">Custom Elements</a> <a href="/tags/d3/" style="font-size: 10px">D3</a> <a href="/tags/debounce/" style="font-size: 10px">Debounce</a> <a href="/tags/debug/" style="font-size: 10.83px">Debug</a> <a href="/tags/dependency/" style="font-size: 10px">Dependency</a> <a href="/tags/document/" style="font-size: 10px">Document</a> <a href="/tags/ecma-262-3/" style="font-size: 15.83px">ECMA-262-3</a> <a href="/tags/ecmascript/" style="font-size: 15.83px">ECMAScript</a> <a href="/tags/es6/" style="font-size: 20px">ES6</a> <a href="/tags/errors/" style="font-size: 10px">Errors</a> <a href="/tags/essential/" style="font-size: 10px">Essential</a> <a href="/tags/evaluation-strategy/" style="font-size: 10px">Evaluation strategy</a> <a href="/tags/event/" style="font-size: 10px">Event</a> <a href="/tags/exceptions/" style="font-size: 10px">Exceptions</a> <a href="/tags/express/" style="font-size: 10px">Express</a> <a href="/tags/flip/" style="font-size: 10px">FLIP</a> <a href="/tags/flexbox/" style="font-size: 10px">Flexbox</a> <a href="/tags/funarg/" style="font-size: 10px">Funarg</a> <a href="/tags/gist/" style="font-size: 10px">Gist</a> <a href="/tags/github/" style="font-size: 10px">Github</a> <a href="/tags/guide/" style="font-size: 10px">Guide</a> <a href="/tags/html/" style="font-size: 10px">HTML</a> <a href="/tags/http/" style="font-size: 10px">HTTP</a> <a href="/tags/hexo/" style="font-size: 10.83px">Hexo</a> <a href="/tags/ie/" style="font-size: 10px">IE</a> <a href="/tags/iife/" style="font-size: 10px">IIFE</a> <a href="/tags/jshint/" style="font-size: 10px">JSHint</a> <a href="/tags/javascript/" style="font-size: 19.17px">JavaScript</a> <a href="/tags/leak/" style="font-size: 10px">Leak</a> <a href="/tags/linting/" style="font-size: 10px">Linting</a> <a href="/tags/mvc/" style="font-size: 10px">MVC</a> <a href="/tags/methodology/" style="font-size: 10px">Methodology</a> <a href="/tags/mock/" style="font-size: 10px">Mock</a> <a href="/tags/modular/" style="font-size: 10px">Modular</a> <a href="/tags/mongodb/" style="font-size: 10px">MongoDB</a> <a href="/tags/oop/" style="font-size: 10.83px">OOP</a> <a href="/tags/partial-application/" style="font-size: 10px">Partial Application</a> <a href="/tags/pattern/" style="font-size: 10px">Pattern</a> <a href="/tags/patterns/" style="font-size: 10px">Patterns</a> <a href="/tags/performance/" style="font-size: 14.17px">Performance</a> <a href="/tags/promise/" style="font-size: 13.33px">Promise</a> <a href="/tags/prototype/" style="font-size: 11.67px">Prototype</a> <a href="/tags/quality/" style="font-size: 10px">Quality</a> <a href="/tags/quiz/" style="font-size: 10px">Quiz</a> <a href="/tags/regex/" style="font-size: 10px">Regex</a> <a href="/tags/requirejs/" style="font-size: 10px">RequireJS</a> <a href="/tags/sass/" style="font-size: 10px">SASS</a> <a href="/tags/svg/" style="font-size: 10px">SVG</a> <a href="/tags/scope/" style="font-size: 10.83px">Scope</a> <a href="/tags/shapes/" style="font-size: 10px">Shapes</a> <a href="/tags/shuffle/" style="font-size: 10px">Shuffle</a> <a href="/tags/sort/" style="font-size: 17.5px">Sort</a> <a href="/tags/source-map/" style="font-size: 10.83px">Source Map</a> <a href="/tags/styling/" style="font-size: 10px">Styling</a> <a href="/tags/sublime-text/" style="font-size: 10px">Sublime Text</a> <a href="/tags/template/" style="font-size: 10px">Template</a> <a href="/tags/throttle/" style="font-size: 10px">Throttle</a> <a href="/tags/timing/" style="font-size: 10px">Timing</a> <a href="/tags/tools/" style="font-size: 12.5px">Tools</a> <a href="/tags/variable-object/" style="font-size: 10px">Variable object</a> <a href="/tags/visualizations/" style="font-size: 10px">Visualizations</a> <a href="/tags/when/" style="font-size: 12.5px">When</a> <a href="/tags/delete/" style="font-size: 10px">delete</a> <a href="/tags/execution-context/" style="font-size: 10px">execution context</a> <a href="/tags/fetch/" style="font-size: 10px">fetch</a> <a href="/tags/function/" style="font-size: 10px">function</a> <a href="/tags/nodejs/" style="font-size: 10px">nodejs</a> <a href="/tags/nodemon/" style="font-size: 10px">nodemon</a> <a href="/tags/npm/" style="font-size: 10px">npm</a> <a href="/tags/nvm/" style="font-size: 10px">nvm</a> <a href="/tags/performance/" style="font-size: 10px">performance</a> <a href="/tags/prebrowsing/" style="font-size: 10px">prebrowsing</a> <a href="/tags/prefetching/" style="font-size: 10px">prefetching</a> <a href="/tags/preloading/" style="font-size: 10px">preloading</a> <a href="/tags/tabindex/" style="font-size: 10px">tabindex</a> <a href="/tags/this/" style="font-size: 10px">this</a> <a href="/tags/ui-router/" style="font-size: 14.17px">ui-router</a></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/01/18/debouncing-throttling-explained-examples/">实例解析防抖和节流函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/08/quick-tip-multiple-versions-node-nvm/">使用 nvm 管理不同版本的 node 与 npm</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/08/15-ways-to-write-self-documenting-javascript/">如何编写更加自解释的代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/31/high-performance-animations/">使用 FLIP 来提高 Web 动画的性能</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/28/styling-broken-images/">定制图片加载失败时的样式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/26/delivering-octicons-with-svg/">使用 SVG 输出 Octicon</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/18/how-to-use-npm-as-a-build-tool/">如何将 npm 作为构建工具使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/what-you-can-do-with-gists-on-github/">任何人都可以使用到的 Gist 服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/19/prefetching-preloading-prebrowsing/">前端性能优化 - 资源预加载</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/18/es6-in-depth-the-future/">深入解析 ES6：未来展望</a></li></ul></div></div></aside><aside id="topic-wrap" class="toc-wrap f-right"><h3 class="toc-wrap-title">内容</h3><div class="toc-tree"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#他们都在激动什么"><span class="toc-number">1.</span> <span class="toc-text">他们都在激动什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件不是万金油"><span class="toc-number">2.</span> <span class="toc-text">事件不是万金油</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise-相关术语"><span class="toc-number">3.</span> <span class="toc-text">Promise 相关术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javascript-有了-promise"><span class="toc-number">4.</span> <span class="toc-text">JavaScript 有了 Promise！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器支持和-polyfill"><span class="toc-number">5.</span> <span class="toc-text">浏览器支持和 Polyfill</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#与其他库的兼容性"><span class="toc-number">6.</span> <span class="toc-text">与其他库的兼容性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂的异步代码变得简单了"><span class="toc-number">7.</span> <span class="toc-text">复杂的异步代码变得简单了</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将-promise-用于-xmlhttprequest"><span class="toc-number">8.</span> <span class="toc-text">将 Promise 用于 XMLHttpRequest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链式调用"><span class="toc-number">9.</span> <span class="toc-text">链式调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#值的处理"><span class="toc-number">9.1.</span> <span class="toc-text">值的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列的异步操作"><span class="toc-number">9.2.</span> <span class="toc-text">队列的异步操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误处理"><span class="toc-number">10.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript-异常和-promise"><span class="toc-number">10.1.</span> <span class="toc-text">JavaScript 异常和 Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实践错误处理"><span class="toc-number">10.2.</span> <span class="toc-text">实践错误处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行和串行-鱼与熊掌兼得"><span class="toc-number">11.</span> <span class="toc-text">并行和串行 —— 鱼与熊掌兼得</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建序列"><span class="toc-number">11.1.</span> <span class="toc-text">创建序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附赠章节promise-和-generator"><span class="toc-number">12.</span> <span class="toc-text">附赠章节：Promise 和 Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise-api-参考"><span class="toc-number">13.</span> <span class="toc-text">Promise API 参考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法"><span class="toc-number">13.1.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">13.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例方法"><span class="toc-number">13.3.</span> <span class="toc-text">实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最后"><span class="toc-number">14.</span> <span class="toc-text">最后</span></a></li></ol></div><div class="toc-progress"></div></aside></div><footer id="footer" class="inner"><span class="copyright">© 2017 bubkoo</span><span class="theme">@<a href="https://github.com/bubkoo/hexo-theme-formula" target="_blank">formula</a></span></footer><img id="go2top" src="/images/top_arrow.png" alt="go2top"><script charset="utf-8" src="/js/lib/jquery-2.1.3.min.js"></script><script charset="utf-8" src="/js/lib/jquery.imagesloaded.min.js"></script><script charset="utf-8" src="/fancybox/jquery.fancybox.pack.js"></script><script charset="utf-8" src="/js/lib/sea.js"></script><script charset="utf-8" src="/js/main.js"></script><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
    owner: 'bubkoo',
    repo: 'bubkoo.github.com',
    oauth: {
        client_id: '13c9fa4a27f96e5296bf',
        client_secret: 'd0f07fcf8605a22de1e57fd96ddb0666d2ce0751',
    },
})
gitment.render('article-comment')</script></body></html>
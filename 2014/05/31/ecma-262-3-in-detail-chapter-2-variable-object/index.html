<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>ECMA-262-3 详解 第二章 变量对象 | bubkoo</title><meta name="author" content="bubkoo"><meta name="description" content="本文译自 Dmitry A. Soshnikov 的文章 ECMA-262-3 in detail. Chapter 2. Variable object.
参考了一些译文，作为自己学习 ECMAScript 的一点积累。
概要创建应用程序的时，总免不了要声明变量和函数。然而，解析器（interpreter）是如何以及从哪里找到这些数据（变量，函数）的，当我们引用一个变量时，在解析器内部又发生了什么？
许多 ECMAScript 程序员都知道变量与执行上下文密切相关：
12345678var a = 10; // 全局上下文中的变量 (function () &amp;#123;  var b = 20; // 函数上下文中的局部变量&amp;#125;)(); alert(a); // 10alert(b); // &quot;b&quot; is not defined
同样，许多 ECMAScript 程序员也知道，基于当前版本的规范，独立作用域只能通过“函数代码”才能创建。也就是说，与 C/C++ 不同，在 ECMAScript 中 for 循环不会创建一个局部上下文（即局部作用域）。
12345for (var k in &amp;#123;a: 1, b: 2&amp;#125;) &amp;#123;  alert(k);&amp;#125; alert(k); // 尽管循环已经结束，但是变量 “k” 仍然在作用域中
下面具体来看一下，当我们声明变量和函数时，究竟发生了什么。"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:title" content="ECMA-262-3 详解 第二章 变量对象"><meta property="og:site_name" content="bubkoo"><link href="/favicon.ico" rel="icon" type="image/x-ico"><link href="/atom.xml" rel="alternate" title="bubkoo" type="application/atom+xml"><link href="/css/style.css" rel="stylesheet" type="text/css" charset="utf-8"><link href="/fancybox/jquery.fancybox.css" rel="stylesheet" type="text/css" charset="utf-8"><script id="google_analytics">(function (window, document, src, ga) {

  window['GoogleAnalyticsObject'] = ga;

  if (!window[ga]) {
    window[ga] = function () {
      (window[ga].q = window[ga].q || []).push(arguments);
    };
  }

  window[ga].l = 1 * new Date();

  var thisTag = document.getElementById('google_analytics');
  var script  = document.createElement('script');

  script.async = true;
  script.src   = src;

  thisTag.parentNode.insertBefore(script, thisTag);

  setTimeout(function () {
    script.parentNode.removeChild(script);
    thisTag.parentNode.removeChild(thisTag);
  }, 100);

})(window, document, 'https://www.google-analytics.com/analytics.js', 'ga');

ga('create', 'UA-78428859-2', 'auto');
ga('send', 'pageview');</script><script id="baidu_tongji">var _hmt = _hmt || [];
(function () {
  var script  = document.createElement('script');
  var thisTag = document.getElementById('baidu_tongji');

  script.src = '//hm.baidu.com/hm.js?49a1665c33b011585a2a629fdbed5b61';

  thisTag.parentNode.insertBefore(script, thisTag);

  setTimeout(function () {
    script.parentNode.removeChild(script);
    thisTag.parentNode.removeChild(thisTag);
  }, 100);
})();</script><!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]--><script>__start__ = window.performance && performance.timing ? performance.timing.navigationStart : Date.now();</script></head><body><header id="header" hoot="default" hoot-rate="1" class="inner"><div class="f-left"><a href="/" class="site-title">bubkoo</a></div><nav class="f-right"><ul class="site-nav"><li><a href="/">&lt;&gt;</a></li><li><a href="/archives">Archives</a></li><li><a href="https://github.com/bubkoo">Github</a></li></ul></nav></header><div id="container" class="inner"><div id="main"><article class="article post"><div class="article-wrap"><header class="article-header"><span class="article-header-icon icon-black"></span><h1 class="article-header-title">ECMA-262-3 详解 第二章 变量对象</h1><time datetime="2014-05-31T12:56:23.000Z" itemprop="datePublished" class="article-header-time"><span class="day">31</span><span class="month">2014年05月</span></time></header><section class="article-content"><p>本文译自 <a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">Dmitry A. Soshnikov</a> 的文章 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 2. Variable object.</a></p>
<p>参考了一些译文，作为自己学习 ECMAScript 的一点积累。</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>创建应用程序的时，总免不了要声明变量和函数。然而，解析器（interpreter）是如何以及从哪里找到这些数据（变量，函数）的，当我们引用一个变量时，在解析器内部又发生了什么？</p>
<p>许多 ECMAScript 程序员都知道变量与<a href="http://bubkoo.com/2014/05/28/ecma-262-3-in-detail-chapter-1-execution-contexts/">执行上下</a>文密切相关：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// 全局上下文中的变量</span></div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">// 函数上下文中的局部变量</span></div><div class="line">&#125;)();</div><div class="line"> </div><div class="line">alert(a); <span class="comment">// 10</span></div><div class="line">alert(b); <span class="comment">// "b" is not defined</span></div></pre></td></tr></table></figure>
<p>同样，许多 ECMAScript 程序员也知道，基于当前版本的规范，独立作用域只能通过“函数代码”才能创建。也就是说，与 C/C++ 不同，在 ECMAScript 中 <code>for</code> 循环不会创建一个局部上下文（即局部作用域）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) &#123;</div><div class="line">  alert(k);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">alert(k); <span class="comment">// 尽管循环已经结束，但是变量 “k” 仍然在作用域中</span></div></pre></td></tr></table></figure>
<p>下面具体来看一下，当我们声明变量和函数时，究竟发生了什么。</p>
<a id="more"></a>
<h2 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h2><p>如果变量与执行上下文相关，那么它就应该知道数据储存在哪里以及如何访问这些数据，这种机制被称为变量对象（variable object）。</p>
<p>变量对象（简称为 VO）是与某个执行上下文相关的一个特殊对象，并储存了一下数据：</p>
<ul>
<li>变量（var, VariableDeclaration）</li>
<li>函数声明（FunctionDeclaration, 缩写为FD）</li>
<li>函数形参</li>
</ul>
<p class="j-quote">注意，在 ES5 中，变量对象和活动对象并入了词法环境模型（lexical environments model），详细的描述请<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" target="_blank" rel="external">看这里</a>。</p>

<p>简单举例，可以用 ECMAScript 的对象来表示变量对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VO = &#123;&#125;;</div></pre></td></tr></table></figure>
<p>正如我们之前所说，VO 是执行上下文的一个属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">activeExecutionContext = &#123;</div><div class="line">  <span class="attr">VO</span>: &#123;</div><div class="line">    <span class="comment">// 上下文中的数据 (变量声明（var）, 函数声明（FD), 函数形参（function arguments）)</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>只有全局上下文中的变量对象可以通过 VO 的属性名间接访问（因为在全局上下文中，全局对象自身就是变量对象，稍候会详细介绍）。在其他上下文中是不能直接访问 VO 对象的，因为它只是内部机制的一个实现（抽象的）。</p>
<p>当我们声明一个变量或函数时，就等于是在 VO 对象上添加了一个相应键/值的属性。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">test(<span class="number">30</span>);</div></pre></td></tr></table></figure>
<p>对应的变量对象是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局上下文中的变量对象</span></div><div class="line">VO(globalContext) = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">10</span>,</div><div class="line">  <span class="attr">test</span>: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// “test” 函数上下文中的变量对象</div><div class="line">VO(test functionContext) = &#123;</div><div class="line">  x: 30,</div><div class="line">  b: 20</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是，在实现层面上（和规范中）变量对象只是一个抽象概念。从本质上说，在实际执行上下文中，VO 可能完全不叫 VO，而且其初始结构也可能完全不同。</p>
<h2 id="不同执行上下文中的变量对象"><a href="#不同执行上下文中的变量对象" class="headerlink" title="不同执行上下文中的变量对象"></a>不同执行上下文中的变量对象</h2><p>对于所有类型的执行上下文，变量对象的一些操作（如变量初始化）和行为都是相同的。从这个角度来看，把变量对象表示为抽象概念更加合适。而在函数上下文中同样可以通过变量对象定义一些相关的额外细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AbstractVO (变量实例化过程中的通用行为)</div><div class="line"> </div><div class="line">  ║</div><div class="line">  ╠══&gt; GlobalContextVO</div><div class="line">  ║        (VO === this === global)</div><div class="line">  ║</div><div class="line">  ╚══&gt; FunctionContextVO</div><div class="line">           (VVO === AO, &lt;arguments&gt; object and &lt;formal parameters&gt; are added)</div></pre></td></tr></table></figure>
<p>下面具体分析。</p>
<h3 id="全局上下文中的变量对象"><a href="#全局上下文中的变量对象" class="headerlink" title="全局上下文中的变量对象"></a>全局上下文中的变量对象</h3><p>首先，有必要给出全局对象（Global Object）的定义：</p>
<blockquote>
<p>全局对象是一个在进入任何执行上下文之前就创建的对象，此对象以单例的形式存在，它的属性在程序任何地方都可以访问，其生命周期随着程序的结束而终止。</p>
</blockquote>
<p>全局对象创建时，<code>Math</code>、<code>String</code>、<code>Date</code>、<code>parseInt</code> 等属性也会同时被初始化，同样也可以附加其它对象作为属性，其中包括可以引用全局对象自身的属性。比如，BOM 中，全局对象上的 <code>window</code> 属性就指向了全局对象自身（但是，并非所有的实现都是如此）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">global = &#123;</div><div class="line">  <span class="attr">Math</span>: <span class="xml"><span class="tag">&lt;<span class="name">...</span>&gt;</span>,</span></div><div class="line">  String: <span class="tag">&lt;<span class="name">...</span>&gt;</span></div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  window: global</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在引用全局对象的属性时，前缀通常可以省略，因为全局对象是不能通过名字直接访问的。尽管如此，通过全局上下文中的 this 是可以直接访问到全局对象的，也可以通过全局对象中的属性来访问到全局对象，例如，DOM 中的 <code>window</code> 属性。看下面写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>(<span class="number">10</span>); <span class="comment">// 等同于 global.String(10);</span></div><div class="line"> </div><div class="line"><span class="comment">// 带前缀</span></div><div class="line"><span class="built_in">window</span>.a = <span class="number">10</span>; <span class="comment">// === global.window.a = 10 === global.a = 10;</span></div><div class="line"><span class="keyword">this</span>.b = <span class="number">20</span>;   <span class="comment">// global.b = 20;</span></div></pre></td></tr></table></figure>
<p>因此，全局上下文中的变量对象就是全局对象自身：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VO(globalContext) === global;</div></pre></td></tr></table></figure>
<p>准确理解“全局上下文中的变量对象就是全局对象自身”是非常必要的，正是由于如此，在全局上下文中声明一个变量时，我们可以通过全局对象的属性间接访问到这个变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>);</div><div class="line"> </div><div class="line">alert(a); <span class="comment">// 直接访问，is found in VO(globalContext): "test"</span></div><div class="line"> </div><div class="line">alert(<span class="built_in">window</span>[<span class="string">'a'</span>]);  <span class="comment">// 间接访问，通过 global === VO(globalContext): "test"</span></div><div class="line">alert(a === <span class="keyword">this</span>.a); <span class="comment">// true</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> aKey = <span class="string">'a'</span>;</div><div class="line">alert(<span class="built_in">window</span>[aKey]); <span class="comment">// 间接访问，通过动态属性名的方式："test"</span></div></pre></td></tr></table></figure>
<h3 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a>函数上下文中的变量对象</h3><p>在函数上下文中，变量对象（VO）不能直接被访问到，此时活动对象（Activation Object，简称 AO）扮演着 VO 的角色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VO(functionContext) === AO;</div></pre></td></tr></table></figure>
<blockquote>
<p>活动对象在进入函数上下文的时候被创建，同时伴随着 <code>arguments</code> 属性的初始化，该属性是 <code>Arguments</code> 对象的值：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AO = &#123;</div><div class="line">  <span class="attr">arguments</span>: </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>arguments</code> 对象是活动对象（AO）中的一个属性，包含以下属性：</p>
<ul>
<li>callee - 当前函数的引用</li>
<li>length - 实参数量</li>
<li>properties-indexes（字符串类型的整数），属性的值就是函数的参数值（按参数列表从左到右排列）。<code>properties-indexes</code> 的元素的个数等于 <code>arguments.length</code>，<code>properties-indexes</code> 的值和实际传递进来的参数之间是共享的。</li>
</ul>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="comment">// 定义的函数参数（x,y,z）的个数</span></div><div class="line">  alert(foo.length); <span class="comment">// 3</span></div><div class="line"> </div><div class="line">  <span class="comment">// 实际传递的参数个数</span></div><div class="line">  alert(<span class="built_in">arguments</span>.length); <span class="comment">// 2</span></div><div class="line"> </div><div class="line">  <span class="comment">// 引用函数自身</span></div><div class="line">  alert(<span class="built_in">arguments</span>.callee === foo); <span class="comment">// true</span></div><div class="line"> </div><div class="line">  <span class="comment">// 参数互相共享</span></div><div class="line">  alert(x === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// true</span></div><div class="line">  alert(x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">20</span>;</div><div class="line">  alert(x); <span class="comment">// 20</span></div><div class="line"> </div><div class="line">  x = <span class="number">30</span>;</div><div class="line">  alert(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 30</span></div><div class="line"> </div><div class="line">  <span class="comment">// 然而，对于没有传递的参数 z，</span></div><div class="line">  <span class="comment">// 相关的 arguments 对象的 index-property 是不共享的</span></div><div class="line">  z = <span class="number">40</span>;</div><div class="line">  alert(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// undefined</span></div><div class="line"> </div><div class="line">  <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">50</span>;</div><div class="line">  alert(z); <span class="comment">// 40</span></div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</div></pre></td></tr></table></figure>
<p>对于最后一种情况，在老版本的 Chrome 浏览器中有一个 Bug：形参 <code>z</code> 和 <code>arguments[2]</code> 之间仍然是共享的。</p>
<h2 id="处理上下文代码的几个阶段"><a href="#处理上下文代码的几个阶段" class="headerlink" title="处理上下文代码的几个阶段"></a>处理上下文代码的几个阶段</h2><p>至此，也就到了本文最核心的部分了。处理执行上下文代码分为两个阶段：</p>
<ol>
<li>进入执行上下文</li>
<li>执行代码</li>
</ol>
<p>变量对象的修改和这两个阶段密切相关。</p>
<p>要注意的是，这两个处理阶段是通用的行为，与上下文类型无关（不管是全局上下文还是函数上下文都是一致的）。</p>
<h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时（在代码执行前），VO 就会被下列属性填充（在此前已经描述过了）：</p>
<ul>
<li>函数的所有形参（如果是在函数执行上下文中）<br>每个形参都对应变量对象中的一个属性，该属性由形参名和对应的实参值构成，如果没有传递实参，那么该属性值就为 <code>undefined</code></li>
<li>所有函数声明（FunctionDeclaration, FD）<br>每个函数声明都对应变量对象中的一个属性，这个属性由一个函数对象的名称和值构成，如果变量对象中存在相同的属性名，则完全替换该属性。</li>
<li>所有变量声明（var, VariableDeclaration）<br>每个变量声明都对应变量对象中的一个属性，该属性的键/值是变量名和 <code>undefined</code>，如果变量名与已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。</li>
</ul>
<p>举例说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c = <span class="number">10</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">  <span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span> <span class="title">_e</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">test(<span class="number">10</span>); <span class="comment">// call</span></div></pre></td></tr></table></figure>
<p>当进入 <code>test</code> 的执行上下文，并传递了实参 <code>10</code>，AO 对象如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AO(test) = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">10</span>,</div><div class="line">  <span class="attr">b</span>: <span class="literal">undefined</span>,</div><div class="line">  <span class="attr">c</span>: <span class="literal">undefined</span>,</div><div class="line">  <span class="attr">d</span>: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">FunctionDeclaration</span> "<span class="attr">d</span>"&gt;</span></span></div><div class="line">  e: undefined</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意：AO 并不包含函数 <code>x</code>，这是因为 <code>x</code> 不是函数声明，而是一个函数表达式（FunctionExpression，简称为 FE），函数表达式不会影响 VO。</p>
<p>同理，函数 <code>_e</code> 也是函数表达式，就像我们即将看到的那样，因为它分配给了变量 <code>e</code>，所以可以通过名称 <code>e</code> 来访问。函数声明与函数表达式的异同，将在 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="external">Chapter 5. Functions</a> 中进行详细的探讨。</p>
<p>这之后，将进入处理上下文代码的第二个阶段：执行代码。</p>
<h3 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h3><p>此时，AO/VO 的属性已经填充好了。（尽管，大部分属性都还没有赋予真正的值，都只是初始化时候的 <code>undefined</code> 值）。</p>
<p>继续以上一例子，到了执行代码阶段，AO/VO 就会修改为如下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AO[<span class="string">'c'</span>] = <span class="number">10</span>;</div><div class="line">AO[<span class="string">'e'</span>] = <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">FunctionExpression</span> "<span class="attr">_e</span>"&gt;</span>;</span></div></pre></td></tr></table></figure>
<p>再次注意，函数表达式 <code>_e</code> 仍在内存中，它被保存在声明的变量 <code>e</code> 中。但函数表达式 <code>x</code> 却不在 AO/VO 中，如果尝试在其定义前或者定义后调用 <code>x</code> 函数，这时会发生“x未定义”的错误。未保存在变量中的函数表达式只能在其内部或通过递归才能被调用。</p>
<p>另一个经典的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">alert(x); <span class="comment">// function</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line">alert(x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">x = <span class="number">20</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"> </div><div class="line">alert(x); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<p>为什么第一次弹出的是 “function”？为何在 <code>x</code> 声明前就能访问到？为什么弹出的不是 “10” 或者 “20”？原因在于，根据规范，在进入上下文时，VO 中的 <code>x</code> 被填充为函数声明。同时，还有变量声明 <code>x</code>，但是，根据前面的规则，变量声明是在函数形参和函数声明之后，并且，变量声明不会影响已经存在的同名函数或形参，因此，进入上下文时，VO 如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">VO = &#123;&#125;;</div><div class="line"> </div><div class="line">VO[<span class="string">'x'</span>] = <span class="xml"><span class="tag">&lt;<span class="name">引用了函数声明“x”</span>&gt;</span></span></div><div class="line"> </div><div class="line">// 发现var x = 10;</div><div class="line">// 如果函数“x”还未定义</div><div class="line">// 则 "x" 为 undefined, 但是，在我们的例子中</div><div class="line">// 变量声明并不会影响同名的函数值</div><div class="line"> </div><div class="line">VO['x'] = <span class="tag">&lt;<span class="name">值不受影响，仍是函数</span>&gt;</span></div></pre></td></tr></table></figure>
<p>随后，在执行代码阶段，VO 被修改为如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">VO[<span class="string">'x'</span>] = <span class="number">10</span>;</div><div class="line">VO[<span class="string">'x'</span>] = <span class="number">20</span>;</div></pre></td></tr></table></figure>
<p>正如在第二个和第三个alert显示的那样。</p>
<p>下面的例子里我们可以再次看到，变量是在进入上下文阶段放入VO中的。(因为，虽然else部分代码永远不会执行，但是不管怎样，变量 <code>b</code> 仍然存在于VO中。)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">alert(a); <span class="comment">// 1</span></div><div class="line">alert(b); <span class="comment">// undefined, but not "b is not defined"</span></div></pre></td></tr></table></figure>
<h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><p>通常，各类文章和 JavaScript 相关的书籍都声称：“不管是使用 <code>var</code> 关键字（在全局上下文）还是不使用 <code>var</code> 关键字（在任何地方），都可以声明一个全局变量”。这样描述是不恰当的，请记住：</p>
<p>使用 <code>var</code> 是声明变量的唯一方式。</p>
<p>如下赋值语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p>仅仅是在全局对象时创建了新的属性（而不是变量）。“不是变量”并不是意味着它无法改变，而是指它不符合 ECMAScript 规范中的变量概念，所以它“不是变量”（它之所以能成为全局对象的属性，完全是因为 <code>VO(globalContext) === global</code>，大家还记得这个吧？）。</p>
<p>让我们通过下面的实例看看具体的区别吧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">alert(a); <span class="comment">// undefined</span></div><div class="line">alert(b); <span class="comment">// "b" is not defined</span></div><div class="line"> </div><div class="line">b = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</div></pre></td></tr></table></figure>
<p>所有根源仍然是 VO 和它的修改阶段（进入上下文阶段和执行代码阶段）：</p>
<p>进入上下文：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">VO = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="literal">undefined</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们看到，这个阶段并没有任何 <code>b</code>，因为它不是变量，<code>b</code> 在执行代码阶段才出现。（但是，在我们这个例子中也不会出现，因为在 <code>b</code> 出现前就发生了错误）</p>
<p>将上述代码稍作改动：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">alert(a); <span class="comment">// undefined, we know why</span></div><div class="line"> </div><div class="line">b = <span class="number">10</span>;</div><div class="line">alert(b); <span class="comment">// 10, created at code execution</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</div><div class="line">alert(a); <span class="comment">// 20, modified at code execution</span></div></pre></td></tr></table></figure>
<p>关于变量还有非常重要的一点：与简单属性不同的是，变量是不能删除的<code>{DontDelete}</code>，这意味着要想通过 <code>delete</code> 操作符来删除一个变量是不可能的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">10</span>;</div><div class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">alert(<span class="keyword">delete</span> a); <span class="comment">// true</span></div><div class="line"> </div><div class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</div><div class="line">alert(<span class="built_in">window</span>.b); <span class="comment">// 20</span></div><div class="line"> </div><div class="line">alert(<span class="keyword">delete</span> b); <span class="comment">// false</span></div><div class="line"> </div><div class="line">alert(<span class="built_in">window</span>.b); <span class="comment">// still 20</span></div></pre></td></tr></table></figure>
<p class="j-quote">注意，在 ES5 中，<code>{DontDelete}</code> 被 重命名为了 <code>[[Configurable]]</code>，而且可以通过 <code>Object.defineProperty</code> 来手动控制。</p>

<p>但是，这里有个例外，就是 <code>eval</code> 执行上下文中，是可以删除变量的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">'var a = 10;'</span>);</div><div class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">alert(<span class="keyword">delete</span> a); <span class="comment">// true</span></div><div class="line"> </div><div class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>在一些调试工具（如 Firebug）的控制台中实验这些例子时，需要注意：Firebug 是使用 <code>eval</code> 来执行控制台里的代码，因此，变量同样没有 <code>{DontDelete}</code> 特性，可以被删除。</p>
<h2 id="特殊属性-__parent__"><a href="#特殊属性-parent" class="headerlink" title="特殊属性: __parent__"></a>特殊属性: __parent__</h2><p>根据前面的介绍，按照规范，活动对象是不能被直接访问到的。但是，一些具体的实现并没有完全遵守规范，例如在 SpiderMonkey 和 Rhino 中，函数有个特殊属性 <code>__parent__</code>，通过这个属性可以直接引用到创建该函数的上下文的活动对象或全局变量对象。</p>
<p>例如（在 SpiderMonkey 和 Rhino 中）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"> </div><div class="line">alert(foo.__parent__); <span class="comment">// global</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> VO = foo.__parent__;</div><div class="line"> </div><div class="line">alert(VO.a); <span class="comment">// 10</span></div><div class="line">alert(VO === global); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>在上面例子中，可以看到函数 <code>foo</code> 是在全局上下文中创建的，相应的，它的 <code>__parent__</code> 属性设置为全局上下文的变量对象，也就是全局对象。</p>
<p>然而，在 SpiderMonkey 中以相同的方式获取活动对象（AO）是不可能的：不同的版本表现都不同，内部函数的 <code>__parent__</code> 属性会返回 <code>null</code> 或者全局对象。</p>
<p>在 Rhino 中，以相同的方式获取活动对象是允许的：</p>
<p>如下所示（Rhino）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</div><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</div><div class="line"> </div><div class="line">  <span class="comment">// 函数 foo 的活动对象</span></div><div class="line">  <span class="keyword">var</span> AO = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).__parent__;</div><div class="line"> </div><div class="line">  print(AO.y); <span class="comment">// 20</span></div><div class="line"> </div><div class="line">  <span class="comment">// 当前活动对象的 __parent__ 属性指向全局对象</span></div><div class="line">  <span class="comment">// 这样就形成了所说的作用域链</span></div><div class="line">  print(AO.__parent__ === global); <span class="comment">// true</span></div><div class="line">  print(AO.__parent__.x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文深入讨论了跟执行上下文相关的对象，我希望这些知识对您来说能有所帮助，能解决一些您曾经遇到的问题或困惑。按照计划，在后续的章节中，我们将探讨 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="external">Scope chain</a>，<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/#function-activation" target="_blank" rel="external">Identifier resolution</a>，<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="external">Closures</a>。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li>10.1.3 — <a href="http://bclary.com/2004/11/07/#a-10.1.3" target="_blank" rel="external">Variable Instantiation</a></li>
<li>10.1.5 — <a href="http://bclary.com/2004/11/07/#a-10.1.5" target="_blank" rel="external">Global Object</a></li>
<li>10.1.6 — <a href="http://bclary.com/2004/11/07/#a-10.1.6" target="_blank" rel="external">Activation Object</a></li>
<li>10.1.8 — <a href="http://bclary.com/2004/11/07/#a-10.1.8" target="_blank" rel="external">Arguments Object</a></li>
</ul>
<p class="j-dot"><strong>Translated by:</strong> Dmitry A. Soshnikov.<br><strong>Published on:</strong> 2010-03-15<br><br><strong>Originally written by:</strong> Dmitry A. Soshnikov [ru, <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/" target="_blank" rel="external">read »</a>]<br><strong>Originally published on:</strong> 2009-06-27</p></section><footer class="article-footer clearfix"><div class="categories"><a href="/categories/javascript/" title="JavaScript">JavaScript</a></div><div class="tags"><a href="/tags/ecmascript/" title="ECMAScript">ECMAScript</a> <a href="/tags/ecma-262-3/" title="ECMA-262-3">ECMA-262-3</a> <a href="/tags/variable-object/" title="Variable object">Variable object</a></div></footer></div><nav class="article-nav clearfix"><a href="/2014/06/01/ecma-262-3-in-detail-chapter-3-this/" class="article-nav-link article-nav-newer"><strong class="article-nav-type">Newer</strong><span class="article-nav-title">ECMA-262-3 详解 第三章 This</span></a><a href="/2014/05/28/ecma-262-3-in-detail-chapter-1-execution-contexts/" class="article-nav-link article-nav-older"><strong class="article-nav-type">Older</strong><span class="article-nav-title">ECMA-262-3 详解 第一章 执行上下文</span></a></nav></article><section id="article-comment" class="article-comment"><div data-thread-key="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/" data-title="ECMA-262-3 详解 第二章 变量对象" data-url="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/" class="ds-thread"></div></section></div><aside id="sidebar" role="sidebar"><div class="widget tagcloud"><h3 class="widget-title">标签</h3><div class="widget-content"><a href="/tags/aop/" style="font-size: 10px">AOP</a> <a href="/tags/algorithm/" style="font-size: 18.33px">Algorithm</a> <a href="/tags/analysis/" style="font-size: 10px">Analysis</a> <a href="/tags/angularjs/" style="font-size: 15px">AngularJS</a> <a href="/tags/animation/" style="font-size: 10px">Animation</a> <a href="/tags/architecture/" style="font-size: 16.67px">Architecture</a> <a href="/tags/archives/" style="font-size: 10.83px">Archives</a> <a href="/tags/async/" style="font-size: 12.5px">Async</a> <a href="/tags/backbone/" style="font-size: 10px">Backbone</a> <a href="/tags/browsers/" style="font-size: 10px">Browsers</a> <a href="/tags/css/" style="font-size: 12.5px">CSS</a> <a href="/tags/css3/" style="font-size: 10px">CSS3</a> <a href="/tags/closure/" style="font-size: 10.83px">Closure</a> <a href="/tags/closures/" style="font-size: 10px">Closures</a> <a href="/tags/cookies/" style="font-size: 10px">Cookies</a> <a href="/tags/cross-domain/" style="font-size: 10px">Cross Domain</a> <a href="/tags/custom-elements/" style="font-size: 10.83px">Custom Elements</a> <a href="/tags/d3/" style="font-size: 10px">D3</a> <a href="/tags/debounce/" style="font-size: 10px">Debounce</a> <a href="/tags/debug/" style="font-size: 10.83px">Debug</a> <a href="/tags/dependency/" style="font-size: 10px">Dependency</a> <a href="/tags/document/" style="font-size: 10px">Document</a> <a href="/tags/ecma-262-3/" style="font-size: 15.83px">ECMA-262-3</a> <a href="/tags/ecmascript/" style="font-size: 15.83px">ECMAScript</a> <a href="/tags/es6/" style="font-size: 20px">ES6</a> <a href="/tags/errors/" style="font-size: 10px">Errors</a> <a href="/tags/essential/" style="font-size: 10px">Essential</a> <a href="/tags/evaluation-strategy/" style="font-size: 10px">Evaluation strategy</a> <a href="/tags/event/" style="font-size: 10px">Event</a> <a href="/tags/exceptions/" style="font-size: 10px">Exceptions</a> <a href="/tags/express/" style="font-size: 10px">Express</a> <a href="/tags/flip/" style="font-size: 10px">FLIP</a> <a href="/tags/flexbox/" style="font-size: 10px">Flexbox</a> <a href="/tags/funarg/" style="font-size: 10px">Funarg</a> <a href="/tags/gist/" style="font-size: 10px">Gist</a> <a href="/tags/github/" style="font-size: 10px">Github</a> <a href="/tags/guide/" style="font-size: 10px">Guide</a> <a href="/tags/html/" style="font-size: 10px">HTML</a> <a href="/tags/http/" style="font-size: 10px">HTTP</a> <a href="/tags/hexo/" style="font-size: 10.83px">Hexo</a> <a href="/tags/ie/" style="font-size: 10px">IE</a> <a href="/tags/iife/" style="font-size: 10px">IIFE</a> <a href="/tags/jshint/" style="font-size: 10px">JSHint</a> <a href="/tags/javascript/" style="font-size: 19.17px">JavaScript</a> <a href="/tags/leak/" style="font-size: 10px">Leak</a> <a href="/tags/linting/" style="font-size: 10px">Linting</a> <a href="/tags/mvc/" style="font-size: 10px">MVC</a> <a href="/tags/methodology/" style="font-size: 10px">Methodology</a> <a href="/tags/mock/" style="font-size: 10px">Mock</a> <a href="/tags/modular/" style="font-size: 10px">Modular</a> <a href="/tags/mongodb/" style="font-size: 10px">MongoDB</a> <a href="/tags/oop/" style="font-size: 10.83px">OOP</a> <a href="/tags/partial-application/" style="font-size: 10px">Partial Application</a> <a href="/tags/pattern/" style="font-size: 10px">Pattern</a> <a href="/tags/patterns/" style="font-size: 10px">Patterns</a> <a href="/tags/performance/" style="font-size: 14.17px">Performance</a> <a href="/tags/promise/" style="font-size: 13.33px">Promise</a> <a href="/tags/prototype/" style="font-size: 11.67px">Prototype</a> <a href="/tags/quality/" style="font-size: 10px">Quality</a> <a href="/tags/quiz/" style="font-size: 10px">Quiz</a> <a href="/tags/regex/" style="font-size: 10px">Regex</a> <a href="/tags/requirejs/" style="font-size: 10px">RequireJS</a> <a href="/tags/sass/" style="font-size: 10px">SASS</a> <a href="/tags/svg/" style="font-size: 10px">SVG</a> <a href="/tags/scope/" style="font-size: 10.83px">Scope</a> <a href="/tags/shapes/" style="font-size: 10px">Shapes</a> <a href="/tags/shuffle/" style="font-size: 10px">Shuffle</a> <a href="/tags/sort/" style="font-size: 17.5px">Sort</a> <a href="/tags/source-map/" style="font-size: 10.83px">Source Map</a> <a href="/tags/styling/" style="font-size: 10px">Styling</a> <a href="/tags/sublime-text/" style="font-size: 10px">Sublime Text</a> <a href="/tags/template/" style="font-size: 10px">Template</a> <a href="/tags/throttle/" style="font-size: 10px">Throttle</a> <a href="/tags/timing/" style="font-size: 10px">Timing</a> <a href="/tags/tools/" style="font-size: 12.5px">Tools</a> <a href="/tags/variable-object/" style="font-size: 10px">Variable object</a> <a href="/tags/visualizations/" style="font-size: 10px">Visualizations</a> <a href="/tags/when/" style="font-size: 12.5px">When</a> <a href="/tags/delete/" style="font-size: 10px">delete</a> <a href="/tags/execution-context/" style="font-size: 10px">execution context</a> <a href="/tags/fetch/" style="font-size: 10px">fetch</a> <a href="/tags/function/" style="font-size: 10px">function</a> <a href="/tags/nodejs/" style="font-size: 10px">nodejs</a> <a href="/tags/nodemon/" style="font-size: 10px">nodemon</a> <a href="/tags/npm/" style="font-size: 10px">npm</a> <a href="/tags/nvm/" style="font-size: 10px">nvm</a> <a href="/tags/performance/" style="font-size: 10px">performance</a> <a href="/tags/prebrowsing/" style="font-size: 10px">prebrowsing</a> <a href="/tags/prefetching/" style="font-size: 10px">prefetching</a> <a href="/tags/preloading/" style="font-size: 10px">preloading</a> <a href="/tags/tabindex/" style="font-size: 10px">tabindex</a> <a href="/tags/this/" style="font-size: 10px">this</a> <a href="/tags/ui-router/" style="font-size: 14.17px">ui-router</a></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/01/18/debouncing-throttling-explained-examples/">实例解析防抖和节流函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/08/quick-tip-multiple-versions-node-nvm/">使用 nvm 管理不同版本的 node 与 npm</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/08/15-ways-to-write-self-documenting-javascript/">如何编写更加自解释的代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/31/high-performance-animations/">使用 FLIP 来提高 Web 动画的性能</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/28/styling-broken-images/">定制图片加载失败时的样式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/26/delivering-octicons-with-svg/">使用 SVG 输出 Octicon</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/18/how-to-use-npm-as-a-build-tool/">如何将 npm 作为构建工具使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/what-you-can-do-with-gists-on-github/">任何人都可以使用到的 Gist 服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/19/prefetching-preloading-prebrowsing/">前端性能优化 - 资源预加载</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/18/es6-in-depth-the-future/">深入解析 ES6：未来展望</a></li></ul></div></div></aside><aside id="topic-wrap" class="toc-wrap f-right"><h3 class="toc-wrap-title">内容</h3><div class="toc-tree"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概要"><span class="toc-number">1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据声明"><span class="toc-number">2.</span> <span class="toc-text">数据声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不同执行上下文中的变量对象"><span class="toc-number">3.</span> <span class="toc-text">不同执行上下文中的变量对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局上下文中的变量对象"><span class="toc-number">3.1.</span> <span class="toc-text">全局上下文中的变量对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数上下文中的变量对象"><span class="toc-number">3.2.</span> <span class="toc-text">函数上下文中的变量对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理上下文代码的几个阶段"><span class="toc-number">4.</span> <span class="toc-text">处理上下文代码的几个阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进入执行上下文"><span class="toc-number">4.1.</span> <span class="toc-text">进入执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行代码"><span class="toc-number">4.2.</span> <span class="toc-text">执行代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于变量"><span class="toc-number">5.</span> <span class="toc-text">关于变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特殊属性-__parent__"><span class="toc-number">6.</span> <span class="toc-text">特殊属性: __parent__</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">8.</span> <span class="toc-text">扩展阅读</span></a></li></ol></div><div class="toc-progress"></div></aside></div><footer id="footer" class="inner"><span class="copyright">© 2017 bubkoo</span><span class="theme">@<a href="https://github.com/bubkoo/hexo-theme-formula" target="_blank">formula</a></span></footer><img id="go2top" src="/images/top_arrow.png" alt="go2top"><script charset="utf-8" src="/js/lib/jquery-2.1.3.min.js"></script><script charset="utf-8" src="/js/lib/jquery.imagesloaded.min.js"></script><script charset="utf-8" src="/fancybox/jquery.fancybox.pack.js"></script><script charset="utf-8" src="/js/lib/sea.js"></script><script charset="utf-8" src="/js/main.js"></script><script id="redundancy3">var duoshuoQuery = { short_name: 'bubkoo' };
(function () {
  var ds = document.createElement('script');

  ds.type    = 'text/javascript';
  ds.async   = true;
  ds.src     = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';

  (document.getElementsByTagName('head')[0]
  || document.getElementsByTagName('body')[0]).appendChild(ds);

  ds.parentNode.removeChild(ds);

  var script = document.getElementById('redundancy3');
  script && script.parentNode.removeChild(script);
})();</script></body></html>
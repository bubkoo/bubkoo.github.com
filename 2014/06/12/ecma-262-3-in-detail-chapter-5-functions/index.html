<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>ECMA-262-3 详解 第五章 函数 | bubkoo</title><meta name="author" content="bubkoo"><meta name="description" content="本文译自 Dmitry A. Soshnikov 的文章 ECMA-262-3 in detail. Chapter 5. Functions.
其中大部分参考了 goddyzhao 的翻译。
概述本文将介绍 ECMAScript 中一个非常常见的对象 – 函数。我们将着重介绍函数都有哪些类型，不同类型的函数是如何影响上下文的变量对象的，以及每种类型的函数的作用域链中都包含什么，并回答诸如下面这样的问题：下面声明的函数有什么区别吗？（如果有，区别是什么）。
123var foo = function () &amp;#123;  ...&amp;#125;;
上述方式创建的函数和如下方式创建的有什么不同？
123function foo() &amp;#123;  ...&amp;#125;
下面代码为什么要用一个括号包起来呢？
123(function () &amp;#123;  ...&amp;#125;)();
本文和此前几篇文章都是有关联的，因此，要想完全搞懂这部分内容，建议先去阅读第二章 变量对象以及第四章 作用域链。
下面，我们首先来看一下函数类型。"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:title" content="ECMA-262-3 详解 第五章 函数"><meta property="og:site_name" content="bubkoo"><link href="/favicon.ico" rel="icon" type="image/x-ico"><link href="/atom.xml" rel="alternate" title="bubkoo" type="application/atom+xml"><link href="/css/style.css" rel="stylesheet" type="text/css" charset="utf-8"><link href="/fancybox/jquery.fancybox.css" rel="stylesheet" type="text/css" charset="utf-8"><script id="google_analytics">(function (window, document, src, ga) {

  window['GoogleAnalyticsObject'] = ga;

  if (!window[ga]) {
    window[ga] = function () {
      (window[ga].q = window[ga].q || []).push(arguments);
    };
  }

  window[ga].l = 1 * new Date();

  var thisTag = document.getElementById('google_analytics');
  var script  = document.createElement('script');

  script.async = true;
  script.src   = src;

  thisTag.parentNode.insertBefore(script, thisTag);

  setTimeout(function () {
    script.parentNode.removeChild(script);
    thisTag.parentNode.removeChild(thisTag);
  }, 100);

})(window, document, 'https://www.google-analytics.com/analytics.js', 'ga');

ga('create', 'UA-78428859-2', 'auto');
ga('send', 'pageview');</script><script id="baidu_tongji">var _hmt = _hmt || [];
(function () {
  var script  = document.createElement('script');
  var thisTag = document.getElementById('baidu_tongji');

  script.src = '//hm.baidu.com/hm.js?49a1665c33b011585a2a629fdbed5b61';

  thisTag.parentNode.insertBefore(script, thisTag);

  setTimeout(function () {
    script.parentNode.removeChild(script);
    thisTag.parentNode.removeChild(thisTag);
  }, 100);
})();</script><!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]--><script>__start__ = window.performance && performance.timing ? performance.timing.navigationStart : Date.now();</script></head><body><header id="header" hoot="default" hoot-rate="1" class="inner"><div class="f-left"><a href="/" class="site-title">bubkoo</a></div><nav class="f-right"><ul class="site-nav"><li><a href="/">&lt;&gt;</a></li><li><a href="/archives">Archives</a></li><li><a href="https://github.com/bubkoo">Github</a></li></ul></nav></header><div id="container" class="inner"><div id="main"><article class="article post"><div class="article-wrap"><header class="article-header"><span class="article-header-icon icon-black"></span><h1 class="article-header-title">ECMA-262-3 详解 第五章 函数</h1><time datetime="2014-06-12T21:56:23.000Z" itemprop="datePublished" class="article-header-time"><span class="day">12</span><span class="month">2014年06月</span></time></header><section class="article-content"><p>本文译自 <a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">Dmitry A. Soshnikov</a> 的文章 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 5. Functions</a>.</p>
<p>其中大部分参考了 <a href="http://zh.blog.goddyzhao.me/" target="_blank" rel="external">goddyzhao</a> 的<a href="http://zh.blog.goddyzhao.me/post/11273713920/functions#_=_" target="_blank" rel="external">翻译</a>。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文将介绍 ECMAScript 中一个非常常见的对象 – 函数。我们将着重介绍函数都有哪些类型，不同类型的函数是如何影响上下文的变量对象的，以及每种类型的函数的作用域链中都包含什么，并回答诸如下面这样的问题：下面声明的函数有什么区别吗？（如果有，区别是什么）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上述方式创建的函数和如下方式创建的有什么不同？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面代码为什么要用一个括号包起来呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>本文和此前几篇文章都是有关联的，因此，要想完全搞懂这部分内容，建议先去阅读<a href="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/">第二章 变量对象</a>以及<a href="http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/">第四章 作用域链</a>。</p>
<p>下面，我们首先来看一下函数类型。</p>
<a id="more"></a>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>ECMAScript 中包含三类函数，每一类都有各自的特性。</p>
<h3 id="函数声明function-declaration"><a href="#函数声明（Function-Declaration）" class="headerlink" title="函数声明（Function Declaration）"></a>函数声明（Function Declaration）</h3><blockquote>
<p>函数声明（简称FD）是指这样的函数：</p>
<ul>
<li>一个必选的函数名</li>
<li>代码位置：要么是程序级别，要么在另一个函数体中</li>
<li>在进入上下文阶段时被创建</li>
<li>会影响变量对象</li>
<li>以如下方式声明：</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">exampleFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这类函数的主要特性是：只有它们可以影响变量对象（储存在上下文的 VO 中）。这个特性同时也解释了第二个重要点（它是变量对象特性的结果）—— 在代码执行阶段它们已经可用（因为 FD 在进入上下文阶段已经存在于 VO 中 —— 代码执行之前）。</p>
<p>例如（函数在其声明之前被调用）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'foo'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从定义中还提到了非常重要的一点 —— 函数声明在代码中的位置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数声明可以直接在程序级别的全局上下文中</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalFD</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 或者直接在另外一个函数的函数体中</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFD</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有这两个位置可以声明函数，也就是说，在表达式的位置或者是代码块中进行函数声明都是不可以的。</p>
<p>介绍完了函数声明，接下来介绍函数表达式（function expression）。</p>
<h3 id="函数表达式function-expression"><a href="#函数表达式（Function-Expression）" class="headerlink" title="函数表达式（Function Expression）"></a>函数表达式（Function Expression）</h3><blockquote>
<p>函数表达式（简称：FE）是指这样的函数：</p>
<ul>
<li>代码位置必须要在表达式的位置</li>
<li>函数名是可选的</li>
<li>不会影响变量对象</li>
<li>在执行代码阶段才被创建</li>
</ul>
</blockquote>
<p>这类函数的主要特性是：它们的代码总是在表达式的位置。最简单的表达式的例子就是赋值表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上述例子中将一个匿名函数赋值给了变量 <code>foo</code>，之后该函数就可以通过 <code>foo</code> 来访问了 ——  <code>foo()</code>。</p>
<p>正如定义中提到的，函数表达式也可以有名字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">_foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里要注意的是，在函数表达式的外部可以通过变量 <code>foo</code> ——<code>foo()</code> 来访问，而在函数内部（比如递归调用），还可以用 <code>_foo</code>（译者注：但在外部是无法使用 <code>_foo</code> 的）。</p>
<p>当函数表达式有名字的时候，它很难和函数声明作区分。不过，如果仔细看这两者的定义的话，要区分它们还是很容易的：函数表达式总是在表达式的位置。 如下例子展示的各类 ECMAScript 表达式都属于函数表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在括号中(grouping operator)只可能是表达式</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 在数组初始化中 —— 同样也只能是表达式</span></div><div class="line">[<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;];</div><div class="line"> </div><div class="line"><span class="comment">// 逗号操作符也只能跟表达式</span></div><div class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure>
<p>定义中还提到函数表达式是在执行代码阶段创建的，并且不是存储在变量对象上的。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不论是在定义前还是定义后，FE都是无法访问的</span></div><div class="line"><span class="comment">// (因为它是在代码执行阶段创建出来的),</span></div><div class="line"> </div><div class="line">alert(foo); <span class="comment">// "foo" is not defined</span></div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 后面也没用，因为它根本就不在VO中</span></div><div class="line"> </div><div class="line">alert(foo);  <span class="comment">// "foo" is not defined</span></div></pre></td></tr></table></figure>
<p>问题来了，函数表达式要来干嘛？其实答案是很明显的 —— 在表达式中使用，从而避免对变量对象造成“污染”。最简单的例子就是将函数作为参数传递给另外一个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">  callback();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'foo.bar'</span>);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">foo(<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'foo.baz'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上述例子中，部分变量存储了对FE的引用，这样函数就会保留在内存中并在之后，可以通过变量来访问（因为变量是可以影响 VO 的）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'foo'</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">foo();</div></pre></td></tr></table></figure>
<p>另外一个例子是创建封装的闭包从外部上下文中隐藏辅助性数据（在下面的例子中我们使用 FE，它在创建后立即调用）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;&#125;;</div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line">  foo.bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(x);</div><div class="line">  &#125;;</div><div class="line"> </div><div class="line">&#125;)();</div><div class="line"> </div><div class="line">foo.bar(); <span class="comment">// 10;</span></div><div class="line"> </div><div class="line">alert(x); <span class="comment">// "x" 未定义</span></div></pre></td></tr></table></figure>
<p>我们看到函数 <code>foo.bar</code>（通过其 <code>[[Scope]]</code> 属性）获得了对函数 <code>initialize</code> 内部变量 <code>x</code> 的访问。 而同样的 <code>x</code> 在外部就无法访问到。很多库都使用这种策略来创建“私有”数据以及隐藏辅助数据。通常，这样的情况下 FE 的名字都会省略掉：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="comment">// 初始化作用域</span></div><div class="line"> </div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>还有一个 FE 的例子是：在执行代码阶段在条件语句中创建 FE，这种方式也不会影响 VO：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> bar = (foo % <span class="number">2</span> == <span class="number">0</span></div><div class="line">  ? <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="number">0</span>); &#125;</div><div class="line">  : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="number">1</span>); &#125;</div><div class="line">);</div><div class="line"> </div><div class="line">bar(); <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>注意：ES5 标准的绑定函数，使函数正确绑定 <code>this</code> 的值，将其锁定在函数的任何调用中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> boundFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x;</div><div class="line">&#125;.bind(&#123;<span class="attr">x</span>: <span class="number">10</span>&#125;);</div><div class="line"> </div><div class="line">boundFn(); <span class="comment">// 10</span></div><div class="line">boundFn.call(&#123;<span class="attr">x</span>: <span class="number">20</span>&#125;); <span class="comment">// 仍然是 10</span></div></pre></td></tr></table></figure>
<p>绑定功能最常使用在事件监听或推迟（<code>setTimeout</code>）执行函数时，保证函数执行时 <code>this</code> 是指定的对象。</p>
<p>你可以在 ES5 系列的 <a href="http://dmitrysoshnikov.com/notes/note-1-ecmascript-bound-functions/" target="_blank" rel="external">appropriate chapter</a> 中获取更多关于绑定函数的细节。</p>
<h4 id="有关括号的问题"><a href="#“有关括号”的问题" class="headerlink" title="“有关括号”的问题"></a>“有关括号”的问题</h4><p>现在让我们来回答本文开始提到的问题 – “为什么立即执行的函数需要用括号将其包起来？”。答案就是：将函数限制为表达式语句。</p>
<p>标准中提到，表达式语句（ExpressionStatement）不能以左大括号 <code>{</code> 开始 —— 因为这样一来就和代码块冲突了， 也不能以 <code>function</code> 关键字开始，因为这样一来又和函数声明冲突了。也就是说，以如下所示的方式来定义一个立即执行的函数，解释器都会抛出错误，只是原因不同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;();</div><div class="line"> </div><div class="line"><span class="comment">// or with a name</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>如果我们是在全局代码（程序级别）中这样定义函数，解释器会以函数声明来处理，因为它看到了是以 <code>function</code> 开始的。在第一个例子中，会抛出语法错误，原因是既然是个函数声明，则缺少函数名了（一个函数声明其名字是必须的）。</p>
<p>而在第二个例子中，看上去已经有了名字了（foo），应该会正确执行。然而，这里还是会抛出语法错误 —— 分组操作符内部缺少表达式。这里要注意的是，这个例子中，函数声明后面的()会被当组操作符来处理，而非函数调用的()。因此，如果我们有如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// "foo" 是函数声明</span></div><div class="line"><span class="comment">// 并且是在进入上下文的时候创建的</span></div><div class="line"> </div><div class="line">alert(foo); <span class="comment">// function</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  alert(x);</div><div class="line">&#125;(<span class="number">1</span>); <span class="comment">// 这里只是组操作符，并非调用!</span></div><div class="line"> </div><div class="line">foo(<span class="number">10</span>); <span class="comment">// 这里就是调用了, 10</span></div></pre></td></tr></table></figure>
<p>上述代码其实就是如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// function declaration</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 含表达式的组操作符</span></div><div class="line">(<span class="number">1</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 另外一个组操作符</span></div><div class="line"><span class="comment">// 包含一个函数表达式</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 这里面也是表达式</span></div><div class="line">(<span class="string">"foo"</span>);</div><div class="line"> </div><div class="line"><span class="comment">// etc</span></div></pre></td></tr></table></figure>
<p>如果我们定义一个如下代码（定义里包含一个语句），我们可能会说，定义歧义，会得到报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;alert(<span class="number">1</span>)&#125;</div></pre></td></tr></table></figure>
<p>根据规范，上述代码是错误的（一个表达式语句不能以 <code>function</code> 关键字开头）。然而，正如我们在后面要看到的，没有一种实现对其抛出错误， 它们各自按照自己的方式在处理。</p>
<p>那么究竟怎样才能创建一个立即执行的函数呢？答案很明显，它必须是个函数表达式，而不能是函数声明。而创建表达式最简单的方式就是使用上述提到的组操作符。因为在组操作符中只可能是表达式。 这样一来解释器也不会纠结了，会果断将其以 FE 的方式来处理。这样的函数将在执行阶段创建出来，然后立马执行，随后被移除（如果有没有对其的引用的话）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  alert(x);</div><div class="line">&#125;)(<span class="number">1</span>); <span class="comment">// 好了，这样就是函数调用了，而不再是组操作符了，1</span></div></pre></td></tr></table></figure>
<p>要注意的是，在下面的例子中，函数调用，其括号就不再是必须的了，因为函数本来就在表达式的位置了，解释器自然会以 FE 来处理，并且会在执行代码阶段创建该函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line"> </div><div class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x % <span class="number">2</span> != <span class="number">0</span> ? <span class="string">'yes'</span> : <span class="string">'no'</span>;</div><div class="line">  &#125;(<span class="number">1</span>)</div><div class="line"> </div><div class="line">&#125;;</div><div class="line"> </div><div class="line">alert(foo.bar); <span class="comment">// 'yes'</span></div></pre></td></tr></table></figure>
<p>因此，对“括号有关”问题的完整的回答则如下所示：</p>
<blockquote>
<p>如果要在函数创建后立马进行函数调用，并且函数不在表达式的位置时，括号就是必须的 —— 这样情况下，其实是手动的将其转换成了 FE。 而当解释器直接将其以 FE 的方式处理的时候，说明 FE 本身就在函数表达式的位置 —— 这个时候括号就不是必须的了。</p>
</blockquote>
<p>另外，除了使用括号的方式将函数转换成为FE之外，还有其他的方式，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'anonymous function is called'</span>);</div><div class="line">&#125;();</div><div class="line"> </div><div class="line"><span class="comment">// 或者这样</span></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'ECMAScript'</span>);</div><div class="line">&#125;();</div><div class="line"> </div><div class="line"><span class="comment">// 当然，还有其他很多方式</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>不过，括号是最通用也是最优雅的方式。</p>
<p>顺便提下，组操作符既可以包含没有调用括号的函数，又可以包含有调用括号的函数，这两者都是合法的 FE：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)();</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;());</div></pre></td></tr></table></figure>
<h4 id="实现扩展函数语句"><a href="#实现扩展：函数语句" class="headerlink" title="实现扩展：函数语句"></a>实现扩展：函数语句</h4><p>看如下代码，符合规范的解释器都无法解释这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(); <span class="comment">// 1 还是 0 ? 在不同引擎中测试</span></div></pre></td></tr></table></figure>
<p>这里有必要提下：根据标准，上述代码结构是不合法的，因为，此前我们就介绍过，函数声明是不能出现在代码块中的（这里 <code>if</code> 和 <code>else</code> 就包含代码块）。此前提到的，函数声明只能出现在两个位置：程序级别或者另外一个函数的函数体中。</p>
<p>为什么这种结构是错误的呢？因为在代码块中只允许语句。函数要想在这个位置出现的唯一可能就是要成为表达式语句。 但是，根据定义表达式语句又不能以左大括号开始（这样会与代码块冲突）也不能以 <code>function</code> 关键字开始（这样又会和 FD 冲突）。</p>
<p>然而，在错误处理部分，规范允许实现对程序语法进行扩展。而上述例子就是其中一种扩展。目前，所有的实现中都不会对上述情况抛出错误，都会以各自的方式进行处理。</p>
<p>因此根据规范，上述 <code>if-else</code> 中应当需要 FE。然而，绝大多数实现中都在进入上下文的时候在这里简单地创建了 FD，并且使用了最后一次的声明。最后 <code>foo</code> 函数显示了 <code>1</code>，尽管理论上 <code>else</code> 中的代码根本不会被执行到。</p>
<p>而 SpiderMonkey（TraceMonkey 也是）实现中，会将上述情况以两种方式来处理：一方面它不会将这样的函数以函数声明来处理（也就意味着函数会在执行代码阶段才会创建出来），然而，另外一方面，它们又不属于真正的函数表达式，因为在没有括号的情况是不能作函数调用的（同样会有解析错误 —— 和 FD 冲突），它们还是存储在变量对象中。</p>
<p>我认为 SpiderMonkey 单独引入了自己的中间函数类型 ——（FE+FD），这样的做法是正确的。这样的函数会根据时间和对应的条件正确创建出来，不像 FE。和 FD 有点类似，可以在外部对其进行访问。SpiderMonkey 将这种语法扩展命名为函数语句（Function Statement）（简称 FS）；这部分理论在 MDC 中有<a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Functions#Conditionally_defining_a_function" target="_blank" rel="external">具体介绍</a>。JavaScript 的发明者  Brendan Eich 也<a href="https://mail.mozilla.org/pipermail/es-discuss/2008-February/005314.html" target="_blank" rel="external">提到过</a>这类函数类型。</p>
<h4 id="命名函数表达式nfe的特性"><a href="#命名函数表达式（NFE）的特性" class="headerlink" title="命名函数表达式（NFE）的特性"></a>命名函数表达式（NFE）的特性</h4><p>当 FE 有名字之后（named function expression，简称：NFE），就产生了一个重要的特性。正如在定义中提到的，函数表达式是不会影响上下文的变量对象的（这就意味着不论是在定义前还是在定义后，都是不可能通过名字来进行调用的）。然而，FE 可以通过自己的名字进行递归调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar</span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">if</span> (bar) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  foo(<span class="literal">true</span>); <span class="comment">// "foo" name is available</span></div><div class="line"> </div><div class="line">&#125;)();</div><div class="line"> </div><div class="line"><span class="comment">// but from the outside, correctly, is not</span></div><div class="line"> </div><div class="line">foo(); <span class="comment">// "foo" is not defined</span></div></pre></td></tr></table></figure>
<p>这里 <code>foo</code> 这个名字究竟保存在哪里呢？在 <code>foo</code> 的活跃对象中吗？非也，因为在 <code>foo</code> 函数中根本就没有定义任何 <code>foo</code>。那么是在上层上下文的变量对象中吗？也不是，因为根据定义 —— FE 是不会影响 VO 的 —— 正如我们在外层对其调用的结果所看到的那样。那么，它究竟保存在哪里了呢？</p>
<p>不卖关子了，马上来揭晓。当解释器在执行代码阶段看到了有名字的 FE 之后，它会在创建 FE 之前，创建一个辅助型的特殊对象，并把它添加到当前的作用域链中。然后，再创建 FE，在这个时候（根据<a href="http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/">第四章 作用域链</a>的描述），函数拥有了 <code>[[Scope]]</code> 属性 —— 创建函数所在上下文的作用域链（这个时候，在 <code>[[Scope]]</code> 就有了那个特殊对象）。之后，特殊对象中唯一的属性 —— FE 的名字添加到了该对象中；其值就是对 FE 的引用。在最后，当前上下文退出的时候，就会把该特殊对象移除。 用伪代码来描述此算法就如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">specialObject = &#123;&#125;;</div><div class="line"> </div><div class="line">Scope = specialObject + Scope;</div><div class="line"> </div><div class="line">foo = FunctionExpression;</div><div class="line">foo.[[Scope]] = Scope;</div><div class="line">specialObject.foo = foo; <span class="comment">// &#123;DontDelete&#125;, &#123;ReadOnly&#125;</span></div><div class="line"> </div><div class="line"><span class="keyword">delete</span> Scope[<span class="number">0</span>]; <span class="comment">// 从作用域链的最前面移除specialObject</span></div></pre></td></tr></table></figure>
<p>这就是为什么在函数外是无法通过名字访问到该函数的（因为它并不在上层作用域中存在），而在函数内部却可以访问到。</p>
<p>而这里要注意的一点是：在某些实现中，比如 Rhino，FE 的名字并不是保存在特殊对象中的，而是保存在 FE 的活跃对象中。再比如微软的实现 —— JScript，则完全破坏了 FE 的规则，直接将该名字保存在上层作用域的变量对象中了，这样在外部也可以访问到。</p>
<h4 id="nfe-和-spidermonkey"><a href="#NFE-和-SpiderMonkey" class="headerlink" title="NFE 和 SpiderMonkey"></a>NFE 和 SpiderMonkey</h4><p>说到实现，部分版本的 SpiderMonkey 有一个与上述提到的特殊对象相关的特性，这个特性也可以看作是个 bug（既然所有的实现都是严格遵循标准的，那么这个就是标准的问题了）。此特性和标识符处理相关：作用域链的分析是二维的，在标识符查询的时候，还要考虑作用域链中每个对象的原型链。</p>
<p>当在 <code>Object.prototype</code> 对象上定义一个属性，并将该属性名指定为一个“根本不存在”的变量时，就能够体现该特性。 比如，下面例子中的变量 <code>x</code>，在作用域链查询过程中，一直到全局对象也是找不到 <code>x</code> 的。 然而，在 SpiderMonkey 中，全局对象继承自 <code>Object.prototype</code>，于是，对应的值就在该对象中找到了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(x); <span class="comment">// 10</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>活动对象是没有原型一说的。可以通过内部函数来证明。 如果在定义一个局部变量 <code>x</code> 并声明一个内部函数（FD 或者匿名的 FE），然后，在内部函数中引用变量 <code>x</code>，这个时候该变量会在上层函数上下文中查询到（理应如此），而不是在 <code>Object.prototype</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</div><div class="line"> </div><div class="line">  <span class="comment">// 函数声明</span></div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(x);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  bar(); <span class="comment">// 20, from AO(foo)</span></div><div class="line"> </div><div class="line">  <span class="comment">// 函数表达式也一样</span></div><div class="line"> </div><div class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(x); <span class="comment">// 20, also from AO(foo)</span></div><div class="line">  &#125;)();</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo();</div></pre></td></tr></table></figure>
<p>在有些实现中，存在这样的异常：它们会在活动对象上设置原型。比方说，在 Blackberry 的实现中，上述例子中变量 <code>x</code> 值就会变成 <code>10</code>。 因为 <code>x</code> 从 <code>Object.prototype</code> 中就找到了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AO(bar FD or anonymous FE) -&gt; no -&gt;</div><div class="line">AO(bar FD or anonymous FE).[[Prototype]] -&gt; yes - <span class="number">10</span></div></pre></td></tr></table></figure>
<p>当出现有名字的 FE 的特殊对象的时候，在 SpiderMonkey 中也是有同样的异常。该特殊对象是普通对象 —— “和通过 <code>new Object()</code> 表达式产生的一样”。相应地，它也应当继承自 <code>Object.prototype</code>，上述描述只针对 SpiderMonkey（1.7版本）。其他的实现（包括新的 TraceMonkey）是不会给这个特殊对象设置原型的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">    alert(x); <span class="comment">// 20, but not 10, as don't reach AO(foo)</span></div><div class="line"> </div><div class="line">    <span class="comment">// "x" is resolved by the chain:</span></div><div class="line">    <span class="comment">// AO(bar) - no -&gt; __specialObject(bar) -&gt; no</span></div><div class="line">    <span class="comment">// __specialObject(bar).[[Prototype]] - yes: 20</span></div><div class="line"> </div><div class="line">  &#125;)();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">20</span>;</div><div class="line"> </div><div class="line">foo();</div></pre></td></tr></table></figure>
<p class="j-quote">注意：在 ES5 中这个行为已经改变了，并且在当前版本的 Firefox 中，储存 FE 名字的对象不再继承自 <code>Object.prototype</code>。</p>

<h4 id="nfe-和-jscript"><a href="#NFE-和-JScript" class="headerlink" title="NFE 和 JScript"></a>NFE 和 JScript</h4><p>微软的实现 —— JScript，是 IE 的 JS 引擎（截至本文撰写时最新是 JScript5.8 —— IE8），该引擎与 NFE 相关的 bug 有很多。每个 bug 基本上都和 ECMA-262-3rd 规范是完全违背的。有些甚至会引发严重的错误。</p>
<p>第一，针对上述这样的情况，JScript 完全破坏了 FE 的规则：不应当将函数名字保存在变量对象中的。另外，FE 的名字应当保存在特殊对象中，并且只有在函数自身内部才可以访问（其他地方均不可以）。而 JScript 却将其直接保存在上层上下文的变量对象中。并且，JScript 居然还将 FE 以 FD 的方式处理，在进入上下文的时候就将其创建出来，并在定义之前就可以访问到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FE 保存在变量对象中</span></div><div class="line"><span class="comment">// 和FD一样，在定义前就可以通过名字访问到</span></div><div class="line">testNFE();</div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">testNFE</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'testNFE'</span>);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 同样的，在定义之后也可以通过名字访问到</span></div><div class="line">testNFE();</div></pre></td></tr></table></figure>
<p>正如大家所见，完全破坏了 FE 的规则。</p>
<p>第二，在声明同时，将 NFE 赋值给一个变量的时候，JScript 会创建两个不同的函数对象。 这种行为感觉完全不符合逻辑（特别是考虑到在 NFE 外层，其名字根本是无法访问到的）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'foo'</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">alert(<span class="keyword">typeof</span> bar); <span class="comment">// "function", NFE 在 VO 中了 – 这里就错了</span></div><div class="line"> </div><div class="line"><span class="comment">// 然后，还有更有趣的</span></div><div class="line">alert(foo === bar); <span class="comment">// false!</span></div><div class="line"> </div><div class="line">foo.x = <span class="number">10</span>;</div><div class="line">alert(bar.x); <span class="comment">// undefined</span></div><div class="line"> </div><div class="line"><span class="comment">// 然而，两个函数完全做的是同样的事情</span></div><div class="line"> </div><div class="line">foo(); <span class="comment">// "foo"</span></div><div class="line">bar(); <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<p>然而，要注意的是： 当将 NFE 和赋值给变量这两件事情分开的话（比如，通过组操作符），在定义好后，再进行变量赋值，这样，两个对象就相同了，返回true：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> foo = bar;</div><div class="line"> </div><div class="line">alert(foo === bar); <span class="comment">// true</span></div><div class="line"> </div><div class="line">foo.x = <span class="number">10</span>;</div><div class="line">alert(bar.x); <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<p>这个时候就好解释了。事实上，一开始的确创建了两个对象，不过之后就只剩下一个了。这里将 NFE 以 FD 的方式来处理，然后，当进入上下文的时候，FD <code>bar</code> 就创建出来了。 在这之后，到了执行代码阶段，又创建出了第二个对象 —— FE <code>bar</code>，该对象不会进行保存。相应的，由于没有变量对其进行引用，随后FE <code>bar</code> 对象就被移除了。 因此，这里就只剩下一个对象 —— FD <code>bar</code> 对象，对该对象的引用就赋值给了 <code>foo</code> 变量。</p>
<p>第三，通过 <code>arguments.callee</code> 对一个函数进行间接引用，它引用的是和激活函数名一致的对象（事实上是 —— 函数，因为有两个对象）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  alert([</div><div class="line">    <span class="built_in">arguments</span>.callee === foo,</div><div class="line">    <span class="built_in">arguments</span>.callee === bar</div><div class="line">  ]);</div><div class="line"> </div><div class="line">&#125;;</div><div class="line"> </div><div class="line">foo(); <span class="comment">// [true, false]</span></div><div class="line">bar(); <span class="comment">// [false, true]</span></div></pre></td></tr></table></figure>
<p>第四，JScript 会将 NFE 以 FD 来处理，但当遇到条件语句又不遵循此规则了。比如说，和 FD 那样，NFE 会在进入上下文的时候就创建出来，这样最后一次定义的就会被使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="number">1</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line"> </div><div class="line">  foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="number">2</span>);</div><div class="line">  &#125;;</div><div class="line"> </div><div class="line">&#125;</div><div class="line">bar(); <span class="comment">// 2</span></div><div class="line">foo(); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>上述行为从逻辑上也是可以解释通的：当进入上下文的时候，最后一次定义的FD <code>bar</code> 被创建出来（有 <code>alert(2)</code> 的函数），之后到了执行代码阶段又一个新的函数 —— FE <code>bar</code> 被创建出来，对其引用赋值给了变量 <code>foo</code>。因此（<code>if</code> 代码块中由于判断条件是 <code>false</code>，因此其代码块中的代码永远不会被执行到）<code>foo</code> 函数的调用会打印出 <code>1</code>。 尽管“逻辑上”是对的，但是这个仍然算是 IE 的 bug。因为它明显就破坏了实现的规则，所以我这里用了引号“逻辑上”。</p>
<p>第五个 JScript 中 NFE 的 bug 与给一个未受限的标识符赋值（也就是说，没有 <code>var</code> 关键字）来创建全局对象的属性相关。由于这里 NFE 会以 FD 的方式来处理，并相应地会保存在变量对象上，赋值给未受限的标识符（不是给变量而是给全局对象的一般属性），当函数名和标识符名字相同的时候，该属性就不会是全局的了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="comment">// 没有var，就不是局部变量，而是全局对象的属性</span></div><div class="line"> </div><div class="line">  foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"> </div><div class="line">&#125;)();</div><div class="line"> </div><div class="line"><span class="comment">// 然而，在匿名函数的外层，foo又是不可访问的</span></div><div class="line"> </div><div class="line">alert(<span class="keyword">typeof</span> foo); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>这里从“逻辑上”又是可以解释通的：进入上下文时，函数声明在匿名函数本地上下文的活跃对象中。当进入执行代码阶段的时候，因为 <code>foo</code> 这个名字已经在 AO 中存在了（本地），相应地，赋值操作也只是简单的对 AO 中的 <code>foo</code> 进行更新而已。并没有在全局对象上创建新的属性。</p>
<h3 id="通过-function-构造器创建的函数"><a href="#通过-Function-构造器创建的函数" class="headerlink" title="通过 Function 构造器创建的函数"></a>通过 Function 构造器创建的函数</h3><p>这类函数有别于 FD 和 FE，有自己的专属特性： 它们的 <code>[[Scope]]</code> 属性中只包含全局对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</div><div class="line">  <span class="keyword">var</span> y = <span class="number">30</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'alert(x); alert(y);'</span>);</div><div class="line"> </div><div class="line">  bar(); <span class="comment">// 10, "y" is not defined</span></div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到 <code>bar</code> 函数的 <code>[[Scope]]</code> 属性并未包含 <code>foo</code> 上下文的 AO —— 变量 <code>y</code> 是无法访问的，并且变量 <code>x</code> 是来自全局上下文。顺便提下，这里要注意的是，<code>Function</code> 构造器可以通过 <code>new</code> 关键字和省略 <code>new</code> 关键字两种用法。上述例子中，这两种用法都是一样的。</p>
<p>此类函数其他特性则和<a href="http://bclary.com/2004/11/07/#a-13.1.1" target="_blank" rel="external">同类语法产生式</a>以及<a href="http://bclary.com/2004/11/07/#a-13.1.2" target="_blank" rel="external">联合对象</a>有关。 该机制在规范中建议在作优化的时候采用（当然，具体的实现者也完全有权利不使用这类优化）。比方说，有个 <code>100</code> 个元素的数组，在循环数组过程中会给数组每个元素赋值（函数），这个时候，实现的时候就可以采用联合对象的机制了。这样，最终所有的数组元素都会引用同一个函数（只有一个函数）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"> </div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</div><div class="line">  a[k] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 这里就可以使用联合对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，通过 <code>Function</code> 构造器创建的函数就无法使用联合对象了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"> </div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k $lt; <span class="number">100</span>; k++) &#123;</div><div class="line">  a[k] = <span class="built_in">Function</span>(<span class="string">''</span>); <span class="comment">// 只能是100个不同的函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是另外一个和联合对象相关的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">z</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> z * z;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> x = foo();</div><div class="line"><span class="keyword">var</span> y = foo();</div></pre></td></tr></table></figure>
<p>上述例子，在实现过程中同样可以使用联合对象。来使得 <code>x</code> 和 <code>y</code> 引用同一个对象，因为函数（包括它们内部的 <code>[[Scope]]</code> 属性）物理上是不可分辨的。 因此，通过 <code>Function</code> 构造器创建的函数总是会占用更多内存资源。</p>
<h2 id="函数创建的算法"><a href="#函数创建的算法" class="headerlink" title="函数创建的算法"></a>函数创建的算法</h2><p>如下所示使用伪代码表示的函数创建的算法（不包含联合对象的步骤）。有助于理解 ECMAScript 中的函数对象。此算法对所有函数类型都是一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">F = <span class="keyword">new</span> NativeObject();</div><div class="line"> </div><div class="line"><span class="comment">// 属性 [[Class]] is "Function"</span></div><div class="line">F.[[Class]] = <span class="string">"Function"</span></div><div class="line"> </div><div class="line"><span class="comment">// 函数对象的原型</span></div><div class="line">F.[[Prototype]] = <span class="built_in">Function</span>.prototype</div><div class="line"> </div><div class="line"><span class="comment">// 对函数自身引用</span></div><div class="line"><span class="comment">// [[Call]] 在函数调用时F()激活</span></div><div class="line"><span class="comment">// 同时创建一个新的执行上下文</span></div><div class="line">F.[[Call]] = <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></div><div class="line"> </div><div class="line">// 内置的构造器</div><div class="line">// [[Construct]] 会在使用“new”关键字的时候激活</div><div class="line">// 事实上，它会为新对象申请内存</div><div class="line">// 然后调用 F.[[Call]]来初始化创建的对象，将this值设置为新创建的对象</div><div class="line">F.[[Construct]] = internalConstructor</div><div class="line"> </div><div class="line">// 当前上下文（创建函数F的上下文）的作用域名链</div><div class="line">F.[[Scope]] = activeContext.Scope</div><div class="line">// 如果是通过new Function(...)来创建的，则</div><div class="line">F.[[Scope]] = globalContext.Scope</div><div class="line"> </div><div class="line">// 形参的个数</div><div class="line">F.length = countParameters</div><div class="line"> </div><div class="line">// 通过F创建出来的对象的原型</div><div class="line">__objectPrototype = new Object();</div><div class="line">__objectPrototype.constructor = F // &#123;DontEnum&#125;, 在遍历中不能枚举</div><div class="line">F.prototype = __objectPrototype</div><div class="line"> </div><div class="line">return F</div></pre></td></tr></table></figure>
<p>要注意的是，<code>F.[[Prototype]]</code> 是函数（构造器）的原型，而 <code>F.prototype</code> 是通过该函数创建出来的对象的原型（因为通常对这两个概念都会混淆，在有些文章中会将 <code>F.prototype</code> 叫做“构造器的原型”，这是错误的）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了很多关于函数的内容；不过在后面的关于对象和原型的文章中，还会提到函数作为构造器是如何工作的。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><ol>
<li>— <a href="http://bclary.com/2004/11/07/#a-13" target="_blank" rel="external">Function Definition</a></li>
</ol>
</li>
<li>15.3 — <a href="http://bclary.com/2004/11/07/#a-15.3" target="_blank" rel="external">Function Objects</a></li>
</ul>
<p class="j-dot"><strong>Translated by:</strong> Dmitry A. Soshnikov.<br><strong>Published on:</strong> 2010-04-05<br><br><strong>Originally written by:</strong> Dmitry A. Soshnikov [ru, <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-5-functions/" target="_blank" rel="external">read »</a>]<br><strong>Originally published on:</strong> 2009-07-08</p></section><footer class="article-footer clearfix"><div class="categories"><a href="/categories/javascript/" title="JavaScript">JavaScript</a></div><div class="tags"><a href="/tags/ecmascript/" title="ECMAScript">ECMAScript</a> <a href="/tags/ecma-262-3/" title="ECMA-262-3">ECMA-262-3</a> <a href="/tags/function/" title="function">function</a></div></footer></div><nav class="article-nav clearfix"><a href="/2014/06/15/ecma-262-3-in-detail-chapter-6-closures/" class="article-nav-link article-nav-newer"><strong class="article-nav-type">Newer</strong><span class="article-nav-title">ECMA-262-3 详解 第六章 闭包</span></a><a href="/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/" class="article-nav-link article-nav-older"><strong class="article-nav-type">Older</strong><span class="article-nav-title">ECMA-262-3 详解 第四章 作用域链</span></a></nav></article><section id="article-comment" class="article-comment"><div data-thread-key="http://bubkoo.com/2014/06/12/ecma-262-3-in-detail-chapter-5-functions/" data-title="ECMA-262-3 详解 第五章 函数" data-url="http://bubkoo.com/2014/06/12/ecma-262-3-in-detail-chapter-5-functions/" class="ds-thread"></div></section></div><aside id="sidebar" role="sidebar"><div class="widget tagcloud"><h3 class="widget-title">标签</h3><div class="widget-content"><a href="/tags/aop/" style="font-size: 10px">AOP</a> <a href="/tags/algorithm/" style="font-size: 18.33px">Algorithm</a> <a href="/tags/analysis/" style="font-size: 10px">Analysis</a> <a href="/tags/angularjs/" style="font-size: 15px">AngularJS</a> <a href="/tags/animation/" style="font-size: 10px">Animation</a> <a href="/tags/architecture/" style="font-size: 16.67px">Architecture</a> <a href="/tags/archives/" style="font-size: 10.83px">Archives</a> <a href="/tags/async/" style="font-size: 12.5px">Async</a> <a href="/tags/backbone/" style="font-size: 10px">Backbone</a> <a href="/tags/browsers/" style="font-size: 10px">Browsers</a> <a href="/tags/css/" style="font-size: 12.5px">CSS</a> <a href="/tags/css3/" style="font-size: 10px">CSS3</a> <a href="/tags/closure/" style="font-size: 10.83px">Closure</a> <a href="/tags/closures/" style="font-size: 10px">Closures</a> <a href="/tags/cookies/" style="font-size: 10px">Cookies</a> <a href="/tags/cross-domain/" style="font-size: 10px">Cross Domain</a> <a href="/tags/custom-elements/" style="font-size: 10.83px">Custom Elements</a> <a href="/tags/d3/" style="font-size: 10px">D3</a> <a href="/tags/debounce/" style="font-size: 10px">Debounce</a> <a href="/tags/debug/" style="font-size: 10.83px">Debug</a> <a href="/tags/dependency/" style="font-size: 10px">Dependency</a> <a href="/tags/document/" style="font-size: 10px">Document</a> <a href="/tags/ecma-262-3/" style="font-size: 15.83px">ECMA-262-3</a> <a href="/tags/ecmascript/" style="font-size: 15.83px">ECMAScript</a> <a href="/tags/es6/" style="font-size: 20px">ES6</a> <a href="/tags/errors/" style="font-size: 10px">Errors</a> <a href="/tags/essential/" style="font-size: 10px">Essential</a> <a href="/tags/evaluation-strategy/" style="font-size: 10px">Evaluation strategy</a> <a href="/tags/event/" style="font-size: 10px">Event</a> <a href="/tags/exceptions/" style="font-size: 10px">Exceptions</a> <a href="/tags/express/" style="font-size: 10px">Express</a> <a href="/tags/flip/" style="font-size: 10px">FLIP</a> <a href="/tags/flexbox/" style="font-size: 10px">Flexbox</a> <a href="/tags/funarg/" style="font-size: 10px">Funarg</a> <a href="/tags/gist/" style="font-size: 10px">Gist</a> <a href="/tags/github/" style="font-size: 10px">Github</a> <a href="/tags/guide/" style="font-size: 10px">Guide</a> <a href="/tags/html/" style="font-size: 10px">HTML</a> <a href="/tags/http/" style="font-size: 10px">HTTP</a> <a href="/tags/hexo/" style="font-size: 10.83px">Hexo</a> <a href="/tags/ie/" style="font-size: 10px">IE</a> <a href="/tags/iife/" style="font-size: 10px">IIFE</a> <a href="/tags/jshint/" style="font-size: 10px">JSHint</a> <a href="/tags/javascript/" style="font-size: 19.17px">JavaScript</a> <a href="/tags/leak/" style="font-size: 10px">Leak</a> <a href="/tags/linting/" style="font-size: 10px">Linting</a> <a href="/tags/mvc/" style="font-size: 10px">MVC</a> <a href="/tags/methodology/" style="font-size: 10px">Methodology</a> <a href="/tags/mock/" style="font-size: 10px">Mock</a> <a href="/tags/modular/" style="font-size: 10px">Modular</a> <a href="/tags/mongodb/" style="font-size: 10px">MongoDB</a> <a href="/tags/oop/" style="font-size: 10.83px">OOP</a> <a href="/tags/partial-application/" style="font-size: 10px">Partial Application</a> <a href="/tags/pattern/" style="font-size: 10px">Pattern</a> <a href="/tags/patterns/" style="font-size: 10px">Patterns</a> <a href="/tags/performance/" style="font-size: 14.17px">Performance</a> <a href="/tags/promise/" style="font-size: 13.33px">Promise</a> <a href="/tags/prototype/" style="font-size: 11.67px">Prototype</a> <a href="/tags/quality/" style="font-size: 10px">Quality</a> <a href="/tags/quiz/" style="font-size: 10px">Quiz</a> <a href="/tags/regex/" style="font-size: 10px">Regex</a> <a href="/tags/requirejs/" style="font-size: 10px">RequireJS</a> <a href="/tags/sass/" style="font-size: 10px">SASS</a> <a href="/tags/svg/" style="font-size: 10px">SVG</a> <a href="/tags/scope/" style="font-size: 10.83px">Scope</a> <a href="/tags/shapes/" style="font-size: 10px">Shapes</a> <a href="/tags/shuffle/" style="font-size: 10px">Shuffle</a> <a href="/tags/sort/" style="font-size: 17.5px">Sort</a> <a href="/tags/source-map/" style="font-size: 10.83px">Source Map</a> <a href="/tags/styling/" style="font-size: 10px">Styling</a> <a href="/tags/sublime-text/" style="font-size: 10px">Sublime Text</a> <a href="/tags/template/" style="font-size: 10px">Template</a> <a href="/tags/throttle/" style="font-size: 10px">Throttle</a> <a href="/tags/timing/" style="font-size: 10px">Timing</a> <a href="/tags/tools/" style="font-size: 12.5px">Tools</a> <a href="/tags/variable-object/" style="font-size: 10px">Variable object</a> <a href="/tags/visualizations/" style="font-size: 10px">Visualizations</a> <a href="/tags/when/" style="font-size: 12.5px">When</a> <a href="/tags/delete/" style="font-size: 10px">delete</a> <a href="/tags/execution-context/" style="font-size: 10px">execution context</a> <a href="/tags/fetch/" style="font-size: 10px">fetch</a> <a href="/tags/function/" style="font-size: 10px">function</a> <a href="/tags/nodejs/" style="font-size: 10px">nodejs</a> <a href="/tags/nodemon/" style="font-size: 10px">nodemon</a> <a href="/tags/npm/" style="font-size: 10px">npm</a> <a href="/tags/nvm/" style="font-size: 10px">nvm</a> <a href="/tags/performance/" style="font-size: 10px">performance</a> <a href="/tags/prebrowsing/" style="font-size: 10px">prebrowsing</a> <a href="/tags/prefetching/" style="font-size: 10px">prefetching</a> <a href="/tags/preloading/" style="font-size: 10px">preloading</a> <a href="/tags/tabindex/" style="font-size: 10px">tabindex</a> <a href="/tags/this/" style="font-size: 10px">this</a> <a href="/tags/ui-router/" style="font-size: 14.17px">ui-router</a></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/01/18/debouncing-throttling-explained-examples/">实例解析防抖和节流函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/08/quick-tip-multiple-versions-node-nvm/">使用 nvm 管理不同版本的 node 与 npm</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/08/15-ways-to-write-self-documenting-javascript/">如何编写更加自解释的代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/31/high-performance-animations/">使用 FLIP 来提高 Web 动画的性能</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/28/styling-broken-images/">定制图片加载失败时的样式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/26/delivering-octicons-with-svg/">使用 SVG 输出 Octicon</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/18/how-to-use-npm-as-a-build-tool/">如何将 npm 作为构建工具使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/what-you-can-do-with-gists-on-github/">任何人都可以使用到的 Gist 服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/19/prefetching-preloading-prebrowsing/">前端性能优化 - 资源预加载</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/18/es6-in-depth-the-future/">深入解析 ES6：未来展望</a></li></ul></div></div></aside><aside id="topic-wrap" class="toc-wrap f-right"><h3 class="toc-wrap-title">内容</h3><div class="toc-tree"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数类型"><span class="toc-number">2.</span> <span class="toc-text">函数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数声明function-declaration"><span class="toc-number">2.1.</span> <span class="toc-text">函数声明（Function Declaration）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数表达式function-expression"><span class="toc-number">2.2.</span> <span class="toc-text">函数表达式（Function Expression）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#有关括号的问题"><span class="toc-number">2.2.1.</span> <span class="toc-text">“有关括号”的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现扩展函数语句"><span class="toc-number">2.2.2.</span> <span class="toc-text">实现扩展：函数语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名函数表达式nfe的特性"><span class="toc-number">2.2.3.</span> <span class="toc-text">命名函数表达式（NFE）的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nfe-和-spidermonkey"><span class="toc-number">2.2.4.</span> <span class="toc-text">NFE 和 SpiderMonkey</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nfe-和-jscript"><span class="toc-number">2.2.5.</span> <span class="toc-text">NFE 和 JScript</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过-function-构造器创建的函数"><span class="toc-number">2.3.</span> <span class="toc-text">通过 Function 构造器创建的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数创建的算法"><span class="toc-number">3.</span> <span class="toc-text">函数创建的算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">5.</span> <span class="toc-text">扩展阅读</span></a></li></ol></div><div class="toc-progress"></div></aside></div><footer id="footer" class="inner"><span class="copyright">© 2017 bubkoo</span><span class="theme">@<a href="https://github.com/bubkoo/hexo-theme-formula" target="_blank">formula</a></span></footer><img id="go2top" src="/images/top_arrow.png" alt="go2top"><script charset="utf-8" src="/js/lib/jquery-2.1.3.min.js"></script><script charset="utf-8" src="/js/lib/jquery.imagesloaded.min.js"></script><script charset="utf-8" src="/fancybox/jquery.fancybox.pack.js"></script><script charset="utf-8" src="/js/lib/sea.js"></script><script charset="utf-8" src="/js/main.js"></script><script id="redundancy3">var duoshuoQuery = { short_name: 'bubkoo' };
(function () {
  var ds = document.createElement('script');

  ds.type    = 'text/javascript';
  ds.async   = true;
  ds.src     = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';

  (document.getElementsByTagName('head')[0]
  || document.getElementsByTagName('body')[0]).appendChild(ds);

  ds.parentNode.removeChild(ds);

  var script = document.getElementById('redundancy3');
  script && script.parentNode.removeChild(script);
})();</script></body></html>
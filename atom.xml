<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bubkoo</title>
  <icon>https://www.gravatar.com/avatar/c6a531a6e39f97f96546f58c0aa49557</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bubkoo.com/"/>
  <updated>2017-09-21T12:30:42.000Z</updated>
  <id>http://bubkoo.com/</id>
  
  <author>
    <name>bubkoo</name>
    <email>bubkoo@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 框架新轮子：Mickey</title>
    <link href="http://bubkoo.com/2017/09/21/react-framework-mickey/"/>
    <id>http://bubkoo.com/2017/09/21/react-framework-mickey/</id>
    <published>2017-09-21T12:30:42.000Z</published>
    <updated>2017-09-21T12:30:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/mickeyjsx/mickey" target="_blank" rel="external">Mickey</a> 是一款基于 <a href="https://facebook.github.io/react/" target="_blank" rel="external">react</a>、<a href="https://github.com/reactjs/redux" target="_blank" rel="external">redux</a>、<a href="https://github.com/yelouafi/redux-saga" target="_blank" rel="external">redux-saga</a> 和 <a href="https://github.com/ReactTraining/react-router" target="_blank" rel="external">react-router</a> 的轻量前端框架，其大部分思路借鉴了 <a href="https://github.com/dvajs/dva" target="_blank" rel="external">dva</a>，提供了更方便的 model 设计思路和更简单的 <a href="http://redux.js.org/docs/basics/Actions.html" target="_blank" rel="external">actions</a> 管理方案。</p><a id="more"></a><h2><span id="为什么">为什么</span></h2><p>基于 redux 的应用避免不了大量的<a href="https://github.com/reactjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md" target="_blank" rel="external">样板代码</a>，还要维护大量的 action-type <a href="http://redux.js.org/docs/basics/Actions.html" target="_blank" rel="external">常量字符串</a>，这些都是低效和重复的劳动。<a href="https://github.com/dvajs/dva" target="_blank" rel="external">dva</a> 基于 elm 概念，通过 <code>reducers</code>, <code>effects</code> 和 <code>subscriptions</code> 来组织 model，在减少样本代码层面前进了一大步：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  namespace: <span class="string">'xxx'</span>,  <span class="comment">// 命名空间，规定了 store 的结构</span></div><div class="line">  subscriptions:&#123;&#125;,  <span class="comment">// 事件订阅，将在 model 被加载时调用</span></div><div class="line">  state: &#123;&#125;,         <span class="comment">// 初始状态</span></div><div class="line">  effects: &#123;&#125;,       <span class="comment">// 处理异步 action</span></div><div class="line">  reducers: &#123;&#125;,      <span class="comment">// 处理同步 action</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>看一个更接近实际的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  namespace: <span class="string">'users'</span>,</div><div class="line">  </div><div class="line">  state: &#123;</div><div class="line">    items: [],</div><div class="line">    loading: <span class="literal">false</span>,</div><div class="line">  &#125;,</div><div class="line"> </div><div class="line">  effects: &#123;</div><div class="line">    *query (&#123; payload = &#123;&#125; &#125;, &#123; call, put &#125;) &#123;</div><div class="line">      <span class="keyword">const</span> &#123; response, error &#125; = <span class="keyword">yield</span> call(queryUser, payload); </div><div class="line">      <span class="keyword">if</span> (response) &#123;</div><div class="line">        <span class="keyword">yield</span> put(&#123;</div><div class="line">          type: <span class="string">'querySuccess'</span>,</div><div class="line">          payload: response.data,</div><div class="line">        &#125;)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">yield</span> put(&#123;</div><div class="line">          type: <span class="string">'queryFailed'</span>,</div><div class="line">        &#125;)</div><div class="line">  &#125;</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  reducers: &#123;</div><div class="line">    query: <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; ...state, <span class="attr">loading</span>: <span class="literal">true</span> &#125;),</div><div class="line">    queryFailed: <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; ...state, <span class="attr">loading</span>: <span class="literal">false</span> &#125;),</div><div class="line">    querySuccess: <span class="function">(<span class="params">state, &#123; payload &#125;</span>) =&gt;</span> (&#123;</div><div class="line">      ...state,</div><div class="line">  items: payload,</div><div class="line">  loading: <span class="literal">false</span>,</div><div class="line">&#125;),</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>仔细看上面代码，对一个异步 action 处理通常会经历以下几步：</p><ol><li>在 <code>effects</code> 中设计异步 action 处理方法：<code>*query</code></li><li>在 <code>reducers</code> 中设计对应的同步 action 处理方法：<code>query</code>，这里我们将 UI 状态置为 loading</li><li>异步接口调用成功后通常会分成功和失败两种情况分别触发 <code>querySuccess</code> 和 <code>queryFailed</code> 两个同步的 action</li></ol><p>实际项目中 model 可能会更<a href="https://github.com/zuiidea/antd-admin/blob/master/src/models/user.js" target="_blank" rel="external">复杂</a> ，需要在 model 的 <code>effects</code> 和 <code>reducers</code> 两个大结构中<strong>跳转编辑</strong>才能完成对一个异步 action 的处理，也就是说，我们需要先在 <code>effects</code> 完成 <code>*query()</code> 的逻辑，然后在 <code>reducers</code> 中完成 <code>query()</code>、<code>querySuccess()</code> 和 <code>queryFailed()</code> 三个同步 reducer。这样的跳转使编写代码、阅读代码和排查问题都非常不便。</p><h3><span id="就近原则">就近原则</span></h3><p>我们都知道，相同逻辑或者相关的代码放在一起是模块化思路之一。同理，对于一个异步 action 的所有处理属于强相关代码，在 Mickey 中可以这样来实现上面的 model：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  namespace: <span class="string">'users'</span>,</div><div class="line">  state: &#123; &#125;,</div><div class="line">  query: &#123;</div><div class="line">    * effect() &#123; &#125;, <span class="comment">// 处理 query 的异步逻辑</span></div><div class="line">    prepare() &#123; &#125;,  <span class="comment">// 异步请求前的准备工作，如置 loading</span></div><div class="line">    success() &#123; &#125;,  <span class="comment">// 请求成功</span></div><div class="line">    failed() &#123; &#125;,   <span class="comment">// 请求失败</span></div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对上面 <code>query</code> 的结构有几点说明：</p><ul><li>包含不超过 1 个异步处理方法，<strong>方法名随意</strong></li><li>可以包含任意个同步处理处理方法，<code>prepare</code> 这个方法名固定</li><li><code>dispatch({type: &#39;users/query&#39;})</code> 时，将同时触发 <code>*effect</code> 和 <code>prepare</code>，所以这两个方法需要在上面的结构中<strong>至少出现一个</strong></li><li>除 <code>effect</code> 和 <code>prepare</code> 其他两个方法 <code>success</code> 和 <code>failed</code> 可以统称为<strong>回调方法</strong>，回调方法的方法名和数量都随意</li></ul><h3><span id="不修改原生api">不修改原生API</span></h3><p>dva 对 saga 的 <code>put</code> 方法和 store 的 <code>dispatch</code> 方法做了重新封装，封装的思路是自动判断和添加 <code>namespace</code>，如上面示例中的 <code>put({type: &#39;querySuccess&#39;})</code>。</p><p>如果没有这层封装会不会更好呢？一方面不会给开发者带去理解上的困难，另一方面也保证的原生 API 的纯净。但是，如果没有这层封装每次在 model 内部调用 <code>put</code> 或 <code>dispatch</code> 就非常麻烦，必须指定完整的命名空间。</p><p>在上一节中提到，在 model 中除了 <code>*effect</code> 和 <code>prepare</code> 之外的方法我们统称为回调，这些回调方法通常会在异步请求完成之后之后通过 <code>put</code> 一个 action 来触发，既然这样我们何不直接将这些回调方法的名称作为 <code>*effect</code> 的参数，在 <code>*effect</code> 内部就可以直接调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  namespace: <span class="string">'users'</span>,</div><div class="line">  state: &#123; </div><div class="line">  items: [],</div><div class="line">loading: <span class="literal">false</span>,</div><div class="line">  &#125;,</div><div class="line">  query: &#123;</div><div class="line">    * effect(payload, &#123; call &#125;, &#123; success, failed &#125;) &#123; </div><div class="line">      <span class="keyword">const</span> &#123; response, error &#125; = <span class="keyword">yield</span> call(queryUser, payload); </div><div class="line">  <span class="keyword">if</span> (response) &#123;</div><div class="line"><span class="keyword">yield</span> success(response.data);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">yield</span> failed();</div><div class="line">  &#125;</div><div class="line">    &#125;, </div><div class="line">    prepare: <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; ...state, <span class="attr">loading</span>: <span class="literal">true</span> &#125;),</div><div class="line">    failed: <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; ...state,, <span class="attr">loading</span>: <span class="literal">false</span> &#125;),</div><div class="line">    success: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> (&#123; ...state, <span class="attr">items</span>: payload, <span class="attr">loading</span>: <span class="literal">false</span> &#125;),</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过在 <code>*effect</code> 方法中注入回调函数，不仅不需要修改原生 <code>dispatch</code> 和 <code>put</code> 的行为，同时不再需要关心和维护 action-type <a href="http://redux.js.org/docs/basics/Actions.html" target="_blank" rel="external">常量字符串</a>。</p><p>在 Mickey 中 <code>*effect</code> 方法的完整签名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*effect (payload, sagaEffects, callbacks, innerActions, actions) &#123; &#125;</div></pre></td></tr></table></figure><p>同步 action 处理方法签名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">someName(state, payload) &#123; <span class="keyword">return</span> newState &#125;</div></pre></td></tr></table></figure><p>对比原生 reducer 方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">someName(state, action) &#123; <span class="keyword">return</span> newState &#125;</div></pre></td></tr></table></figure></p><p>区别在于方法的第二个参数，正是由于我们不再需要关心和维护 action-type 字符串，所以在 mickey 中直接使用了 <code>payload</code> 作为第二个参数。</p><h2><span id="完整示例">完整示例</span></h2><p>看下面计数器的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> createApp, &#123;connect, injectActions&#125; <span class="keyword">from</span> <span class="string">'mickey'</span></div><div class="line"></div><div class="line"><span class="comment">// 1. Initialize</span></div><div class="line"><span class="keyword">const</span> app = createApp()</div><div class="line"></div><div class="line"><span class="comment">// 2. Model</span></div><div class="line">app.model(&#123;</div><div class="line">  namespace: <span class="string">'counter'</span>,</div><div class="line">  state: &#123;</div><div class="line">    count: <span class="number">0</span>,</div><div class="line">    loading: <span class="literal">false</span>,</div><div class="line">  &#125;,</div><div class="line">  increment: <span class="function"><span class="params">state</span> =&gt;</span> (&#123; ...state, <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;),</div><div class="line">  decrement: <span class="function"><span class="params">state</span> =&gt;</span> (&#123; ...state, <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;),</div><div class="line">  incrementAsync: &#123;</div><div class="line">    * effect(payload, &#123; call &#125;, &#123; succeed &#125;) &#123;</div><div class="line">      <span class="keyword">const</span> delay = <span class="function"><span class="params">timeout</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(resolve, timeout)</div><div class="line">      &#125;)</div><div class="line">      <span class="keyword">yield</span> call(delay, <span class="number">2000</span>)</div><div class="line">      <span class="keyword">yield</span> succeed()</div><div class="line">    &#125;,</div><div class="line">    prepare: <span class="function"><span class="params">state</span> =&gt;</span> (&#123; ...state, <span class="attr">loading</span>: <span class="literal">true</span> &#125;),</div><div class="line">    succeed: <span class="function"><span class="params">state</span> =&gt;</span> (&#123; ...state, <span class="attr">count</span>: state.count + <span class="number">1</span>, <span class="attr">loading</span>: <span class="literal">false</span> &#125;),</div><div class="line">  &#125;,</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 3. Component</span></div><div class="line"><span class="keyword">const</span> Comp = <span class="function">(<span class="params">props</span>) =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;h1&gt;&#123;props.counter.count&#125;&lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">    &lt;button onClick=&#123;() =&gt; props.actions.counter.decrement()&#125;&gt;-&lt;/</span>button&gt;</div><div class="line">    &lt;button onClick=&#123;() =&gt; props.actions.counter.increment()&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></div><div class="line">    &lt;button onClick=&#123;() =&gt; props.actions.counter.incrementAsync()&#125;&gt;+ Async&lt;<span class="regexp">/button&gt;</span></div><div class="line"><span class="regexp">  &lt;/</span>div&gt;</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 4. Connect state with component and inject `actions`</span></div><div class="line"><span class="keyword">const</span> App = injectActions(</div><div class="line">    connect(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">counter</span>: state.counter &#125;)(Comp)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 5. View</span></div><div class="line">app.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'))</span></div></pre></td></tr></table></figure><h2><span id="更多示例">更多示例</span></h2><ul><li><a href="https://github.com/mickeyjsx/mickey/blob/master/examples/counter" target="_blank" rel="external">Counter</a>：简单的计数器</li><li><a href="https://github.com/mickeyjsx/mickey/blob/master/examples/counter-persist" target="_blank" rel="external">Counter-Persist</a>：搭配 <a href="https://github.com/rt2zz/redux-persist" target="_blank" rel="external">redux-persist</a> 使用</li><li><a href="https://github.com/mickeyjsx/mickey/blob/master/examples/counter-immutable" target="_blank" rel="external">Counter-Immutable</a>：搭配 <a href="https://github.com/facebook/immutable-js/" target="_blank" rel="external">ImmutableJS</a> 使用</li><li><a href="https://github.com/mickeyjsx/mickey/blob/master/examples/counter-persist-immutable" target="_blank" rel="external">Counter-Persist-Immutable</a>：搭配 <a href="https://github.com/rt2zz/redux-persist" target="_blank" rel="external">redux-persist</a> 和 <a href="https://github.com/facebook/immutable-js/" target="_blank" rel="external">ImmutableJS</a> 使用</li><li><a href="https://github.com/mickeyjsx/mickey/blob/master/examples/counter-undo" target="_blank" rel="external">Counter-Undo</a>：搭配 <a href="https://github.com/omnidan/redux-undo" target="_blank" rel="external">redux-undo</a> 使用</li><li><a href="https://github.com/mickeyjsx/mickey/blob/master/docs/zh-CN/examples/simple-router" target="_blank" rel="external">Simple-Router</a>：基于 <a href="https://reacttraining.com/react-router/" target="_blank" rel="external">react-router@4.x</a></li><li><a href="https://github.com/mickeyjsx/mickey-todo" target="_blank" rel="external">mickey-todo</a> (<a href="https://mickeyjsx.github.io/todo" target="_blank" rel="external">demo</a>): 简单的 TODO 应用</li><li><a href="https://github.com/mickeyjsx/mickey-vstar" target="_blank" rel="external">mickey-vstar</a> (<a href="http://mickeyjsx.github.io/vstar" target="_blank" rel="external">demo</a>)：查询指定 Github 账号中被加星项目并按加星数排序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/mickeyjsx/mickey&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mickey&lt;/a&gt; 是一款基于 &lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;react&lt;/a&gt;、&lt;a href=&quot;https://github.com/reactjs/redux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;redux&lt;/a&gt;、&lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;redux-saga&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/ReactTraining/react-router&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;react-router&lt;/a&gt; 的轻量前端框架，其大部分思路借鉴了 &lt;a href=&quot;https://github.com/dvajs/dva&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dva&lt;/a&gt;，提供了更方便的 model 设计思路和更简单的 &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;actions&lt;/a&gt; 管理方案。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="React" scheme="http://bubkoo.com/tags/react/"/>
    
      <category term="Framework" scheme="http://bubkoo.com/tags/framework/"/>
    
      <category term="Mickey" scheme="http://bubkoo.com/tags/mickey/"/>
    
  </entry>
  
  <entry>
    <title>实例解析防抖和节流函数</title>
    <link href="http://bubkoo.com/2017/01/18/debouncing-throttling-explained-examples/"/>
    <id>http://bubkoo.com/2017/01/18/debouncing-throttling-explained-examples/</id>
    <published>2017-01-18T15:52:45.000Z</published>
    <updated>2017-01-18T15:52:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>防抖（<strong>Debounce</strong>）和节流（<strong>Throttle</strong>）都是用来控制某个函数在一定时间内执行多少次的技巧，两者即相似又不同。</p><p>我们无法直接控制 DOM 事件触发频率，但我们可以在事件绑定和函数执行之间加一个控制层，所以当我们绑定 DOM 事件的时候，加上防抖或节流的函数变得特别有用。</p><a id="more"></a><p>看下面滚动事件的例子：</p><iframe src="//codepen.io/dcorb/embed/PZOZgB?height=320&theme-id=1&slug-hash=PZOZgB&default-tab=result&user=dcorb" scrolling="no" frameborder="0" width="100%" height="320" allowtransparency="true"></iframe><p>当使用触控板，滚动滚轮，或者拖拽滚动条的时候，一秒就可以触发 <code>30</code> 次事件。经测试，在移动设备上轻轻滚动一下，一秒可以触发 <code>100</code> 次之多。这么高的执行频率是你期待的吗？</p><p>早在 2011 年，Twitter 就出现了一个问题：当向下滚动页面的时候，页面会变得很卡顿。John Resig 发表了<a href="http://ejohn.org/blog/learning-from-twitter" target="_blank" rel="external">一篇博客</a>解释这个问题，文中指出了问题的根源在于绑定的 <code>onScroll</code> 事件回调开销巨大。John 建议的解决方案是，在 <code>onScroll</code> 回调中，每间隔 <code>250ms</code> 才执行一次。就这样一个简单的优化，避免了影响用户体验。</p><h2><span id="防抖-debounce">防抖 Debounce</span></h2><p>防抖技术可以把多个调用合并成一次。</p><p>想象一下，当电梯门快要关闭的时候，突然有人准备上来，此时电梯并没有改变楼层，而是再次打开电梯门，电梯延迟了改变楼层的功能，但是优化了资源。</p><p>直观感受一下面的例子：</p><iframe src="//codepen.io/dcorb/embed/KVxGqN?height=360&theme-id=1&slug-hash=KVxGqN&default-tab=result&user=dcorb" scrolling="no" frameborder="0" width="100%" height="360" allowtransparency="true"></iframe><h3><span id="提前触发">提前触发</span></h3><p>在前面例子中，debounce 回调都是在事件停止频繁触发一定时间后才执行：</p><p><img src="http://bubkoo.qiniudn.com/images/debounce.png" alt=""></p><p>我们可以使回调在第一次触发事件的时候就执行，直到停止频繁触发并等待一定时间后才可能执行下一次回调，在类似不小心点了提交按钮两下而提交了两次的情况下很有用：</p><p><img src="http://bubkoo.qiniudn.com/images/debounce-leading.png" alt=""></p><p>在 underscore 中，对应的选项叫 <code>immediate</code>：</p><iframe src="//codepen.io/dcorb/embed/GZWqNV?height=360&theme-id=1&slug-hash=GZWqNV&default-tab=result&user=dcorb" scrolling="no" frameborder="0" width="100%" height="360" allowtransparency="true"></iframe><h3><span id="调整窗口大小">调整窗口大小</span></h3><p>调整桌面浏览器窗口大小的时候，会触发很多次 <code>resize</code> 事件：</p><iframe src="//codepen.io/dcorb/embed/XXPjpd?height=300&theme-id=1&slug-hash=XXPjpd&default-tab=result&user=dcorb" scrolling="no" frameborder="0" width="100%" height="300" allowtransparency="true"></iframe><h3><span id="通过-keypress-触发的自动完成功能">通过 keypress 触发的自动完成功能</span></h3><p>直到用户输入完成之后，才向服务器发送一次 AJAX 请求，相似的使用场景还有，直到用户输完，才验证输入的正确性，显示错误信息等。</p><iframe src="//codepen.io/dcorb/embed/mVGVOL?height=200&theme-id=1&slug-hash=mVGVOL&default-tab=result&user=dcorb" scrolling="no" frameborder="0" width="100%" height="200" allowtransparency="true"></iframe><h2><span id="节流throttle">节流（Throttle）</span></h2><p>只允许一个函数在 <code>x</code> 毫秒内执行一次，跟 debounce 主要的不同在于，throttle 保证 <code>x</code> 毫秒内至少执行一次。</p><p>例如，我们需要在用户向下滚动滚动页面时，检查滚动位置距底部多远，当邻近底部时就需要发送 AJAX 请求获取更多的数据插入到页面中。此时，debounce 就不适用了，因为只有当用户停止滚动的时候它才会触发。使用 throttle 可以保证我们不断检查距离底部有多远。</p><iframe src="//codepen.io/dcorb/embed/eJLMxa?height=607&theme-id=1&slug-hash=eJLMxa&default-tab=result&user=dcorb" scrolling="no" frameborder="0" width="100%" height="607" allowtransparency="true"></iframe><h2><span id="使用-debounce-和-throttle-以及常见的坑">使用 debounce 和 throttle 以及常见的坑</span></h2><p>自己造一个 debounce/throttle 的轮子看起来很诱人，或者随便找个博文复制过来。我是建议直接使用 underscore 或 lodash 。如果仅需要 <code>_.debounce</code> 或 <code>_.throttle</code> 方法，可以使用 lodash 的自定义构建工具，生成一个 <code>2KB</code> 的压缩库。使用以下的简单命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm i -g lodash-cli</div><div class="line">lodash-cli include=debounce,throttle</div></pre></td></tr></table></figure><p>常见的坑是，不止一次地调用 <code>_.debounce</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误</span></div><div class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   _.debounce(doSomething, <span class="number">300</span>); </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 正确</span></div><div class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, _.debounce(doSomething, <span class="number">200</span>));</div></pre></td></tr></table></figure><p>取消执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> debounced_version = _.debounce(doSomething, <span class="number">200</span>);</div><div class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, debounced_version);</div><div class="line"></div><div class="line"><span class="comment">// 如果需要的话</span></div><div class="line">debounced_version.cancel();</div></pre></td></tr></table></figure><h2><span id="requestanimationframe">requestAnimationFrame</span></h2><p>requestAnimationFrame 是另一种限速（节流）方式，与 <code>_.throttle(dosomething, 16)</code> 等价，可以使用 rAF API 替换 throttle 方法，对比一下优缺点：</p><p><strong>优点：</strong></p><ul><li>动画保持 60fps（每一帧 16 ms），浏览器内部决定渲染的最佳时机</li><li>简洁标准的 API，后期维护成本低</li></ul><p><strong>缺点：</strong></p><ul><li>动画的开始/取消需要开发者自己控制，不像<code>_.debounce</code>或<code>_.throttle</code>由函数内部处理</li><li>页面所在的浏览器 Tab 未激活时，一切都不会执行</li><li>尽管所有的现代浏览器都<a href="http://caniuse.com/#feat=requestanimationframe" target="_blank" rel="external">支持 rAF</a>，IE9，Opera Mini 和 老的 Android 还是需要<a href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="external">打补丁</a></li><li>NodeJS 不支持，无法在服务器端用于文件系统事件</li></ul><p>下面示例的灵感来自于 <a href="http://www.html5rocks.com/en/tutorials/speed/animations/" target="_blank" rel="external">Paul Lewis 的文章</a>，我们用 requestAnimationFrame 控制 scroll，然后与<code>16ms</code>的<code>_.throttle</code>做对比；两者性能相仿，对于更复杂的场景，rAF 可能效果更佳。</p><iframe src="//codepen.io/dcorb/embed/pgOKKw?height=330&theme-id=1&slug-hash=pgOKKw&default-tab=result&user=dcorb" scrolling="no" frameborder="0" width="100%" height="330" allowtransparency="true"></iframe><h2><span id="结论">结论</span></h2><p>使用 debounce，throttle 和 requestAnimationFrame 都可以优化事件处理：</p><ul><li><strong>debounce</strong> 把触发非常频繁的事件（比如按键）合并成一次执行</li><li><strong>throttle</strong> 保证每<code>x</code>毫秒恒定的执行次数，比如每<code>200ms</code>检查下滚动位置，并触发页面加载</li><li><strong>requestAnimationFrame</strong> 可替代 throttle，函数需要重新计算和渲染屏幕上的元素时，想保证动画或变化的平滑性，可以用它。注意：IE9 不支持</li></ul><p class="j-quote"><br>原文：<a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="external">Debouncing and Throttling Explained Through Examples</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;防抖（&lt;strong&gt;Debounce&lt;/strong&gt;）和节流（&lt;strong&gt;Throttle&lt;/strong&gt;）都是用来控制某个函数在一定时间内执行多少次的技巧，两者即相似又不同。&lt;/p&gt;
&lt;p&gt;我们无法直接控制 DOM 事件触发频率，但我们可以在事件绑定和函数执行之间加一个控制层，所以当我们绑定 DOM 事件的时候，加上防抖或节流的函数变得特别有用。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Debounce" scheme="http://bubkoo.com/tags/debounce/"/>
    
      <category term="Throttle" scheme="http://bubkoo.com/tags/throttle/"/>
    
  </entry>
  
  <entry>
    <title>使用 nvm 管理不同版本的 node 与 npm</title>
    <link href="http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/"/>
    <id>http://bubkoo.com/2017/01/08/quick-tip-multiple-versions-node-nvm/</id>
    <published>2017-01-08T23:19:39.000Z</published>
    <updated>2017-01-08T23:19:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 NodeJS 运行环境。如果没有一个合适的工具，这个问题将非常棘手。</p><p><a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a> 应运而生，nvm 是 Mac 下的 node 管理工具，有点类似管理 Ruby 的 rvm，如果需要管理 Windows 下的 node，官方推荐使用 <a href="https://github.com/hakobera/nvmw" target="_blank" rel="external">nvmw</a> 或 <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="external">nvm-windows</a>。不过，nvm-windows 并不是 nvm 的简单移植，他们也没有任何关系。但下面介绍的所有命令，都可以在 nvm-windows 中运行。</p><a id="more"></a><h2><span id="nvm-与-n-的区别">nvm 与 n 的区别</span></h2><p>node 版本管理工具还有一个是 TJ大神的 <a href="https://github.com/tj/n" target="_blank" rel="external">n</a> 命令，n 命令是作为一个 node 的模块而存在，而 nvm 是一个独立于 node/npm 的外部 shell 脚本，因此 n 命令相比 nvm 更加局限。</p><p>由于 npm 安装的模块路径均为 <code>/usr/local/lib/node_modules</code>，当使用 n 切换不同的 node 版本时，实际上会共用全局的 node/npm 目录。 因此不能很好的满足『按不同 node 版本使用不同全局 node 模块』的需求。</p><h2><span id="卸载全局安装的-nodenpm">卸载全局安装的 node/npm</span></h2><p>在官网下载的 node 安装包，运行后会自动安装在全局目录，使用过程中经常会遇到一些<strong>权限问题</strong>，所以推荐按照以下方法卸载全局安装的 node/npm。</p><p>首先，打开你 Finder，按 <code>shift+command+G</code>，打开前往文件夹的窗口，分别输入下列目录进去之后删除 <code>node</code> 和 <code>node_modules</code> 相关的文件和文件夹:</p><ul><li>打开 <code>/usr/local/lib</code>，删除 <code>node</code> 和 <code>node_modules</code> 相关的文件和文件夹</li><li>打开 <code>/usr/local/include</code>，删除 <code>node</code> 和 <code>node_modules</code> 相关的文件和文件夹</li><li>如果你是使用的 <code>brew install node</code> 安装的 NodeJS，那么你还需要在终端中执行 <code>brew uninstall node</code> 命令来卸载</li><li>检查你的个人主文件夹下面的所有的 <code>local</code>、<code>lib</code> 以及 <code>include</code> 文件夹，并且删除所有与 <code>node</code> 和 <code>node_modules</code> 相关的文件以及文件夹</li><li>打开 <code>/usr/local/bin</code> 并删除 <code>node</code> 可执行文件</li></ul><p>你可能还需要在你的终端中输入一些额外的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo rm /usr/local/bin/npm</div><div class="line">sudo rm /usr/local/share/man/man1/node.1</div><div class="line">sudo rm /usr/local/lib/dtrace/node.d</div><div class="line">sudo rm -rf ~/.npm</div><div class="line">sudo rm -rf ~/.node-gyp</div><div class="line">sudo rm /opt/local/bin/node</div><div class="line">sudo rm /opt/local/include/node</div><div class="line">sudo rm -rf /opt/local/lib/node_modules</div></pre></td></tr></table></figure><h2><span id="windows-安装">Windows 安装</span></h2><p>首先最重要的是：一定要卸载已安装的 NodeJS，否则会发生冲突。然后下载 <a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="external">nvm-windows</a> 最新安装包，直接安装即可。</p><h2><span id="os-xlinux-安装">OS X/Linux 安装</span></h2><p>与 Windows 不同，我们并不一定要先卸载原有的 NodeJS。当然我们推荐还是先卸载掉比较好。另外，你还需要 C++ 编译器，Linux 发行版一般不用担心，像 Ubuntu 都可以直接用 <code>build-essential</code> 套件，OS X 的话，可以用 <code>X-Code</code> 的命令行工具。运行这个命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcode-select --install</div></pre></td></tr></table></figure><p>在 Linux 中：（如果是 Debian 发行版）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install build-essential</div></pre></td></tr></table></figure><p>然后我们可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</div></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</div></pre></td></tr></table></figure><p>从远程下载 <code>install.sh</code> 脚本并执行。注意这个版本年数字 <code>v0.33.0</code> 会随着项目开发而变化。随时通过<a href="https://github.com/creationix/nvm#install-script" target="_blank" rel="external">官方最新安装命令</a>来检查最新安装版本是有好处的。</p><h2><span id="安装多版本-nodenpm">安装多版本 node/npm</span></h2><p>例如，我们要安装4.2.2版本，可以用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm install 4.2.2</div></pre></td></tr></table></figure><p>nvm 遵守<a href="http://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本</a>命名规则。例如，你想安装最新的 <code>4.2</code> 系列的最新的一个版本的话，可以运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm install 4.2</div></pre></td></tr></table></figure><p>nvm 会寻找 <code>4.2.x</code> 中最高的版本来安装。</p><p>你可以通过以下命令来列出远程服务器上所有的可用版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm ls-remote</div></pre></td></tr></table></figure><p>Windows 的话，就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm ls available</div></pre></td></tr></table></figure><h2><span id="在不同版本间切换">在不同版本间切换</span></h2><p>每当我们安装了一个新版本 Node 后，全局环境会自动把这个新版本设置为默认。</p><p>nvm 提供了 <code>nvm use</code> 命令。这个命令的使用方法和 <code>install</code> 命令类似。</p><p>例如，切换到 <code>4.2.2</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm use 4.2.2</div></pre></td></tr></table></figure><p>切换到最新的 `4.2.x``：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm use 4.2</div></pre></td></tr></table></figure><p>切换到 iojs：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm use iojs-v3.2.0</div></pre></td></tr></table></figure><p>切换到最新版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm use node</div></pre></td></tr></table></figure><p>每次执行切换的时候，系统都会把 node 的可执行文件链接放到特定版本的文件上。</p><p>我们还可以用 nvm 给不同的版本号设置别名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm alias awesome-version 4.2.2</div></pre></td></tr></table></figure><p>我们给 <code>4.2.2</code> 这个版本号起了一个名字叫做 <code>awesome-version</code>，然后我们可以运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm use awesome-version</div></pre></td></tr></table></figure><p>下面这个命令可以取消别名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm unalias awesome-version</div></pre></td></tr></table></figure><p>另外，你还可以设置 <code>default</code> 这个特殊别名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm alias default node</div></pre></td></tr></table></figure><h2><span id="列出已安装实例">列出已安装实例</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm ls</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/images/nvm-ls.png" alt="nvm ls"></p><p>上面绿色箭头是当前正在使用的版本，下面列出的还有设置过的别名。</p><h2><span id="在项目中使用不同版本的-node">在项目中使用不同版本的 Node</span></h2><p>我们可以通过创建项目目录中的 <code>.nvmrc</code> 文件来指定要使用的 Node 版本。之后在项目目录中执行 <code>nvm use</code> 即可。<code>.nvmrc</code> 文件内容只需要遵守上文提到的语义化版本规则即可。另外还有个工具叫做 <a href="https://github.com/wbyoung/avn" target="_blank" rel="external">avn</a>，可以自动化这个过程。</p><h2><span id="在多环境中npm该如何使用呢">在多环境中，npm该如何使用呢？</span></h2><p>每个版本的 Node 都会自带一个不同版本的 npm，可以用 <code>npm -v</code> 来查看 npm 的版本。全局安装的 npm 包并不会在不同的 Node 环境中共享，因为这会引起兼容问题。它们被放在了不同版本的目录下，例如 <code>~/.nvm/versions/node/&lt;version&gt;/lib/node_modules&lt;/version&gt;</code> 这样的目录。这刚好也省去我们在 Linux 中使用 <code>sudo</code> 的功夫了。因为这是用户的主文件夹，并不会引起权限问题。</p><p>但问题来了，我们安装过的 npm 包，都要重新再装一次？幸运的是，我们有个办法来解决我们的问题，运行下面这个命令，可以从特定版本导入到我们将要安装的新版本 Node：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm install v5.0.0 --reinstall-packages-from=4.2</div></pre></td></tr></table></figure><h2><span id="其他命令">其他命令</span></h2><p>直接运行特定版本的 Node</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm run 4.2.2 --version</div></pre></td></tr></table></figure><p>在当前终端的子进程中运行特定版本的 Node</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm exec 4.2.2 node --version</div></pre></td></tr></table></figure><p>确认某个版本Node的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm which 4.2.2</div></pre></td></tr></table></figure><p>安装 Node 的其他实现，例如 iojs（一个基于 ES6 的 Node 实现，现在已经和 Node 合并）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm install iojs-v3.2.0</div></pre></td></tr></table></figure><p>快捷命令：</p><ul><li><code>nvm install node</code> 安装最新版 Node</li><li><code>nvm install iojs</code> 安装最新版 iojs</li><li><code>nvm install unstable</code> 安装最新不稳定版本的 Node</li></ul><h2><span id="参考资源">参考资源</span></h2><ul><li><a href="https://www.sitepoint.com/quick-tip-multiple-versions-node-nvm/" target="_blank" rel="external">Quick Tip: Install Multiple Versions of Node.js using nvm</a></li><li><a href="http://benznext.com/completely-uninstall-node-js-from-mac-os-x/" target="_blank" rel="external">How To Completely Uninstall Node.js From Mac OS X</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 NodeJS 运行环境。如果没有一个合适的工具，这个问题将非常棘手。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/creationix/nvm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nvm&lt;/a&gt; 应运而生，nvm 是 Mac 下的 node 管理工具，有点类似管理 Ruby 的 rvm，如果需要管理 Windows 下的 node，官方推荐使用 &lt;a href=&quot;https://github.com/hakobera/nvmw&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nvmw&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/coreybutler/nvm-windows&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nvm-windows&lt;/a&gt;。不过，nvm-windows 并不是 nvm 的简单移植，他们也没有任何关系。但下面介绍的所有命令，都可以在 nvm-windows 中运行。&lt;/p&gt;
    
    </summary>
    
      <category term="Node" scheme="http://bubkoo.com/categories/node/"/>
    
    
      <category term="Tools" scheme="http://bubkoo.com/tags/tools/"/>
    
      <category term="nvm" scheme="http://bubkoo.com/tags/nvm/"/>
    
  </entry>
  
  <entry>
    <title>如何编写更加自解释的代码</title>
    <link href="http://bubkoo.com/2016/09/08/15-ways-to-write-self-documenting-javascript/"/>
    <id>http://bubkoo.com/2016/09/08/15-ways-to-write-self-documenting-javascript/</id>
    <published>2016-09-08T21:20:28.000Z</published>
    <updated>2016-09-08T21:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你发现代码中的某些注释完全无用时你会怎么办？</p><p>我们经常会犯一个错误：当我们更新代码时，却忘记更新相应的注释。不友好的注释并不会影响代码的执行，但使我们的调试和阅读带来极大困扰，注释描述的是一种逻辑，而代码确是另外一种，结果会浪费我们大量时间来搞懂这段代码的意思，更糟糕的是这样的注释很可能误导我们。</p><p>这并不是说注释完全没有必要，优秀的代码有具有相应优秀的注释。我们可以利用某些编程技术来减少我们的注释，使我们的代码更加自解释。这不仅仅使我们的代码更加容易理解，还有助于改善项目的整体设计。</p><p>这样的代码通常被称为<em>自解释</em>的代码，下面我将介绍一些编写自解释代码的方法。</p><a id="more"></a><h2><span id="概览">概览</span></h2><p>一些程序猿将注释也作为自解释代码的一部分，注释很重要，可以用很大的篇幅单独讨论。在本文中，我们只讨论代码。</p><p>我先将要讨论的技术分为三大类：</p><ul><li><strong>代码结构</strong>，清晰的代码和目录结构能更好地表达我们的意图；</li><li><strong>命名相关</strong>，比如方法和变量命名；</li><li><strong>语法相关</strong>，使用（不使用）某些语法特性可以使代码更清晰。</li></ul><p>这几个点看起来都很简单，难点在于在合适地方选择合适的技术，下面我将用分别用实例讲解如何使用这些技术。</p><h2><span id="代码结构">代码结构</span></h2><p>改善现有代码的结构来增加项目整体的清晰度。</p><h3><span id="提取帮助函数">提取帮助函数</span></h3><p>将一些通用的代码提取为帮助函数。例如，很难想到下面代码是什么意思：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> width = (value - <span class="number">0.5</span>) * <span class="number">16</span>;</div></pre></td></tr></table></figure><p>可以在这里添加注释，或者将其提取成为一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> width = emToPixels(value);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">emToPixels</span>(<span class="params">ems</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (ems - <span class="number">0.5</span>) * <span class="number">16</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>唯一的变化就是我们将计算过程移到一个函数中，通过函数名使其自解释，同时我们还得到一个可以复用的帮助函数，减少了代码冗余。</p><h3><span id="将条件表达式提取为函数">将条件表达式提取为函数</span></h3><p>一个包含多个条件判断的表达式在没有注释的情况下很难理解，看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!el.offsetWidth || !el.offsetHeight) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>是不是很难理解，我们可以将条件判断部分提取为一个函数，是不是瞬间就变得很好理解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isVisible</span>(<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> el.offsetWidth &amp;&amp; el.offsetHeight;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(!isVisible(el)) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="用变量替换表达式">用变量替换表达式</span></h3><p>这和上个方法很像，这里只是将表达式的计算结果放在一个变量中，看上面讨论过的那个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!el.offsetWidth || !el.offsetHeight) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>引入变量后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isVisible = el.offsetWidth &amp;&amp; el.offsetHeight;</div><div class="line"><span class="keyword">if</span>(!isVisible) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当一段逻辑非常特殊，仅仅用在一个位置，使用变量就比提取函数更加合适。这种方法最常用于数学表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> a * b + (c / d);</div></pre></td></tr></table></figure><p>我们可以这样重构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> multiplier = a * b;</div><div class="line"><span class="keyword">var</span> divisor = c / d;</div><div class="line"><span class="keyword">return</span> multiplier + divisor;</div></pre></td></tr></table></figure><h3><span id="类和模块接口">类和模块接口</span></h3><p>类和模块中的公共方法和属性可以使代码更加清晰，看下面示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</div><div class="line">    setState(state) &#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getState() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当然，这个类还可以包含其他代码，这里我特意写了这样一个简单类来演示。你可以一眼就看出如何使用这些方法吗？这些方法名看似都非常合理，尽管如此，我们还是不知道该如何使用这些方法，我们还需要阅读类的使用文档才能明白这些方法的作用。</p><p>如果改成如下实现呢：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</div><div class="line">    open() &#123;</div><div class="line">        <span class="keyword">this</span>.state = <span class="string">'open'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    close() &#123;</div><div class="line">        <span class="keyword">this</span>.state = <span class="string">'closed'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    isOpen() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state === <span class="string">'open'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>是不是更加容易理解和使用？现在，你可以一眼就看出来如何使用 <code>Box</code> 类。这里我们仅仅改变了公共接口，在内部仍然使用 <code>this.state</code> 属性来表示。</p><h3><span id="代码分组">代码分组</span></h3><p>将不同的代码分组也可以作为“文档”的一部分，例如，我们应该保证变量的声明位置尽量靠近变量的使用位置，而且尽可能按组使用这些变量。</p><p>分组可以暗示代码内部之间的关系，将来其让人修改你的代码时也可以更快找到该修改的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line"></div><div class="line">blah()</div><div class="line">xyz();</div><div class="line"></div><div class="line">bar(foo);</div><div class="line">baz(<span class="number">1337</span>);</div><div class="line">quux(foo);</div></pre></td></tr></table></figure><p>你可以一看看出 <code>foo</code> 使用了多少次吗？对比以下实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line">bar(foo);</div><div class="line">quux(foo);</div><div class="line"></div><div class="line">blah()</div><div class="line">xyz();</div><div class="line"></div><div class="line">baz(<span class="number">1337</span>);</div></pre></td></tr></table></figure><p>我们将使用 <code>foo</code> 的代码分组到一起，这样就可以清楚地知道哪些代码依赖了这个变量。</p><h3><span id="使用纯函数">使用纯函数</span></h3><p>纯函数比依赖状态的函数更加容易被理解。</p><p>什么是纯函数呢？如果一个函数，对相同的输入参数，无论何时调用这个函数总是返回相同的结果，这个函数没有任何改变函数返回值的副作用（如，时间因素，Ajax请求等）。</p><p>这类函数更加容易理解，函数的输出结果仅由输入参数决定，你不必纠结这个结果到底是如何得到的，会不会有其他因素影响的了结果，你可以完全信任这类函数的返回值，更不会影响函数外部的状态。</p><h3><span id="文件和目录结构">文件和目录结构</span></h3><p>在同一个项目中保持相同的命名约定，如果项目中没有明确的命名约定，可以遵循你选择的语言的标准。</p><p>比如，你正在添加 UI 相关的代码，可以先在项目中找到这类代码的位置，如果 UI 相关的代码放在 <code>src/ui/</code> 下面，那么请将你的代码也放在这里。</p><h2><span id="命名相关">命名相关</span></h2><p>先看一个名言：</p><blockquote><p>在计算机领域只有两个难题：缓存失效和命名。–  Phil Karlton</p></blockquote><p>下面我们就来看看如何通过命名来使我们的代码自解释。</p><h3><span id="函数命名">函数命名</span></h3><p>函数命名并不复杂，但有几个原则可以遵循：</p><ul><li>避免使用语义模糊的动词，比如“handle”或“manage”：<code>handleLinks()</code>, <code>manageObjects()</code> 我们很难理解这些方法到底是用来干什么的？</li><li>使用主动动词：<code>cutGrass()</code>, <code>sendFile()</code>；</li><li>暗示返回值：<code>getMagicBullet()</code>, <code>readFile()</code>；</li><li>对于强类型的语言，还可以使用方法签名来暗示函数的返回值。</li></ul><h3><span id="变量命名">变量命名</span></h3><p>对于变量命名有两个经验法则：</p><ul><li>暗示数值的单位：对于数值类型的变量，我们可以通过更好的命名来暗示该值对于的单位，例如，使用 <code>widthPx</code> 代替 <code>width</code> 可以让我们更清晰地知道该值的单位是像素；</li><li>不要使用简写：<code>a</code> 或 <code>b</code> 是不规范的变量命名，循环中的计数器除外。</li></ul><h3><span id="遵循现有的命名规范">遵循现有的命名规范</span></h3><p>尽量遵循现有项目中的命名规范。例如，对于特殊类型的对象，请保持相同的命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = getElement();</div></pre></td></tr></table></figure><p>请不要突然命名为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> node = getElement();</div></pre></td></tr></table></figure><h3><span id="使用更有意义的错误提示">使用更有意义的错误提示</span></h3><p>Undefined is not an object!</p><p>这个错误我们经常可以看到，这是一个反例，我们应该确保我们的代码中抛出的任何错误都有一个有意义的错误消息。</p><p>如何做呢？</p><ul><li>应该描述清楚具体的问题；</li><li>如果可能，尽可能包含导致该错误的变量或数据；</li><li>关键点：错误信息应该帮助我们找到错误所在，应该作为文档告知我们函数应该如果工作。</li></ul><h2><span id="语法相关">语法相关</span></h2><h3><span id="不要使用某些语法技巧">不要使用某些语法技巧</span></h3><p>看下面示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imTricky &amp;&amp; doMagic();</div></pre></td></tr></table></figure><p>下面的方式更加一目了然：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(imTricky) &#123;</div><div class="line">    doMagic();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>请总是使用后面这种方式，前一种语法技巧不会给任何人带来任何好处。</p><h3><span id="使用命名的常量">使用命名的常量</span></h3><p>如果在代码中有一个特殊的数字或字符串字面量，请将其声明为一个常量。如果在代码中直接使用一个特殊的数字字面量，现在可能很好理解其意义，但在一两个月之后，没人会理解这个数字的具体意义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MEANING_OF_LIFE = <span class="number">42</span>;</div></pre></td></tr></table></figure><h3><span id="避免使用-boolean-字面量">避免使用 Boolean 字面量</span></h3><p>使用 Boolean 字面量可能导致一些不好理解的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myThing.setData(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, <span class="literal">true</span>);</div></pre></td></tr></table></figure></p><p>我们压根不知道这里的 <code>true</code> 是什么含义，除非阅读 <code>setData()</code> 的源码。我们可以添加另外一个方法来完成相同的功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myThing.mergeData(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;);</div></pre></td></tr></table></figure><h3><span id="充分利用语言特性">充分利用语言特性</span></h3><p>一个很好的例子是循环代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ids = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; things.length; i++) &#123;</div><div class="line">  ids.push(things[i].id);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在上面代码中，我们收集数组每项的 ID 放到一个新数组中，为了搞懂这段代码我们需要阅读整个循环体中的代码，请比较实用 <code>map</code> 的实现方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ids = things.map(<span class="function"><span class="keyword">function</span>(<span class="params">thing</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> thing.id;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>另一个实例是 JavaScript 的 <code>const</code> 关键字。通常，我们可能会定义一些永远都不会改变值的变量，一个非常常见的例子是实用 CommonJS 加载一个模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</div></pre></td></tr></table></figure><p>我们可以直接将其声明为一个常量，使其意义更加清晰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</div></pre></td></tr></table></figure><h2><span id="结论">结论</span></h2><p>编写自解释的代码能够提高系统的可维护性，每一段注释都需要额外的维护精力，所以应该尽可能减少注释的数量。然而，自解释的代码并不能完全替代注释，有必要在适当的位置保留某些关键的注释，而且 API 文档也非常必要，除非你的代码库非常轻量级 – 开发人员可以直接阅读你的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你发现代码中的某些注释完全无用时你会怎么办？&lt;/p&gt;
&lt;p&gt;我们经常会犯一个错误：当我们更新代码时，却忘记更新相应的注释。不友好的注释并不会影响代码的执行，但使我们的调试和阅读带来极大困扰，注释描述的是一种逻辑，而代码确是另外一种，结果会浪费我们大量时间来搞懂这段代码的意思，更糟糕的是这样的注释很可能误导我们。&lt;/p&gt;
&lt;p&gt;这并不是说注释完全没有必要，优秀的代码有具有相应优秀的注释。我们可以利用某些编程技术来减少我们的注释，使我们的代码更加自解释。这不仅仅使我们的代码更加容易理解，还有助于改善项目的整体设计。&lt;/p&gt;
&lt;p&gt;这样的代码通常被称为&lt;em&gt;自解释&lt;/em&gt;的代码，下面我将介绍一些编写自解释代码的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Document" scheme="http://bubkoo.com/tags/document/"/>
    
      <category term="Quality" scheme="http://bubkoo.com/tags/quality/"/>
    
  </entry>
  
  <entry>
    <title>使用 FLIP 来提高 Web 动画的性能</title>
    <link href="http://bubkoo.com/2016/03/31/high-performance-animations/"/>
    <id>http://bubkoo.com/2016/03/31/high-performance-animations/</id>
    <published>2016-03-31T17:48:03.000Z</published>
    <updated>2016-03-31T17:48:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 动画已经存在很多年了，使用恰当可以很好地提高网站的用户体验，也正是由于其容易使用，就很可能出现性能低下的动画，从而降低了整个页面的运行效率。回想一下：你曾经是否使用过 CSS 来改变元素的宽度、高度或绝对位置？如果回答是肯定的，就意味着你触发了性能低下的重排或重绘计算，在某些情况下甚至可能导致<a href="http://jankfree.org/" target="_blank" rel="external">页面闪烁</a>。</p><p>什么样的情况会导致页面闪烁呢？现代浏览器根据设备的刷新率来刷新页面中的内容，对大多数设备而言，屏幕以 <code>60</code> 次每秒的频率刷新，即 <code>60HZ</code>。如果在屏幕上出现了某些运动，如滚动、过渡或动画，浏览器应该每秒刷新 <code>60</code> 帧，如果某些帧花费的时间太长，进而导致浏览器的刷新频率跟不上设备的刷新频率（跳帧现象），就会出现页面闪烁。<strong>所以在 Web 应用中运行的动画都应该保持在 <code>60FPS</code> 下</strong>。</p><p>为了生成流畅的动画，你需要让浏览器尽可能少地工作，最好的办法就是充分利用 GPU，并避免动画过程中触发页面重排或重绘。目前 Chrome，Firefox，Safari，Opera 和 IE11 都对 <code>transform</code>（<code>translate</code>，<code>rotate</code> 和 <code>scale</code>） 和 <code>opacity</code> 进行硬件加速。<strong>所以我们应该尽量使用 <code>transform</code> 和 <code>opacity</code> 属性来实现我们的动画</strong>，因为改变其他属性都可能导致页面<a href="https://csstriggers.com/" target="_blank" rel="external">重排或重绘</a>。<strong>还有最好在绝对定位的元素上使用动画</strong>，因为这些元素位置的改变不会影响其他元素。只要严格遵循以上两条规则，就能确保在绝大多数情况下你的动画在 <code>60FPS</code> 下运行。这还不是全部，下面将介绍一个新的技术方案，可以帮助你创建真正轻量级的动画。</p><a id="more"></a><h2><span id="什么是-flip-技术">什么是 FLIP 技术</span></h2><p>FLIP 是将一些开销高昂的动画，如针对 <code>width</code>，<code>height</code>，<code>left</code> 或 <code>top</code> 的动画，映射为 transform 动画。通过记录元素的两个快照，一个是元素的初始位置（First - <code>F</code>），另一个是元素的最终位置（Last - <code>L</code>），然后对元素使用一个 <code>transform</code> 变换来反转（Invert - <code>I</code>），让元素看起来还在初始位置，最后移除元素上的 <code>transform</code> 使元素由初始位置运动（Play - <code>P</code>）到最终位置。</p><p>所以 FLIP 来源于 <strong>F</strong>irst，<strong>L</strong>ast，<strong>I</strong>nvert，<strong>P</strong>lay。</p><p>分解一下：</p><ul><li><strong>First</strong>：元素的初始状态。</li><li><strong>Last</strong>：元素的最终状态。</li><li><strong>Invert</strong>：先计算出从初始状态到最终状态元素发生的改变，比如宽度、高度、透明度等，然后在元素上应用一个 <code>transform</code> 或 <code>opacity</code> 使这些改变反转。如果一个元素由初始状态到最终状态是向下移动了 <code>90px</code>，那就需要对元素应用 <code>transform: translate(0, -90px)</code>，这样就使元素看起来还在初始位置。</li><li><strong>Play</strong>：移除元素上的 <code>transform</code> 并设置 <code>transform</code> 相关的动画。</li></ul><p>那为什么是删除元素中的 <code>transform</code> 而不是直接应用一个 <code>transform</code> 使元素由初始位置运动到最终位置呢？从上面的 <strong>Invert</strong> 可知元素其实已经在最终状态上，而且通过应用反转浏览器就已经知道从 <code>F</code> 到 <code>L</code> 的过程，对浏览器来说就能更快地启动动画。</p><h2><span id="js-实现">JS 实现</span></h2><p>思路已经很清晰，直接看实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取初始位置</span></div><div class="line"><span class="keyword">var</span> first = el.getBoundingClientRect();</div><div class="line"></div><div class="line"><span class="comment">// 为元素指定一个样式，让元素在最终位置上</span></div><div class="line">el.classList.add(<span class="string">'totes-at-the-end'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 获取最终位置</span></div><div class="line"><span class="keyword">var</span> last = el.getBoundingClientRect();</div><div class="line"></div><div class="line"><span class="comment">// 如果有必要也可以对其他样式进行计算，但最好坚持只进行 transform 和 opacity 相关的计算</span></div><div class="line"><span class="keyword">var</span> invert = first.top - last.top;</div><div class="line"></div><div class="line"><span class="comment">// 反转</span></div><div class="line">el.style.transform = <span class="string">'translateY('</span> + invert + <span class="string">'px)'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 等到下一帧，也就是其他所有的样式都已经被应用</span></div><div class="line">requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 添加动画相关的设置 </span></div><div class="line">  el.classList.add(<span class="string">'animate-on-transforms'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 开始动画</span></div><div class="line">  el.style.transform = <span class="string">''</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 结束时清理</span></div><div class="line">el.addEventListener(<span class="string">'transitionend'</span>, tidyUpAnimations);</div></pre></td></tr></table></figure><p>也可以使用 <a href="http://w3c.github.io/web-animations/" target="_blank" rel="external">Web Animations API</a>，代码更加简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取初始位置</span></div><div class="line"><span class="keyword">var</span> first = el.getBoundingClientRect();</div><div class="line"></div><div class="line"><span class="comment">// 为元素指定一个样式，让元素在最终位置上</span></div><div class="line">el.classList.add(<span class="string">'totes-at-the-end'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 获取最终位置</span></div><div class="line"><span class="keyword">var</span> last = el.getBoundingClientRect();</div><div class="line"></div><div class="line"><span class="comment">// 反转</span></div><div class="line"><span class="keyword">var</span> invert = first.top - last.top;</div><div class="line"></div><div class="line"><span class="comment">// 应用动画</span></div><div class="line"><span class="keyword">var</span> player = el.animate([</div><div class="line">  &#123; <span class="attr">transform</span>: <span class="string">'translateY('</span> + invert + <span class="string">'px)'</span> &#125;,</div><div class="line">  &#123; <span class="attr">transform</span>: <span class="string">'translateY(0)'</span> &#125;</div><div class="line">], &#123;</div><div class="line">  duration: <span class="number">300</span>,</div><div class="line">  easing: <span class="string">'cubic-bezier(0,0,0.32,1)'</span>,</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 结束时清理</span></div><div class="line">player.addEventListener(<span class="string">'finish'</span>, tidyUpAnimations);</div></pre></td></tr></table></figure><p>如果运行上面的代码你可以需要 <a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="external">Web Animations API polyfill</a> 这个兼容模块，这个模块很轻量，但确实让代码好看了很多。</p><p>Chrome 团队已经将以上方案封装为一个独立的 JS 模块 - <a href="https://github.com/GoogleChrome/flipjs" target="_blank" rel="external">flipjs</a>，并提供了几个 <a href="https://googlechrome.github.io/flipjs/" target="_blank" rel="external">Demo</a>。</p><h2><span id="css-实现">CSS 实现</span></h2><p><a href="http://blog.lunarlogic.io/author/ania/" target="_blank" rel="external">ANNA MIGAS</a> 知道 FLIP 技术后，封装了一个轻量级的 CSS 动画模块 - <a href="https://github.com/szynszyliszys/repaintless" target="_blank" rel="external">repaintless.css</a>，用于实现某些 FLIP 动画，并在其<a href="http://blog.lunarlogic.io/2016/boost-your-css-animation-performance-with-repaintless-css/" target="_blank" rel="external">文章</a>中演示了 FLIP 的性能。</p><p><img src="http://bubkoo.qiniudn.com/images/flip-60fps.gif" alt="使用 repaintless.css 实现 60FPS 动画"></p><h2><span id="这到底有什么好处">这到底有什么好处？</span></h2><p>先陈述一个事实，当用户与你的网站进行交互，从交互结束到感知到响应大概需要 <code>100ms</code> 的生理反应时间，如果网站能在这 <code>100ms</code> 内做出响应，那么对用户来说就相当于网站立即进行了响应，然后只需要保证动画在 60FPS 运行就能给用户带来最佳的体验。</p><p><img src="http://bubkoo.qiniudn.com/images/taking-advantage-of-user-perception.jpg" alt=""></p><p>我们可以充分利用用户 <code>100ms</code> 生理反应时间来进行相关的计算：<code>getBoundingClientRect</code> 或 <code>getComputedStyle</code>，并通过 FLIP 技术使动画尽快开始，最后通过 <code>transform</code> 和 <code>opacity</code> 的动画来保证动画的平滑运行。可以深入阅读 <a href="https://aerotwist.com/blog/pixels-are-expensive/" target="_blank" rel="external">Pixels are Expensive</a> 了解更多。</p><p>那些可以映射为 <code>transform</code> 和 <code>opacity</code> 的属性变换都可以使用该解决方案，并且在设计阶段也应该尽量使动画满足这个方案（还记得文章开始提到关于动画的两个原则吗？）。</p><p>你也许会觉得这是过度设计，但对我来说却不是：</p><ol><li><strong>用户需要</strong>。Google 的 Paul Kinlan 最近做了一个<a href="http://paul.kinlan.me/what-news-readers-want/" target="_blank" rel="external">调研</a>，是关于用户对新闻类 APP 最期待什么样的功能。回答令人惊讶，最多的声音不是离线支持，不是平台间同步，不是更好的通知方式，或类似功能方面的改进，而是希望使用起来更加<strong>平滑</strong>。平滑就意味着没有屏幕闪烁，没有卡顿，没有抖动。</li><li><strong>移动端需要</strong>。FLIP 技术带来的改变对于 PC 端可能并不是那么明显，但对于 CPU 并不算非常强大的移动端却是相当显著。</li></ol><h2><span id="几点提示">几点提示</span></h2><p>使用 FLIP 技术时有几点需要牢记：</p><ol><li>不要超出用户反应时间 <code>100ms</code>。否则用户会觉得你的应用没有立即响应，通过 DevTools 时刻留意是哪些计算导致超出了这个时间。</li><li>精心组织你的动画。设想一下，如果一个 FLIP 动画正在运行，同时你接着想执行下一个 FLIP 动画，这时就要确保下一个动画的预计算工作是在闲置或用户的反应时间内进行，这样就可以保证两个动画互不影响。</li><li>内容可能被扭曲。当进行某些缩放动画时可能导致内容扭曲，毕竟这是一种 Hack 技术。</li></ol><h2><span id="参考资源">参考资源</span></h2><ul><li><a href="http://www.html5rocks.com/zh/tutorials/speed/high-performance-animations" target="_blank" rel="external">High Performance Animations</a></li><li><a href="https://csstriggers.com/" target="_blank" rel="external">CSS Triggers</a></li><li><a href="http://jankfree.org/" target="_blank" rel="external">What is Jank?</a></li><li><a href="https://aerotwist.com/blog/flip-your-animations/" target="_blank" rel="external">FLIP Your Animations</a></li><li><a href="https://github.com/GoogleChrome/flipjs" target="_blank" rel="external">GoogleChrome flip.js</a></li><li><a href="http://w3c.github.io/web-animations/" target="_blank" rel="external">Web Animations API</a></li><li><a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="external">Web Animations API polyfill</a></li><li><a href="http://blog.lunarlogic.io/2016/boost-your-css-animation-performance-with-repaintless-css/" target="_blank" rel="external">Boost Your CSS Animation Performance with the Repaintless.css Library</a></li><li><a href="https://github.com/szynszyliszys/repaintless" target="_blank" rel="external">repaintless.css</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 动画已经存在很多年了，使用恰当可以很好地提高网站的用户体验，也正是由于其容易使用，就很可能出现性能低下的动画，从而降低了整个页面的运行效率。回想一下：你曾经是否使用过 CSS 来改变元素的宽度、高度或绝对位置？如果回答是肯定的，就意味着你触发了性能低下的重排或重绘计算，在某些情况下甚至可能导致&lt;a href=&quot;http://jankfree.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;页面闪烁&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;什么样的情况会导致页面闪烁呢？现代浏览器根据设备的刷新率来刷新页面中的内容，对大多数设备而言，屏幕以 &lt;code&gt;60&lt;/code&gt; 次每秒的频率刷新，即 &lt;code&gt;60HZ&lt;/code&gt;。如果在屏幕上出现了某些运动，如滚动、过渡或动画，浏览器应该每秒刷新 &lt;code&gt;60&lt;/code&gt; 帧，如果某些帧花费的时间太长，进而导致浏览器的刷新频率跟不上设备的刷新频率（跳帧现象），就会出现页面闪烁。&lt;strong&gt;所以在 Web 应用中运行的动画都应该保持在 &lt;code&gt;60FPS&lt;/code&gt; 下&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了生成流畅的动画，你需要让浏览器尽可能少地工作，最好的办法就是充分利用 GPU，并避免动画过程中触发页面重排或重绘。目前 Chrome，Firefox，Safari，Opera 和 IE11 都对 &lt;code&gt;transform&lt;/code&gt;（&lt;code&gt;translate&lt;/code&gt;，&lt;code&gt;rotate&lt;/code&gt; 和 &lt;code&gt;scale&lt;/code&gt;） 和 &lt;code&gt;opacity&lt;/code&gt; 进行硬件加速。&lt;strong&gt;所以我们应该尽量使用 &lt;code&gt;transform&lt;/code&gt; 和 &lt;code&gt;opacity&lt;/code&gt; 属性来实现我们的动画&lt;/strong&gt;，因为改变其他属性都可能导致页面&lt;a href=&quot;https://csstriggers.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;重排或重绘&lt;/a&gt;。&lt;strong&gt;还有最好在绝对定位的元素上使用动画&lt;/strong&gt;，因为这些元素位置的改变不会影响其他元素。只要严格遵循以上两条规则，就能确保在绝大多数情况下你的动画在 &lt;code&gt;60FPS&lt;/code&gt; 下运行。这还不是全部，下面将介绍一个新的技术方案，可以帮助你创建真正轻量级的动画。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://bubkoo.com/categories/css/"/>
    
    
      <category term="Performance" scheme="http://bubkoo.com/tags/performance/"/>
    
      <category term="Animation" scheme="http://bubkoo.com/tags/animation/"/>
    
      <category term="FLIP" scheme="http://bubkoo.com/tags/flip/"/>
    
  </entry>
  
  <entry>
    <title>定制图片加载失败时的样式</title>
    <link href="http://bubkoo.com/2016/03/28/styling-broken-images/"/>
    <id>http://bubkoo.com/2016/03/28/styling-broken-images/</id>
    <published>2016-03-28T10:36:09.000Z</published>
    <updated>2016-03-28T10:36:09.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hexo-insert-code"><img src="http://bubkoo.com/broken.jpg" alt="图片加载失败，默认样式有木有很丑陋？" class="no-fancy"></div><style type="text/css">.no-fancy{margin-top:20px;}</style><p>但也并非一定要如此，我们可以通过 CSS 为加载失败的图片定制样式，提供更好的体验。</p><a id="more"></a><h2><span id="关于-img-标签的两个事实">关于 img 标签的两个事实</span></h2><p>要了解如何为破裂的图片定制样式，需要先搞清楚连个事实：</p><ol><li><strong>我们可以为 <code>&lt;img&gt;</code> 元素指定字体样式</strong>，这些样式将用于破裂图片的替代文字，不会影响正常显示的图片。</li><li><strong><code>&lt;img&gt;</code> 元素实际上是一种<a href="https://www.w3.org/TR/CSS21/generate.html#before-after-content" target="_blank" rel="external">替换元素</a></strong>，其外观和尺寸由外部资源定义，所以通常情况下 <code>:before</code> 和 <code>:after</code> 这两个伪元素都不起作用，一旦图片加载失败时这两个伪元素将出现。</li></ol><p>正是基于以上两点，我们可以为破裂的图片定制样式，而不会影响正常加载的图片。</p><h2><span id="实践">实践</span></h2><p>使用下面的无效的图片地址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://bubkoo.com/broken.jpg"</span> <span class="attr">alt</span>=<span class="string">"图片裂开了"</span> &gt;</span></div></pre></td></tr></table></figure><h3><span id="添加一些帮助信息">添加一些帮助信息</span></h3><p>处理破裂图片的一种方式就是为破裂图片提供更多的帮助信息，以方便用户理解这是一个破裂的图片，使用 <code>attr()</code> 表达式我们还可以将破裂图片的地址显示出来。<br><div class="hexo-insert-code"><img src="http://bubkoo.com/broken.jpg" alt="图片裂开了" class="no-fancy broken-img"></div><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.broken-img</span> &#123;  </div><div class="line">  <span class="attribute">font-family</span>: <span class="string">'Helvetica'</span>;</div><div class="line">  <span class="attribute">font-weight</span>: <span class="number">300</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">2</span>;  </div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line"></div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: auto;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.broken-img</span><span class="selector-pseudo">:before</span> &#123;  </div><div class="line">  <span class="attribute">content</span>: <span class="string">"We're sorry, the image below is broken :("</span>;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.broken-img</span><span class="selector-pseudo">:after</span> &#123;  </div><div class="line">  <span class="attribute">content</span>: <span class="string">"(url: "</span> <span class="built_in">attr</span>(src) <span class="string">")"</span>;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><style type="text/css">.broken-img {    font-family: 'Helvetica';  font-weight: 300;  line-height: 2;    text-align: center;  width: 100%;  height: auto;  display: block;  position: relative;}.broken-img:before {    content: "We're sorry, the image below is broken :(";  display: block;  margin-bottom: 10px;}.broken-img:after {    content: "(url: " attr(src) ")";  display: block;  font-size: 12px;}</style><h3><span id="替换默认的替代文本">替换默认的替代文本</span></h3><p>我们可以使伪元素盖在破裂的图片元素之上，从而在外观上替换掉默认的替代文本：<br><div class="hexo-insert-code"><img src="http://bubkoo.com/broken.jpg" alt="图片裂开了" class="no-fancy broken-img-alt"></div><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.broken-img-alt</span> &#123;  </div><div class="line">  <span class="attribute">font-family</span>: <span class="string">'Helvetica'</span>;</div><div class="line">  <span class="attribute">font-weight</span>: <span class="number">300</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">2</span>;  </div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line"></div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: auto;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.broken-img-alt</span><span class="selector-pseudo">:after</span> &#123;  </div><div class="line">  <span class="attribute">content</span>: <span class="string">"\f016"</span> <span class="string">" "</span> <span class="built_in">attr</span>(alt);</div><div class="line"></div><div class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</div><div class="line">  <span class="attribute">font-family</span>: FontAwesome;</div><div class="line">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(100, 100, 100);</div><div class="line"></div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><style type="text/css">.broken-img-alt {    font-family: 'Helvetica';  font-weight: 300;  line-height: 2;    text-align: center;  width: 100%;  height: auto;  display: block;  position: relative;}.broken-img-alt:after {    content: "\f016" " " attr(alt);  font-size: 16px;  font-family: FontAwesome;  color: rgb(100, 100, 100);  display: block;  position: absolute;  z-index: 2;  top: 0;  left: 0;  width: 100%;  height: 100%;  background-color: #fff;}</style><h3><span id="更丰富的样式">更丰富的样式</span></h3><p>除了定制自定义的提示信息外，我们还可以通过伪元素来提供更丰富的样式。<br><div class="hexo-insert-code"><img src="http://bubkoo.com/broken.jpg" alt="图片裂开了" class="no-fancy broken-more"></div><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.broken-more</span> &#123;  </div><div class="line">  <span class="attribute">font-family</span>: <span class="string">'Helvetica'</span>;</div><div class="line">  <span class="attribute">font-weight</span>: <span class="number">300</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">2</span>;  </div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line"></div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: auto;</div><div class="line">  <span class="attribute">min-height</span>: <span class="number">50px</span>;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.broken-more</span><span class="selector-pseudo">:before</span> &#123;  </div><div class="line">  <span class="attribute">content</span>: <span class="string">" "</span>;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line"></div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: -<span class="number">10px</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="built_in">calc</span>(100% + 10px);</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(230, 230, 230);</div><div class="line">  <span class="attribute">border</span>: <span class="number">2px</span> dotted <span class="built_in">rgb</span>(200, 200, 200);</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.broken-more</span><span class="selector-pseudo">:after</span> &#123;  </div><div class="line">  <span class="attribute">content</span>: <span class="string">"\f127"</span> <span class="string">" Broken Image "</span>;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</div><div class="line">  <span class="attribute">font-style</span>: normal;</div><div class="line">  <span class="attribute">font-family</span>: FontAwesome;</div><div class="line">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(100, 100, 100);</div><div class="line"></div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">5px</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><style type="text/css">.broken-more {    font-family: 'Helvetica';  font-weight: 300;  line-height: 2;    text-align: center;  width: 100%;  height: auto;  min-height: 50px;  display: block;  position: relative;}.broken-more:before {    content: " ";  display: block;  position: absolute;  top: -10px;  left: 0;  height: calc(100% + 10px);  width: 100%;  background-color: rgb(230, 230, 230);  border: 2px dotted rgb(200, 200, 200);  border-radius: 5px;}.broken-more:after {    content: "\f127" " Broken Image ";  display: block;  font-size: 16px;  font-style: normal;  font-family: FontAwesome;  color: rgb(100, 100, 100);  position: absolute;  top: 5px;  left: 0;  width: 100%;  text-align: center;}</style><h2><span id="浏览器兼容性">浏览器兼容性</span></h2><p>不幸的是，这种方案并不兼容所有浏览器。对某些浏览器而言，即便是图片破裂了，伪元素也不会出现。</p><p>下面是通过我的测试列举出来的兼容表：</p><table><thead><tr><th>Browser</th><th style="text-align:center">Alt</th><th style="text-align:center">:before:</th><th style="text-align:center">:after:</th></tr></thead><tbody><tr><td>Chrome (Desktop and Android)</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td>Firefox (Desktop and Android)</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td>Opera (Desktop)</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td>Opera Mini</td><td style="text-align:center">✓ **</td><td style="text-align:center">✗</td><td style="text-align:center">✗</td></tr><tr><td>Safari (Desktop and iOS)</td><td style="text-align:center">✓ *</td><td style="text-align:center">✗</td><td style="text-align:center">✗</td></tr><tr><td>iOS Webview (Chrome, Firefox, others)</td><td style="text-align:center">✓ *</td><td style="text-align:center">✗</td><td style="text-align:center">✗</td></tr></tbody></table><p>** 不支持定义替代文本的样式<br>* 只有当图片的宽度足够包含替换文本时才显示，如果没有为图片指定宽度，那么替代文本可能压根就不显示</p><p>对于那些不支持伪元素的浏览器，为伪元素指定的样式也将被忽略，所以不用担心会打乱页面布局。这意味着我们可以为那些兼容的浏览器定制这类样式，为用户提供一个更好的体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;hexo-insert-code&quot;&gt;&lt;img src=&quot;http://bubkoo.com/broken.jpg&quot; alt=&quot;图片加载失败，默认样式有木有很丑陋？&quot; class=&quot;no-fancy&quot;&gt;&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;.no-fancy{
	margin-top:20px;
}&lt;/style&gt;
&lt;p&gt;但也并非一定要如此，我们可以通过 CSS 为加载失败的图片定制样式，提供更好的体验。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://bubkoo.com/categories/css/"/>
    
    
      <category term="Styling" scheme="http://bubkoo.com/tags/styling/"/>
    
  </entry>
  
  <entry>
    <title>使用 SVG 输出 Octicon</title>
    <link href="http://bubkoo.com/2016/03/26/delivering-octicons-with-svg/"/>
    <id>http://bubkoo.com/2016/03/26/delivering-octicons-with-svg/</id>
    <published>2016-03-26T00:08:32.000Z</published>
    <updated>2016-03-26T00:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="github.com">GitHub</a> 不再使用字体来输出图标了。我们把代码中所有的 <a href="http://octicons.github.com/" target="_blank" rel="external">Octicon</a> 替换成了 SVG 版本。虽然这些改动并不那么明显，但马上你就能体会到 SVG 图标的优点。</p><p><img src="http://bubkoo.qiniudn.com/images/svg-vs-iconfont.png" alt="左侧放大后的字体版本和右侧清晰的 SVG 版本"></p><p>切换到 SVG 以后，图标会作为图片渲染而非文字，这使其在任何分辨率下都能很好地以各种像素值显示。</p><a id="more"></a><h2><span id="为何使用-svg">为何使用 SVG？</span></h2><h3><span id="图标字体渲染问题">图标字体渲染问题</span></h3><p>图标字体从一开始就是一种 Hack。将图标作为 Unicode 符号生成一个自定义字体，并通过打包后的 CSS 来引入图标，这样只需要在任意元素上添加一个 class，图标就可以显示出来，然后我们通过 CSS 就能即时改变图标的尺寸和颜色。</p><p>然而，虽然这些图标是矢量图形，但在 <code>1x</code> 显示屏下的渲染效果并不理想。在基于 WebKit 的浏览器下，图标可能会在某些窗口宽度下变得模糊，因为此时图标是作为文本输出的，本来用于提高文本可读性的次像素渲染技术反而使图标看起来糟糕许多。</p><h3><span id="对页面渲染的改进">对页面渲染的改进</span></h3><p>因为我们直接将 SVG 注入 HTML（这也是我们选择这种方式的主要原因），所以不会再出现图标字体下载 -&gt; 缓存 -&gt; 渲染过程中出现的样式闪动问题。</p><p><img src="http://bubkoo.qiniudn.com/images/iconfont-flash.gif" alt="页面闪动"></p><h3><span id="可访问性">可访问性</span></h3><p>就像在<a href="https://speakerdeck.com/ninjanails/death-to-icon-fonts" target="_blank" rel="external">《图标字体已死》</a>一文中所述，有些用户会选择覆盖掉 GitHub 的字体，而对于患有读写障碍的用户，某些特定字体却是更加容易阅读。对于选择修改字体的用户来说，基于字体的图标就被渲染成了空白方框，这搞乱了页面布局，而且也不提供任何信息。而不管字体覆盖与否，SVG 都可以正常显示，并且对于读屏器用户来说，可以选择是否读出 SVG 的 <code>alt</code> 属性。</p><h3><span id="图形尺寸更合适">图形尺寸更合适</span></h3><p>我们目前对每个图标在所有尺寸下提供对应的图形。因为站点的加载依赖了图标字体的下载，我们曾被迫把图标限制在最重要的 <code>16px</code> 尺寸下，这使每个符号在视觉上做出一些让步，当在新页面上缩放这些图标时，显示的还是 <code>16px</code> 版本。而 SVG 可以方便地 fork 全部的图标集，在指定的每个尺寸提供更合适的图形。当然图标字体也可以这么做，但这样用户需要下载两倍数据量，甚至更多。</p><h3><span id="便于维护">便于维护</span></h3><p>打包自定义字体相当繁琐。一些 Web 应用也因此而生，我们内部也搞了一个。而使用 SVG 的话，添加一个新图标只需要将 SVG 文件放入相应的目录即可。</p><h3><span id="可添加动画效果">可添加动画效果</span></h3><p>动画并非必要，但使用 SVG 就有了添加动画的可能性，而且 SVG 动画也的确在某些地方有实际应用，例如这个<a href="http://codepen.io/aaronshekey/pen/wMZBgK" target="_blank" rel="external">预加载动画</a>。</p><h2><span id="实现方案">实现方案</span></h2><h3><span id="我们的方案">我们的方案</span></h3><p>Octicon 在整个 GitHub 的代码中出现了约 <code>2500</code> 次。在用 SVG 之前，我们使用 <code>&lt;span class=&quot;octicon octicon-alert&quot;&gt;&lt;/span&gt;</code> 这种简单的标签来引入。要切换到 SVG，我们添加了一个往 HTML 内直接注入 SVG 路径的辅助方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%= octicon(:symbol =&gt; &quot;plus&quot;) %&gt;</div></pre></td></tr></table></figure><p>输出：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"octicon octicon-plus"</span> <span class="attr">width</span>=<span class="string">"12"</span> <span class="attr">height</span>=<span class="string">"16"</span> <span class="attr">role</span>=<span class="string">"img"</span> <span class="attr">version</span>=<span class="string">"1.1"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 12 16"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M12 9H7v5H5V9H0V7h5V2h2v5h5v2z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure><p>就如上面那样，我们最终的方案是往页面 HTML 中直接注入 SVG，这样就可以灵活通过 CSS 的 <code>fill:</code> 属性来调整修改图标的颜色。</p><p>我们将所有的 SVG 图形放在一个的目录而不是一个图标字体中，然后将里面这些图形的路径通过辅助方法直接注入到 HTML 里。比如，通过 <code>&lt;%= octicon(:symbol =&gt; &quot;alert&quot;) %&gt;</code> 就可以得到一个警告图标。</p><p>我们也尝试了如下好几种在页面中添加 SVG 图标的方法，但有些由于受到 GitHub 生产环境的限制而失败了。</p><ol><li>最开始我们尝试提供一个单一的“SVG 仓库”，然后用 <code>&lt;use&gt;</code> 元素来引入 SVG 拼图中的单个图形。在我们当前的跨域安全策略和资源管道条件下，使用外部提供 SVG 拼图很难做到。</li><li>SVG 背景，这种方式无法实时调整图标的颜色。</li><li>用 <code>&lt;img&gt;</code> 的 <code>src</code> 属性来引入 SVG，这种方式无法实时调整图标的颜色。</li><li>将“SVG 仓库”整个嵌入到每个页面，然后使用 <code>&lt;use&gt;</code> 把每个 SVG 都嵌入到整个 GitHub 的每个单页，但是想想就不对，特别是有时候这个页面一个图标都没用到。</li></ol><h3><span id="性能">性能</span></h3><p>在切换到 SVG 以后，我们还没发现<a href="https://cloud.githubusercontent.com/assets/54012/13176951/eedb1330-d6e3-11e5-8dfb-99932ff7ee25.png" target="_blank" rel="external">页面加载和性能</a>上有任何不良影响。我们之前曾预计渲染时间会大幅下降，但往往性能和人的感知更相关。由于 SVG 图标被渲染为了指定宽高的图像，页面也不再会像之前那样<a href="http://jankfree.org/" target="_blank" rel="external">闪动</a>了。</p><p>同时由于我们不再输出字体相关的 CSS，我们还能<a href="https://cloud.githubusercontent.com/assets/54012/13176888/70d42346-d6e3-11e5-88eb-0ca0a393392c.png" target="_blank" rel="external">干掉一些多余的 CSS 代码</a>。</p><h3><span id="缺点和坑">缺点和坑</span></h3><ul><li>Firefox 对 SVG 仍然有像素值计算的问题，虽然图标字体也有相同的问题。</li><li>如果你需要 SVG 有背景色，你可能需要在外面包一层额外的 <code>div</code>。</li><li>由于 SVG 是作为图片提供的，某些 CSS 的覆盖问题也需要重新考量。如果你看到我们的页面布局有任何奇怪的地方，请告知。</li><li>IE 浏览器下，需要对 SVG 元素指定宽高属性，才能正常显示大小。</li><li>在技术方案升级过程中，我们层同时输出 SVG 和图标字体。在我们仍然为每个 SVG 图标指定 <code>font-family</code> 时会导致 IE 崩溃。在完全转用 SVG 以后，这个问题就解决了。</li></ul><h2><span id="总结">总结</span></h2><p>通过换掉图标字体，我们能更方便、更快速、更有可访问性地提供图标了。而且它们看起来也更棒了。享受吧。</p><p>[完]</p><p class="j-quote">原文：<a href="https://github.com/blog/2112-delivering-octicons-with-svg" target="_blank" rel="external">Delivering Octicons with SVG</a></p><h2><span id="更多阅读">更多阅读</span></h2><ul><li><a href="https://speakerdeck.com/ninjanails/death-to-icon-fonts" target="_blank" rel="external">Death to Icon Fonts</a></li><li><a href="https://kartikprabhu.com/articles/inline-svg-icons" target="_blank" rel="external">Inline SVG Icons</a></li><li><a href="https://css-tricks.com/icon-fonts-vs-svg/" target="_blank" rel="external">Inline SVG vs Icon Fonts</a></li><li><a href="http://www.w3cways.com/1733.html" target="_blank" rel="external">Web 设计新趋势: 使用 SVG 代替 Web Icon Font</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;github.com&quot;&gt;GitHub&lt;/a&gt; 不再使用字体来输出图标了。我们把代码中所有的 &lt;a href=&quot;http://octicons.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Octicon&lt;/a&gt; 替换成了 SVG 版本。虽然这些改动并不那么明显，但马上你就能体会到 SVG 图标的优点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/images/svg-vs-iconfont.png&quot; alt=&quot;左侧放大后的字体版本和右侧清晰的 SVG 版本&quot;&gt;&lt;/p&gt;
&lt;p&gt;切换到 SVG 以后，图标会作为图片渲染而非文字，这使其在任何分辨率下都能很好地以各种像素值显示。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML" scheme="http://bubkoo.com/categories/html/"/>
    
    
      <category term="SVG" scheme="http://bubkoo.com/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>如何将 npm 作为构建工具使用</title>
    <link href="http://bubkoo.com/2016/03/18/how-to-use-npm-as-a-build-tool/"/>
    <id>http://bubkoo.com/2016/03/18/how-to-use-npm-as-a-build-tool/</id>
    <published>2016-03-18T15:54:37.000Z</published>
    <updated>2016-03-18T15:54:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>上个月，我在这篇文章<a href="http://blog.keithcirkel.co.uk/why-we-should-stop-using-grunt/" target="_blank" rel="external">《为什么要停止使用 Grunt 和 Gulp》</a>中建议大家使用 npm 作为替代方案，npm 的 <code>scripts</code> <a href="https://www.npmjs.org/doc/misc/npm-scripts.html" target="_blank" rel="external">配置</a>可以实现这些构建工具的所有功能，而且更简洁、更优雅和较少的模块依赖和维护开销。本文第一稿大概有 6000 字，深入讲解了如何将 npm 作为替代方案，但那篇文章主要在表达我的观点，而不是作为一篇教程。然而，读者的反馈却很强烈，许多读者告诉我 npm 并不能完全实现这些构建工具提供的特性，甚至有的读者直接给我一个 <code>Gruntfile</code>，然后反问我：“怎么用 npm 来实现这样的构建方案”？所以我决定进一步更新本文，将其作为一个新手入门教程，主要分享如何使用 npm 来完成一些常见的构建任务。</p><p>npm 是一个很好的工具，提供了一些奇特的功能，也是 NodeJS 的核心，包括我在内的很多人每天都在使用 npm，事实上在我的 Bash 历史记录中，npm 的使用频率仅次于 git。npm 更新也很快，旨在使 npm 成为一个强大的模块管理工具。而且，npm 有一个功能子集，可以通过运行一些任务来维护模块的生命周期，换句话说，它也是一个强大的构建工具。</p><a id="more"></a><h2><span id="scripts-配置">scripts 配置</span></h2><p>首先，我们需要搞清楚如何使用 npm 来管理构建脚本。作为核心命令之一的 <code>npm run-script</code> 命令（简称 <code>npm run</code> ）可以从 <code>package.json</code> 中解析出 <code>scripts</code> 对象，然后将该对象的键作为 <code>npm run</code> 的第一个参数，它会在操作系统的默认终端中执行该键对应的命令，请看下面的 <code>package.json</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"myproject"</span>,</div><div class="line">  <span class="attr">"devDependencies"</span>: &#123;</div><div class="line">    <span class="attr">"jshint"</span>: <span class="string">"latest"</span>,</div><div class="line">    <span class="attr">"browserify"</span>: <span class="string">"latest"</span>,</div><div class="line">    <span class="attr">"mocha"</span>: <span class="string">"latest"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">    <span class="attr">"lint"</span>: <span class="string">"jshint **.js"</span>,</div><div class="line">    <span class="attr">"test"</span>: <span class="string">"mocha test/"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果运行 <code>npm run lint</code>，npm 将在终端中执行 <code>jshint **.js</code>，如果运行 <code>npm run test</code>，npm 将在终端中执行 <code>mocha test/</code>。执行 <code>npm run xxx</code> 时会将 <code>node_modules/.bin</code> 加入终端的 <code>PATH</code> 环境变量中，这样你就可以直接运行那些作为依赖安装的二进制模块，也就是说你不需要 <code>&quot;./node_modules/.bin/jshint **.js&quot;</code> 或 <code>&quot;$(npm bin)/jshint **.js&quot;</code> 这样来指定命令的路径。如果执行不带参数的 <code>npm run</code> 命令，它将列举出目前可执行的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Available scripts in the user-service package:  </div><div class="line">  lint</div><div class="line">     jshint **.js</div><div class="line">  test</div><div class="line">    mocha test/</div></pre></td></tr></table></figure><h2><span id="快捷命令">快捷命令</span></h2><p>npm 为一些命令提供了快捷方式：<code>npm test</code>，<code>npm start</code> 和 <code>npm stop</code>，例如 <code>npm test</code> 就是 <code>npm run test</code> 的快捷命令，快捷命令存在的原因有二：</p><ol><li>这些是大多数项目都将使用的通用任务，所以不必每次都需要输入如此之多字符。</li><li>更重要的是，这为测试、启动和停止模块提供了对应的标准接口。一些持续集成工具（比如 Travis）就充分利用了这一特性，将 <code>npm test</code> 作为 NodeJS 模块的默认命令。这也可以使开发者加入一个新项目更加容易，他们不需要阅读文档就知道可以运行像 <code>npm test</code> 这样的命令。</li></ol><h2><span id="钩子">钩子</span></h2><p>另一个炫酷的特性是，可以在 <code>scripts</code> 中为任何可执行的命令指定 <code>pre-</code> 和 <code>post-</code> 钩子。例如，当运行 <code>npm run lint</code> 时，即便是没有在 <code>scripts</code> 中定义对应的 <code>pre-</code> 命令，npm 也会首先执行 <code>npm run prelint</code>，接着才是 <code>npm run lint</code>，最后是 <code>npm run postlint</code>。</p><p>这个规则适用于所有命令，<code>npm test</code> 也一样（<code>npm run pretest</code>，<code>npm run test</code>，<code>npm run posttest</code>）。并且这些命令可以感知 <code>exit-code</code>，也就是说如果 <code>pretest</code> 命令退出时返回了非零的 <code>exit-code</code>，那么后续的 <code>test</code> 和 <code>posttest</code> 命令都不会继续执行。需要注意的是钩子不能嵌套，比如 <code>prepretest</code> 这样的命令将被忽略。</p><p>npm 也为一些内置命令（<code>install</code>，<code>uninstall</code>，<code>publish</code> 和 <code>update</code>）提供了钩子，用户不能重写这些内置命令的行为，但可以通过钩子来影响这些命令的行为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">    "lint": "jshint **.js",</div><div class="line">    "build": "browserify index.js &gt; myproject.min.js",</div><div class="line">    "test": "mocha test/",</div><div class="line"></div><div class="line">    "prepublish": "npm run build # also runs npm run prebuild",    </div><div class="line">    "prebuild": "npm run test # also runs npm run pretest",</div><div class="line">    "pretest": "npm run lint"</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h2><span id="传递参数">传递参数</span></h2><p>npm <a href="http://blog.npmjs.org/post/98131109725/npm-2-0-0" target="_blank" rel="external">2.0.0</a> 之后可以为命令传递参数，请看下面例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">    "test": "mocha test/",</div><div class="line">    "test:xunit": "npm run test -- --reporter xunit"</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>我们可以直接运行 <code>npm run test</code> 也就是 <code>mocha test/</code>，我们还可以在命令后面加上 <code>--</code> 来传递自定义的参数，比如 <code>npm run test -- anothertest.js</code> 将运行 <code>mocha test/ anothertest.js</code>，一个更实用的例子是 <code>npm run test -- --grep parser</code>，将运行 <code>mocha test/ --grep parser</code>。这可以让我们将一些命令组合起来使用，并提供一些高级配置项。</p><h2><span id="自定义变量">自定义变量</span></h2><p>可以在 <code>package.json</code> 文件中的 <a href="https://www.npmjs.org/doc/misc/npm-config.html#per-package-config-settings" target="_blank" rel="external">config</a> 中指定任意数量的变量，然后我们可以在 <code>scripts</code> 中像使用环境变量一样来使用这些变量：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">"name": "fooproject",</div><div class="line">  "config": &#123;</div><div class="line">    "reporter": "xunit"</div><div class="line">  &#125;,</div><div class="line">  "scripts": &#123;</div><div class="line">    "test": "mocha test/ --reporter $npm_package_config_reporter",</div><div class="line">    "test:dev": "npm run test --fooproject:reporter=spec"</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>在 <code>config</code> 中的所有属性都将加上 <code>npm_package_config_</code> 前缀暴露到环境变量中，在上面的 <code>config</code> 对象中有一个值为 <code>xunit</code> 的 <code>reporter</code> 属性，所以运行 <code>npm run test</code> 时，将执行 <code>mocha test/ --reporter xunit</code>。</p><p>可以通过如下两种方式来覆盖变量的值：</p><ol><li>和上例中的 <code>test:dev</code> 一样，可以通过 <code>--fooproject:reporter=spec</code> 将  <code>reporter</code> 变量的值指定为 <code>spec</code>。具体使用时，你需要将 <code>fooproject</code> 替换为你自己的项目名，同时将 <code>reporter</code> 替换为你需要替换的变量名。</li><li>通过用户配置来覆盖，通过运行 <code>npm config set fooproject:reporter spec</code> 将会在 <code>&lt;sub&gt;/.npmrc</code> 文件中添加 <code>fooproject:reporter=spec</code> 项，运行 npm 时将动态读取这些配置并且替换 <code>npm_package_config_reporter</code> 变量的值，这意味着运行 <code>npm run test</code> 将执行 <code>mocha test/ --reporter spec</code>。可以通过运行 <code>npm config delete fooproject:reporter</code> 来删除这些个人配置项。比较优雅的方式是在 <code>package.json</code> 文件中为变量指定一些默认值，同时用户可以在 <code>&lt;/sub&gt;/.npmrc</code> 文件中自定义某些变量的值。</li></ol><p>老实说，我并不喜欢对这种定义和使用变量的方式，而且还有一个缺陷，那就是在 Windows 中引用变量是通过 <code>%</code> 加变量名，如果 <code>scripts</code> 中定义的是 NodeJS 脚本，并不会有什么问题，然而对于 shell 脚本却不兼容。</p><h2><span id="windows-的问题">Windows 的问题</span></h2><p>继续深入之前，我们先聊一个题外话。npm 依赖操作系统的 shell 作为其脚本运行的环境，Linux、Solaris、BSD 和 Mac OSX 都内置了 Bash 作为他们的默认 shell，而 Windows 却没有，在 Windows 中，npm 将使用 Windows 的命令行工具作为其运行环境。</p><p>但这也算不上什么大问题，Bash 和 Windows 中的许多语法都一样：</p><ul><li><code>&amp;&amp;</code> 连续执行多个命令，前面的命令执行成功后才执行后面的命令</li><li><code>&amp;</code> 连续执行多个命令，不管前面命令执行成功没有，后面的命令将继续执行 </li><li><code>&lt;</code> 使命令从文件读入 </li><li><code>&gt;</code> 把命令的输出重定向到文件中</li><li><code>|</code> 把命令的输出重定向到下一个命令</li></ul><p>最大的问题在于，某些命令的命名不同（<code>cp</code> 和 Windows 中的 <code>COPY</code>）和变量的引用方式（Windows 中使用 <code>%</code> 引用变量，而 Bash 却是使用 <code>$</code>）。但这些问题都是可以解的：</p><ol><li>对于某些特殊的命令，我们可以不使用系统内置的命令，而是使用具有相同功能的 npm 模块。例如我们可以使用 <a href="https://www.npmjs.org/package/rimraf" target="_blank" rel="external">rimraf</a> 这个模块来替代内置的 <code>rm</code> 命令。</li><li>只使用那些跨平台兼容的语法，即便是仅仅使用 <code>&amp;&amp;</code>，<code>&gt;</code>，<code>|</code> 和 <code>&lt;</code> 这些语法就可以完成很多令人惊讶的功能。环境变量的引用只是冰山一角。</li></ol><h2><span id="如何替换构建工具">如何替换构建工具</span></h2><p>现在我们回归正题，如果我们想要替换 Grunt 和 Gulp 这样的构建工具，我们需要实现这些构建工具及其插件的对等功能。我从各种项目和上篇文章的评论中收集了一些最流行的构建任务，下面我将演示如何通过 npm 来实现这些任务。</p><h3><span id="多文件处理">多文件处理</span></h3><p>在上一篇文章的评论中有几个人提到：构建工具的一个优势是可以使用 <code>*.js</code>， <code>*.min.css</code> 或 <code>assets/*/*</code> 这样的 <strong>globs</strong> 语法来进行多文件处理。事实上这个特性的灵感来源于 Bash 中的 <code>glob</code> 命令。 Shell 会将命令参数（如 <code>*.js</code>）中的星号解析为通配符，使用连续两个星号表示跨目录递归查询。如果你正在使用 Mac 或 Linux，你可以在终端中玩一下，比如 <code>ls *.js</code>。</p><p>现在的问题是，Windows 的命令行并不支持该特性。新运的是，Windows 会将参数（如 <code>*.js</code>）逐字完整地传递给命令，这样就可以为 Windows 安装对应的兼容库就可以实现 <code>glob</code> 语法。在 npm 中有两个最流行的 <code>glob</code> 包 <a href="https://www.npmjs.org/package/minimatch" target="_blank" rel="external">minimatch</a> 和 <a href="https://www.npmjs.org/package/glob" target="_blank" rel="external">glob</a>，已经被 <code>1500</code> 多个项目依赖，包括 JSHint，JSCS，Mocha，Jade，Stylus，Node-Sass…等等，而且这个数量还在增长。</p><p>这样你就可以在 <code>scripts</code> 中直接使用 <code>glob</code> 语法了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">  "jshint": "latest"</div><div class="line">&#125;,</div><div class="line">"scripts": &#123;</div><div class="line">  "lint": "jshint *.js"</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="执行多任务">执行多任务</span></h3><p>在 Grunt 和 Gulp 中可以将一些任务组合起来成为一个新的命令，尤其是在构建或测试时非常实用。在 npm 中有两种方式可以解这个问题：一是通过 <code>pre-</code> 和 <code>post-</code> 钩子，如果在执行某个任务之前需要执行某个任务（如压缩之前合并文件），这是个不错的选择；另外你还可以实用 <code>&amp;&amp;</code> 这个命令连接符：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">  "jshint": "latest",</div><div class="line">  "stylus": "latest",</div><div class="line">  "browserify": "latest"</div><div class="line">&#125;,</div><div class="line">"scripts": &#123;</div><div class="line">  "lint": "jshint **",</div><div class="line">  "build:css": "stylus assets/styles/main.styl &gt; dist/main.css",</div><div class="line">  "build:js": "browserify assets/scripts/main.js &gt; dist/main.js",</div><div class="line">  "build": "npm run build:css &amp;&amp; npm run build:js",</div><div class="line">  "prebuild:js": "npm run lint"</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上例中 <code>build</code> 包含了 <code>build:css</code> 和 <code>build:js</code> 两个任务，并且在执行 <code>build:js</code> 前将先执行 <code>lint</code> 任务。独立执行 <code>build:css</code> 或 <code>build:js</code> 也是可行的，单独执行 <code>build:js</code> 前也会先执行 <code>lint</code>。所以我们可以像这样来组合我们的任务，并且这是 Windows 兼容的。</p><h3><span id="使用数据流">使用数据流</span></h3><p>Gulp 一个最大的特性是使用流将一个任务的输出 <strong>pipe</strong> 到下一个任务（Grunt 需要频繁地读取和保存文件）。在 Bash 和 Windows 的命令行中都有 <code>|</code> 这个管道操作符，可以用来将一个命令的输出（<code>stdout</code>）作为下一个命令的输入（<code>stdin</code>）。比方说对一个 CSS 文件，你想先通过 <a href="https://github.com/postcss/autoprefixer" target="_blank" rel="external">Autoprefixer</a> 处理，然后 <a href="https://github.com/jbleuzen/node-cssmin" target="_blank" rel="external">CSSMin</a>，最后保存到文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">  "autoprefixer": "latest",</div><div class="line">  "cssmin": "latest"</div><div class="line">&#125;,</div><div class="line">"scripts": &#123;</div><div class="line">  "build:css": "autoprefixer -b 'last 2 versions' &lt; assets/styles/main.css | cssmin &gt; dist/main.css"</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就像你看到的那样，首先通过 <code>autoprefixer</code> 为我们的 CSS 添加浏览器厂商前缀，然后将其输出 <strong>pipe</strong> 到 <code>cssmin</code> 来压缩我们的 CSS，最后将整个输出保存到 <code>dist/main.css</code> 文件。绝大多数工具都支持 <code>stdin</code> 和 <code>stdout</code>，而且上述代码可以在 Windows，Mac 和 Linux 平台下完美兼容。</p><h3><span id="版本号">版本号</span></h3><p>版本号管理是 Grunt 和 Gulp 中的一个常见任务，可以方便地将 <code>package.json</code> 中的版本号加一，为项目打 Tag 和 Commit。</p><p>npm 的一个核心功能就是版本管理，运行 <code>npm version patch</code> 就可以增加修订版本号：<code>1.1.1 -&gt; 1.1.2</code>，运行 <code>npm version minor</code> 可以增加次要版本号：<code>1.1.1 -&gt; 1.2.0</code>，运行 <code>npm version major</code> 可以增加主版本号：<code>1.1.1 -&gt; 2.0.0</code>，这几个命令将自动为你的项目打 Tag 和 Commit，就剩下 <code>git push</code> 和 <code>npm publish</code> 了。</p><p>还可以自定义这几个命令的行为。如果不想为项目打 Tag，你可以在命令后面加上 <code>--git-tag-version=false</code>，或者通过 <code>npm config set git-tag-version false</code> 将其设置为默认项。如果想自定义提交信息呢？可以这样 <code>npm version patch -m &quot;Bumped to %s&quot;</code>，或直接设置为默认项 <code>npm config set message &quot;Bumped to %s&quot;</code>。甚至可以通过 <code>--sign-git-tag=true</code> 为 Tag 签名，也可以通过 <code>npm config set sign-git-tag true</code> 将其设置为默认项。</p><h3><span id="清理">清理</span></h3><p>很多构建工具都会有一个 <code>clean</code> 任务，用来清理构建过程或构建后生成的文件，在 Bash 中自带了一个清理命令 <code>rm</code>，在命令后面加上 <code>-r</code> 参数可以递归删除目录。这个命令再简单不过了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">  "clean": "rm -r dist/*"</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果想兼容 Windows 可以使用 <a href="https://www.npmjs.org/package/rimraf" target="_blank" rel="external">rimraf</a> 这个平台无关的兼容模块：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">  "rimraf": "latest"</div><div class="line">&#125;,</div><div class="line">"scripts": &#123;</div><div class="line">  "clean": "rimraf dist"</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="文件名-hash-化">文件名 Hash 化</span></h3><p>在 Grunt 和 Gulp 分别有 <a href="https://www.npmjs.org/package/grunt-hash" target="_blank" rel="external">grunt-hash</a> 和 <a href="https://www.npmjs.org/package/gulp-hash" target="_blank" rel="external">gulp-hash</a> 两个插件，用来根据文件的内容生成一个 hash 化后的文件名。要用已有的命令来实现这个功能还是比较难，我搜索了 npm 模块，也没有找到具有相同功能的模块，所以最后我自己实现了一个 - <a href="https://github.com/keithamus/hashmark" target="_blank" rel="external">hashmark</a>。该支持流操作，可以作为某些 Grunt/Gulp 插件的依赖项。继续之前的例子，我们可以将构建结果 <strong>pipe</strong> 到一个具有 hash 值文件名的文件中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">  "autoprefixer": "latest",</div><div class="line">  "cssmin": "latest"</div><div class="line">&#125;,</div><div class="line">"scripts": &#123;</div><div class="line">  "build:css": "autoprefixer -b '&gt; 5%' &lt; assets/styles/main.css | cssmin | hashmark -l 8 'dist/main.#.css'"</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在执行 <code>build:css</code> 任务将得到一个类似 <code>dist/main.3ecfca12.css</code> 这样的文件。</p><h3><span id="watch">Watch</span></h3><p>这也是 Grunt/Gulp 备受欢迎的原因之一，很多构建工具都支持监视文件系统的变化然后执行相应的构建或刷新任务，这在开发过程中非常实用。这也是在上篇文章中许多开发者关注的问题之一，他们认为如果没有 <code>watch</code> 类似的任务就黯然失色了。</p><p>好吧，其实很多工具自身就提供了这个选项，可以用于监听复杂的文件系统。比如 <a href="https://www.npmjs.org/package/mocha" target="_blank" rel="external">Mocha</a> 就提供了 <code>-w</code> 选项，还有 <a href="https://www.npmjs.org/package/stylus" target="_blank" rel="external">Stylus</a>、<a href="https://www.npmjs.org/package/node-sass" target="_blank" rel="external">Node-Sass</a>、<a href="https://www.npmjs.org/package/jade" target="_blank" rel="external">Jade</a> 和 <a href="https://www.npmjs.org/package/karma" target="_blank" rel="external">Karma</a> 等等。你可以这样使用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">  "mocha": "latest",</div><div class="line">  "stylus": "latest"</div><div class="line">&#125;,</div><div class="line">"scripts": &#123;</div><div class="line">  "test": "mocha test/",</div><div class="line">  "test:watch": "npm run test -- -w",</div><div class="line"></div><div class="line">  "css": "stylus assets/styles/main.styl &gt; dist/main.css",</div><div class="line">  "css:watch": "npm run css -- -w"</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当然，并不是所有工具都提供了该选项，就算都有这个选项，有时候你还希望在文件变化时触发某个任务集合，不用担心，有很多模块可以监视文件变化，并在文件变化是触发某个命令，比如 <a href="https://www.npmjs.org/package/watch" target="_blank" rel="external">watch</a>、<a href="https://www.npmjs.org/package/onchange" target="_blank" rel="external">onchange</a>、 <a href="https://www.npmjs.org/package/dirwatch" target="_blank" rel="external">dirwatch</a> 这些模块，甚至可以用 <a href="https://github.com/remy/nodemon" target="_blank" rel="external">nodemon</a>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">  "stylus": "latest",</div><div class="line">  "jade": "latest",</div><div class="line">  "browserify": "latest",</div><div class="line">  "watch": "latest",</div><div class="line">&#125;,</div><div class="line">"scripts": &#123;</div><div class="line">  "build:js": "browserify assets/scripts/main.js &gt; dist/main.js",</div><div class="line">  "build:css": "stylus assets/styles/main.styl &gt; dist/main.css",</div><div class="line">  "build:html": "jade assets/html/index.jade &gt; dist/index.html",</div><div class="line">  "build": "npm run build:js &amp;&amp; npm run build:css &amp;&amp; npm run build:html",</div><div class="line">  "build:watch": "watch 'npm run build' .",</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就是这么简单，仅仅 13 行配置就可以监视整个项目文件，当任何文件改变时就自动执行构建 HTML、CSS 和 JS 的任务，直接执行 <code>npm run build:watch</code> 就可以开始无痛开发了。使用一个我写的模块 <a href="https://www.npmjs.org/package/parallelshell" target="_blank" rel="external">Parallelshell</a>，用于并发执行多个命令，我们还可以做一些优化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">  "stylus": "latest",</div><div class="line">  "jade": "latest",</div><div class="line">  "browserify": "latest",</div><div class="line">  "watch": "latest",</div><div class="line">  "parallelshell": "latest"</div><div class="line">&#125;,</div><div class="line">"scripts": &#123;</div><div class="line">  "build:js": "browserify assets/scripts/main.js &gt; dist/main.js",</div><div class="line">  "watch:js": "watch 'npm run build:js' assets/scripts/",</div><div class="line">  "build:css": "stylus assets/styles/main.styl &gt; dist/main.css",</div><div class="line">  "watch:css": "watch 'npm run build:css' assets/styles/",</div><div class="line">  "build:html": "jade index.jade &gt; dist/index.html",</div><div class="line">  "watch:html": "watch 'npm run build:html' assets/html",</div><div class="line">  "build": "npm run build:js &amp;&amp; npm run build:css &amp;&amp; npm run build:html",</div><div class="line">  "build:watch": "parallelshell 'npm run watch:js' 'npm run watch:css' 'npm run watch:html'",</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行 <code>npm run build:watch</code> 时将通过 <a href="https://www.npmjs.org/package/parallelshell" target="_blank" rel="external">Parallelshell</a> 分别运行独立的监视任务，如果只有 CSS 文件发生了变化，那么将只执行 CSS 构建任务。<a href="https://www.npmjs.org/package/parallelshell" target="_blank" rel="external">Parallelshell</a> 将每个任务的输出（<code>stdout</code> 和 <code>stderr</code>）连接到主进程，并监听了 <code>exitCode</code> 来确保构建任务的日志输出（这与 <code>&amp;</code> 这个命令连接符不同）。</p><h3><span id="livereload">LiveReload</span></h3><p>LiveReload 也是一个很受欢迎的特性：当文件变化时自动刷新浏览器中的页面，<a href="https://www.npmjs.org/package/live-reload" target="_blank" rel="external">live-reload</a> 这个 npm 模块可以实现这个功能，看下面例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">  "live-reload": "latest",</div><div class="line">&#125;,</div><div class="line">"scripts": &#123;</div><div class="line">  "livereload": "live-reload --port 9091 dist/",</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- In your HTML file --&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//localhost:9091"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>执行 <code>npm run livereload</code> 后，<code>dist/</code> 目录下的任何改变都将通知到你访问的 HTML 页面，并触发页面自动刷新。</p><h3><span id="自定义脚本">自定义脚本</span></h3><p>那么如果一个模块并没有提供相应的命令行工具，如 <a href="https://www.npmjs.org/package/favicons" target="_blank" rel="external">favicon</a>，该怎么办呢？我们可以自己写一段 JavaScript 脚本来执行相应的功能，这也正是 Grunt/Gulp 插件所做的事情，还可以给模块维护者提交 PullRequest 让他们提供一个命令行工具：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// scripts/favicon.js</span></div><div class="line"><span class="keyword">var</span> favicons = <span class="built_in">require</span>(<span class="string">'favicons'</span>);  </div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);  </div><div class="line">favicons(&#123;  </div><div class="line">    source: path.resolve(<span class="string">'../assets/images/logo.png'</span>),</div><div class="line">    dest: path.resolve(<span class="string">'../dist/'</span>),</div><div class="line">&#125;);</div></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">  "favicons": "latest",</div><div class="line">&#125;,</div><div class="line">"scripts": &#123;</div><div class="line">  "build:favicon": "node scripts/favicon.js",</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="一个相对复杂的例子">一个相对复杂的例子</span></h2><p>在上篇文章的评论中有些人说我忽视构建工具的关键点：构建工具不仅仅是用于执行单个任务，更重要的是它们可以将单个任务连接起来成为复杂的构建流程。所以这里我就将上面演示过的例子组合起来成为一个复杂的构建任务，这和具有上百行代码的 <code>Gruntfile</code> 所做的事情一样。在本例中我想完成以下构建任务：</p><ul><li>Lint、Test 和编译 JS 文件，生成对应的 sourcemap，hash 化文件名，最后上传到  S3</li><li>将 Stylus 编译为一个独立的 Hash 化的 CSS 文件，生成对应的 sourcemap，并上传到  S3</li><li>为编译后测试添加 watcher</li><li>启动一个静态服务器，用于浏览和测试编译结果</li><li>为 CSS 和 JS 文件添加 livereload</li><li>设计一个与构建环境相关的总任务，将所有相关任务包括进来，这样就可以运行这个简单的命令来完成复杂的构建过程</li><li>自动打开浏览器并访问我们的测试页面</li></ul><p>我将本例的完整代码放在 <a href="https://github.com/keithamus/npm-scripts-example" target="_blank" rel="external">npm-scripts-example</a> 这个代码库中，下面是我们最关注的部分：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">    "clean": "rimraf dist/*",</div><div class="line"></div><div class="line">    "prebuild": "npm run clean -s",</div><div class="line">    "build": "npm run build:scripts -s &amp;&amp; npm run build:styles -s &amp;&amp; npm run build:markup -s",</div><div class="line">    "build:scripts": "browserify -d assets/scripts/main.js -p [minifyify --compressPath . --map main.js.map --output dist/main.js.map] | hashmark -n dist/main.js -s -l 8 -m assets.json 'dist/&#123;name&#125;&#123;hash&#125;&#123;ext&#125;'",</div><div class="line">    "build:styles": "stylus assets/styles/main.styl -m -o dist/ &amp;&amp; hashmark -s -l 8 -m assets.json dist/main.css 'dist/&#123;name&#125;&#123;hash&#125;&#123;ext&#125;'",</div><div class="line">    "build:markup": "jade assets/markup/index.jade --obj assets.json -o dist",</div><div class="line"></div><div class="line">    "test": "karma start --singleRun",</div><div class="line"></div><div class="line">    "watch": "parallelshell 'npm run watch:test -s' 'npm run watch:build -s'",</div><div class="line">    "watch:test": "karma start",</div><div class="line">    "watch:build": "nodemon -q -w assets/ --ext '.' --exec 'npm run build'",</div><div class="line"></div><div class="line">    "open:prod": "opener http://example.com",</div><div class="line">    "open:stage": "opener http://staging.example.internal",</div><div class="line">    "open:dev": "opener http://localhost:9090",</div><div class="line"></div><div class="line">    "deploy:prod": "s3-cli sync ./dist/ s3://example-com/prod-site/",</div><div class="line">    "deploy:stage": "s3-cli sync ./dist/ s3://example-com/stage-site/",</div><div class="line"></div><div class="line">    "serve": "http-server -p 9090 dist/",</div><div class="line">    "live-reload": "live-reload --port 9091 dist/",</div><div class="line"></div><div class="line">    "dev": "npm run open:dev -s &amp; parallelshell 'npm run live-reload -s' 'npm run serve -s' 'npm run watch -s'"</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>上面的 <code>-s</code> 是禁止 npm 输出任何日志信息，你可以尝试删除这个选项来看看有什么不同。</p><p>如果用 Grunt 来完成相同的构建任务，则需要上百行的 <code>Gruntfile</code> 代码，并且还需要十多个额外的模块。就可读性而言，npm 的 scripts 虽然表面上可读性并不是那么高，但就我而言我可以脚本语言更加容易被理解，每个任务所做的事情也更加清楚。 </p><h2><span id="总结">总结</span></h2><p>希望通过本文你了解到了 npm 在构建方面的能力，当需要构建一个项目时 Grunt/Gulp 并不一定是首选工具，或许 npm 就能满足你的需求。</p><p>[完]</p><p class="j-quote">原文：<a href="http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/" target="_blank" rel="external">How to Use npm as a Build Tool</a></p><h2><span id="参考阅读">参考阅读</span></h2><ul><li><a href="http://blog.keithcirkel.co.uk/why-we-should-stop-using-grunt/" target="_blank" rel="external">Why we should stop using Grunt &amp; Gulp</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上个月，我在这篇文章&lt;a href=&quot;http://blog.keithcirkel.co.uk/why-we-should-stop-using-grunt/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《为什么要停止使用 Grunt 和 Gulp》&lt;/a&gt;中建议大家使用 npm 作为替代方案，npm 的 &lt;code&gt;scripts&lt;/code&gt; &lt;a href=&quot;https://www.npmjs.org/doc/misc/npm-scripts.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配置&lt;/a&gt;可以实现这些构建工具的所有功能，而且更简洁、更优雅和较少的模块依赖和维护开销。本文第一稿大概有 6000 字，深入讲解了如何将 npm 作为替代方案，但那篇文章主要在表达我的观点，而不是作为一篇教程。然而，读者的反馈却很强烈，许多读者告诉我 npm 并不能完全实现这些构建工具提供的特性，甚至有的读者直接给我一个 &lt;code&gt;Gruntfile&lt;/code&gt;，然后反问我：“怎么用 npm 来实现这样的构建方案”？所以我决定进一步更新本文，将其作为一个新手入门教程，主要分享如何使用 npm 来完成一些常见的构建任务。&lt;/p&gt;
&lt;p&gt;npm 是一个很好的工具，提供了一些奇特的功能，也是 NodeJS 的核心，包括我在内的很多人每天都在使用 npm，事实上在我的 Bash 历史记录中，npm 的使用频率仅次于 git。npm 更新也很快，旨在使 npm 成为一个强大的模块管理工具。而且，npm 有一个功能子集，可以通过运行一些任务来维护模块的生命周期，换句话说，它也是一个强大的构建工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://bubkoo.com/categories/tools/"/>
    
    
      <category term="npm" scheme="http://bubkoo.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>任何人都可以使用到的 Gist 服务</title>
    <link href="http://bubkoo.com/2016/02/24/what-you-can-do-with-gists-on-github/"/>
    <id>http://bubkoo.com/2016/02/24/what-you-can-do-with-gists-on-github/</id>
    <published>2016-02-24T10:22:25.000Z</published>
    <updated>2016-02-24T10:22:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/" target="_blank" rel="external">Github</a> 作为代码分享平台在开发者中非常流行。此平台托管了包括游戏、书籍以至于字体在内的一千两百多万个开源项目（现在更多），这使其成为互联网上最大的代码库。Github 还提供另一个非常有用的功能，这就是 <a href="https://gist.github.com/" target="_blank" rel="external">Gist</a>。开发人员常常使用 Gist 记录他们的代码片段，但是 Gist 不仅仅是为极客和码农开发的，每个人都可以用到它。如果您听说过类似 Pastebin 或 Pastie 这样的 Web 应用的话，那您就可以看到它们和 Gist 很像，但是 Gist 比它们要更优雅，因为这些免费应用一般含有广告，而且带有很多其他杂七杂八的功能。</p><p>如果您不是极客您也可以按照如下方式使用Gist：</p><a id="more"></a><h2><span id="匿名张贴">匿名张贴</span></h2><p>您不需要拥有 Github 账号就可以使用 Gist。用浏览器打开 <a href="http://gist.github.com" target="_blank" rel="external">http://gist.github.com</a>，在窗口中写下你想说的就可以创建一个 Gist。您可以发布一个私密的 Gist，也就是说这个 Gist 将不能被他人搜索到而只对直接在浏览器中输入其 URL 的人可见。</p><h2><span id="像-wiki-一样记录历史">像 Wiki 一样记录历史</span></h2><p>如果您修改了已经发布了的 Gist 的话，之前的所有版本都将被保存。您可以点击 Revisions 按钮按时间浏览，而且您可以通过内置的 diff 引擎查看任意两个版本间的差异。这也可以用于<a href="http://www.labnol.org/internet/tools/google-docs-free-online-file-comparison-software/2414/" target="_blank" rel="external">比较文本文件</a>。</p><p><img src="http://bubkoo.qiniudn.com/images/file-difference.png" alt=""></p><h2><span id="发布富文本内容">发布富文本内容</span></h2><p>虽然 Gist 只能用纯文本来写，但是您可以用 <a href="https://help.github.com/articles/markdown-basics" target="_blank" rel="external">Markdown</a> 来发布 html 格式的 Gist。您可以添加列表、图片（已有图床上的）和<a href="http://www.labnol.org/software/embed-tables-spreadsheet-data-in-websites/7435/" target="_blank" rel="external">表格</a>。当您用 Markdown 的时候不要忘了文件名要以 <code>.md</code> 作为后缀名。</p><p><img src="http://bubkoo.qiniudn.com/images/markdown-gist.png" alt=""></p><h2><span id="把-gist-当作一个写作平台">把 Gist 当作一个写作平台</span></h2><p>虽然现在有很多写作引擎，比如 Blogger、Medium、Tumblr，但您还可以用 Gist 来快速发布您的作品。您可以用纯文本或者 Markdown 等文档标记语言些一个 Gist 然后用 <a href="http://roughdraft.io" target="_blank" rel="external">http://roughdraft.io</a> 来把它作为一个独立的网页发布。</p><h2><span id="托管单个页面">托管单个页面</span></h2><p>Bl.ocks 是一个非常有趣的专为 Gist 开发的应用。您可以用纯文本把 HTML、CSS、JavaScript 代码写下来以 index.html 为文件名保存为 Gist，然后用 <a href="http://bl.ocks.org/" target="_blank" rel="external">http://bl.ocks.org</a> 把渲染好的结果在浏览器中展示出来。比如，这个 <a href="https://gist.github.com/labnol/122d4de95c6a127b1c9b" target="_blank" rel="external">gist</a> 展示出来就是<a href="http://bl.ocks.org/labnol/raw/122d4de95c6a127b1c9b/" target="_blank" rel="external">这样</a>。</p><p>显然宽带限制是一个问题，但是 <a href="http://bl.ock.org" target="_blank" rel="external">http://bl.ock.org</a> 作为一个通过 Gist 托管 HTML 的工具仍然是相当不错的。当然您也可以用 <a href="http://www.labnol.org/internet/host-website-on-google-drive/28178/" target="_blank" rel="external">Google Drive</a>。</p><h2><span id="制作任务列表">制作任务列表</span></h2><p>您可以用 Gist 跟踪待处理任务（举个<a href="https://gist.github.com/labnol/8e1cdf64cd7b0c1a811e" target="_blank" rel="external">栗子</a>）。这是用<a href="https://github.com/blog/1375%0A-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="external">特殊的</a>纯文本语法写的但是你可以任意勾选。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">- </span>[x] Pick the flowers</div><div class="line"><span class="bullet">- </span>[ ] Call John 9303032332</div><div class="line"><span class="bullet">- </span>[x] Cancel cable subscription</div><div class="line"><span class="bullet">- </span>[ ] Book the flight tickets</div></pre></td></tr></table></figure><p>您可以勾选或者勾去任意选项，源文本将会自动变更。如果您的 Gist 是公有的的话，任何人都可以看到您的列表，但是只有您（拥有者）可以改变其勾选状态。注意：任务列表也可以在 issue 中建立，所有拥有写权限的人都可以 uncheck/check。</p><h2><span id="作为网页收藏夹">作为网页收藏夹</span></h2><p>在 Chrome 浏览器您可以找到一个叫 <a href="https://chrome.google.com/webstore/detail/cejmhmbmafamjegaebkjhnckhepgmido" target="_blank" rel="external">GistBox</a> 的插件，通过这个插件您可以在浏览网页时选择保存网页内容为 Gist。您甚至可以添加标注或标签以易于以后更容易找到它们。</p><h2><span id="把-gist-嵌入网页中">把 Gist 嵌入网页中</span></h2><p>用一行 JS 代码就可以把任何一条 Gist 嵌入到网页中。嵌入的 Gist 格式不发生任何变化，而且访问者可以非常方便的把它们 fork 到他们的 Github 中。要嵌入 WordPress 的话有这个<a href="http://wordpress.org/plugins/oembed-gist/" target="_blank" rel="external">插件</a>和这个<a href="http://en.support.wordpress.com/gist/" target="_blank" rel="external">短代码</a>可以使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://gist.github.com/username/gist-id.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><h2><span id="测量访问量">测量访问量</span></h2><p>您可以使用 Google Analytics 查看您的 Gist 的访问量。因为 Gist 纯文本中不允许运行 JS 代码，所以我们可以用 <a href="https://github.com/igrigorik/ga-beacon" target="_blank" rel="external">GA Beacon</a> 来记录实时访问 Gist 的情况。</p><p>把如下代码添加到 Gist 中，用 Markdown 格式保存，这样就在这个 Gist 中添加了一个透明追踪图像了。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![<span class="string">Analytics</span>](<span class="link">https://ga-beacon.appspot.com/UA-XXXXX-X/gist-id?pixel</span>)</div></pre></td></tr></table></figure><h2><span id="在桌面端管理gist">在桌面端管理Gist</span></h2><p><a href="http://www.gistoapp.com/" target="_blank" rel="external">Gisto</a> 是一个能让您在浏览器之外管理 Gist 的桌面应用。您可以对 Gist 进行搜索、编辑、查看历史和分享。 此应用可运行于苹果、微软和 linux 系统。当然您也可以用 <a href="http://www.gistboxapp.com/" target="_blank" rel="external">GistBox</a> 这个 Web 应用替代它。</p><p>您是不是对Gist有了一个全新的认识呢？</p><p class="j-quote">翻译来源：<a href="http://www.labnol.org/internet/github-gist-tutorial/28499/" target="_blank" rel="external">Github Gist Tutorial</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github&lt;/a&gt; 作为代码分享平台在开发者中非常流行。此平台托管了包括游戏、书籍以至于字体在内的一千两百多万个开源项目（现在更多），这使其成为互联网上最大的代码库。Github 还提供另一个非常有用的功能，这就是 &lt;a href=&quot;https://gist.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gist&lt;/a&gt;。开发人员常常使用 Gist 记录他们的代码片段，但是 Gist 不仅仅是为极客和码农开发的，每个人都可以用到它。如果您听说过类似 Pastebin 或 Pastie 这样的 Web 应用的话，那您就可以看到它们和 Gist 很像，但是 Gist 比它们要更优雅，因为这些免费应用一般含有广告，而且带有很多其他杂七杂八的功能。&lt;/p&gt;
&lt;p&gt;如果您不是极客您也可以按照如下方式使用Gist：&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://bubkoo.com/categories/tools/"/>
    
    
      <category term="Github" scheme="http://bubkoo.com/tags/github/"/>
    
      <category term="Gist" scheme="http://bubkoo.com/tags/gist/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化 - 资源预加载</title>
    <link href="http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/"/>
    <id>http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/</id>
    <published>2015-11-19T00:29:36.000Z</published>
    <updated>2015-11-19T00:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>当提到前端性能优化时，我们首先会联想到文件的合并、压缩，文件缓存和开启服务器端的 gzip 压缩等，这使得页面加载更快，用户可以尽快使用我们的 Web 应用来达到他们的目标。</p><p>资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。</p><p>引用 <a href="https://twitter.com/patrickhamann" target="_blank" rel="external">Patrick Hamann</a> 的<a href="http://patrickhamann.com/workshops/performance/tasks/2_Critical_Path/2_3.html" target="_blank" rel="external">解释</a>：</p><blockquote><p>预加载是浏览器对将来可能被使用资源的一种暗示，一些资源可以在当前页面使用到，一些可能在将来的某些页面中被使用。作为开发人员，我们比浏览器更加了解我们的应用，所以我们可以对我们的核心资源使用该技术。</p></blockquote><p>这种做法曾经被称为 <em>prebrowsing</em>，但这并不是一项单一的技术，可以细分为几个不同的技术：<code>DNS-prefetch</code>、<code>subresource</code> 和标准的 <code>prefetch</code>、<code>preconnect</code>、<code>prerender</code>。</p><a id="more"></a><h2><span id="dns-预解析-dns-prefetch">DNS 预解析 DNS-Prefetch</span></h2><p>通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。例如，我们将来可能从 <code>example.com</code> 获取图片或音频资源，那么可以在文档顶部的 <code>&lt;head&gt;</code> 标签中加入以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//example.com"</span>&gt;</span></div></pre></td></tr></table></figure><p>当我们从该 URL 请求一个资源时，就不再需要等待 DNS 的解析过程。该技术对使用第三方资源特别有用。</p><p>在 Harry Roberts 的<a href="http://csswizardry.com/2013/01/front-end-performance-for-web-designers-and-front-end-developers/#section:dns-prefetching" target="_blank" rel="external">文章</a>中提到：</p><blockquote><p>通过简单的一行代码就可以告知那些兼容的浏览器进行 DNS 预解析，这意味着当浏览器真正请求该域中的某个资源时，DNS 的解析就已经完成了。</p></blockquote><p>这似乎是一个非常微小的性能优化，显得也并非那么重要，但事实并非如此 – <a href="https://docs.google.com/presentation/d/18zlAdKAxnc51y_kj-6sWLmnjl6TLnaru_WH0LJTjP-o/present?slide=id.g120f70e9a_041" target="_blank" rel="external">Chrome 一直都做了类似的优化</a>。当在浏览器的地址栏中输入 URL 的一小段时，Chrome 就自动完成了 DNS 预解析（甚至页面预渲染），从而为每个请求节省了至关重要的时间。</p><h2><span id="预连接-preconnect">预连接 Preconnect</span></h2><p>与 DNS 预解析类似，<code>preconnect</code> 不仅完成 DNS 预解析，同时还将进行 TCP 握手和建立传输层协议。可以这样使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span>&gt;</span></div></pre></td></tr></table></figure><p>在 Ilya Grigorik 的<a href="https://www.igvita.com/2015/08/17/eliminating-roundtrips-with-preconnect/" target="_blank" rel="external">文章</a>中有更详细的介绍：</p><blockquote><p>现代浏览器都试着预测网站将来需要哪些连接，然后预先建立 socket 连接，从而消除昂贵的 DNS 查找、TCP 握手和 TLS 往返开销。然而，浏览器还不够聪明，并不能准确预测每个网站的所有预链接目标。好在，在 Firefox 39 和 Chrome 46 中我们可以使用 <code>preconnect</code> 告诉浏览器我们需要进行哪些预连接。</p></blockquote><h2><span id="预获取-prefetching">预获取 Prefetching</span></h2><p>如果我们确定某个资源将来一定会被使用到，我们可以让浏览器预先请求该资源并放入浏览器缓存中。例如，一个图片和脚本或任何可以被浏览器缓存的资源：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"image.png"</span>&gt;</span></div></pre></td></tr></table></figure><p>与 DNS 预解析不同，预获取真正请求并下载了资源，并储存在缓存中。但预获取还依赖于一些条件，某些预获取可能会被浏览器忽略，例如从一个非常缓慢的网络中获取一个庞大的字体文件。并且，Firefox 只会在<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ" target="_blank" rel="external">浏览器闲置</a>时进行资源预获取。</p><p>在 Bram Stein 的<a href="http://www.bramstein.com/writing/preload-hints-for-web-fonts.html" target="_blank" rel="external">帖子</a>中说到，这对 webfonts 性能提升非常明显。目前，字体文件必须等到 DOM 和 CSS 构建完成之后才开始下载，使用预获取就可以轻松绕过该瓶颈。</p><p><strong>注意：</strong>要测试资源的预获取有点困难，但在 Chrome 和 Firefox 的网络面板中都有资源预获取的记录。还需要记住，预获取的资源没有同源策略的限制。</p><h2><span id="subresources">Subresources</span></h2><p>这是另一个预获取方式，这种方式指定的预获取资源具有最高的优先级，在所有 <code>prefetch</code> 项之前进行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"subresource"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span>&gt;</span></div></pre></td></tr></table></figure><p>根据 <a href="https://www.chromium.org/spdy/link-headers-and-server-hint/link-rel-subresource" target="_blank" rel="external">Chrome 文档</a>：</p><blockquote><p><code>rel=prefetch</code> 为将来的页面提供了一种低优先级的资源预加载方式，而 <code>rel=subresource</code> 为当前页面提供了一种高优先级的资源预加载。</p></blockquote><p>所以，如果资源是当前页面必须的，或者资源需要尽快可用，那么最好使用 <code>subresource</code> 而不是 <code>prefetch</code>。</p><h2><span id="预渲染-prerender">预渲染 Prerender</span></h2><p>这是一个核武器，因为 <code>prerender</code> 可以预先加载文档的所有资源：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prerender"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span>&gt;</span></div></pre></td></tr></table></figure><p>Steve Souders 在他的<a href="http://www.stevesouders.com/blog/2013/11/07/prebrowsing/" target="_blank" rel="external">一篇文章</a>中写到：</p><blockquote><p>这类似于在一个隐藏的 tab 页中打开了某个链接 – 将下载所有资源、创建 DOM 结构、完成页面布局、应用 CSS 样式和执行 JavaScript 脚本等。当用户真正访问该链接时，隐藏的页面就切换为可见，使页面看起来就是瞬间加载完成一样。Google 搜索在其即时搜索页面中已经应用该技术多年了，微软也宣称将在 IE11 中支持该特性。</p></blockquote><p>需要注意的是不要滥用该特性，当你知道用户一定会点击某个链接时才可以进行预渲染，否则浏览器将无条件地下载所有预渲染需要的资源。</p><p>更多相关讨论：</p><blockquote><p>所有预加载技术都存在一个潜在的风险：对资源预测错误，而预加载的开销（抢占 CPU 资源，消耗电池，浪费带宽等）是高昂的，所以必须谨慎行事。虽然很难确定用户下一步将访问哪些资源，但高可信的场景确实存在：</p><ul><li>如果用户完成一个带有明显结果的搜索，那么结果页面很可能会被加载</li><li>如果用户进入到登陆页面，那么登陆成功的页面很可能会被加载</li><li>如果用户阅读一个多页的文章或访问一个分页的结果集，那么下一页很可能会被加载</li></ul></blockquote><p>最后，使用 <a href="http://www.w3.org/TR/page-visibility/" target="_blank" rel="external">Page Visibility API</a> 可以防止页面真正可见前被执行。</p><h2><span id="preload">Preload</span></h2><p><code>preload</code> 是一个新规范，与 <code>prefetch</code> 不同（可能被忽略）的是，浏览器一定会预加载该资源：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"image.png"</span>&gt;</span>☄</div></pre></td></tr></table></figure><p>虽然该规范还没有被所有浏览器兼容，但其背后的思想还是非常有意思的。</p><h2><span id="总结">总结</span></h2><p>预测用户下一步将访问哪些资源是困难的，需要进行大量的测试，但是这带来的性能提升是明显的。如果我们愿意尝试这些预获取技术，一定会显著提升用户的体验。</p><h2><span id="深入阅读">深入阅读</span></h2><ul><li><a href="https://docs.google.com/presentation/d/18zlAdKAxnc51y_kj-6sWLmnjl6TLnaru_WH0LJTjP-o/present?slide=id.p19" target="_blank" rel="external">Slides from a talk by Ilya Grigorik called Preconnect, prerender, prefetch</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ" target="_blank" rel="external">MDN link prefetching FAQ</a></li><li><a href="https://w3c.github.io/preload/" target="_blank" rel="external">W3C preload spec</a></li><li><a href="http://csswizardry.com/2013/01/front-end-performance-for-web-designers-and-front-end-developers/#section:dns-prefetching" target="_blank" rel="external">Harry Roberts on DNS prefetching</a></li><li><a href="https://medium.com/@luisvieira_gmr/html5-prefetch-1e54f6dda15d" target="_blank" rel="external">HTML5 prefetch</a></li><li><a href="http://www.bramstein.com/writing/preload-hints-for-web-fonts.html" target="_blank" rel="external">Preload hints for webfonts</a></li></ul><p class="j-quote">原文：<a href="https://css-tricks.com/prefetching-preloading-prebrowsing" target="_blank" rel="external">Prefetching, preloading, prebrowsing</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当提到前端性能优化时，我们首先会联想到文件的合并、压缩，文件缓存和开启服务器端的 gzip 压缩等，这使得页面加载更快，用户可以尽快使用我们的 Web 应用来达到他们的目标。&lt;/p&gt;
&lt;p&gt;资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。&lt;/p&gt;
&lt;p&gt;引用 &lt;a href=&quot;https://twitter.com/patrickhamann&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Patrick Hamann&lt;/a&gt; 的&lt;a href=&quot;http://patrickhamann.com/workshops/performance/tasks/2_Critical_Path/2_3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;解释&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;预加载是浏览器对将来可能被使用资源的一种暗示，一些资源可以在当前页面使用到，一些可能在将来的某些页面中被使用。作为开发人员，我们比浏览器更加了解我们的应用，所以我们可以对我们的核心资源使用该技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种做法曾经被称为 &lt;em&gt;prebrowsing&lt;/em&gt;，但这并不是一项单一的技术，可以细分为几个不同的技术：&lt;code&gt;DNS-prefetch&lt;/code&gt;、&lt;code&gt;subresource&lt;/code&gt; 和标准的 &lt;code&gt;prefetch&lt;/code&gt;、&lt;code&gt;preconnect&lt;/code&gt;、&lt;code&gt;prerender&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://bubkoo.com/categories/css/"/>
    
    
      <category term="performance" scheme="http://bubkoo.com/tags/performance/"/>
    
      <category term="prefetching" scheme="http://bubkoo.com/tags/prefetching/"/>
    
      <category term="preloading" scheme="http://bubkoo.com/tags/preloading/"/>
    
      <category term="prebrowsing" scheme="http://bubkoo.com/tags/prebrowsing/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：未来展望</title>
    <link href="http://bubkoo.com/2015/11/18/es6-in-depth-the-future/"/>
    <id>http://bubkoo.com/2015/11/18/es6-in-depth-the-future/</id>
    <published>2015-11-18T02:33:43.000Z</published>
    <updated>2015-11-18T02:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/08/es6-in-depth-the-future/" target="_blank" rel="external">ES6 In Depth: The Future</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-08-21</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p class=&quot;j-quote&quot;&gt;参考原文：&lt;a href=&quot;https://hacks.mozilla.org/2015/08/es6-in-depth-the-future/&quot; target=&quot;_blank&quot; rel=&quot;external
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：Modules</title>
    <link href="http://bubkoo.com/2015/11/18/es6-in-depth-modules/"/>
    <id>http://bubkoo.com/2015/11/18/es6-in-depth-modules/</id>
    <published>2015-11-18T02:32:42.000Z</published>
    <updated>2015-11-18T02:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/" target="_blank" rel="external">ES6 In Depth: Modules</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-08-14</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p class=&quot;j-quote&quot;&gt;参考原文：&lt;a href=&quot;https://hacks.mozilla.org/2015/08/es6-in-depth-modules/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;E
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：Subclassing</title>
    <link href="http://bubkoo.com/2015/11/18/es6-in-depth-subclassing/"/>
    <id>http://bubkoo.com/2015/11/18/es6-in-depth-subclassing/</id>
    <published>2015-11-18T02:31:37.000Z</published>
    <updated>2015-11-18T02:31:37.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/" target="_blank" rel="external">ES6 In Depth: Subclassing</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-08-07</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p class=&quot;j-quote&quot;&gt;参考原文：&lt;a href=&quot;https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/&quot; target=&quot;_blank&quot; rel=&quot;externa
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：let 和 const</title>
    <link href="http://bubkoo.com/2015/11/18/es6-in-depth-let-and-const/"/>
    <id>http://bubkoo.com/2015/11/18/es6-in-depth-let-and-const/</id>
    <published>2015-11-18T02:30:27.000Z</published>
    <updated>2015-11-18T02:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/" target="_blank" rel="external">ES6 In Depth: let and const</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-07-31</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p class=&quot;j-quote&quot;&gt;参考原文：&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/&quot; target=&quot;_blank&quot; rel=&quot;exter
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：Classes</title>
    <link href="http://bubkoo.com/2015/11/18/es6-in-depth-classes/"/>
    <id>http://bubkoo.com/2015/11/18/es6-in-depth-classes/</id>
    <published>2015-11-18T02:29:20.000Z</published>
    <updated>2015-11-18T02:29:20.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/07/es6-in-depth-classes/" target="_blank" rel="external">ES6 In Depth: Classes</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-07-22</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p class=&quot;j-quote&quot;&gt;参考原文：&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-classes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;E
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：Proxies</title>
    <link href="http://bubkoo.com/2015/11/18/es6-in-depth-proxies-and-reflect/"/>
    <id>http://bubkoo.com/2015/11/18/es6-in-depth-proxies-and-reflect/</id>
    <published>2015-11-18T02:28:04.000Z</published>
    <updated>2015-11-18T02:28:04.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/07/es6-in-depth-proxies-and-reflect/" target="_blank" rel="external">ES6 In Depth: Proxies</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-07-17</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p class=&quot;j-quote&quot;&gt;参考原文：&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-proxies-and-reflect/&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：Generators</title>
    <link href="http://bubkoo.com/2015/11/18/es6-in-depth-generators-continued/"/>
    <id>http://bubkoo.com/2015/11/18/es6-in-depth-generators-continued/</id>
    <published>2015-11-18T02:24:52.000Z</published>
    <updated>2015-11-18T02:24:52.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/07/es6-in-depth-generators-continued/" target="_blank" rel="external">ES6 In Depth: Generators, continued</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-07-09</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p class=&quot;j-quote&quot;&gt;参考原文：&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-generators-continued/&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：Collections</title>
    <link href="http://bubkoo.com/2015/10/09/es6-in-depth-collections/"/>
    <id>http://bubkoo.com/2015/10/09/es6-in-depth-collections/</id>
    <published>2015-10-09T17:02:10.000Z</published>
    <updated>2015-10-09T17:02:10.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/06/es6-in-depth-collections/" target="_blank" rel="external">ES6 In Depth: Collections</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-06-19</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p class=&quot;j-quote&quot;&gt;参考原文：&lt;a href=&quot;https://hacks.mozilla.org/2015/06/es6-in-depth-collections/&quot; target=&quot;_blank&quot; rel=&quot;externa
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：使用 Babel 和 Broccoli</title>
    <link href="http://bubkoo.com/2015/08/15/es6-in-depth-babel-and-broccoli/"/>
    <id>http://bubkoo.com/2015/08/15/es6-in-depth-babel-and-broccoli/</id>
    <published>2015-08-15T13:12:38.000Z</published>
    <updated>2015-08-15T13:12:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 才刚被标准化，人们就在开始谈论 ES7 将提供哪些闪亮的新特性了。作为 Web 开发人员，我们更想知道如何使用这些新特性。在之前的文章中，作者鼓励我们在一些工具的帮助下开始使用 ES6：</p><blockquote><p>如果你想使用这些新语法，你可以使用 <a href="https://babeljs.io/" target="_blank" rel="external">Babel</a> 或 Google 的 <a href="https://github.com/google/traceur-compiler" target="_blank" rel="external">Traceur</a> 将 ES6 代码转换为友好的 ES5 代码。</p></blockquote><p>本文的主题就是这些工具的使用，上面这些工具被统称为 <em>transpiler</em>，transpiler 也被称为<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler" target="_blank" rel="external">源码到源码的编译器</a>，用于在抽象级别进行编程语言之间的相互转换。使用 transpiler 可以让我们用 ES6 语法来编写代码，同时保证这些代码能在所有浏览器上运行。</p><a id="more"></a><h2><span id="transpiler">Transpiler</span></h2><p>使用 transpiler 非常简单，只需要下面两步：</p><p>1.用 ES6 语法编写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> q = <span class="number">99</span>;</div><div class="line"><span class="keyword">let</span> myVariable = <span class="string">`<span class="subst">$&#123;q&#125;</span> bottles of beer on the wall, <span class="subst">$&#123;q&#125;</span> bottles of beer.`</span>;</div></pre></td></tr></table></figure><p>2.将上面代码作为 transpiler 的输入，经 transpiler 处理后将得到下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> q = <span class="number">99</span>;</div><div class="line"><span class="keyword">var</span> myVariable = <span class="string">""</span> + q + <span class="string">" bottles of beer on the wall, "</span> + q + <span class="string">" bottles of beer."</span></div></pre></td></tr></table></figure><p>得到的代码是老式的 JavaScript 语法，可以在任何浏览器中运行。</p><p>transpiler 的内部工作原理相当复杂，超出了本文的讨论范围。这里我们仅仅将 transpiler 作为一个黑盒来处理我们的代码，正如你会开车，但并不需要知道发动机的工作原理一样。</p><h2><span id="babel-实践">Babel 实践</span></h2><p>使用 Babel 有几种不同的方式。Babel 提供了一个命令行工具，你可以在终端中使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">babel script.js --out-file script-compiled.js</div></pre></td></tr></table></figure><p>还有一个浏览器端库。首先，将 Babel 嵌入到页面中，然后将你的 ES6 代码放在 <code>type</code> 属性值为 <code>text/babel</code> 的 <code>script</code> 标签中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/babel-core/browser.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript"><span class="comment">// Your ES6 code</span></span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>上面两种方式实用性不强，当代码变得庞大，我们就会开始将代码分割到不同文件或文件夹中。这时，我们就需要一个构建工具，并将 Babel 集成到我们的构建流程中。</p><p>下面我们将把 Babel 集成到一个构建工具中 – <a href="http://broccolijs.com/" target="_blank" rel="external">Broccoli.js</a>，并通过几个例子来演示 ES6 代码的编写和执行。示例的完整代码放在<a href="https://github.com/givanse/broccoli-babel-examples" target="_blank" rel="external">这里</a>，一共包含三个示例：</p><ul><li>es6-fruits</li><li>es6-website</li><li>es6-modules</li></ul><p>每个例子都是建立在前个例子的基础上，我们可以先从最简单的例子入手，然后进阶到一个通用的解决方案，最终可以作为一个庞大项目的起点。本文将详细讨论前面两个例子，之后你将能自行阅读和理解第三个例子中的代码。</p><p>如果你还在犹豫，那就等到浏览器兼容这些新特性吧，这样你也会被甩在时代的后面。浏览器完全兼容这些新特性需要很长的时间，而且每年都将发布一些新的 ECMAScript 标准，我们将看到新标准将比浏览器厂商的发布更加频繁。所以，别犹豫了，让我们开始使用这些新特性吧。</p><h2><span id="小试牛刀">小试牛刀</span></h2><p>Broccoli 是一个快速构建工具，不仅可以用来混淆和压缩文件，借助 <a href="https://www.npmjs.com/browse/keyword/broccoli-plugin" target="_blank" rel="external">Broccoli 插件</a>还可以做很多构建相关的工作，为我们节省了在处理文件、目录和执行命令上的时间。</p><h3><span id="准备工作">准备工作</span></h3><p>首先，我们需要<a href="https://nodejs.org/" target="_blank" rel="external">安装 Node 0.11 </a>或更新的版本。</p><p>如果你使用的是 unix 系统，那么请避免使用 package manager (apt, yum) 来安装，这可以避免在安装过程中使用 root 权限。最好只为当前用户使用链接中提供的二进制文件安装。在 <a href="http://givan.se/do-not-sudo-npm/" target="_blank" rel="external">这篇文章</a>中介绍了为什么不推荐使用 root 权限，同时文章中还提供了一些<a href="http://givan.se/do-not-sudo-npm/#install-npm-properly" target="_blank" rel="external">其他安装方式</a>。</p><h3><span id="项目初始化">项目初始化</span></h3><p>使用下面命令初始化我们的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir es6-fruits</div><div class="line"><span class="built_in">cd</span> es6-fruits</div><div class="line">npm init</div><div class="line"><span class="comment"># Create an empty file called Brocfile.js</span></div><div class="line">touch Brocfile.js</div></pre></td></tr></table></figure><p>安装  <strong>broccoli</strong> 和 <strong>broccoli-cli</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># the broccoli library</span></div><div class="line">npm install --save-dev broccoli</div><div class="line"><span class="comment"># command line tool</span></div><div class="line">npm install -g broccoli-cli</div></pre></td></tr></table></figure><h3><span id="编写-es6-代码">编写 ES6 代码</span></h3><p>创建一个 <code>src</code> 目录，在目录中创建一个 <code>fruits.js</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir src</div><div class="line">vim src/fruits.js</div></pre></td></tr></table></figure><p>在我们创建的文件中，使用 ES6 语法编写一小段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fruits = [</div><div class="line">  &#123;<span class="attr">id</span>: <span class="number">100</span>, <span class="attr">name</span>: <span class="string">'strawberry'</span>&#125;,</div><div class="line">  &#123;<span class="attr">id</span>: <span class="number">101</span>, <span class="attr">name</span>: <span class="string">'grapefruit'</span>&#125;,</div><div class="line">  &#123;<span class="attr">id</span>: <span class="number">102</span>, <span class="attr">name</span>: <span class="string">'plum'</span>&#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> fruit <span class="keyword">of</span> fruits) &#123;</div><div class="line">  <span class="keyword">let</span> message = <span class="string">`ID: <span class="subst">$&#123;fruit.id&#125;</span> Name: <span class="subst">$&#123;fruit.name&#125;</span>`</span>;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(message);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">`List total: <span class="subst">$&#123;fruits.length&#125;</span>`</span>);</div></pre></td></tr></table></figure><p>上面代码中使用了 ES6 的三个新特性：</p><ol><li>用 <code>let</code> 声明局部变量</li><li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/" target="_blank" rel="external">for-of</a> 循环</li><li><a href="https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2/" target="_blank" rel="external">template strings</a></li></ol><p>保存文件，然后尝试执行一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node src/fruits.js</div></pre></td></tr></table></figure><p>我们看到执行报错了，但我们的目标是使这段代码可以在 Node 和任何浏览器上都能被执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> fruits = [</div><div class="line">    &lt;sup&gt;&lt;/sup&gt;&lt;sup&gt;&lt;/sup&gt;&lt;sup&gt;&lt;/sup&gt;</div><div class="line">SyntaxError: Unexpected identifier</div></pre></td></tr></table></figure><h3><span id="transpilation">Transpilation</span></h3><p>接下来我们将使用 Broccoli 来加载代码，并通过 Babel 处理，修改 <code>Brocfile.js</code> 文件如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import the babel plugin</span></div><div class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'broccoli-babel-transpiler'</span>);</div><div class="line"></div><div class="line"><span class="comment">// grab the source and transpile it in 1 step</span></div><div class="line">fruits = babel(<span class="string">'src'</span>); <span class="comment">// src/*.js</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = fruits;</div></pre></td></tr></table></figure><p><code>broccoli-babel-transpiler</code> 这个包是 Broccoli 的一个插件，使用前需要安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev broccoli-babel-transpiler</div></pre></td></tr></table></figure><p>构建并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">broccoli build dist <span class="comment"># compile</span></div><div class="line">node dist/fruits.js <span class="comment"># execute ES5</span></div></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ID: 100 Name: strawberry</div><div class="line">ID: 101 Name: grapefruit</div><div class="line">ID: 102 Name: plum</div><div class="line">List total: 3</div></pre></td></tr></table></figure><p>有木有很简单啊！打开 <code>dist/fruits.js</code> 文件来看看编译后的代码，我们将发现通过 Babel 生成的代码可读性是非常强的。</p><h2><span id="在-web-开发中的使用">在 Web 开发中的使用</span></h2><p>接下来我们来看一个稍复杂的例子。首先，退出 <code>es6-fruits</code> 目录；然后，按照之前的步骤创建 <code>es6-website</code> 目录。</p><p>在 <code>src</code> 目录下创建下面三个文件：</p><p><code>src/index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ES6 Today<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">    body &#123;</span></div><div class="line"><span class="css">      <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#9a9a9a</span>;</span></div><div class="line"><span class="undefined">      border-radius: 10px;</span></div><div class="line"><span class="undefined">      padding: 6px;</span></div><div class="line"><span class="undefined">      font-family: monospace;</span></div><div class="line"><span class="undefined">      text-align: center;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="css">    <span class="selector-class">.color</span> &#123;</span></div><div class="line"><span class="undefined">      padding: 1rem;</span></div><div class="line"><span class="css">      <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>ES6 Today<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"info"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//code.jquery.com/jquery-2.1.4.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/my-app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p><code>src/print-info.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printInfo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  $(<span class="string">'#info'</span>)</div><div class="line">      .append(<span class="string">'&lt;p&gt;minimal website example with'</span> +</div><div class="line">              <span class="string">'Broccoli and Babel&lt;/p&gt;'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$(printInfo);</div></pre></td></tr></table></figure><p><code>src/print-colors.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6 Generator</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">hexRange</span>(<span class="params">start, stop, step</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = start; i &lt; stop; i += step) &#123;</div><div class="line">    <span class="keyword">yield</span> i;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printColors</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> content$ = $(<span class="string">'#content'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// contrived example</span></div><div class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> hex <span class="keyword">of</span> hexRange(<span class="number">900</span>, <span class="number">999</span>, <span class="number">10</span>) ) &#123;</div><div class="line">    <span class="keyword">var</span> newDiv = $(<span class="string">'&lt;div&gt;'</span>)</div><div class="line">      .attr(<span class="string">'class'</span>, <span class="string">'color'</span>)</div><div class="line">      .css(&#123; <span class="string">'background-color'</span>: <span class="string">`#<span class="subst">$&#123;hex&#125;</span>`</span> &#125;)</div><div class="line">      .append(<span class="string">`hex code: #<span class="subst">$&#123;hex&#125;</span>`</span>);</div><div class="line">    content$.append(newDiv);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$(printColors);</div></pre></td></tr></table></figure><p>或许你已经注意到 <code>function* hexRange</code>，没错这就是 <a href="https://hacks.mozilla.org/2015/05/es6-in-depth-generators/" target="_blank" rel="external">ES6 generator</a>，目前该特性还没有被所有浏览器兼容，为了使用这个特性，我们需要一个 polyfill，Babel 为我们提供了这个 polyfill。</p><p>下一步就是合并 JS 文件，难点在于 <code>Brocfile.js</code> 文件的编写，这次我们需要安装 4 个插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev broccoli-babel-transpiler</div><div class="line">npm install --save-dev broccoli-funnel</div><div class="line">npm install --save-dev broccoli-concat</div><div class="line">npm install --save-dev broccoli-merge-trees</div></pre></td></tr></table></figure><p><code>Brocfile.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Babel transpiler</span></div><div class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'broccoli-babel-transpiler'</span>);</div><div class="line"><span class="comment">// filter trees (subsets of files)</span></div><div class="line"><span class="keyword">var</span> funnel = <span class="built_in">require</span>(<span class="string">'broccoli-funnel'</span>);</div><div class="line"><span class="comment">// concatenate trees</span></div><div class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'broccoli-concat'</span>);</div><div class="line"><span class="comment">// merge trees</span></div><div class="line"><span class="keyword">var</span> mergeTrees = <span class="built_in">require</span>(<span class="string">'broccoli-merge-trees'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Transpile the source files</span></div><div class="line"><span class="keyword">var</span> appJs = babel(<span class="string">'src'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Grab the polyfill file provided by the Babel library</span></div><div class="line"><span class="keyword">var</span> babelPath = <span class="built_in">require</span>.resolve(<span class="string">'broccoli-babel-transpiler'</span>);</div><div class="line">babelPath = babelPath.replace(<span class="regexp">/\/index.js$/</span>, <span class="string">''</span>);</div><div class="line">babelPath += <span class="string">'/node_modules/babel-core'</span>;</div><div class="line"><span class="keyword">var</span> browserPolyfill = funnel(babelPath, &#123;</div><div class="line">  files: [<span class="string">'browser-polyfill.js'</span>]</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Add the Babel polyfill to the tree of transpiled files</span></div><div class="line">appJs = mergeTrees([browserPolyfill, appJs]);</div><div class="line"></div><div class="line"><span class="comment">// Concatenate all the JS files into a single file</span></div><div class="line">appJs = concat(appJs, &#123;</div><div class="line">  <span class="comment">// we specify a concatenation order</span></div><div class="line">  inputFiles: [<span class="string">'browser-polyfill.js'</span>, <span class="string">'**/*.js'</span>],</div><div class="line">  outputFile: <span class="string">'/js/my-app.js'</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Grab the index file</span></div><div class="line"><span class="keyword">var</span> index = funnel(<span class="string">'src'</span>, &#123;<span class="attr">files</span>: [<span class="string">'index.html'</span>]&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Grab all our trees and</span></div><div class="line"><span class="comment">// export them as a single and final tree</span></div><div class="line"><span class="built_in">module</span>.exports = mergeTrees([index, appJs]);</div></pre></td></tr></table></figure><p>构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">broccoli build dist</div></pre></td></tr></table></figure><p>构建结果，<code>dist</code> 的目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$&gt; tree dist/</div><div class="line">dist/</div><div class="line">├── index.html</div><div class="line">└── js</div><div class="line">    └── my-app.js</div></pre></td></tr></table></figure><p>这就是一个完整静态网站的根目录，可以使用任何静态服务器来启动，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> dist/</div><div class="line">python -m SimpleHTTPServer</div><div class="line"><span class="comment"># visit http://localhost:8000/</span></div></pre></td></tr></table></figure><p>你将看到如下结果：</p><p><img src="http://bubkoo.qiniudn.com/images/es6-in-depth-babel-and-broccoli.png" alt=""></p><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/06/es6-in-depth-babel-and-broccoli/" target="_blank" rel="external">ES6 In Depth: Using ES6 today with Babel and Broccoli</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-06-17 21:38</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 才刚被标准化，人们就在开始谈论 ES7 将提供哪些闪亮的新特性了。作为 Web 开发人员，我们更想知道如何使用这些新特性。在之前的文章中，作者鼓励我们在一些工具的帮助下开始使用 ES6：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你想使用这些新语法，你可以使用 &lt;a href=&quot;https://babeljs.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Babel&lt;/a&gt; 或 Google 的 &lt;a href=&quot;https://github.com/google/traceur-compiler&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Traceur&lt;/a&gt; 将 ES6 代码转换为友好的 ES5 代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文的主题就是这些工具的使用，上面这些工具被统称为 &lt;em&gt;transpiler&lt;/em&gt;，transpiler 也被称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Source-to-source_compiler&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码到源码的编译器&lt;/a&gt;，用于在抽象级别进行编程语言之间的相互转换。使用 transpiler 可以让我们用 ES6 语法来编写代码，同时保证这些代码能在所有浏览器上运行。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：Symbol</title>
    <link href="http://bubkoo.com/2015/07/24/es6-in-depth-symbols/"/>
    <id>http://bubkoo.com/2015/07/24/es6-in-depth-symbols/</id>
    <published>2015-07-24T01:39:57.000Z</published>
    <updated>2015-07-24T01:39:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Symbol 是什么？</p><p>Symbols 不是图标，也不是指在代码中可以使用小图片：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> 😻 = 😺 × 😍;  <span class="comment">// SyntaxError</span></div></pre></td></tr></table></figure><p>也不是指代其他一些东西的语法。那么，Symbol 到究竟是什么呢？</p><a id="more"></a><h2><span id="七种数据类型">七种数据类型</span></h2><p>JavaScript 在 1997 年被标准化时，就有 6 种数据类型，直到 ES6 出现之前，程序中的变量一定是以下 6 种数据类型之一：</p><ul><li>Undefined</li><li>Null</li><li>Boolean</li><li>Number</li><li>String</li><li>Object</li></ul><p>每种数据类型都是一系列值的组合，前面 5 种数据类型值的数量都是有限的。<code>Boolean</code> 类型只有两个值：<code>true</code> 和 <code>false</code>，为 <code>Boolean</code> 类型的变量赋值时，并不会产生新的值（共享了 <code>true</code> 和 <code>false</code> 这两个值）。对于 <code>Number</code> 和 <code>String</code> 来说，它们的值则多得多了，标准的说法是有 18,437,736,874,454,810,627 个 <code>Number</code> 类型的值（包括 <code>NAN</code>）。<code>String</code> 类型的个数就难以统计了，我原以为是 (2<sup>144,115,188,075,855,872</sup> − 1) ÷ 65,535…不过也许我算错了。</p><p>对象值的个数是无限的，每个对象都是独一无二的，每次打开一个网页，都创建了一系列的对象。</p><p>ES6 中的 Symbol 也是一种数据类型，但是不是字符串，也不是对象，而是一种新的数据类型：第七种数据类型。</p><p>下面我们来看一个场景，也许 Symbol 能派上用场。</p><h2><span id="一个布尔值引出的问题">一个布尔值引出的问题</span></h2><p>有时，把一些属于其他对象的数据暂存在另一个对象中是非常方便的。例如，假设你正在编写一个 JS 库，使用 CSS 中的 transition 来让一个 DOM 元素在屏幕上飞奔，你已经知道不能同时将多个 transition 应用在同一个 <code>div</code> 上，否则将使得动画非常不美观，你也确实有办法来解决这个问题，但是首先你需要知道该 <code>div</code> 是否已经在移动中。</p><p>怎么解决这个问题呢？</p><p>其中一个方法是使用浏览器提供的 API 来探测元素是否处于动画状态，但杀鸡焉用牛刀，在将元素设置为移动时，你的库就知道了该元素正在移动。</p><p>你真正需要的是一种机制来跟踪哪些元素正在移动，你可以将正在移动的元素保存在一个数组中，每次要为一个元素设置动画时，首先检查一下这个元素是否已经在这个列表中。</p><p>啊哈，但是如果你的数组非常庞大，即便是这样的线性搜索也会产生性能问题。</p><p>那么，你真正想做的就是直接在元素上设置一个标志：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (element.isMoving) &#123;</div><div class="line">  smoothAnimations(element);</div><div class="line">&#125;</div><div class="line">element.isMoving = <span class="literal">true</span>;</div></pre></td></tr></table></figure><p>这也有一些潜在的问题，不得不承认这样一个事实：还有其他代码也可能操作该 ODM 元素。</p><ol><li>在其他代码中，你创建的属性会被 <code>for-in</code> 或 <code>Object.keys()</code> 枚举出来；</li><li>在其他一些库中也许已经使用了同样的方式（在元素上设置了相同的属性），那么这将和你的代码发生冲突，产生不可预计的结果；</li><li>其他一些库可能在将来会使用同样的方式，这也会与你的代码发生冲突；</li><li>标准委员会可能会为每个元素添加一个 <code>.isMoving()</code> 原生方法，那么你的代码就彻底不能工作了。</li></ol><p>当然，对于最后三个问题，你可以选择一个无意义的不会有人会使用到的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) &#123;</div><div class="line">  smoothAnimations(element);</div><div class="line">&#125;</div><div class="line">element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = <span class="literal">true</span>;</div></pre></td></tr></table></figure><p>这似乎太不靠谱了，看了让人眼睛痛。</p><p>你还可以用加密算法来生成一个几乎唯一的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// get 1024 Unicode characters of gibberish</span></div><div class="line"><span class="keyword">var</span> isMoving = SecureRandom.generateName();</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">if</span> (element[isMoving]) &#123;</div><div class="line">  smoothAnimations(element);</div><div class="line">&#125;</div><div class="line">element[isMoving] = <span class="literal">true</span>;</div></pre></td></tr></table></figure><p><code>object[name]</code> 语法允许我们将任何字符串作为属性名，代码能正常工作，冲突几乎是不可能了，代码看起来也美观多了。</p><p>但是，这回导致糟糕的调试体验，每次使用 <code>console.log()</code> 打印出包含该属性的元素时，你回看到一个庞大的垃圾字符串，并且如果还不止一个这样的属性呢？每次刷新后属性名都发生了变化，怎么样使这些属性看起来更加直观呢？</p><p>为什么这么难？我们只是为了保存一个小小的标志位。</p><h2><span id="用-symbol-来解决问题">用 Symbol 来解决问题</span></h2><p>Symbol 值可以由程序创建，并可以作为属性名，而且不用担心属性名冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</div></pre></td></tr></table></figure><p>调用 <code>Symbol()</code> 方法将创建一个新的 Symbol 类型的值，并且该值不与其它任何值相等。</p><p>与数字和字符串一样，Symbol 类型的值也可以作为对象的属性名，正是由于它不与任何其它值相等，对应的属性也不会发生冲突：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj[mySymbol] = <span class="string">"ok!"</span>;  <span class="comment">// guaranteed not to collide</span></div><div class="line"><span class="built_in">console</span>.log(obj[mySymbol]);  <span class="comment">// ok!</span></div></pre></td></tr></table></figure><p>下面是使用 Symbol 来解决上面的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create a unique symbol</span></div><div class="line"><span class="keyword">var</span> isMoving = <span class="built_in">Symbol</span>(<span class="string">"isMoving"</span>);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">if</span> (element[isMoving]) &#123;</div><div class="line">  smoothAnimations(element);</div><div class="line">&#125;</div><div class="line">element[isMoving] = <span class="literal">true</span>;</div></pre></td></tr></table></figure><p>上面代码需要注意几点：</p><ul><li>方法 <code>Symbol(&quot;isMoving&quot;)</code> 中的 <code>&quot;isMoving&quot;</code> 字符串被称为 Symbol 的描述信息，这对调试非常有帮助。可以通过 <code>console.log(isMoving)</code> 打印出来，或通过 <code>isMoving.toString()</code> 将 <code>isMoving</code> 转换为字符串时，或在一些错误信息中显示出来。</li><li><code>element[isMoving]</code> 访问的是 <em>symbol-keyed</em> 属性，除了属性名是 Symbol 类型的值之外，与其它属性都一样。</li><li>和数组一样，symbol-keyed 属性不能通过 <code>.</code> 操作符来访问，必须使用方括号的方式。</li><li>操作 symbol-keyed 属性也非常方便，通过上面代码我们已经知道如何获取和设置 <code>element[isMoving]</code> 的值，我们还可以这样使用：<code>if (isMoving in element)</code> 或 <code>delete element[isMoving]</code>。</li><li>另一方面，只有在 <code>isMoving</code> 的作用域范围内才可以使用上述代码，这可以实现弱封装机制：在一个模块内创建一些 Symbol，只有在该模块内部的对象才能使用，而不用担心与其它模块的代码发生冲突。</li></ul><p>由于 Symbol 的设计初衷是为了避免冲突，当遍历 JavaScript 对象时，并不会枚举到以 Symbol 作为建的属性，比如，<code>for-in</code> 循环只会遍历到以字符串作为键的属性，<code>Object.keys(obj)</code> 和 <code>Object.getOwnPropertyNames(obj)</code> 也一样，但这并不意味着 Symbol 为键的属性是不可枚举的：使用 <code>Object.getOwnPropertySymbols(obj)</code> 这个新方法可以枚举出来，还有 <code>Reflect.ownKeys(obj)</code> 这个新方法可以返回对象中所有字符串和 Symbol 键。（我将在后面的文章中详细介绍 <code>Reflect</code> 这个新特性。）</p><p>库和框架的设计者将会发现很多 Symbol 的用途，稍后我们将看到，JavaScript 语言本身也对其有广泛的应用。</p><h2><span id="symbol-究竟是什么呢">Symbol 究竟是什么呢</span></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>()</div><div class="line"><span class="string">"symbol"</span></div></pre></td></tr></table></figure><p>Symbol 是完全不一样的东西。一旦创建后就不可更改，不能对它们设置属性（如果在严格模式下尝试这样做，你将得到一个 TypeError）。它们可以作为属性名，这时它们和字符串的属性名没有什么区别。</p><p>另一方面，每个 Symbol 都是独一无二的，不与其它 Symbol 重复（即便是使用相同的 Symbol 描述创建），创建一个 Symbol 就跟创建一个对象一样方便。</p><p>ES6 中的 Symbol 与传统语言（如 Lisp 和 Ruby）中的 Symbol 中的类似，但并不是完全照搬到 JavaScript 中。在 Lisp 中，所有标识符都是 Symbol；在 JavaScript 中，标识符和大多数属性仍然是字符串，Symbol 只是提供了一个额外的选择。</p><p>值得注意的是：与其它类型不同的是，Symbol 不能自动被转换为字符串，当尝试将一个 Symbol 强制转换为字符串时，将返回一个 TypeError。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">"&lt;3"</span>);</div><div class="line">&gt; <span class="string">"your symbol is "</span> + sym</div><div class="line"><span class="comment">// TypeError: can't convert symbol to string</span></div><div class="line">&gt; <span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></div><div class="line"><span class="comment">// TypeError: can't convert symbol to string</span></div></pre></td></tr></table></figure><p>应该避免这样的强制转换，应该使用 <code>String(sym)</code> 或 <code>sym.toString()</code> 来转换。</p><h2><span id="获取-symbol-的三种方法">获取 Symbol 的三种方法</span></h2><ul><li><strong>Symbol()</strong> 每次调用时都返回一个唯一的 Symbol。</li><li><strong>Symbol.for(string)</strong> 从 Symbol 注册表中返回相应的 Symbol，与上个方法不同的是，Symbol 注册表中的 Symbol 是共享的。也就是说，如果你调用 <code>Symbol.for(&quot;cat&quot;)</code> 三次，都将返回相同的 Symbol。当不同页面或同一页面不同模块需要共享 Symbol 时，注册表就非常有用。</li><li><strong>Symbol.iterator</strong> 返回语言预定义的一些 Symbol，每个都有其特殊的用途。</li></ul><p>如果你仍不确定 Symbol 是否有用，那么接下来的内容将非常有趣，因为我将为你演示 Symbol 的实际应用。</p><h2><span id="symbol-在-es6-规范中的应用">Symbol 在 ES6 规范中的应用</span></h2><p>我们已经知道可以使用 Symbol 来避免代码冲突。之前在<a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/" target="_blank" rel="external">介绍 iterator</a> 时，我们还解析了 <code>for (var item of myArray)</code> 内部是以调用 <code>myArray[Symbol.iterator]()</code> 开始的，当时我提到这个方法可以使用 <code>myArray.iterator()</code> 来代替，但是使用 Symbol 的后向兼容性更好。</p><p>在 ES6 中还有一些地方使用到了 Symbol。（这些特性还没有在 FireFox 中实现。）</p><ul><li><strong>使 <code>instanceof</code> 可扩展</strong>。在 ES6 中，<code>object instanceof constructor</code> 表达式被标准化为构造函数的一个方法：<code>constructor[Symbol.hasInstance](object)</code>，这意味着它是可扩展的。</li><li><strong>消除新特性和旧代码之间的冲突</strong>。</li><li><strong>支持新类型的字符串匹配</strong>。在 ES5 中，调用 <code>str.match(myObject)</code> 时，首先会尝试将 <code>myObject</code> 转换为 <code>RegExp</code> 对象。在 ES6 中，首先将检查 <code>myObject</code> 中是否有 <code>myObject[Symbol.match](str)</code> 方法，在所有正则表达式工作的地方都可以提供一个自定义的字符串解析方法。</li></ul><p>这些用途还比较窄，但仅仅通过我文章中的代码很难看到这些新特性产生的重大影响。JavaScript 的 Symbol 是 PHP 和 Python 中 <code>__doubleUnderscores</code> 的改进版本，标准组织将使用它来为语言添加新特性，而不会对已有代码产生影响。</p><h2><span id="兼容性">兼容性</span></h2><p>Firefox 36 和 Chrome 38 实现了 Symbol，并且 Firefox 的实现者是本文的原文作者，所以有什么问题可以直接联系作者。</p><p>对于还没有原生支持 Symbol 的浏览器，你可以使用 polyfill，如 <a href="https://github.com/zloirock/core-js#ecmascript-6-symbols" target="_blank" rel="external">core.js</a>，但该 polyfill 实现并不完美，请阅读<a href="https://github.com/zloirock/core-js#caveats-when-using-symbol-polyfill" target="_blank" rel="external">注意事项</a>。 </p><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/" target="_blank" rel="external">ES6 In Depth: Symbols</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-06-11 23:13</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Symbol 是什么？&lt;/p&gt;
&lt;p&gt;Symbols 不是图标，也不是指在代码中可以使用小图片：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; 😻 = 😺 × 😍;  &lt;span class=&quot;comment&quot;&gt;// SyntaxError&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也不是指代其他一些东西的语法。那么，Symbol 到究竟是什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>在 Web 开发中生成几何图形的几种方式</title>
    <link href="http://bubkoo.com/2015/07/22/working-with-shapes-in-web-design/"/>
    <id>http://bubkoo.com/2015/07/22/working-with-shapes-in-web-design/</id>
    <published>2015-07-22T15:16:15.000Z</published>
    <updated>2015-07-22T15:16:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在进行 Web 开发时，很多时候都是在有意或无意地创建一些矩形，深究一下，到底有多少中方式来得到一个几何图形呢？本文将简单介绍几种生成圆形、三角形和多边形的方式，并分析每种方式的优缺点。</p><p>下面是可能使用到的方式：</p><ol><li><a href="https://css-tricks.com/working-with-shapes-in-web-design/#shapes-border-radius" target="_blank" rel="external">border-radius</a></li><li><a href="https://css-tricks.com/working-with-shapes-in-web-design/#shapes-border" target="_blank" rel="external">border</a></li><li><a href="https://css-tricks.com/working-with-shapes-in-web-design/#shapes-transform-rotate" target="_blank" rel="external">rotating shapes with transform</a></li><li><a href="https://css-tricks.com/working-with-shapes-in-web-design/#shapes-pseudo-elem" target="_blank" rel="external">pseudo elements</a></li><li><a href="https://css-tricks.com/working-with-shapes-in-web-design/#shapes-box-shadow" target="_blank" rel="external">box-shadow</a></li><li><a href="https://css-tricks.com/working-with-shapes-in-web-design/#shapes-shape-outside" target="_blank" rel="external">wrapping text into shapes with shape-outside</a></li><li><a href="https://css-tricks.com/working-with-shapes-in-web-design/#shapes-clip-path" target="_blank" rel="external">clip-path on an element</a></li><li><a href="https://css-tricks.com/working-with-shapes-in-web-design/#shapes-svg-assets" target="_blank" rel="external">SVG assets</a></li><li><a href="https://css-tricks.com/working-with-shapes-in-web-design/#shapes-canvas" target="_blank" rel="external">canvas</a></li></ol><a id="more"></a><h2><span id="border-radius">border-radius</span></h2><p>使用 <code>border-radius</code> 样式属性是得到圆形的最简单的方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.element</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p class="fully-content"><iframe src="//codepen.io/css-tricks/embed/LVembR?height=300&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="300"></iframe></p><p><code>border-radius</code> 的属性值可以是长度值或百分比。值为 <code>50%</code> 和 <code>100%</code> 时都可以得到一个圆形，Jessica Eldredge 有篇文章介绍了<a href="http://jessica-eldredge.com/2014/09/07/border-radius-50-or-100-percent" target="_blank" rel="external">为什么要使用 50% 而不是 100%</a>。</p><p>使用该属性还可以制作出其他形状，如圆角矩形，椭圆形等。</p><p class="fully-content"><iframe src="//codepen.io/css-tricks/embed/5dd5c582ec9b79c7d8ac38c350bd3f02?height=490&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="490"></iframe></p><p><strong>优点：</strong></p><ul><li>支持现代浏览器；</li><li>只需要少量的 CSS。</li></ul><p><a href="https://css-tricks.com/almanac/properties/b/border-radius/" target="_blank" rel="external">深入阅读</a></p><h2><span id="border">border</span></h2><p>通过设置 CSS 中的 <code>border</code> 属性我们可以一些不同的图形，例如，通过将一个元素的三个边框颜色设置为透明，我们可以模拟一个三角形的样子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.triangle</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid red;</div><div class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</div><div class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</div><div class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p class="fully-content"><iframe src="//codepen.io/css-tricks/embed/vOpjXZ?height=300&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="300"></iframe></p><p>我们可以使三角形指向任何想要的方向，下面是一个动画教程：</p><p class="fully-content"><iframe src="//codepen.io/chriscoyier/embed/lotjh?height=350&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="350"></iframe></p><p>你可以使用 <a href="http://apps.eky.hk/css-triangle-generator/" target="_blank" rel="external">CSS 三角形生成器</a>来帮你自动生成一个三角形，如果你想以编程的方式来实现一个三角形，这里有一个 CSS 的 <a href="https://css-tricks.com/snippets/sass/css-triangle-mixin/" target="_blank" rel="external">Mixin</a>。</p><p>也可以是使用该技术来得到一个梯形：</p><p class="fully-content"><iframe src="//codepen.io/css-tricks/embed/580955e70863188e57c68338d9dfa2ae?height=268&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="268"></iframe></p><p><strong>优点：</strong></p><ul><li>浏览器都支持；</li><li>有现成的工具可用，比如，<a href="https://coveloping.com/tools/css-shapes-generator" target="_blank" rel="external">CSS 形状生成器</a>，可以很方便地生成你想要的几何形状。</li></ul><h2><span id="transform">transform</span></h2><p>可以使用 <code>transform</code> 来做出特定的形状，如钻石形状：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.diamond</span> &#123;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p class="fully-content"><iframe src="//codepen.io/css-tricks/embed/a4a12f6351b38e1a41e78676f20f0cf8?height=268&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="268"></iframe></p><p>在上面例子中，由于 <code>transform</code> 旋转，导致图形溢出了父元素，我们可以通过 <code>transform-origin</code> 来调整：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.diamond</span> &#123;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg);</div><div class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>支持现在浏览器。</li></ul><p><strong>缺点：</strong></p><ul><li>需要使用 <code>transform-origin</code> 来修正元素的位置，这可能会不好调整。</li></ul><h2><span id="pseudo-elements">Pseudo elements</span></h2><p>Pseudo elements(伪元素)是利用 CSS 制作几何形状的重要工具，大大提高了可制作形状的数量，如下面的五角形：</p><p class="fully-content"><iframe src="//codepen.io/css-tricks/embed/ca0b36c2d7ea75ea7fd5cd982c328006?height=300&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="300"></iframe></p><p>使用 <code>:before</code> 为元素，我们生成了两个不同的形状，其中一个在另一个的上面，通过上例中的 CSS 可知，为了得到这个形状，对两个形状的位置要求非常严格。这是我对使用 CSS 来制作复杂形状最不满意的地方：越复杂的形状要求越复杂的代码，一旦你得到五边形或六边形后，你会发现这样的代码非常丑陋，在项目中这样的的代码是不可维护的。</p><p><strong>优点：</strong></p><ul><li>可以制作任何你想要的形状；</li><li>不用像图片一样需要额外的 HTTP 请求。</li></ul><p><strong>缺点：</strong></p><ul><li>在大型项目中，制作复杂形状的代码会变得不可维护，也不是长久之计。</li></ul><h2><span id="box-shadow">box-shadow</span></h2><p>这也许是使用 CSS 制作形状最奇怪的方式，因为使用 <code>box-shadow</code> 可以创造惊人的艺术效果。看下面的 demo：</p><p class="fully-content"><iframe src="//codepen.io/zessx/embed/BsfFt?height=500&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="500"></iframe></p><p><strong>优点：</strong></p><ul><li>你可以使用 <code>box-shadow</code> 制作形状？</li></ul><p><strong>缺点：</strong></p><ul><li>如果将来想修改图形，需要精确找到像素位置对应的 <code>box-shadow</code> 属性，这是个烦人的工作；</li><li>得到的形状不可以被第三方软件编辑，比如 Illustrator，Photoshop 或 Sketch。</li></ul><h2><span id="使用-shape-outside-使文字围绕图形">使用 shape-outside 使文字围绕图形</span></h2><p>使用 <code>shape-outside</code> 属性可以使文字围绕图形（圆、椭圆或多边形）。需要注意的是：目前这个属性只对浮动元素有效。看下面这个简单的例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.element</span> &#123;  </div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">  <span class="attribute">shape-outside</span>: <span class="built_in">circle</span>(50%);</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://7b1fai.com1.z0.glb.clouddn.com/images/shape-outside.png" alt=""></p><p><code>shape-outside</code> 属性对应的方法有：<code>circle()</code>， <code>ellipse()</code>、<code>polygon()</code> 和 <code>inset()</code>，下面这个例子使用了 <code>ellipse()</code> 方法：</p><p class="fully-content"><iframe src="//codepen.io/css-tricks/embed/7fa99015d63597648d5e312c5b73ac25?height=400&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="400"></iframe></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.element</span> &#123;</div><div class="line">  <span class="attribute">shape-outside</span>: <span class="built_in">ellipse</span>(150px 300px at 50% 50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用 <code>ellipse()</code> 方法时需要指定椭圆需要的 x 和 y 半径，其次是椭圆的中心位置。在上例中，椭圆的中心位置就位于元素的中心位置上。</p><p>然后，这里有一个需要注意的问题：当使用 <code>shape-outside</code> 属性时，并不会影响元素本身的形状，只影响了围绕它的其他元素的形状。如果为该元素这是一个边框和背景，我们将发现该元素仍然是一个矩形：</p><p class="fully-content"><iframe src="//codepen.io/css-tricks/embed/5e47a80626dfa27a42dd18a0e2b8450b?height=400&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="400"></iframe></p><p>你可以这样来理解：使用了 <code>shape-outside</code> 属性的元素只改变了围绕它的其他元素，而元素本身的几何形状并没有改变。为了改变元素自身的形状可以将 <code>shape-outside</code> 和 <code>clip-path()</code> 结合使用，例如：</p><p class="fully-content"><iframe src="//codepen.io/css-tricks/embed/4e5420d8c1a2766b25dd3c98f684bf9c?height=400&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="400"></iframe></p><p>还有很多没有涉及到的内容，如果想要深入了解 <code>shape-outside</code> 属性，可以参考<a href="https://css-tricks.com/almanac/properties/s/shape-outside/" target="_blank" rel="external">这篇文章</a>。</p><p><strong>优点：</strong></p><ul><li>可以实现文字环绕形状效果；</li><li>可以设置形状的 <code>margin</code>、<code>padding</code> 和 <code>border</code> 属性，这可以使我们对元素位置进行精细控制。</li></ul><p><strong>缺点：</strong></p><ul><li>IE 和 Firefox 不支持该属性；</li><li>不改变元素的实际形状。</li></ul><h2><span id="clip-path">clip-path</span></h2><p>与上面介绍的 <code>shape-outside</code> 属性一样，<code>clip-path</code> 属性可以使用的方法有：<code>inset()</code>、<code>polygon()</code> 和 <code>ellipse()</code>，看下面这个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.element</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(0% 100%, 100% 100%, 0% 0%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p class="fully-content"><iframe src="//codepen.io/css-tricks/embed/84ce4f54c0d96b1ba0a2e9a9290876fb?height=400&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="400"></iframe></p><p><code>clip-path</code> 属性是完全支持 CSS3 动画的：</p><p class="fully-content"><iframe src="//codepen.io/css-tricks/embed/10c03204463e92a72a6756678e6348d1?height=300&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="300"></iframe></p><p>可以使用 <a href="http://bennettfeely.com/clippy/" target="_blank" rel="external">Clippy</a> 这样的工具来生成你需要的代码：</p><p><img src="http://7b1fai.com1.z0.glb.clouddn.com/images/clippy.jpg" alt="Clippy"></p><p>深入阅读可以参考：</p><ul><li><a href="https://css-tricks.com/almanac/properties/c/clip/" target="_blank" rel="external">Almanac entry for clip-path</a> </li><li><a href="https://css-tricks.com/clipping-masking-css/" target="_blank" rel="external">Clipping and Masking in CSS</a></li></ul><p><strong>优点：</strong></p><ul><li>可以制作复杂的形状，而不需要图片这样的额外资源。</li></ul><p><strong>缺点：</strong></p><ul><li>实现文字环绕图片效果需要结合使用 <code>clip-path</code> 和 <code>shape-outside</code> 这两个属性。</li></ul><h2><span id="svg">SVG</span></h2><p>使用 SVG（可缩放的矢量图形）可以制作出任何你想要的图形，如 <a href="http://www.polygon.com/a/ps4-review" target="_blank" rel="external">console</a>、logo、图标、社会媒体按钮等。</p><p>本文并不会教你<a href="https://css-tricks.com/using-svg/" target="_blank" rel="external">如何使用 SVG</a>，因为涉及太多的最佳实践和技术细节。通常，如果一个项目需要使用到图形，我的首选肯定是 SVG，因为这意味着更少的奇怪的不可预知的代码，也意味着如果设计师需要对图形进行润色，他们可以随时编辑这些形状。</p><p>如果想详细了解 SVG，这里有一篇关于 SVG 的<a href="https://css-tricks.com/mega-list-svg-information/" target="_blank" rel="external">汇总文章</a>。</p><p><strong>优点：</strong></p><ul><li>较小的文件大小；</li><li>可以在任何流行的图形编辑器中编辑它们；</li><li>不熟悉 CSS 和 JavaScript 的人也可以制作它们；</li><li>无失真缩放；</li><li>广泛的浏览器支持和大量的兼容方案；</li><li>可以将它们添加到页面标签中，并可以<a href="http://www.sitepoint.com/tips-accessible-svg/" target="_blank" rel="external">支持屏幕阅读器</a>；</li><li>支持 CSS 和 JavaScript 动画。</li></ul><p><strong>缺点：</strong></p><ul><li>如果它们是非常简单的形状，你可以使用纯 CSS 的方案来实现。</li></ul><h2><span id="canvas">canvas</span></h2><p>使用 <code>canvas</code> 元素来制作图表和互动式游戏非常有用，因为它的设计初衷就是用来绘制图表。<code>canvas</code> 绘图教程超出了本文的范围，这里你需要了解的是用 <code>canvas</code> 可以做什么，下面是使用 <code>canvas</code> 来绘制一个正方形：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>);</div><div class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line">ctx.fillStyle = <span class="string">'#0074d9'</span>;</div><div class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</div></pre></td></tr></table></figure><p class="fully-content"><iframe src="//codepen.io/css-tricks/embed/194842e7086d6b740ba102fd3be9c510?height=268&default-tab=result" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" height="268"></iframe></p><p>对每个 <code>canvas</code>，我们需要给 <code>.getContext()</code> 方法传递 <code>&quot;2d&quot;</code> 这个字符串参数，目前还没有 3d 上下文，也许将来会支持。</p><p>在 MDN 上有一系列关于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial" target="_blank" rel="external">canvas 的教程</a>。</p><p><strong>优点：</strong></p><ul><li>制作游戏和交互式图表。</li></ul><p><strong>缺点：</strong></p><ul><li>依赖 JavaScript。</li></ul><h2><span id="总结">总结</span></h2><p>选择一种制作图形的方式，就与选择一种垂直对齐方式一样：没有最好的方案，只有最适合项目的方案。在我的项目开发中，我并没有只选择其中一种技术，而是将这些方式使用在最适合它们的位置，同时注意保持完善的文档，并且不给其他开发人员造成困扰。</p><h2><span id="参考资源">参考资源</span></h2><ul><li><a href="https://css-tricks.com/almanac/properties/c/clip/" target="_blank" rel="external">Almanac entry for clip-path</a></li><li><a href="https://css-tricks.com/clipping-masking-css/" target="_blank" rel="external">More info about clip-path</a></li><li><a href="http://www.w3.org/TR/css-shapes/#propdef-shape-outside" target="_blank" rel="external">W3C on CSS Shapes</a></li><li><a href="https://css-tricks.com/examples/ShapesOfCSS/" target="_blank" rel="external">The Shapes of CSS</a></li><li><a href="http://www.html5rocks.com/en/tutorials/shapes/getting-started/" target="_blank" rel="external">Getting started with CSS Shapes</a></li><li><a href="http://bennettfeely.com/clippy/" target="_blank" rel="external">Clippy</a></li><li><a href="http://codepen.io/collection/qFesk/" target="_blank" rel="external">Adobe’s CSS Shapes CodePen collection</a></li><li><a href="https://css-tricks.com/clipping-masking-css/" target="_blank" rel="external">Clipping and masking in CSS</a></li><li><a href="http://jessica-eldredge.com/2014/09/07/border-radius-50-or-100-percent/" target="_blank" rel="external">Border-radius: 50% vs 100%</a></li><li><a href="http://www.webdesignerdepot.com/2015/03/how-to-get-started-with-css-shapes/" target="_blank" rel="external">How to get started with CSS shapes</a></li><li><a href="https://chrome.google.com/webstore/detail/css-shapes-editor/nenndldnbcncjmeacmnondmkkfedmgmp" target="_blank" rel="external">Shapes editor Chrome extension</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial" target="_blank" rel="external">Canvas tutorial on MDN</a></li><li><a href="https://css-tricks.com/mega-list-svg-information" target="_blank" rel="external">A compendium of SVG information</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在进行 Web 开发时，很多时候都是在有意或无意地创建一些矩形，深究一下，到底有多少中方式来得到一个几何图形呢？本文将简单介绍几种生成圆形、三角形和多边形的方式，并分析每种方式的优缺点。&lt;/p&gt;
&lt;p&gt;下面是可能使用到的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/working-with-shapes-in-web-design/#shapes-border-radius&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;border-radius&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/working-with-shapes-in-web-design/#shapes-border&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;border&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/working-with-shapes-in-web-design/#shapes-transform-rotate&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;rotating shapes with transform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/working-with-shapes-in-web-design/#shapes-pseudo-elem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pseudo elements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/working-with-shapes-in-web-design/#shapes-box-shadow&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;box-shadow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/working-with-shapes-in-web-design/#shapes-shape-outside&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wrapping text into shapes with shape-outside&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/working-with-shapes-in-web-design/#shapes-clip-path&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;clip-path on an element&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/working-with-shapes-in-web-design/#shapes-svg-assets&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SVG assets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/working-with-shapes-in-web-design/#shapes-canvas&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;canvas&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://bubkoo.com/categories/css/"/>
    
    
      <category term="CSS" scheme="http://bubkoo.com/tags/css/"/>
    
      <category term="Shapes" scheme="http://bubkoo.com/tags/shapes/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：箭头函数</title>
    <link href="http://bubkoo.com/2015/06/28/es6-in-depth-arrow-functions/"/>
    <id>http://bubkoo.com/2015/06/28/es6-in-depth-arrow-functions/</id>
    <published>2015-06-28T23:36:05.000Z</published>
    <updated>2015-06-28T23:36:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>从一开始箭头就是 JavaScript 的一部分，在第一个 JavaScript 中就建议将内联的脚本代码包裹在 HTML 的注释中，这可以防止那些不支持 JavaScript 的浏览器错误滴将你的代码显示为明文。你也许写过下面这样的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">&lt;!--</span></div><div class="line"><span class="javascript">    <span class="built_in">document</span>.bgColor = <span class="string">"brown"</span>;  <span class="comment">// red</span></span></div><div class="line"><span class="javascript"><span class="comment">// --&gt;</span></span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>古老的浏览器将看到两个不被支持的标签和一段注释，只有支持 JavaScript 的新浏览器才会将其解析为 JavaScript 代码。</p><p>为了支持这个古怪的特性，浏览器的 JavaScript 引擎把 <code>&lt;!--</code> 作为一个单行注释的开始，这不是开玩笑的，这一直都是这门语言的一部分，并且至今还能用，不仅仅在 <code>&lt;script&gt;</code> 标签内的首行，而是在 JavaScript 代码的任何部位都可用，它甚至还能在 Node 中使用。</p><p>凑巧的是，这种风格的注释在 ES6 中首次<a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-html-like-comments" target="_blank" rel="external">被标准化</a>。但这并不是我们将谈论的箭头。</p><a id="more"></a><p><code>--&gt;</code> 也表示一个单行注释，与 HTML 不同的是，在 HTML 中，<code>--&gt;</code> 之前的部分是注释内容，而在 JavaScript 中，在 <code>--&gt;</code> 之后的行才是注释。</p><p>只有当 <code>--&gt;</code> 出现在一行的开始时，才表示该箭头是一个注释，因为在其他情况下，<code>--&gt;</code> 是一个操作符（goes to）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countdown</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">while</span> (n--&gt;<span class="number">0</span>)  <span class="comment">// "n goes to zero"</span></div><div class="line">    alert(n);</div><div class="line">  blastoff();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="http://codepen.io/anon/pen/oXZaBY?editors=001" target="_blank" rel="external">上面代码是真实能运行的</a>。循环运行直到 <code>n</code> 为 <code>0</code>，这并不是 ES6 的新特性，但结合我们熟悉的特性，这具有很强的误导性。你能搞明白上面代码的运行情况吗？你可以在 <a href="http://stackoverflow.com/questions/1642028/what-is-the-name-of-the-operator" target="_blank" rel="external">Stack Overflow</a> 上找到相应的解答。</p><p>当然还有一个箭头，那就是小于等于操作符 <code>&lt;=</code>，也许你还可以找到使用箭头的地方，但我们还是停下来，看一个我们从没见过的箭头：</p><ul><li><code>&lt;!--</code> 单行注释</li><li><code>--&gt;</code> goes to 操作符</li><li><code>&lt;=</code> 小于等于操作符</li><li><code>=&gt;</code> ???</li></ul><p>那么，<code>=&gt;</code> 表示什么呢？这就是本文将讨论的话题。</p><p>首先，我们来谈谈函数。</p><h2><span id="无处不在的函数表达式">无处不在的函数表达式</span></h2><p>JavaScript 一个有趣的特点是，任何时候你需要一个函数，你可以很方便地创建它们。</p><p>例如，为一个按钮绑定点击事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#confetti-btn"</span>).click(</div></pre></td></tr></table></figure><p>jQuery 的 <code>.click()</code> 方法需要一个函数作为参数，我们可以很方便地就地创建一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#confetti-btn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  playTrumpet();</div><div class="line">  fireConfettiCannon();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>现在对我们来说，编写这样的代码是最自然的事了。但是在 JavaScript 流行起来之前，这种风格的代码看起来还是有些奇怪，因为在其他语言中都没有这样的特性。在 1958 年，Lisp 就有了函数表达式，也叫 lambda 函数，而在存在多年的 C++、Python、C# 和 Java 中没有该特性。</p><p>现在，这四门语言都有了 lambda 表达式，而且新出现的语言都普遍内置了 lambda 表达式。如今 JavaScript 也支持该特性了，这必须感谢那些重度依赖 lambda 表达式的库的开发者，这推动了该特性被广泛采纳。</p><p>与其他几门语言相比，JavaScript 的语法略显冗长：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A very simple function in six languages.</span></div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a &gt; <span class="number">0</span>; &#125; <span class="comment">// JS</span></div><div class="line">[](int a) &#123; <span class="keyword">return</span> a &gt; <span class="number">0</span>; &#125;  <span class="comment">// C++</span></div><div class="line">(lambda (a) (&gt; a <span class="number">0</span>))  ;; Lisp</div><div class="line">lambda a: a &gt; 0  # Python</div><div class="line">a =&gt; a &gt; <span class="number">0</span>  <span class="comment">// C#</span></div><div class="line">a -&gt; a &gt; <span class="number">0</span>  <span class="comment">// Java</span></div></pre></td></tr></table></figure><h2><span id="箭头函数">箭头函数</span></h2><p>ES6 引入了一种新的语法来编写函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> selected = allJobs.filter(<span class="function"><span class="keyword">function</span> (<span class="params">job</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> job.isSelected();</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="keyword">var</span> selected = allJobs.filter(<span class="function"><span class="params">job</span> =&gt;</span> job.isSelected());</div></pre></td></tr></table></figure><p>当你需要只有一个参数的函数，箭头函数的语法可以简化为 <code>Identifier =&gt; Expression</code>，直接省略了 <code>function</code> 和 <code>return</code> 关键字，连括号和结尾的分号也同时省略了。</p><p>编写一个有多个（或没有参数，或 <a href="http://bubkoo.com/2015/06/27/es6-in-depth-rest-parameters-and-defaults/">Rest 参数和参数默认值</a>，或<a href="http://bubkoo.com/2015/06/28/es6-in-depth-destructuring/">解构</a>参数）参数的函数，你需要用括号将参数括起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> total = values.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="keyword">var</span> total = values.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</div></pre></td></tr></table></figure><p>箭头函数还可以与一些工具函数库完美地配合使用，比如  <a href="http://underscorejs.org/" target="_blank" rel="external">Underscore.js</a> 和 <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="external">Immutable</a>，事实上，<a href="https://facebook.github.io/immutable-js/docs/#/" target="_blank" rel="external">Immutable 文档</a>中的例子全部都是使用 ES6 编写，其中有很多已经使用到了箭头函数。</p><p>函数体除了使用一个表达式外，箭头函数还可以包含一个语句块，回忆之前我们提到过的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line">$(<span class="string">"#confetti-btn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  playTrumpet();</div><div class="line">  fireConfettiCannon();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>下面是采用箭头函数的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line">$(<span class="string">"#confetti-btn"</span>).click(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</div><div class="line">  playTrumpet();</div><div class="line">  fireConfettiCannon();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>需要注意的是，使用语句块的箭头函数不会自动返回一个值，必须显式地使用 <code>return</code> 来返回一个值。</p><p>还有一个忠告，当使用箭头函数来返回一个对象时，始终使用括号将返回的对象括起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create a new empty object for each puppy to play with</span></div><div class="line"><span class="keyword">var</span> chewToys = puppies.map(<span class="function"><span class="params">puppy</span> =&gt;</span> &#123;&#125;);   <span class="comment">// BUG!</span></div><div class="line"><span class="keyword">var</span> chewToys = puppies.map(<span class="function"><span class="params">puppy</span> =&gt;</span> (&#123;&#125;)); <span class="comment">// ok</span></div></pre></td></tr></table></figure><p>因为空对象 <code>{}</code> 与空语句块 <code>{}</code> 看上去一模一样，ES6 将始终把紧跟在 <code>=&gt;</code> 后面的 <code>{</code> 当作语句块的开始，而不是一个对象的开始，那么 <code>puppy =&gt; {}</code> 就被解析为一个没有函数体的箭头函数，而且返回值为 <code>undefined</code>。</p><h2><span id="this-关键字">this 关键字</span></h2><p>箭头函数和普通函数有一个微妙的区别，那就是<strong>箭头函数没有它们自己的 <code>this</code></strong>，箭头函数中的 <code>this</code> 值始终来自闭包所在的作用域。</p><p>开始实际例子前，我们一起来回顾一些知识点。</p><p>在 JavaScript 中 <code>this</code> 是如何工作的？它的值来自哪里？<a href="http://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work" target="_blank" rel="external">这里</a>有一个简短的回答。如果这个问题对你来说非常简单，说明你已经有一定的实践经验了。</p><p>之所以这个问题被频繁地提出，是因为函数都是自动判断其 <code>this</code> 值，而不管你是否使用到了 <code>this</code> 的值。你是否也写过下面这样的 hack 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  addAll: <span class="function"><span class="keyword">function</span> <span class="title">addAll</span>(<span class="params">pieces</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    _.each(pieces, <span class="function"><span class="keyword">function</span> (<span class="params">piece</span>) </span>&#123;</div><div class="line">      self.add(piece);</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>内部函数仅仅是为了调用外部对象中的 <code>.add(piece)</code> 方法，但内部函数并没有继承外部函数的 <code>this</code>，在内部函数中，<code>this</code> 的值可能是 <code>window</code> 或 <code>undeinfed</code>。这里使用了 <code>self</code> 这个临时变量来将外部函数中的 <code>this</code> 值传递到内部函数中（也可以使用 <code>.bind(this)</code> 的方式，但两个方式都不是特别漂亮）。</p><p>在 ES6 中，如果你遵循以下规则，那么你就再也不会写出上面的 hack 代码了：</p><ul><li>调用对象的方法时，使用 <code>object.method()</code> 语法，这样将通过调用者为这些方法提供一个有意义的 <code>this</code> 值</li><li>其他情况请使用箭头函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  addAll: <span class="function"><span class="keyword">function</span> <span class="title">addAll</span>(<span class="params">pieces</span>) </span>&#123;</div><div class="line">    _.each(pieces, piece =&gt; <span class="keyword">this</span>.add(piece));</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在上面的 ES6 实现中，<code>addAll</code> 方法将通过调用者获取到 <code>this</code> 的值，内部函数中使用了箭头函数，所以将从闭包区域继承 <code>this</code> 的值。</p><p>ES6 还提供了一种更简短的方式来书写对象字面量中的方法，以上代码可以简化为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6 with method syntax</span></div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  addAll(pieces) &#123;</div><div class="line">    _.each(pieces, piece =&gt; <span class="keyword">this</span>.add(piece));</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>箭头函数与普通函数还有一个区别，那就是箭头函数中不能使用 <code>arguments</code> 对象。当然，你可以使用 rest 参数和参数默认值。</p><h2><span id="使用箭头来刺穿计算机的黑暗心脏">使用箭头来刺穿计算机的黑暗心脏</span></h2><p>我们已经讨论了箭头函数的实际用途，这里还有一点我想谈谈：ES6 的箭头函数可以作为一个学习工具，来探索计算机世界中一些深层次的东西。本节的东西不一定实用，你可以自己决定是否跳过本节。</p><p>在 1936 年，阿隆佐·邱奇（Alonzo Church）和阿兰·图灵（Alan Turing）开始独立研发强大的计算机模型。图灵称他的模型为 <em>a-machines</em>，但人们都称其为图灵机。邱奇编写了一种函数机制，他的模型被称为 <a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="external">λ 表达式</a>（λ 是小写希腊字母 lambda），这是 Lisp 使用 LAMBDA 来表示函数的原因，同时也是为什么我们今天将函数表达式称为 “lambda” 表达式的原因。</p><p>但 λ 表达式是什么呢？“计算模型”又是什么意思呢？</p><p>这很难用简单几句话就表达清楚，但我尽力：λ 表达式是最早的编程语言之一，但这并不是 λ 表达式的设计初衷，毕竟一个程序语言不会延续十年或二十年，但 λ 表达式是一个非常简单、纯粹并符合数学思想的语言，可以表达任何形式的计算。邱奇希望通过该模型来证明计算相关的一切事情。</p><p>他发现，在他的模型中只需要一个东西：<em>function</em>。</p><p>想象一下该机制是多么强大，不需要对象、数组、数字，不需要 <code>if</code> 语句和 <code>while</code> 循环，不需要分号、赋值语句、逻辑操作符和事件循环，只使用函数就可以实现 JavaScript 中的任何运算。</p><p>下面是使用 λ 表达式实现的一个排序程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))</div></pre></td></tr></table></figure><p>等价的 JavaScript 函数是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fix = <span class="function"><span class="params">f</span> =&gt;</span> (<span class="function"><span class="params">x</span> =&gt;</span> f(<span class="function"><span class="params">v</span> =&gt;</span> x(x)(v)))</div><div class="line">               (<span class="function"><span class="params">x</span> =&gt;</span> f(<span class="function"><span class="params">v</span> =&gt;</span> x(x)(v)));</div></pre></td></tr></table></figure><p>也就是说，JavaScript 包含了一个 λ 表达式的运行时实例，λ 表达式存在于 JavaScript 内部。</p><p>关于邱奇以及之后的研究者与 λ 表达式之间的故事，以及 λ 表达式如何悄然成为每种编程语言中的主要实现的故事，已经超出了本文的范围。但如果你对计算机基础科学感兴趣，或者你只想了解如何在一门语言中只使用函数来实现循环和递归，你可以在某个下雨的下午研究一下  <a href="https://en.wikipedia.org/wiki/Church_encoding" target="_blank" rel="external">Church numerals</a> 和 <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Strict_fixed_point_combinator" target="_blank" rel="external">fixed-point combinators</a>，并在 Firefox 的控制台或 <a href="https://developer.mozilla.org/en-US/docs/Tools/Scratchpad" target="_blank" rel="external">Scratchpad</a> 中实践一下。有了 ES6 中的箭头函数的优势，JavaScript 可以称为探索 λ 表达式最好的语言。</p><h2><span id="兼容性">兼容性</span></h2><p>早在 2013 年，原文作者就在 Firefox 中实现了箭头函数，Mooij 使其运行得更加快，还要感谢 Tooru Fujisawa 和 ziyunfei 的补丁。</p><p>微软的 Edge 的预览版中也已经实现了箭头函数，若果你现在就想在 Web 开发中使用箭头函数，你可以借助 <a href="http://babeljs.io/" target="_blank" rel="external">Babel</a>, <a href="https://github.com/google/traceur-compiler#what-is-traceur" target="_blank" rel="external">Traceur</a> 和 <a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a>。</p><p>下周我们将讨论一个比较陌生的特性，我们将看到 <code>typeof x</code> 将返回一个从未见过的值。</p><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/" target="_blank" rel="external">ES6 In Depth: Arrow functions</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-06-04 16:25</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从一开始箭头就是 JavaScript 的一部分，在第一个 JavaScript 中就建议将内联的脚本代码包裹在 HTML 的注释中，这可以防止那些不支持 JavaScript 的浏览器错误滴将你的代码显示为明文。你也许写过下面这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;language&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;javascript&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;&amp;lt;!--&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.bgColor = &lt;span class=&quot;string&quot;&gt;&quot;brown&quot;&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;// red&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;古老的浏览器将看到两个不被支持的标签和一段注释，只有支持 JavaScript 的新浏览器才会将其解析为 JavaScript 代码。&lt;/p&gt;
&lt;p&gt;为了支持这个古怪的特性，浏览器的 JavaScript 引擎把 &lt;code&gt;&amp;lt;!--&lt;/code&gt; 作为一个单行注释的开始，这不是开玩笑的，这一直都是这门语言的一部分，并且至今还能用，不仅仅在 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签内的首行，而是在 JavaScript 代码的任何部位都可用，它甚至还能在 Node 中使用。&lt;/p&gt;
&lt;p&gt;凑巧的是，这种风格的注释在 ES6 中首次&lt;a href=&quot;http://people.mozilla.org/~jorendorff/es6-draft.html#sec-html-like-comments&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;被标准化&lt;/a&gt;。但这并不是我们将谈论的箭头。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：解构赋值</title>
    <link href="http://bubkoo.com/2015/06/28/es6-in-depth-destructuring/"/>
    <id>http://bubkoo.com/2015/06/28/es6-in-depth-destructuring/</id>
    <published>2015-06-28T17:36:05.000Z</published>
    <updated>2015-06-28T17:36:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是解构赋值">什么是解构赋值？</span></h2><p>解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性值赋给一系列变量。这个语法非常简洁，而且比传统的属性访问更加清晰。</p><p>在不使用解构赋值的情况下，访问数组的前三项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> first = someArray[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> second = someArray[<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> third = someArray[<span class="number">2</span>];</div></pre></td></tr></table></figure><p>使用解构赋值后，相应的代码变得更简洁和可读：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [first, second, third] = someArray;</div></pre></td></tr></table></figure><p>SpiderMonkey（Firefox 的 JavaScript 引擎）已经支持解构赋值的大部分特性，但还不完全。</p><a id="more"></a><h2><span id="数组和可迭代对象的解构赋值">数组和可迭代对象的解构赋值</span></h2><p>上面我们已经看到了数组解构赋值的例子，该语法的一般形式是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ variable1, variable2, ..., variableN ] = array;</div></pre></td></tr></table></figure><p>这将把数组中对应的项依次赋给 <code>variable1</code> 到 <code>variableN</code>，如果同时需要声明变量，可以在解构表达式前面添加 <code>var</code>，<code>let</code> 或 <code>const</code> 关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [ variable1, variable2, ..., variableN ] = array;</div><div class="line"><span class="keyword">let</span> [ variable1, variable2, ..., variableN ] = array;</div><div class="line"><span class="keyword">const</span> [ variable1, variable2, ..., variableN ] = array;</div></pre></td></tr></table></figure><p>事实上，你还可以嵌套任意的深度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</div><div class="line"><span class="built_in">console</span>.log(foo);</div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(bar);</div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(baz);</div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure><p>此外，还可以跳过数组中的某些项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [,,third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</div><div class="line"><span class="built_in">console</span>.log(third);</div><div class="line"><span class="comment">// "baz"</span></div></pre></td></tr></table></figure><p>你还可以用一个 Rest 表达式来捕获数组中的剩余项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(tail);</div><div class="line"><span class="comment">// [2, 3, 4]</span></div></pre></td></tr></table></figure><p>如果数组越界或访问数组中不存在的项，将得到和通过数组索引访问一样的值：<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log([][<span class="number">0</span>]);</div><div class="line"><span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> [missing] = [];</div><div class="line"><span class="built_in">console</span>.log(missing);</div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>注意，数组解构赋值的方式也同样适用于可遍历的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">yield</span> a;</div><div class="line">    [a, b] = [b, a + b];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> [first, second, third, fourth, fifth, sixth] = fibs();</div><div class="line"><span class="built_in">console</span>.log(sixth);</div><div class="line"><span class="comment">// 5</span></div></pre></td></tr></table></figure><h2><span id="对象的解构赋值">对象的解构赋值</span></h2><p>对象的解构赋值允许你将变量绑定到对象不同的属性值。指定被绑定的属性名，后面紧跟要绑定的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> robotA = &#123; <span class="attr">name</span>: <span class="string">"Bender"</span> &#125;;</div><div class="line"><span class="keyword">var</span> robotB = &#123; <span class="attr">name</span>: <span class="string">"Flexo"</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameA &#125; = robotA;</div><div class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameB &#125; = robotB;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(nameA);</div><div class="line"><span class="comment">// "Bender"</span></div><div class="line"><span class="built_in">console</span>.log(nameB);</div><div class="line"><span class="comment">// "Flexo"</span></div></pre></td></tr></table></figure><p>当绑定的属性名和接收属性值的变量名一样时，还有一个语法糖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"lorem"</span>, <span class="attr">bar</span>: <span class="string">"ipsum"</span> &#125;;</div><div class="line"><span class="built_in">console</span>.log(foo);</div><div class="line"><span class="comment">// "lorem"</span></div><div class="line"><span class="built_in">console</span>.log(bar);</div><div class="line"><span class="comment">// "ipsum"</span></div></pre></td></tr></table></figure><p>与数组一样，也可以嵌套：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> complicatedObj = &#123;</div><div class="line">  arrayProp: [</div><div class="line">    <span class="string">"Zapp"</span>,</div><div class="line">    &#123; <span class="attr">second</span>: <span class="string">"Brannigan"</span> &#125;</div><div class="line">  ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123; <span class="attr">arrayProp</span>: [first, &#123; second &#125;] &#125; = complicatedObj;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(first);</div><div class="line"><span class="comment">// "Zapp"</span></div><div class="line"><span class="built_in">console</span>.log(second);</div><div class="line"><span class="comment">// "Brannigan"</span></div></pre></td></tr></table></figure><p>解构一个不存在的属性时，将得到 <code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123; missing &#125; = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(missing);</div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>使用对象的解构赋值时还有一个潜在的陷阱，在解构赋值时没有声明变量（没有 <code>var</code>、<code>let</code> 或 <code>const</code> 关键字）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; blowUp &#125; = &#123; <span class="attr">blowUp</span>: <span class="number">10</span> &#125;;</div><div class="line"><span class="comment">// Syntax error</span></div></pre></td></tr></table></figure><p>这是因为 JavaScript 语法告诉引擎任何以 <code>{</code> 开始的语句都是语句块（例如，<code>{console}</code> 就是一个合法的语句块），解决方法是将整个语句用一对括号包裹：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(&#123; safe &#125; = &#123;&#125;);</div><div class="line"><span class="comment">// No errors</span></div></pre></td></tr></table></figure><h2><span id="其他情况">其他情况</span></h2><p>当你尝试解构 <code>null</code> 或 <code>undefined</code>，你将得到类型错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;blowUp&#125; = <span class="literal">null</span>;</div><div class="line"><span class="comment">// TypeError: null has no properties</span></div></pre></td></tr></table></figure><p>不过，你可以对其他基本类型（Boolean、String 和 Number）进行解构，将得到 <code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;wtf&#125; = <span class="literal">NaN</span>;</div><div class="line"><span class="built_in">console</span>.log(wtf);</div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>结果也许会让你感到意外，但深究一下，其实原因很简单。在进行对象解构赋值时，被解构的对象将被<a href="https://people.mozilla.org/&lt;sub&gt;jorendorff/es6-draft.html#sec-requireobjectcoercible" target="_blank" rel="external">强制转换</a>为 <code>Object</code>，除 <code>null</code> 和 <code>undefined</code> 外，其它类型都可以被强制转换为对象。进行数组的结构赋值时，要求被解构的对象有一个<a href="https://people.mozilla.org/&lt;/sub&gt;jorendorff/es6-draft.html#sec-getiterator" target="_blank" rel="external">遍历器</a>。 </p><h2><span id="默认值">默认值</span></h2><p>可以为不存在的属性指定一个默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [missing = <span class="literal">true</span>] = [];</div><div class="line"><span class="built_in">console</span>.log(missing);</div><div class="line"><span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">"Something went wrong"</span> &#125; = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(msg);</div><div class="line"><span class="comment">// "Something went wrong"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123; x = <span class="number">3</span> &#125; = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(x);</div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure><h2><span id="实际应用">实际应用</span></h2><h3><span id="函数参数">函数参数</span></h3><p>作为开发人员，我们经常把一个包含多个属性的对象作为函数的参数，来实现更灵活的 API，而不是让 API 的使用者记住一些特定顺序的参数。我们可以使用对象的解构赋值，来避免每次使用参数时的属性访问：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeBreakpoint</span>(<span class="params">&#123; url, line, column &#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="配置对象">配置对象</span></h3><p>完善上面的例子，我们可以为要被解构的对象属性提供默认值，这在对那些作为配置参数的对象非常实用，因为许多配置项都有一个合理的默认值。例如，jQuery 的 <code>ajax</code> 方法的第二个参数为一个配置对象，我们可以这样实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></div><div class="line"><span class="function"><span class="params">  async = true,</span></span></div><div class="line"><span class="function"><span class="params">  beforeSend = noop,</span></span></div><div class="line"><span class="function"><span class="params">  cache = true,</span></span></div><div class="line"><span class="function"><span class="params">  complete = noop,</span></span></div><div class="line"><span class="function"><span class="params">  crossDomain = false,</span></span></div><div class="line"><span class="function"><span class="params">  global = true,</span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> ... more config</span></span></div><div class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// ... do stuff</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这避免了类似这样的重复代码：<code>var foo = config.foo || theDefaultFoo;</code>。</p><h3><span id="与迭代器一起使用">与迭代器一起使用</span></h3><p>当遍历 Map 对象时，我们可以使用解构赋值来遍历 <code>[key, value]</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="built_in">window</span>, <span class="string">"the global"</span>);</div><div class="line">map.set(<span class="built_in">document</span>, <span class="string">"the document"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// "[object Window] is the global"</span></div><div class="line"><span class="comment">// "[object HTMLDocument] is the document"</span></div></pre></td></tr></table></figure><p>只遍历键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>只遍历值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [,value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="返回多个值">返回多个值</span></h3><p>返回一个数组，通过解构赋值提取到返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnMultipleValues</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> [foo, bar] = returnMultipleValues();</div></pre></td></tr></table></figure><p>或者，返回一个键值对的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnMultipleValues</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    foo: <span class="number">1</span>,</div><div class="line">    bar: <span class="number">2</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = returnMultipleValues();</div></pre></td></tr></table></figure><p>这两者都比使用中间变量好：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnMultipleValues</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    foo: <span class="number">1</span>,</div><div class="line">    bar: <span class="number">2</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> temp = returnMultipleValues();</div><div class="line"><span class="keyword">var</span> foo = temp.foo;</div><div class="line"><span class="keyword">var</span> bar = temp.bar;</div></pre></td></tr></table></figure><p>采用延续式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnMultipleValues</span>(<span class="params">k</span>) </span>&#123;</div><div class="line">  k(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line">returnMultipleValues(<span class="function">(<span class="params">foo, bar</span>) =&gt;</span> ...);</div></pre></td></tr></table></figure><h3><span id="导入-commonjs-模块的指定部分">导入 CommonJS 模块的指定部分</span></h3><p>还没使用过 ES6 的模块吧，那至少使用过 CommonJS 吧。当导入一个 CommonJS 模块 X 时，模块提供的方法也许多余你实际使用的。使用解构赋值，你可以明确指定你需要使用模块的哪些部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</div></pre></td></tr></table></figure><p>如果你使用 ES6 的模块机制，你可以看到 import 声明时有一个类似的语法。</p><h2><span id="结论">结论</span></h2><p>我们看到，解构赋值在很多场景下都很实用。在 Mozilla，我们已经有很多经验。Lars Hansen 在 10 年前就向 Opera 引入了解构赋值，Brendan Eich 在稍微晚点也给 Firefox 添加了支持，最早出现在 Firefox 2 中。因此，解构赋值已经渗透到我们每天对 JS 的使用中，悄悄地使我们的代码更简短、整洁。</p><p>几周之前，我说过 ES6 将改变我们的编码方式。这些简单地改进，可以在几分钟内就掌握使用，这些改进正是我们需要的。总的来说，它们最终将影响我们日常的每项工作，是一种革命式进化。</p><p>开发版的 Chrome 已经支持解构赋值，毋庸置疑，其他浏览器在不久将来也会陆续支持。如果现在你想使用该特性，你可以使用 <a href="http://babeljs.io/" target="_blank" rel="external">Babel</a> 或 <a href="https://github.com/google/traceur-compiler#what-is-traceur" target="_blank" rel="external">Traceur</a> 这两个编译器。</p><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/" target="_blank" rel="external">ES6 In Depth: Destructuring</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-05-28 16:12</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是解构赋值？&quot;&gt;&lt;a href=&quot;#什么是解构赋值？&quot; class=&quot;headerlink&quot; title=&quot;什么是解构赋值？&quot;&gt;&lt;/a&gt;什么是解构赋值？&lt;/h2&gt;&lt;p&gt;解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性值赋给一系列变量。这个语法非常简洁，而且比传统的属性访问更加清晰。&lt;/p&gt;
&lt;p&gt;在不使用解构赋值的情况下，访问数组的前三项：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; first = someArray[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; second = someArray[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; third = someArray[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用解构赋值后，相应的代码变得更简洁和可读：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; [first, second, third] = someArray;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;SpiderMonkey（Firefox 的 JavaScript 引擎）已经支持解构赋值的大部分特性，但还不完全。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：Rest 参数和参数默认值</title>
    <link href="http://bubkoo.com/2015/06/27/es6-in-depth-rest-parameters-and-defaults/"/>
    <id>http://bubkoo.com/2015/06/27/es6-in-depth-rest-parameters-and-defaults/</id>
    <published>2015-06-27T17:36:05.000Z</published>
    <updated>2015-06-27T17:36:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将讨论使 JavaScript 函数更有表现力的两个特性：Rest 参数和参数默认值。</p><h2><span id="rest-参数">Rest 参数</span></h2><p>通常，我们需要创建一个可变参数的函数，可变参数是指函数可以接受任意数量的参数。例如，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat" target="_blank" rel="external"><code>String.prototype.concat</code></a> 可以接受任何数量的字符串作为参数。使用 Rest 参数，ES6 为我们提供一种新的方式来创建可变参数的函数。</p><p>我们来实现一个示例函数 <code>containsAll</code>，用于检查一个字符串中是否包含某些子字符串。例如，<code>containsAll(&quot;banana&quot;, &quot;b&quot;, &quot;nan&quot;)</code> 将返回<code>true</code>，<code>containsAll(&quot;banana&quot;, &quot;c&quot;, &quot;nan&quot;)</code> 将返回 <code>false</code>。</p><p>下面是传统的实现方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsAll</span>(<span class="params">haystack</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> needle = <span class="built_in">arguments</span>[i];</div><div class="line">    <span class="keyword">if</span> (haystack.indexOf(needle) === <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>该实现用到了 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="external">arguments</a> 对象，该对象是一个类数组对象，包含函数被调用时的实参列表。这段代码正是我们想要的，但其可读性却不是最优的。函数只有一个形参 <code>haystack</code>，所以不可能一看就知道该函数需要多个参数，并且在遍历 <code>arguments</code> 时，需要特别注意遍历的开始索引为 <code>1</code> ，而不是常见的 <code>0</code>，因为 <code>arguments[0]</code> 就是函数定义时的形参 <code>haystack</code>。如果我们想在 <code>haystack</code> 参数之前或之后添加一些参数，我们不得不更新内部的循环。Rest 参数解决了这些问题，下面是 使用 Rest 参数的实现方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsAll</span>(<span class="params">haystack, ...needles</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> needle <span class="keyword">of</span> needles) &#123;</div><div class="line">    <span class="keyword">if</span> (haystack.indexOf(needle) === <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上两个实现都满足了我们的需求，但后者包含一个特殊的 <code>...needles</code> 语法。我们来看看调用 <code>containsAll(&quot;banana&quot;, &quot;b&quot;, &quot;nan&quot;)</code> 时的细节，参数 <code>haystack</code> 和以往一样，将用函数的第一个实参填充，值为 <code>&quot;banana&quot;</code>，<code>needles</code> 前面的省略号表示它是一个 Rest 参数，剩余的所有实参将被放入一个数组中，并将该数组赋给 <code>needles</code> 遍量。在这个调用中，<code>needles</code> 的值为 <code>[&quot;b&quot;, &quot;nan&quot;]</code>。然后，就是正常的函数执行了。</p><p>只能将函数的最后一个函数作为 Rest 参数，在函数被调用时，Rest 参数之前的参数都将被正常填充，之外的参数将被放入一个数组中，并将该数组作为 Rest 参数的值，如果没有更多的参数，那么 Rest 参数的值为一个空数组 <code>[]</code>，Rest 参数的值永远都不会是 <code>undefined</code>。</p><h2><span id="参数的默认值">参数的默认值</span></h2><p>通常，调用一个函数时，不需要调用者传递所有可能的参数，那些没有传递的参数都需要一个合理的默认值。JavaScript 对那些没有传递的参数都有一个固定的默认值 <code>undefined</code>。在 ES6 中，引入了一种新方法来指定任意参数的默认值。</p><p>看下面例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">animalSentence</span>(<span class="params">animals2=<span class="string">"tigers"</span>, animals3=<span class="string">"bears"</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`Lions and <span class="subst">$&#123;animals2&#125;</span> and <span class="subst">$&#123;animals3&#125;</span>! Oh my!`</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在每个参数的 <code>=</code> 后面是一个表达式，指定了参数未传递时的默认值。所以，<code>animalSentence()</code> 返回 <code>&quot;Lions and tigers and bears! Oh my!&quot;</code>， <code>animalSentence(&quot;elephants&quot;)</code> 返回 <code>&quot;Lions and elephants and bears! Oh my!&quot;</code>， <code>animalSentence(&quot;elephants&quot;, &quot;whales&quot;)</code> 返回 <code>&quot;Lions and elephants and whales! Oh my!&quot;</code>。 </p><p>参数默认值需要注意的几个细节：</p><ul><li>与 Python 不一样的是，<strong>参数默认值的表达式是在函数调用时从左到右计算的</strong>，这意味着表达式可以使用前面已经被填充的参数。例如，我们可以将上面的函数变得更有趣一点：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">animalSentenceFancy</span>(<span class="params">animals2=<span class="string">"tigers"</span>,</span></span></div><div class="line"><span class="function"><span class="params">    animals3=(animals2 == <span class="string">"bears"</span></span>) ? "<span class="title">sealions</span>" : "<span class="title">bears</span>")</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">`Lions and <span class="subst">$&#123;animals2&#125;</span> and <span class="subst">$&#123;animals3&#125;</span>! Oh my!`</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么，<code>animalSentenceFancy(&quot;bears&quot;)</code> 将返回 <code>&quot;Lions and bears and sealions. Oh my!&quot;</code>。</p><ul><li><p>传递 <code>undefined</code> 等同于没有传递该参数。因此，<code>animalSentence(undefined, &quot;unicorns&quot;)</code> 将返回 <code>&quot;Lions and tigers and unicorns! Oh my!&quot;</code>。</p></li><li><p>如果没有为一个参数指定默认值，那么该参数的默认值为 <code>undefined</code>，所以</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">a=<span class="number">42</span>, b</span>) </span>&#123;...&#125;</div></pre></td></tr></table></figure><p>等同于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">a=<span class="number">42</span>, b=undefined</span>) </span>&#123;...&#125;</div></pre></td></tr></table></figure><h2><span id="抛弃-arguments">抛弃 arguments</span></h2><p>通过 Rest 参数和参数的默认值，我们可以完全抛弃 <code>arguments</code> 对象，使我们的代码可读性更高。此外，<code>arguments</code> 对象也加深了<a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments" target="_blank" rel="external">优化 JavaScript 的难题</a>。 </p><p>希望以上两个新特性可以完全取代 <code>arguments</code>。作为第一步，在使用 Rest 参数或参数的默认值时，请避免使用 <code>arguments</code> 对象，假如 <code>arguments</code> 对象还不会立即被移除，或者永远不会，那么也最好是避免在使用 Rest 参数或参数默认值时使用 <code>arguments</code> 对象。</p><h2><span id="兼容性">兼容性</span></h2><p>Firefox 15 以上的版本已经支持这两个新特性。然而，除此之外，还没有其他任何浏览器支持。最近，V8 的<a href="https://code.google.com/p/v8/issues/detail?id=2159" target="_blank" rel="external">实验环境添加了对 Rest 参数的支持</a>，而参数默认值还有一个 <a href="https://code.google.com/p/v8/issues/detail?id=2160" target="_blank" rel="external">issue</a>，JSC 也对 <a href="https://bugs.webkit.org/show_bug.cgi?id=38408" target="_blank" rel="external">Rest 参数</a>和<a href="https://bugs.webkit.org/show_bug.cgi?id=38409" target="_blank" rel="external">参数默认值</a>提了一些 issue。</p><p> <a href="http://babeljs.io/" target="_blank" rel="external">Babel</a> 和 <a href="https://github.com/google/traceur-compiler#what-is-traceur" target="_blank" rel="external">Traceur</a> 这两个编译器都已经支持了参数默认值，所以你可以大胆使用。</p><h2><span id="结论">结论</span></h2><p>尽管从技术层面上看，这两个新特性在并没有给函数引入新的行为，但它们可以使一些函数的声明更具表现力和可读性。</p><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/05/es6-in-depth-rest-parameters-and-defaults/" target="_blank" rel="external">ES6 In Depth: Rest parameters and defaults</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-05-21 13:32</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将讨论使 JavaScript 函数更有表现力的两个特性：Rest 参数和参数默认值。&lt;/p&gt;
&lt;h2 id=&quot;Rest-参数&quot;&gt;&lt;a href=&quot;#Rest-参数&quot; class=&quot;headerlink&quot; title=&quot;Rest 参数&quot;&gt;&lt;/a&gt;Rest 参数&lt;/h2&gt;&lt;p&gt;通常，我们需要创建一个可变参数的函数，可变参数是指函数可以接受任意数量的参数。例如，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;String.prototype.concat&lt;/code&gt;&lt;/a&gt; 可以接受任何数量的字符串作为参数。使用 Rest 参数，ES6 为我们提供一种新的方式来创建可变参数的函数。&lt;/p&gt;
&lt;p&gt;我们来实现一个示例函数 &lt;code&gt;containsAll&lt;/code&gt;，用于检查一个字符串中是否包含某些子字符串。例如，&lt;code&gt;containsAll(&amp;quot;banana&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;nan&amp;quot;)&lt;/code&gt; 将返回&lt;code&gt;true&lt;/code&gt;，&lt;code&gt;containsAll(&amp;quot;banana&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;nan&amp;quot;)&lt;/code&gt; 将返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面是传统的实现方式：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;containsAll&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;haystack&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; needle = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;[i];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (haystack.indexOf(needle) === &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>介绍几个 CSS 方法论</title>
    <link href="http://bubkoo.com/2015/06/25/css-methodologies/"/>
    <id>http://bubkoo.com/2015/06/25/css-methodologies/</id>
    <published>2015-06-25T10:52:08.000Z</published>
    <updated>2015-06-25T10:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>在大型、复杂和快速迭代的系统中，CSS 将非常难以维护。原因之一就是 CSS 没有作用域的概念，每个 CSS 都是全局的，这意味着对 CSS 的任何修改就可能导致一些 UI 的级联改变。</p><p>CSS 的扩展语言 – <a href="http://sixrevisions.com/elsewhere-on-the-web/the-best-css-preprocessors-right-now/" target="_blank" rel="external">CSS 预处理器</a>，比如 Sass、Less 和 Stylus，使我们编写 CSS 更加容易，但在我看来，这些 CSS 的扩展语言并没有真正解决可扩展性问题。</p><p>在 CSS 支持作用域机制之前，我们需要一种机制，使我们的样式只与特定的 HTML 部分关联，这就是 CSS 方法论。本文将讨论如下的 CSS 方法论：</p><ul><li>Object-Oriented CSS (OOCSS)</li><li>Block, Element, Modifier (BEM)</li><li>Scalable and Modular Architecture for CSS (SMACSS)</li><li>SUIT CSS</li><li>Systematic CSS</li></ul><p>CSS 方法论是正式的，文档化的 CSS 编写方法，使我们能够将 CSS 作为一些小的独立的模块来开发和维护，而不是一个庞大的不可分割的一坨代码。采用一种 CSS 方法论 – 即便这是你自己创建的 – 它将使你在 Web 开发中更加得心应手。</p><p>相关文章：<a href="http://sixrevisions.com/css/css-development-at-large-sites/" target="_blank" rel="external">CSS Development at Large-Scale Websites</a></p><p>每个 CSS 方法论都为可扩展性和可维护性提供了一套解决方案，一个 CSS 方法论通常会定义：</p><ul><li>CSS 和 HTML 的最佳实践</li><li>Class 和 ID 的命名约定</li><li>有序的、分组的 CSS 样式</li><li>代码格式</li></ul><p>没有“最好”的 CSS 方法论，不同的个人/团队/项目适合于不同的方法论。希望通过本文你可以找到一个适合你的方法论，或者激发你创建一个你自己的。</p><a id="more"></a><h2><span id="object-oriented-css-oocss"></span></h2><p>Object-Oriented CSS 简称为 OOCSS，发布于 2009 年，这是第一个被广泛采用的 CSS 方法论，直到今天仍有很大的影响力。</p><p>OOCSS 主张结构与样式分离，明确区分内容和它的容器。在 OOCSS 中，样式规则使用相互独立的 CSS 选择器来界定。</p><h3><span id="案例分析">案例分析</span></h3><p>例如，一个按钮元素可以通过两个样式来设定：</p><ul><li><code>.button</code> – 提供按钮的基本样式</li><li><code>.grey-btn</code> – 应用颜色和其他可视化属性</li></ul><p><strong>HTML</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"button grey-btn"</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>CSS</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.button</span> &#123;</div><div class="line">  <span class="attribute">box-sizing</span>: border-box;</div><div class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.grey-btn</span> &#123;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#EEE</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#DDD</span>;</div><div class="line">  <span class="attribute">box-shadow</span>: <span class="built_in">rgba</span>(0, 0, 0, 0.5) <span class="number">1px</span> <span class="number">1px</span> <span class="number">3px</span>;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#555</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>OOCSS 方法论的目标之一是减少样式规则中相同属性的重复率。该方法论试图通过许多小的、模块化的、专有功能的 CSS 类来实现这一目标。很少通过类型选择器（比如：h1，div 和 body）来指定其样式。</p><p>注意：在 OOCSS 方法论中，不鼓励使用后代选择器：</p><p><strong>CSS</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 在 OOCSS 中，不鼓励使用后代选择器 */</span></div><div class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.blog-post</span> <span class="selector-class">.button</span> &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>避免使用后代选择器，这样 HTML 的呈现就不依赖于特定的 HTML 结构（样式与结构分离）。</p><p>OOCSS 鼓励大家尽量复用已有样式，通过扩展现有的样式规则来创建新的样式类，而不要修改或覆盖已有的 CSS 属性。</p><p>下面我们想让无序列表的第一项的颜色突出一些，先看看不好的方式：</p><p><strong>HTML</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 反例 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"to-do"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Combine my CSS files<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Run CSS Lint<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Minify my stylesheet<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>CSS</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 反例 */</span></div><div class="line"><span class="selector-class">.to-do</span> &#123;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#FFF</span>;</div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.to-do</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#FF0000</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>为了使我们的 CSS 更加模块化和更具可维护性，并且避免使用后代选择器，看下面更好的写法：</p><p><strong>HTML</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- OOCSS --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"to-do"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"first-to-do-item"</span>&gt;</span>Combine my CSS files<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Run CSS Lint<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Minify my stylesheet<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>CSS</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* OOCSS */</span></div><div class="line"><span class="selector-class">.to-do</span> &#123;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#FFF</span>;</div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.first-to-do-item</span> &#123;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#FF0000</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="小结">小结</span></h3><p>OOCSS 的主要缺陷是将产生大量的 CSS 类，这将非常难以维护。在我看来，面向对象编程的理念并不是非常适合 CSS。但这并不是说 OOCSS 的原则不实用，相反，OOCSS 是一个最基础的方法论，它给大规模的 CSS 带来了福音。</p><h2><span id="block-element-modifier-bem"></span></h2><p>Block, Element, Modifier 通常被称为 BEM，由俄罗斯的 Google 团队设计。BEM 的主要设计理念是用不同的角色来区分不同的 CSS 类，也就是说用角色来命名 CSS 类。BEM 补充了 OOCSS 的不足，因为 OOCSS 并没有任何的命名约定。</p><p>在 BEM 方法论中，<strong>block</strong> 是一个独立的模块化的 UI 组件，一个 block 可以由多个 HTML 元素组成，甚至可以由多个 block 组成，例如导航菜单或搜索表单。<strong>element</strong> 是 block 的组成部分，服务于一个单一的目的，例如，在一个导航中，element 就是导航菜单中的链接，在实际中就是一个 <code>li</code> 元素和一个 <code>a</code> 元素。<strong>modifier</strong> 用于改变 block 和 element 的默认样式。</p><p>下面是 BEM 的命名规范：</p><ul><li>.block</li><li>.block–modifier</li><li>.block__element</li><li>.block__element–modifier</li></ul><h3><span id="案例分析">案例分析</span></h3><p>看下面的登录表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Password <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure><p>用 BEM 方法论将如下实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"loginform loginform--errors"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"loginform__username loginform__username--error"</span>&gt;</span></div><div class="line">    Username <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"loginform__password"</span>&gt;</span></div><div class="line">    Password <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"loginform__btn loginform__btn--inactive"</span>&gt;</span></div><div class="line">    Sign in</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure><p><code>.loginform</code> 类就是 block。</p><p><code>.loginform</code> 由下面三个 element 组成</p><ul><li><code>.loginform__username</code> 用户名</li><li><code>.loginform__password</code> 密码</li><li><code>.loginform__btn</code> 登录按钮</li></ul><p>还有三个 modifier 分别是：</p><ul><li><code>.loginform__username--error</code> 使用户名元素呈现为一个错误提醒的样式</li><li><code>.loginform__btn--inactive</code> 使登录按钮元素呈现为不可用的样式</li><li><code>.loginform--errors</code> 使整个登录表单呈现为错误提醒的样式</li></ul><p>BEM 的命名约定有助于 CSS 作者遵循 OOCSS 的扁平化设计原则，避免了使用深层次的后代选择器。例如下面的 CSS 选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.loginform</span> <span class="selector-class">.username</span> <span class="selector-class">.error</span> &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以使用单一一个 CSS 类来实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.loginform__username--error</span> &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="小结">小结</span></h3><p>BEM 是一个非常健壮的命名约定，可以方便地区分不同 CSS 类的目的，而且在 HTML 中也可以很方便地识别 CSS 类之间的关系。</p><p>BEM 的反对者主要有以下两类：</p><ul><li>CSS 类名太长太丑</li><li>命名约定对不熟练的开发者不友好</li></ul><h2><span id="scalable-and-modular-architecture-for-css-smacss"></span></h2><p>Jonathan Snook 在 2011 年出版了《Scalable and Modular Architecture for CSS》这本书，简称为 SMACSS，发音是 [smacks]。</p><p>该方法论的核心思路是如何为 CSS 样式分类。Snook 提出了一下五类：</p><ul><li><strong>Base</strong> 为单个 HTML 元素设置默认样式，通常是标签选择器：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">h1 &#123;</div><div class="line"> font-size: <span class="number">32</span>px;</div><div class="line">&#125;</div><div class="line">div &#123;</div><div class="line">  margin: <span class="number">0</span> auto;</div><div class="line">&#125;</div><div class="line">a &#123;</div><div class="line">  color: blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>Layout</strong>  与网页布局相关的样式，样式名通常以 <code>layout-</code> 或 <code>l-</code> 开头：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.layout-sidebar &#123;</div><div class="line">  width: <span class="number">320</span>px;</div><div class="line">&#125;</div><div class="line">.l-comments &#123;</div><div class="line">  width: <span class="number">640</span>px;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>Modules</strong> 模块和可复用的组件：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.call-to-action-button &#123;</div><div class="line">  text-transform: uppercase;</div><div class="line">  color: #FFF200;</div><div class="line">&#125;</div><div class="line">.search-form &#123;</div><div class="line">  display: inline-block;</div><div class="line">  background-color: E1E1E1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>State</strong>  指定界面特定状态的样式规则：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.is-hidden &#123;</div><div class="line">  display: none;</div><div class="line">&#125;</div><div class="line">.is-highlighted &#123;</div><div class="line">  color: #FF0000;</div><div class="line">  background-color: #F4F0BB;</div><div class="line">  border: 1px solid #CBBD15;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>Themes</strong> 影响整体布局和模块的样式，由用户设置触发。</li></ul><p>SMACSS 提供了一个比 BEM 更简单的命名约定。基础样式（base）没有 CSS 类名，因为他们都是标签选择器（h1, p, a 等），模块（module）有一个唯一的样式名，子模块用父模块名作为前缀。</p><p>看下面布局，在 <code>.l-footer</code> 中，有一个搜索模块，并且搜索表单至少被用户提交过一次：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"l-footer"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"search is-submitted"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Search"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></div></pre></td></tr></table></figure><p>SMACSS 也不推荐使用后代选择器，Jonathan Snook 还介绍了 <a href="https://smacss.com/book/applicability" target="_blank" rel="external">CSS 的最佳实用深度</a>理论，该理论的核心思想是通过类名来精确控制目标元素的样式，从而减少 HTML 结构对样式的影响。</p><h2><span id="suit-css"></span></h2><p>Nicolas Gallagher 提出的 SUIT CSS 发布于 2014年，他通过 CSS 预处理器定义了一套类似 BEM 命名规范，SUIT CSS 的命名方式有如下五种：</p><ul><li>u-utilityName</li><li>ComponentName</li><li>ComponentName–modifierName</li><li>ComponentName-elementName</li><li>ComponentName.is-stateOfName</li></ul><p>该命名约定突出的区分了：</p><ul><li>General utility classes</li><li>Standalone/modular UI components</li><li>Individual elements</li><li>Modifiers</li></ul><p>看下面的登录表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"LoginForm LoginForm--errors"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"LoginForm-username is-required"</span>&gt;</span></div><div class="line">    Username <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"LoginForm-password"</span>&gt;</span></div><div class="line">    Password <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"LoginForm-button is-inactive"</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure><h2><span id="systematic-css"></span></h2><p>Systematic CSS 是原文作者最近才提出来的一个方法论，借鉴了许多 OOCSS、BEM、SMACSS、SUIT CSS 和其他一些 CSS 方法论的原理和思路。Systematic CSS 可以作为现有 CSS 方法论的简单的替代方案，只需要记住少许几个命名约定，并且命名也更加直观。</p><p>在 Systematic CSS 方法论中，一个页面被分为一下四个部分：</p><ul><li>Layout</li><li>Elements</li><li>Widgets</li><li>Modifiers</li></ul><p>首先，使用 <code>section</code> 或 <code>div</code> 元素来创建一个页面布局：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"CONTAINER"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"BANNER"</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"NAVIGATION_PRIMARY"</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"NAVIGATION_SECONDARY"</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"MAIN"</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"ADVERTS"</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"FOOTER"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"SITEMAP"</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"LEGAL"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>其次，为内容和交互元素建立默认样式，比如，标题（<code>h1</code>, <code>h2</code>, <code>h3</code>）、段落（<code>p</code>）、列表（<code>ul</code> 和 <code>ol</code>）、表格（<code>table</code>）、表单（<code>form</code>）等。</p><p>然后，确定页面中那些重复的部分，将这些重复的部分提取为一个个独立的模块。在 Systematic CSS 中这些模块被称为 <strong>widget</strong>。看下面两个 widget：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- navigation bar --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"NavBar"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"./"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"about.html"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"learn/"</span>&gt;</span>Learn<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"extend/"</span>&gt;</span>Extend<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"share/"</span>&gt;</span>Share<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- search form --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"SearchBox"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"search.html"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"input-search"</span>&gt;</span>Search<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"q"</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">id</span>=<span class="string">"input-search"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Search<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>最后，为一些默认样式添加修饰（modifier）类。</p><p>看下面例子，<code>navbar-primary</code> 修饰类改变了 <code>NavBar</code> 的默认样式，<code>navbar-selected</code> 修饰类标记了当前的选中项：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"NavBar navbar-primary"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"./"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"about.html"</span> <span class="attr">class</span>=<span class="string">"navbar-selected"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"learn/"</span>&gt;</span>Learn<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"extend/"</span>&gt;</span>Extend<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"share/"</span>&gt;</span>Share<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>在 Systematic CSS 中，一个 CSS 类可以是：</p><ul><li>布局（layout）名称</li><li>组件（widget）名称</li><li>修饰符</li></ul><p>一个 CSS 类只能是以上三种的一种，不能将以上三种结合使用。它们分别有不同的命名约定：</p><ul><li>Layout - 全大写</li><li>Widget - 大驼峰</li><li>Modifier - 全小写加连接符</li></ul><p>这个命名约定的优点是，类的层次结构由它们的名字来代表。</p><p>布局的类名采用全大写的形式，非常显眼，例如：<code>.NAVIGATION</code>，<code>.SIDEBAR</code>，<code>.FOOTER</code>。</p><p>组件的类名采用大驼峰的形式，比较显眼，例如：<code>.MainMenu</code>，<code>.ImageGrid</code>，<code>.BlogPost</code>。</p><p>修饰类是最不重要的类，因为它们修饰一些默认样式，不是默认样式的必要部分，所以它们采用全小写的形式，也最不显眼，例如：<code>.is-highlighted</code>，<code>.has-errors</code>，<code>.hidden</code>。</p><h2><span id="其他-css-方法论">其他 CSS 方法论</span></h2><ul><li><a href="http://bradfrost.com/blog/post/atomic-web-design/" target="_blank" rel="external">Atomic Design</a></li><li><a href="http://docssa.info/" target="_blank" rel="external">DoCSSa</a></li><li><a href="http://www.csstyle.io/" target="_blank" rel="external">csstyle</a></li></ul><h2><span id="相关文章">相关文章</span></h2><ul><li><a href="http://sixrevisions.com/css/css-methodologies" target="_blank" rel="external">A Look at Some CSS Methodologies</a></li><li><a href="http://sixrevisions.com/css/standardized-methods-for-css/" target="_blank" rel="external">5 Standardized Methods for Writing CSS</a></li><li><a href="http://sixrevisions.com/css/using-css3-appropriately/" target="_blank" rel="external">Are You Using CSS3 Appropriately?</a></li><li><a href="http://sixrevisions.com/css/css-style-guides/" target="_blank" rel="external">A List of CSS Styles Guides for Inspiration</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在大型、复杂和快速迭代的系统中，CSS 将非常难以维护。原因之一就是 CSS 没有作用域的概念，每个 CSS 都是全局的，这意味着对 CSS 的任何修改就可能导致一些 UI 的级联改变。&lt;/p&gt;
&lt;p&gt;CSS 的扩展语言 – &lt;a href=&quot;http://sixrevisions.com/elsewhere-on-the-web/the-best-css-preprocessors-right-now/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS 预处理器&lt;/a&gt;，比如 Sass、Less 和 Stylus，使我们编写 CSS 更加容易，但在我看来，这些 CSS 的扩展语言并没有真正解决可扩展性问题。&lt;/p&gt;
&lt;p&gt;在 CSS 支持作用域机制之前，我们需要一种机制，使我们的样式只与特定的 HTML 部分关联，这就是 CSS 方法论。本文将讨论如下的 CSS 方法论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Object-Oriented CSS (OOCSS)&lt;/li&gt;
&lt;li&gt;Block, Element, Modifier (BEM)&lt;/li&gt;
&lt;li&gt;Scalable and Modular Architecture for CSS (SMACSS)&lt;/li&gt;
&lt;li&gt;SUIT CSS&lt;/li&gt;
&lt;li&gt;Systematic CSS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSS 方法论是正式的，文档化的 CSS 编写方法，使我们能够将 CSS 作为一些小的独立的模块来开发和维护，而不是一个庞大的不可分割的一坨代码。采用一种 CSS 方法论 – 即便这是你自己创建的 – 它将使你在 Web 开发中更加得心应手。&lt;/p&gt;
&lt;p&gt;相关文章：&lt;a href=&quot;http://sixrevisions.com/css/css-development-at-large-sites/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS Development at Large-Scale Websites&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每个 CSS 方法论都为可扩展性和可维护性提供了一套解决方案，一个 CSS 方法论通常会定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS 和 HTML 的最佳实践&lt;/li&gt;
&lt;li&gt;Class 和 ID 的命名约定&lt;/li&gt;
&lt;li&gt;有序的、分组的 CSS 样式&lt;/li&gt;
&lt;li&gt;代码格式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;没有“最好”的 CSS 方法论，不同的个人/团队/项目适合于不同的方法论。希望通过本文你可以找到一个适合你的方法论，或者激发你创建一个你自己的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="CSS" scheme="http://bubkoo.com/tags/css/"/>
    
      <category term="Methodology" scheme="http://bubkoo.com/tags/methodology/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：模板字符串</title>
    <link href="http://bubkoo.com/2015/06/23/es6-in-depth-template-strings/"/>
    <id>http://bubkoo.com/2015/06/23/es6-in-depth-template-strings/</id>
    <published>2015-06-23T04:16:48.000Z</published>
    <updated>2015-06-23T04:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 ES6 中引入了一种新的字符串字面量 – 模板字符串，除了使用反引号 (`) 表示，它们看上去和普通的字符串没有什么区别。在最简单的情况下，他们就是普通的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">context.fillText(<span class="string">`Ceci n'est pas une chaîne.`</span>, x, y);</div></pre></td></tr></table></figure><p>之所以被称为模板字符串，是因为模板字符串为 JS 引入了简单的字符串插值特性，也就是说，可以方便优雅地将 JS 的值插入到字符串中。</p><a id="more"></a><p>很多地方可以用到模板字符串，看下面这个不起眼的错误提示消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</div><div class="line">      <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面代码中，<code>${user.name}</code> 和 <code>${action}</code> 被称为<em>模板占位符</em>，JavaScript 将把 <code>user.name</code> 和 <code>action</code> 的值分别插到对应的位置上，然后生成像这样 “User jorendorff is not authorized to do hockey.” 的字符串。</p><p>现在，我们看到了一个比 <code>+</code> 运算符更优雅的语法，下面是一些你期待的特性：</p><ul><li>模板占位符可以是任何 JavaScript 表达式，所以函数调用和四则运算等都是合法的。（甚至你还可以在一个模板字符串中嵌套另一个模板字符串。）</li><li>如果一个值不是字符串，它将被转换为字符串。例如，如果 <code>action</code> 是一个对象，那么该对象的 <code>.toString()</code> 将被调用，来将其转换为字符串。</li><li>如果你想在模板字符串中使用反引号，你需要使用反斜杠 <code>\</code> 将其转义。</li><li><p>同样地，如果想在模板字符串中输出 <code>${</code>，也需要使用反斜杠将其转义：<code>\${</code> 或 <code>$\{</code>。</p></li><li><p>模板字符串可以跨越多行：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#warning"</span>).html(<span class="string">`</span></div><div class="line"><span class="string">  &lt;h1&gt;Watch out!&lt;/h1&gt;</span></div><div class="line"><span class="string">  &lt;p&gt;Unauthorized hockeying can result in penalties</span></div><div class="line"><span class="string">  of up to <span class="subst">$&#123;maxPenalty&#125;</span> minutes.&lt;/p&gt;</span></div><div class="line"><span class="string">`</span>);</div></pre></td></tr></table></figure><ul><li>模板字符串中所有的空格、换行和缩进，都将被原样输出到结果字符串中。</li></ul><p>下面我们来看看模板字符串<strong>做不到的事情</strong>：</p><ul><li>不会自动转义特殊字符，为了避免<a href="http://www.techrepublic.com/blog/it-security/what-is-cross-site-scripting/" target="_blank" rel="external">跨站脚本漏洞</a>，你还是需要小心对待不可信的数据，这一点上与普通字符串一样。</li><li>不能与国际化库配合使用，不处理特殊语言格式的数字、日期等。</li><li>不是模板引擎（比如 <a href="https://mustache.github.io/" target="_blank" rel="external">Mustache</a> 或 <a href="https://mozilla.github.io/nunjucks/" target="_blank" rel="external">Nunjucks</a>）的替代品。模板字符串没有处理循环的语法 – 不能通过一个数组构建出一个表格（table）。</li></ul><p>为了解决这些限制，ES6 为开发者和库设计者提供了另一种模板字符串 – <em>标签模板</em>。</p><p>标签模板的语法很简单，只需要在开始的反引号前引入一个标签。看第一个例子：<code>SaferHTML</code>，我们要使用这个标签模板来解决上述的第一个限制：自动转义特殊字符。</p><p>需要注意的是，<code>SaferHTML</code> 方法并不是 ES6 标准库提供的，我们需要自己来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message =</div><div class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;bonk.sender&#125;</span> has sent you a bonk.&lt;/p&gt;`</span>;</div></pre></td></tr></table></figure><p>这里的 <code>SaferHTML</code> 标签是单个标识符，标签也可以是属性，比如 <code>SaferHTML.escape</code>，甚至还可以是方法调用：<code>SaferHTML.escape({unicodeControlCharacters: false})</code>。准确地说，任何 ES6 的<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-left-hand-side-expressions" target="_blank" rel="external">成员表达式或调用表达式</a>都可以作为标签。</p><p>可以看出，模板字符串仅仅是字符串连接的语法糖，而标签模板确是一个完全不同的东西：函数调用。</p><p>所以，上面代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message =</div><div class="line">  SaferHTML(templateData, bonk.sender);</div></pre></td></tr></table></figure><p>其中 <code>templateData</code> 是一个不可变的字符串数组，由 JS 引擎基于源模板字符串生成，这里的数组含有两个元素，因为模板字符串被占位符分隔后含有两个字符串，因此，<code>templateData</code> 将是这样： <code>Object.freeze([&quot;&lt;p&gt;&quot;, &quot; has sent you a bonk.&lt;/p&gt;&quot;]</code></p><p>（事实上，<code>templateData</code> 上还有另一个属性：<code>templateData.raw</code>，本文并深入不讨论该属性。该属性的值也是一个数组，包含了标签模板中所有的字符串部分，但字符串中包含了转义序列，看上去更像源代码中的字符串，比如 <code>\n</code>。ES6 的内置标签 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw" target="_blank" rel="external"><code>String.raw</code></a> 将使用这些字符串。）</p><p>这就使得 <code>SaferHTML</code> 方法可以随意解析这两个字符串，存在 N 中替换方式。</p><p>在继续阅读钱，你可能在苦苦思索如何实现 <code>SaferHTML</code> 方法。</p><p>下面是一种实现（<a href="https://gist.github.com/jorendorff/1a17f69dbfaafa2304f0" target="_blank" rel="external">gist</a>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = templateData[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</div><div class="line"></div><div class="line">    <span class="comment">// Escape special characters in the substitution.</span></div><div class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</div><div class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</div><div class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Don't escape special characters in the template.</span></div><div class="line">    s += templateData[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>有了上面的方法，即使使用一个恶意的用户名，用户也是安全的。</p><p>一个简单的例子并不足以说明标签模板的灵活性，让我们重温一下上面列举的模板字符串的限制，看看我们还可以做些什么。</p><ul><li><p>模板字符串不会自动转义特殊字符，但是我们可以通过标签模板来解决这个问题，事实上我们还可以将 <code>SaferHTML</code> 这个方法写的更好。</p><p>从安全角度来看，这个 <code>SaferHTML</code> 非常脆弱。在 HTML 中，不同的地方需要用不同的方式去转义，<code>SaferHTML</code> 并没有做到。稍加思考，我们就可以实现一个更加灵活的 <code>SaferHTML</code> 方法，能够将 <code>templateData</code> 中的任何一个 HTML 转义，知道哪个占位符是纯 HTML；哪个是元素的属性，从而需要对 <code>&#39;</code> 和 <code>&quot;</code> 转义；哪个是 URL 的 query 字符串，从而需要用 URL 的 escaping 方法，而不是 HTML 的 escaping；等等。</p><p>这似乎有些牵强，因为 HTML 转义效率比较低。辛运是的，标签模板的字符串是保持不变的，<code>SaferHTML</code> 可以缓存已经转义过的字符串，从而提高效率。</p></li><li><p>模板字符串并没有内置的国际化特性，但通过标签模板，我们可以添加该特性。Jack Hsu 的<a href="http://jaysoo.ca/2014/03/20/i18n-with-es6-template-strings/" target="_blank" rel="external">文章</a>详细介绍了实现过程，看下面例子：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i18n<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, you have <span class="subst">$&#123;amount&#125;</span>:c(CAD) in your bank account.`</span></div><div class="line"><span class="comment">// =&gt; Hallo Bob, Sie haben 1.234,56 $CA auf Ihrem Bankkonto.</span></div></pre></td></tr></table></figure><p>  上面例子中的 <code>name</code> 和 <code>amount</code> 很好理解，将被 JS 引擎替换为对应的字符串，但是还有一个没有见过的占位符：<code>:c(CAD)</code>，这将被 <code>i18n</code> 标签处理，从 <code>i18n</code> 的文档可知：<code>:c(CAD)</code> 表示 <code>amount</code> 是加拿大美元货币值。</p><ul><li>模板字符串不能替代 Mustache 和 Nunjucks 这类模板引擎，部分原因在于模板字符串不支持循环和条件语句。我们可以编写一个标签来实现这类功能：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Purely hypothetical template language based on</span></div><div class="line"><span class="comment">// ES6 tagged templates.</span></div><div class="line"><span class="keyword">var</span> libraryHtml = hashTemplate<span class="string">`</span></div><div class="line"><span class="string">  &lt;ul&gt;</span></div><div class="line"><span class="string">    #for book in <span class="subst">$&#123;myBooks&#125;</span></span></div><div class="line"><span class="string">      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></div><div class="line"><span class="string">    #end</span></div><div class="line"><span class="string">  &lt;/ul&gt;</span></div><div class="line"><span class="string">`</span>;</div></pre></td></tr></table></figure><p>灵活性还不止于此，需要注意的是，标签函数的参数不会自动转换为字符串，参数可以是任何类型，返回值也一样。标签模板甚至可以不需要字符串，你可以使用自定义标签来创建正则表达式、DOM 树、图片、代表整个异步进程的 Promise、JS 数据结构、GL 着色器…</p><p><strong>标签模板允许库设计者创建强大的领域特定语言</strong>。这些语言可能看上去并不像 JS，但他们可以无缝嵌入到 JS 中，并且可以与语言的其余部分进行交互。顺便说一下，我还没有在其他语言中见过类似的特性，我不知道这个特性讲给我们带来些什么，但各种可能性还是非常令人兴奋的。</p><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2/" target="_blank" rel="external">ES6 In Depth: Template strings</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-05-14 16:41</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 ES6 中引入了一种新的字符串字面量 – 模板字符串，除了使用反引号 (`) 表示，它们看上去和普通的字符串没有什么区别。在最简单的情况下，他们就是普通的字符串：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;context.fillText(&lt;span class=&quot;string&quot;&gt;`Ceci n&#39;est pas une chaîne.`&lt;/span&gt;, x, y);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之所以被称为模板字符串，是因为模板字符串为 JS 引入了简单的字符串插值特性，也就是说，可以方便优雅地将 JS 的值插入到字符串中。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：Generator</title>
    <link href="http://bubkoo.com/2015/06/20/es6-in-depth-generators/"/>
    <id>http://bubkoo.com/2015/06/20/es6-in-depth-generators/</id>
    <published>2015-06-20T17:35:22.000Z</published>
    <updated>2015-06-20T17:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天讨论的新特性让我非常兴奋，因为这个特性是 ES6 中最神奇的特性。</p><p>这里的“神奇”意味着什么呢？对于初学者来说，该特性与以往的 JS 完全不同，甚至有些晦涩难懂。从某种意义上说，它完全改变了这门语言的通常行为，这不是“神奇”是什么呢。</p><p>不仅如此，该特性还可以简化程序代码，将复杂的“回调堆栈”改成直线执行的形式。</p><p>我是不是铺垫的太多了？下面开始深入介绍，你自己去判断吧。</p><a id="more"></a><h2><span id="简介">简介</span></h2><p>什么是 Generator？</p><p>看下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">quips</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">"hello "</span> + name + <span class="string">"!"</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="string">"i hope you are enjoying the blog posts"</span>;</div><div class="line">  <span class="keyword">if</span> (name.startsWith(<span class="string">"X"</span>)) &#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">"it's cool how your name starts with X, "</span> + name;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">yield</span> <span class="string">"see you later!"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面代码是模仿 <a href="http://people.mozilla.org/&lt;sub&gt;jorendorff/demos/meow.html" target="_blank" rel="external">Talking cat</a>（当下一个非常流行的应用）的一部分，<a href="http://people.mozilla.org/&lt;/sub&gt;jorendorff/demos/meow.html" target="_blank" rel="external">点击这里</a>试玩，如果你对代码感到困惑，那就回到这里来看下面的解释。</p><p>这看上去很像一个函数，这被称为 Generator 函数，它与我们常见的函数有很多共同点，但还可以看到下面两个差异：</p><ul><li>通常的函数以 <code>function</code> 开始，但 Generator 函数以 <code>function*</code> 开始。</li><li>在 Generator 函数内部，<code>yield</code> 是一个关键字，和 <code>return</code> 有点像。不同点在于，所有函数（包括 Generator 函数）都只能返回一次，而在 Generator 函数中可以 yield 任意次。<em>yield 表达式暂停了 Generator 函数的执行，然后可以从暂停的地方恢复执行。</em></li></ul><p>常见的函数不能暂停执行，而 Generator 函数可以，这就是这两者最大的区别。</p><h2><span id="原理">原理</span></h2><p>调用 <code>quips()</code> 时发生了什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">var</span> iter = quips(<span class="string">"jorendorff"</span>);</div><div class="line">  [object Generator]</div><div class="line">&gt; iter.next()</div><div class="line">  &#123; <span class="attr">value</span>: <span class="string">"hello jorendorff!"</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</div><div class="line">&gt; iter.next()</div><div class="line">  &#123; <span class="attr">value</span>: <span class="string">"i hope you are enjoying the blog posts"</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</div><div class="line">&gt; iter.next()</div><div class="line">  &#123; <span class="attr">value</span>: <span class="string">"see you later!"</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</div><div class="line">&gt; iter.next()</div><div class="line">  &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</div></pre></td></tr></table></figure><p>我们对普通函数的行为非常熟悉，函数被调用时就立即执行，直到函数返回或抛出一个异常，这是所有 JS 程序员的第二天性。</p><p>Generator 函数的调用方法与普通函数一样：<code>quips(&quot;jorendorff&quot;)</code>，但调用一个 Generator 函数时并没有立即执行，而是返回了一个 Generator 对象（上面代码中的 <code>iter</code>），这时函数就立即暂停在函数代码的第一行。</p><p>每次调用 Generator 对象的 <code>.next()</code> 方法时，函数就开始执行，直到遇到下一个 yield 表达式为止。</p><p>这就是为什么我们每次调用 <code>iter.next()</code> 时都会得到一个不同的字符串，这些都是在函数内部通过 yield 表达式产生的值。</p><p>当执行最后一个 <code>iter.next()</code> 时，就到达了 Generator 函数的末尾，所以返回结果的 <code>.done</code> 属性值为 <code>true</code>，并且 <code>.value</code> 属性值为 <code>undefined</code>。</p><p>现在，回到 <a href="http://people.mozilla.org/~jorendorff/demos/meow.html" target="_blank" rel="external">Talking cat</a> 的 DEMO，尝试在代码中添加一些 yield 表达式，看看会发生什么。</p><p>从技术层面上讲，每当 Generator 函数执行遇到 yield 表达式时，函数的栈帧 – 本地变量，函数参数，临时值和当前执行的位置，就从堆栈移除，但是 Generator 对象保留了对该栈帧的引用，所以下次调用 <code>.next()</code> 方法时，就可以恢复并继续执行。</p><p>值得提醒的是 Generator 并不是多线程。在支持多线程的语言中，同一时间可以执行多段代码，并伴随着执行资源的竞争，执行结果的不确定性和较好的性能。而 Generator 函数并不是这样，当一个 Generator 函数执行时，它与其调用者都在同一线程中执行，每次执行顺序都是确定的，有序的，并且执行顺序不会发生改变。与线程不同，Generator 函数可以在内部的 yield 的标志点暂停执行。</p><p>通过介绍 Generator 函数的暂停、执行和恢复执行，我们知道了什么是 Generator 函数，那么现在抛出一个问题：Generator 函数到底有什么用呢？</p><h2><span id="迭代器">迭代器</span></h2><p>通过上篇文章，我们知道迭代器并不是 ES6 的一个内置的类，而只是作为语言的一个扩展点，你可以通过实现 <code>[Symbol.iterator]()</code> 和 <code>.next()</code> 方法来定义一个迭代器。</p><p>但是，实现一个接口还是需要写一些代码的，下面我们来看看在实际中如何实现一个迭代器，以实现一个 <code>range</code> 迭代器为例，该迭代器只是简单地从一个数累加到另一个数，有点像 C 语言中的 <code>for (;;)</code> 循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This should "ding" three times</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</div><div class="line">  alert(<span class="string">"Ding! at floor #"</span> + value);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在有一个解决方案，就是使用 ES6 的类。（如果你对 <code>class</code> 语法还不熟悉，不要紧，我会在将来的文章中介绍。）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(start, stop) &#123;</div><div class="line">    <span class="keyword">this</span>.value = start;</div><div class="line">    <span class="keyword">this</span>.stop = stop;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</div><div class="line"></div><div class="line">  next() &#123;</div><div class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.value;</div><div class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.stop) &#123;</div><div class="line">      <span class="keyword">this</span>.value++;</div><div class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Return a new iterator that counts up from 'start' to 'stop'.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="http://codepen.io/anon/pen/NqGgOQ" target="_blank" rel="external">查看该 DEMO</a>。</p><p>这种实现方式与 <a href="http://gafter.blogspot.com/2007/07/internal-versus-external-iterators.html" target="_blank" rel="external">Java</a> 和 <a href="https://schani.wordpress.com/2014/06/06/generators-in-swift/" target="_blank" rel="external">Swift</a> 的实现方式类似，看上去还不错，但还不能说上面代码就完全正确，代码没有任何 Bug？这很难说。我们看不到任何传统的 <code>for (;;)</code> 循环代码：迭代器的协议迫使我们将循环拆散了。</p><p>在这一点上，你也许会对迭代器不那么热衷了，它们使用起来很方便，但是实现起来似乎很难。</p><p>我们可以引入一种新的实现方式，以使得实现迭代器更加容易。上面介绍的 Generator 可以用在这里吗？我们来试试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = start; i &lt; stop; i++)</div><div class="line">    <span class="keyword">yield</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="http://codepen.io/anon/pen/mJewga" target="_blank" rel="external">查看该 DEMO</a>。</p><p>上面这 4 行代码就可以完全替代之前的那个 23 行的实现，替换掉整个 <code>RangeIterator</code> 类，这是因为 Generator 天生就是迭代器，所有的 Generator 都原生实现了 <code>.next()</code> 和 <code>[Symbol.iterator]()</code> 方法。你只需要实现其中的循环逻辑就够了。</p><p>不使用 Generator 去实现一个迭代器就像被迫写一个很长很长的邮件一样，本来简单的表达出你的意思就可以了，<code>RangeIterator</code> 的实现是冗长和令人费解的，因为它没有使用循环语法去实现一个循环功能。使用 Generator 才是我们需要掌握的实现方式。</p><p>我们可以使用作为迭代器的 Generator 的哪些功能呢？</p><ul><li><strong>使任何对象可遍历</strong> – 编写一个 Genetator 函数去遍历 <code>this</code>，每遍历到一个值就 yield 一下，然后将该 Generator 函数作为要遍历的对象上的 <code>[Symbol.iterator]</code> 方法的实现。</li><li><strong>简化返回数组的函数</strong> – 假如有一个每次调用时都返回一个数组的函数，比如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Divide the one-dimensional array 'icons'</span></div><div class="line"><span class="comment">// into arrays of length 'rowLength'.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">splitIntoRows</span>(<span class="params">icons, rowLength</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> rows = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; icons.length; i += rowLength) &#123;</div><div class="line">    rows.push(icons.slice(i, i + rowLength));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> rows;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用 Generator 可以简化这类函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">splitIntoRows</span>(<span class="params">icons, rowLength</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; icons.length; i += rowLength) &#123;</div><div class="line">    <span class="keyword">yield</span> icons.slice(i, i + rowLength);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这两者唯一的区别在于，前者在调用时计算出了所有结果并用一个数组返回，后者返回的是一个迭代器，结果是在需要的时候才进行计算，然后一个一个地返回。</p><ul><li><strong>无穷大的结果集</strong> – 我们不能构建一个无穷大的数组，但是我们可以返回一个生成无尽序列的 Generator，并且每个调用者都可以从中获取到任意多个需要的值。</li><li><strong>重构复杂的循环</strong> – 你是否想将一个复杂冗长的函数重构为两个简单的函数？Generator 是你重构工具箱中一把新的瑞士军刀。对于一个复杂的循环，我们可以将生成数据集那部分代码重构为一个 Generator 函数，然后用 <code>for-of</code> 遍历：<code>for (var data of myNewGenerator(args))</code>。</li><li><strong>构建迭代器的工具</strong> – ES6 并没有提供一个可扩展的库，来对数据集进行 <code>filter</code> 和 <code>map</code> 等操作，但 Generator 可以用几行代码就实现这类功能。</li></ul><p>例如，假设你需要在 Nodelist 上实现与 <code>Array.prototype.filter</code> 同样的功能的方法。小菜一碟的事：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">filter</span>(<span class="params">test, iterable</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> iterable) &#123;</div><div class="line">    <span class="keyword">if</span> (test(item))</div><div class="line">      <span class="keyword">yield</span> item;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以，Generator 很实用吧？当然，这是实现自定义迭代器最简单直接的方式，并且，在 ES6 中，迭代器是数据集和循环的新标准。</p><p>但，这还不是 Generator 的全部功能。</p><h2><span id="异步代码">异步代码</span></h2><p>下面是我之前写过的 JS 代码（表示代码缩进层次太多）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          &#125;;</div><div class="line">        &#125;)</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>你也许也写过这样的代码。<a href="http://www.html5rocks.com/en/tutorials/async/deferred/" target="_blank" rel="external">异步 API</a> 通常都需要一个回调函数，这意味着每次你都需要编写一个匿名函数来处理异步结果。如果同时处理三个异步事务，我们看到的是三个缩进层次的代码，而不仅仅是三行代码。</p><p>看下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#125;).on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  done(<span class="literal">undefined</span>, <span class="literal">undefined</span>);</div><div class="line">&#125;).on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">  done(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>异步 API 通常都有错误处理的约定，不同的 API 有不同的约定。大多数情况下，错误是默认丢弃的，甚至有些将成功也默认丢弃了。</p><p>直到现在，这些问题仍是我们处理异步编程必须付出的代价，而且我们也已经接受了异步代码只是看不来不像同步代码那样简单和友好。</p><p>Generator 给我们带来了希望，我们可以不再采用上面的方式。</p><p><a href="https://github.com/kriskowal/q/tree/v1/examples/async-generators" target="_blank" rel="external">Q.async()</a>是一个将 Generator 和 Promise 结合起来处理异步代码的实验性尝试，让我们的异步代码类似于相应的同步代码。</p><p>例如： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Synchronous code to make some noise.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeNoise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  shake();</div><div class="line">  rattle();</div><div class="line">  roll();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Asynchronous code to make some noise.</span></div><div class="line"><span class="comment">// Returns a Promise object that becomes resolved</span></div><div class="line"><span class="comment">// when we're done making noise.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeNoise_async</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> Q.async(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> shake_async();</div><div class="line">    <span class="keyword">yield</span> rattle_async();</div><div class="line">    <span class="keyword">yield</span> roll_async();</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最大的区别在于，需要在每个异步方法调用的前面添加 <code>yield</code> 关键字。</p><p>在 <code>Q.async</code> 中，添加一个 <code>if</code> 语句或 <code>try-catch</code> 异常处理，就和在同步代码中的方式一样，与其他编写异步代码的方式相比，减少了很多学习成本。</p><p>如果你想深入阅读，可以参考 James Long 的<a href="http://jlongster.com/A-Study-on-Solving-Callbacks-with-JavaScript-Generators" target="_blank" rel="external">文章</a>。</p><p>Generator 为我们提供了一种更适合人脑思维方式的异步编程模型。但更好的语法也许更有帮助，在 ES7 中，一个基于 Promise 和 Generator 的异步处理函数正在规划之中，灵感来自 C# 中类似的特性。</p><h2><span id="兼容性">兼容性</span></h2><p>在服务器端，现在就可以直接在 io.js 中使用 Generator（或者在 NodeJs 中以 <code>--harmony</code> 启动参数来启动 Node）。</p><p>在浏览器端，目前只有 Firefox 27 和 Chrome 39 以上的版本才支持 Generator，如果想直接在 Web 上使用，你可以使用 <a href="http://babeljs.io/" target="_blank" rel="external">Babel</a> 或 Google 的 <a href="https://github.com/google/traceur-compiler#what-is-traceur" target="_blank" rel="external">Traceur</a> 将 ES6 代码转换为 Web 友好的 ES5 代码。</p><p>一些题外话：JS 版本的 Generator 最早是由 Brendan Eich 实现，他借鉴了 <a href="https://www.python.org/dev/peps/pep-0255/" target="_blank" rel="external">Python Generator</a> 的实现，该实现的灵感来自 <a href="http://www.cs.arizona.edu/icon/" target="_blank" rel="external">Icon</a>，早在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.7" target="_blank" rel="external">2006 年</a>的 Firefox 2.0 就吸纳了 Generator。但标准化的道路是坎坷的，一路下来，其语法和行为都发生了很多改变，Firefox 和 Chrome 中的 ES6 Generator 是由 <a href="http://wingolog.org/" target="_blank" rel="external">Andy Wingo</a> 实现 ，这项工作是由 Bloomberg 赞助的。</p><h2><span id="yield">yield;</span></h2><p>关于 Generator 还有一些未提及的部分，我们还没有涉及到 <code>.throw()</code> 和 <code>.return()</code> 方法的使用，<code>.next()</code> 方法的可选参数，还有 <code>yield*</code> 语法。但我认为这篇文章已经够长了，就像 Generator 一样，我们也暂停一下，另外找个时间再剩余的部分。</p><p>我们已经介绍了 ES6 中两个非常重要的特性，那么现在可以大胆地说，ES6 将改变我们的生活，看似简单的特性，却有极大的用处。</p><p>接下来将介绍一个你每天写的代码都将接触到的特性 – template string。</p><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/05/es6-in-depth-generators/" target="_blank" rel="external">ES6 In Depth: Generators</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-04-29 11:39</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天讨论的新特性让我非常兴奋，因为这个特性是 ES6 中最神奇的特性。&lt;/p&gt;
&lt;p&gt;这里的“神奇”意味着什么呢？对于初学者来说，该特性与以往的 JS 完全不同，甚至有些晦涩难懂。从某种意义上说，它完全改变了这门语言的通常行为，这不是“神奇”是什么呢。&lt;/p&gt;
&lt;p&gt;不仅如此，该特性还可以简化程序代码，将复杂的“回调堆栈”改成直线执行的形式。&lt;/p&gt;
&lt;p&gt;我是不是铺垫的太多了？下面开始深入介绍，你自己去判断吧。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：Iterator 和 for-of 循环</title>
    <link href="http://bubkoo.com/2015/06/15/es6-in-depth-iterators-and-the-for-of-loop/"/>
    <id>http://bubkoo.com/2015/06/15/es6-in-depth-iterators-and-the-for-of-loop/</id>
    <published>2015-06-15T02:28:29.000Z</published>
    <updated>2015-06-15T02:28:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何遍历一个数组的元素？在 20 年前，当 JavaScript 出现时，你也许会这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.length; index++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(myArray[index]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>自从 ES5 开始，你可以使用内置的 <code>forEach</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>代码更为精简，但有一个小缺点：不能使用 <code>break</code> 语句来跳出循环，也不能使用 <code>return</code> 语句来从闭包函数中返回。</p><p>如果有 <code>for-</code> 这种语法来遍历数组就会方便很多。</p><a id="more"></a><p>那么，使用 <code>for-in</code> 怎么样？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123; <span class="comment">// 实际代码中不要这么做</span></div><div class="line">  <span class="built_in">console</span>.log(myArray[index]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样不好，因为： </p><ul><li>上面代码中的 <code>index</code> 变量将会是 <code>&quot;0&quot;</code>、<code>&quot;1&quot;</code>、<code>&quot;3&quot;</code> 等这样的字符串，而并不是数值类型。如果你使用字符串的 <code>index</code> 去参与某些运算（<code>&quot;2&quot; + 1 == &quot;21&quot;</code>），运算结果可能会不符合预期。 </li><li>不仅数组本身的元素将被遍历到，那些由用户添加的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Expando" target="_blank" rel="external">附加（expando）元素</a>也将被遍历到，例如某数组有这样一个属性 <code>myArray.name</code>，那么在某次循环中将会出现 <code>index=&quot;name&quot;</code> 的情况。而且，甚至连数组原型链上的属性也可能被遍历到。 </li><li>最不可思议的是，在某些情况下，上面代码将会以任意顺序去遍历数组元素。</li></ul><p>简单来说，<code>for-in</code> 设计的目的是用于遍历包含键值对的对象，对数组并不是那么友好。</p><h2><span id="强大的-for-of-循环">强大的 for-of 循环</span></h2><p>记得上次我提到过，ES6 并不会影响现有 JS 代码的正常运行，已经有成千上万的 Web 应用都依赖于 <code>for-in</code> 的特性，甚至也依赖 <code>for-in</code> 用于数组的特性，所以从来就没有人提出“改善”现有 <code>for-in</code> 语法来修复上述问题。ES6 解决该问题的唯一办法是引入新的循环遍历语法。</p><p>这就是新的语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> myArray) &#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过介绍上面的 <code>for-in</code> 语法，这个语法看起来并不是那么令人印象深刻。后面我们将详细介绍 <code>for-of</code> 的奇妙之处，现在你只需要知道：</p><ul><li>这是遍历数组最简单直接的方法</li><li>避免了所有 <code>for–in</code> 语法存在的坑</li><li>与 <code>forEach()</code> 不同的是，它支持 <code>break</code>、<code>continue</code> 和 <code>return</code> 语句。</li></ul><p><code>for–in</code> 用于遍历对象的属性。</p><p><code>for-of</code> 用于遍历数据 – 就像数组中的元素。</p><p>然而，这还不是 <code>for-of</code> 的所有特性，下面还有更精彩的部分。</p><h2><span id="支持-for-of-的其他集合">支持 for-of 的其他集合</span></h2><p><code>for-of</code> 不仅仅是为数组设计，还可以用于类数组的对象，比如 DOM 对象的集合 <a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList" target="_blank" rel="external">NodeList</a>。</p><p>也可以用于遍历字符串，它将字符串看成是 Unicode 字符的集合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> chr <span class="keyword">of</span> <span class="string">"😺😲"</span>) &#123;</div><div class="line">  alert(chr);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它还适用于 <code>Map</code> 和 <code>Set</code> 对象。</p><p>也许你从未听说过 <code>Map</code> 和 <code>Set</code> 对象，因为它们是 ES6 中的新对象，后面将有单独的文章去详细介绍它们。如果你在其他语言中使用过这两个对象，那就简单多了。</p><p>例如，可以用一个 <code>Set</code> 对象来对数组元素去重：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// make a set from an array of words</span></div><div class="line"><span class="keyword">var</span> uniqueWords = <span class="keyword">new</span> <span class="built_in">Set</span>(words);</div></pre></td></tr></table></figure><p>当得到一个 <code>Set</code> 对象后，你很可能会去遍历该对象，这很简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> word <span class="keyword">of</span> uniqueWords) &#123;</div><div class="line">  <span class="built_in">console</span>.log(word);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Map</code> 对象由键值对构成，遍历方式略有不同，你需要用两个独立的变量来分别接收键和值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> phoneBookMap) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">"'s phone number is: "</span> + value);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>到目前为止，你已经知道：JS 已经支持一些集合对象，而且后面将会支持更多。<code>for-of</code> 语法正是为这些集合对象而设计。</p><p><code>for-of</code> 不能直接用来遍历对象的属性，如果你想遍历对象的属性，你可以使用 <code>for-in</code> 语句（<code>for-in</code> 就是用来干这个的），或者使用下面的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dump an object's own enumerable properties to the console</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(someObject)) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">": "</span> + someObject[key]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="内部原理">内部原理</span></h2><blockquote><p>“好的艺术家复制，伟大的艺术家偷窃。” – 巴勃罗·毕加索</p></blockquote><p>被添加到 ES6 中的那些新特性并不是无章可循，大多数特性都已经被使用在其他语言中，而且事实也证明这些特性很有用。</p><p>就拿 <code>for-of</code> 语句来说，在 C++、JAVA、C# 和 Python 中都存在类似的循环语句，并且用于遍历这门语言和其标准库中的各种数据结构。</p><p>与其他语言中的 <code>for</code> 和 <code>foreach</code> 语句一样，<code>for-of</code> <strong>要求被遍历的对象实现特定的方法</strong>。所有的 <code>Array</code>、<code>Map</code> 和 <code>Set</code> 对象都有一个共性，那就是他们都实现了一个迭代器（iterator）方法。</p><p>那么，只要你愿意，对其他任何对象你都可以实现一个迭代器方法。</p><p>这就像你可以为一个对象实现一个 <code>myObject.toString（）</code> 方法，来告知 JS 引擎如何将一个对象转换为字符串；你也可以为任何对象实现一个 <code>myObject[Symbol.iterator]()</code> 方法，来告知 JS 引擎如何去遍历该对象。</p><p>例如，如果你正在使用 jQuery，并且非常喜欢用它的 <code>each()</code> 方法，现在你想使所有的 jQuery 对象都支持 <code>for-of</code> 语句，你可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Since jQuery objects are array-like,</span></div><div class="line"><span class="comment">// give them the same iterator method Arrays have</span></div><div class="line">jQuery.prototype[<span class="built_in">Symbol</span>.iterator] =</div><div class="line">  <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator];</div></pre></td></tr></table></figure><p>你也许在想，为什么 <code>[Symbol.iterator]</code> 语法看起来如此奇怪？这句话到底是什么意思？问题的关键在于方法名，ES 标准委员会完全可以将该方法命名为 <code>iterator()</code>，但是，现有对象中可能已经存在名为“iterator”的方法，这将导致代码混乱，违背了最大兼容性原则。所以，标准委员会引入了 <code>Symbol</code>，而不仅仅是一个字符串，来作为方法名。</p><p><code>Symbol</code> 也是 ES6 的新特性，后面将会有单独的文章来介绍。现在你只需要知道标准委员会引入全新的 <code>Symbol</code>，比如 <code>Symbol.iterator</code>，是为了不与之前的代码冲突。唯一不足就是语法有点奇怪，但对于这个强大的新特性和完美的后向兼容来说，这个就显得微不足道了。</p><p>一个拥有 <code>[Symbol.iterator]()</code> 方法的对象被认为是可遍历的（iterable）。在后面的文章中，我们将看到“可遍历对象”的概念贯穿在整个语言中，不仅在 <code>for-of</code> 语句中，而且在 <code>Map</code> 和 <code>Set</code> 的构造函数和析构（Destructuring）函数中，以及新的扩展操作符中，都将涉及到。</p><h2><span id="迭代器对象">迭代器对象</span></h2><p>通常我们不会完完全全从头开始去实现一个迭代器（Iterator）对象，下一篇文章将告诉你为什么。但为了完整起见，让我们来看看一个迭代器对象具体是什么样的。（如果你跳过了本节，你将会错失某些技术细节。）</p><p>就拿 <code>for-of</code> 语句来说，它首先调用被遍历集合对象的 <code>[Symbol.iterator]()</code> 方法，该方法返回一个迭代器对象，迭代器对象可以是拥有 <code>.next</code> 方法的任何对象；然后，在 <code>for-of</code> 的每次循环中，都将调用该迭代器对象上的 <code>.next</code> 方法。下面是一个最简单的迭代器对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> zeroesForeverIterator = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;,</div><div class="line">  next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="number">0</span>&#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在上面代码中，每次调用 <code>.next()</code> 方法时都返回了同一个结果，该结果一方面告知 <code>for-of</code> 语句循环遍历还没有结束，另一方面告知 <code>for-of</code> 语句本次循环的值为 <code>0</code>。这意味着 <code>for (value of zeroesForeverIterator) {}</code> 是一个死循环。当然，一个典型的迭代器不会如此简单。</p><p>ES6 的迭代器通过 <code>.done</code> 和 <code>.value</code> 这两个属性来标识每次的遍历结果，这就是迭代器的设计原理，这与其他语言中的迭代器有所不同。在 Java 中，迭代器对象要分别使用 <code>.hasNext()</code> 和 <code>.next()</code> 两个方法。在 Python 中，迭代器对象只有一个 <code>.next()</code> 方法，当没有可遍历的元素时将抛出一个 <code>StopIteration</code> 异常。但从根本上说，这三种设计都返回了相同的信息。</p><p>迭代器对象可以还可以选择性地实现 <code>.return()</code> 和 <code>.throw(exc)</code> 这两个方法。如果由于异常或使用 <code>break</code> 和 <code>return</code> 操作符导致循环提早退出，那么迭代器的 <code>.return()</code> 方法将被调用，可以通过实现 <code>.return()</code> 方法来释放迭代器对象所占用的资源，但大多数迭代器都不需要实现这个方法。<code>throw(exc)</code> 更是一个特例：在遍历过程中该方法永远都不会被调用，关于这个方法，我会在下一篇文章详细介绍。</p><p>现在我们知道了 <code>for-of</code> 的所有细节，那么我们可以简单地重写该语句。</p><p>首先是 <code>for-of</code> 循环体：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (VAR <span class="keyword">of</span> ITERABLE) &#123;</div><div class="line">  STATEMENTS</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这只是一个语义化的实现，使用了一些底层方法和几个临时变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $iterator = ITERABLE[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"><span class="keyword">var</span> $result = $iterator.next();</div><div class="line"><span class="keyword">while</span> (!$result.done) &#123;</div><div class="line">  VAR = $result.value;</div><div class="line">  STATEMENTS</div><div class="line">  $result = $iterator.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面代码并没有涉及到如何调用 <code>.return()</code> 方法，我们可以添加相应的处理，但我认为这样会影响我们对内部原理的理解。<code>for-of</code> 语句使用起来非常简单，但在其内部有非常多的细节。</p><h2><span id="兼容性">兼容性</span></h2><p>目前，所有 Firefox 的 Release 版本都已经支持 <code>for-of</code> 语句。Chrome 默认禁用了该语句，你可以在地址栏输入 <code>chrome://flags</code> 进入设置页面，然后勾选其中的 “Experimental JavaScript” 选项。微软的 Spartan 浏览器也支持该语句，但是 IE 不支持。如果你想在 Web 开发中使用该语句，而且需要兼容 IE 和 Safari 浏览器，你可以使用 <a href="http://babeljs.io/" target="_blank" rel="external">Babel</a> 或 Google 的 <a href="https://github.com/google/traceur-compiler#what-is-traceur" target="_blank" rel="external">Traceur</a> 这类编译器，来将 ES6 代码转换为 Web 友好的 ES5 代码。</p><p>对于服务器端，我们不需要任何编译器 – 可以在 io.js 中直接使用该语句，或者在 NodeJS 启动时使用 <code>--harmony</code> 启动选项。</p><h2><span id="done-true">{done: true}</span></h2><p>到此，今天的话题已经结束，但对于 <code>for-of</code> 的话题还没有结束。</p><p>在 ES6 中还有一个新对象，该对象可以与 <code>for-of</code> 语句完美地结合使用，今天我并没有提及该对象，因为这是下篇文章我们讨论的主题，我认为这个新对象是 ES6 中最大的特性。如果你还没有在 Python 或 C# 中接触过该对象，你会认为这太奇妙了，但这是编写一个迭代器的最简单的方法，而且它对代码重构非常有用，它还可能改变我们处理异步代码的方式。所以，接着关注我的下篇关于 Generator 的讨论。</p><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/" target="_blank" rel="external">ES6 In Depth: Iterators and the for-of loop</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-04-29 11:39</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何遍历一个数组的元素？在 20 年前，当 JavaScript 出现时，你也许会这样做：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; index &amp;lt; myArray.length; index++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(myArray[index]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;自从 ES5 开始，你可以使用内置的 &lt;code&gt;forEach&lt;/code&gt; 方法：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;myArray.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码更为精简，但有一个小缺点：不能使用 &lt;code&gt;break&lt;/code&gt; 语句来跳出循环，也不能使用 &lt;code&gt;return&lt;/code&gt; 语句来从闭包函数中返回。&lt;/p&gt;
&lt;p&gt;如果有 &lt;code&gt;for-&lt;/code&gt; 这种语法来遍历数组就会方便很多。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 ES6：简介</title>
    <link href="http://bubkoo.com/2015/06/14/es6-in-depth-an-introduction/"/>
    <id>http://bubkoo.com/2015/06/14/es6-in-depth-an-introduction/</id>
    <published>2015-06-14T11:40:52.000Z</published>
    <updated>2015-06-14T11:40:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到深入解析 ES6 系列，本系列将探讨 JavaScript 即将面世的新版本 – ECMAScript 6。ES6 包含许多新特性，这使得 JavaScript 语言更强大和更具表现力，接下来的每周我们将逐一揭开 ES6 的神秘面纱。在开始之前，我们值得花几分钟时间来谈谈什么是 ES6 或者你期待它是什么样的。</p><a id="more"></a><h2><span id="什么是-ecmascript">什么是 ECMAScript</span></h2><p>JavaScript 语言的标准是由 ECMA（类似 W3C 的标准化组织）制定，并命名为 ECMAScript，除其他事项外，ECMAScript 还定义了：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar" target="_blank" rel="external">语法规则</a> – 解析规则、关键字、声明、操作符等</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" target="_blank" rel="external">变量类型</a> – 布尔、数字、字符串、对象等</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="external">原型和继承机制</a></li><li>包含内置对象和方法的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="external">标准库</a> –  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank" rel="external">JSON</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math" target="_blank" rel="external">Math</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">数组方法</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="external">遍历对象的方法</a>等</li></ul><p>ECMAScript 并没有定义处理 HTML 和 CSS 的相关标准，也就是说并没有定义这些 <a href="https://developer.mozilla.org/en-US/docs/Web/API" target="_blank" rel="external">Web API</a>，如 DOM（文档对象模型），这些都被定义在单独的标准中。ECMAScript 规范不仅存在于浏览器端，还包括非浏览器端，如 <a href="http://nodejs.org/" target="_blank" rel="external">NodeJS</a>。</p><h2><span id="新规范">新规范</span></h2><p>就在上周，第 6 版 ECMAScript 规范的最终草案提交给了 ECMA 审查，这意味着什么呢？</p><p>这意味着，这个新规范将在今年夏天与大家正式见面。</p><p>这将是历史性的一刻，新的 JS 规范不是每天都会降临，上个版本 – ES5   出现于 2009 年，从那时起，ES 标准委员会就开始着手制定 ES6 规范。</p><p>ES6 是该语言的重大升级，与此同时，你的 JS 代码也将继续正常运行，ES6 将最大兼容现有代码。事实上，许多浏览器已经实现了 ES6 的某些新特性，这意味着，你的 JS 代码已经在实现了某些 ES6 新特性的浏览器中运行了。如果现在你的代码没有出现任何兼容性问题，那么以后也不会。</p><h2><span id="关于版本号">关于版本号</span></h2><p>以前的 ECMAScript 版本号分别是 1、2、3 和 5。</p><p>那么，第 4 版到哪里去了呢？实际上，第 4 版也在计划之列，并完成了大量工作，但由于想法过于大胆（比如，它制定了一个非常复杂的基于泛型和类型推断的静态类型系统），而最终不得不被废弃掉。</p><p>其实 ES4 是有争议的，当标准委员会停止制定 ES4 规范时，委员会成员同意发布一个相对温和的 ES5，然后继续制定一些更实质性的新特性，这就是为什么在 ES5 的规范中包含下面这句话：</p><blockquote><p>ECMAScript 是一个充满活力的语言，语言本身的进化并不完整，在未来的版本中将进行一些重大的技术改进。</p></blockquote><p>这句话可以被视为一种承诺。</p><h2><span id="兑现承诺">兑现承诺</span></h2><p>在 2009 年发布的 ES5 中，引入了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external"><code>Object.create()</code></a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external"><code>Object.defineProperty()</code></a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" target="_blank" rel="external"><code>getter</code></a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set" target="_blank" rel="external"><code>setter</code></a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="external">严格模式</a>和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank" rel="external"><code>JSON</code></a> 对象。我用过所有这些特性，我也很欣赏 ES5 为这门语言所做的改进，但这并没有对我的编码方式产生巨大影响。对我来说，最重要的创新莫过于那些数组的新方法，如<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external"><code>.map()</code></a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="external"><code>.filter()</code></a>等。</p><p>然而，ES6 是不同的，这是多年“和谐”工作的结晶，也是 JS 历史上从来没有过的实质性的升级。这些新特性包括从简单的箭头函数、字符串插值到复杂的代理、Generator 函数等。</p><p>ES6 改变了我们编写 JS 代码的方式。</p><p>本系列将逐步展示 ES6 的这些新特性，并介绍如何使用这些新特性。</p><p>我们将从一个典型的人们期待了数十年的“缺失功能”开始，所以，下周我们一起来看看 ES6 的迭代器（Iterator）和新的 <code>for-of</code> 循环。</p><p class="j-quote">参考原文：<a href="https://hacks.mozilla.org/2015/04/es6-in-depth-an-introduction/" target="_blank" rel="external">ES6 In Depth: An Introduction</a><br>原文作者：<a href="https://hacks.mozilla.org/author/jorendorffmozillacom/" target="_blank" rel="external">Jason Orendorff</a><br>原文日期：2015-04-23 20:55</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎来到深入解析 ES6 系列，本系列将探讨 JavaScript 即将面世的新版本 – ECMAScript 6。ES6 包含许多新特性，这使得 JavaScript 语言更强大和更具表现力，接下来的每周我们将逐一揭开 ES6 的神秘面纱。在开始之前，我们值得花几分钟时间来谈谈什么是 ES6 或者你期待它是什么样的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ES6" scheme="http://bubkoo.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>几个必备的 JavaScript 函数</title>
    <link href="http://bubkoo.com/2015/06/10/7-essential-javascript-functions/"/>
    <id>http://bubkoo.com/2015/06/10/7-essential-javascript-functions/</id>
    <published>2015-06-10T11:40:13.000Z</published>
    <updated>2015-06-10T11:40:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考原文：<a href="http://davidwalsh.name/essential-javascript-functions" target="_blank" rel="external">7 Essential JavaScript Functions</a> 以下是意译。</p><p>早期，由于浏览器厂商对 JavaScript 实现不同，我们通常需要一些简单的函数来实现某些边缘特性，甚至某些基本特性，比如 <code>addEventListener</code> 和 <code>attachEvent</code>。现在，虽然时代进步了，但仍有一些函数需要开发者掌握，以便于性能优化和快速开发。</p><a id="more"></a><h2><span id="去抖-debounce">去抖 Debounce</span></h2><p>去抖（debounce）函数可以提高某些事件绑定的性能，如果你没有为 <code>scroll</code>、<code>resize</code> 和 <code>key*</code> 事件使用去抖函数，你的代码很可能是性能低下的，下面是一个 <code>debounce</code> 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回一个函数的去抖版本，将函数延迟到事件停止触发，并等待 wait 毫秒之后才执行</span></div><div class="line"><span class="comment">// 如果 immediate 为 true，那么会在开始时立即调用这个函数一次，并在 wait 时间内不会被重复调用</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> timeout;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</div><div class="line">        <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            timeout = <span class="literal">null</span>;</div><div class="line">            <span class="keyword">if</span> (!immediate) &#123;</div><div class="line">                func.apply(context, args);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;</div><div class="line">        clearTimeout(timeout);</div><div class="line">        timeout = setTimeout(later, wait);</div><div class="line">        <span class="keyword">if</span> (callNow) &#123;</div><div class="line">            func.apply(context, args);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 使用案例：resize 事件监听</span></div><div class="line"><span class="keyword">var</span> myEfficientFn = debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 这里完成那些复杂的业务功能</span></div><div class="line">&#125;, <span class="number">250</span>);</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, myEfficientFn);</div></pre></td></tr></table></figure><p>在给定的时间段内，去抖函数至多只允许回调函数被调用一次，这对于某些频繁触发的事件回调特别有用。</p><p><a href="http://davidwalsh.name/javascript-debounce-function" target="_blank" rel="external">深入阅读</a></p><h2><span id="轮询-poll">轮询 Poll</span></h2><p>有时你需要在指定状态时才触发某些事件，而当前状态很可能不是你所需要的，所以我们需要在一定时间间隔内来轮询当前状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">poll</span>(<span class="params">fn, callback, errback, timeout, interval</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> endTime = <span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>()) + (timeout || <span class="number">2000</span>);</div><div class="line">    interval = interval || <span class="number">100</span>;</div><div class="line"></div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">p</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 满足条件时，触发回调</span></div><div class="line">        <span class="keyword">if</span> (fn()) &#123;</div><div class="line">            callback();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 条件不满足，并在指定的时间段内，那么延迟一段时间后再次触发检查</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>()) &lt; endTime) &#123;</div><div class="line">            setTimeout(p, interval);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 条件不满足并已经超时，触发错误回调</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            errback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'timed out for '</span> + fn + <span class="string">': '</span> + <span class="built_in">arguments</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 使用案例：确保元素可见</span></div><div class="line">poll(</div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">'lightbox'</span>).offsetWidth &gt; <span class="number">0</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// Done, success callback</span></div><div class="line">    &#125;,</div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// Error, failure callback</span></div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure><p>轮询函数在 Web 开发中一直都非常实用，将来也一样。</p><p><a href="http://davidwalsh.name/javascript-polling" target="_blank" rel="external">深入阅读</a></p><h2><span id="只触发一次-once">只触发一次 Once</span></h2><p>某些时候，你希望一个函数只被调用一次，比如 <code>onload</code> 事件的回调函数，那么下面代码是你需要的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">fn, context</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (fn) &#123;</div><div class="line">            result = fn.apply(context || <span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">            fn = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line"><span class="keyword">var</span> canOnlyFireOnce = once(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Fired!'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">canOnlyFireOnce(); <span class="comment">// "Fired!"</span></div><div class="line">canOnlyFireOnce(); <span class="comment">// nada</span></div></pre></td></tr></table></figure><p><code>once</code> 函数确保给定的函数只被调用一次，以防止重复初始化。</p><p><a href="http://davidwalsh.name/javascript-once" target="_blank" rel="external">深入阅读</a></p><h2><span id="获取绝对路径-getabsoluteurl">获取绝对路径 getAbsoluteUrl</span></h2><p>从一个字符串变量中获取绝对 URL 地址并不是想象的那么简单，这里有一个巧妙的实现来从一个字符串获取绝对 URL:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getAbsoluteUrl = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!a) &#123;</div><div class="line">            a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line">        &#125;</div><div class="line">        a.href = url;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> a.href;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line">getAbsoluteUrl(<span class="string">'/something'</span>); <span class="comment">// http://davidwalsh.name/something</span></div></pre></td></tr></table></figure><p>元素 <code>a</code> 的 <code>href</code> 属性给你带来了简单的实现，并返回一个可靠的绝对 URL。</p><p><a href="http://davidwalsh.name/get-absolute-url" target="_blank" rel="external">深入阅读</a></p><h2><span id="判断是否是原生函数-isnative">判断是否是原生函数 isNative</span></h2><p>当你想要重写一个函数时，很有必要知道该函数是否是引擎的原生函数，下面的代码将能判断一个函数是否是原生函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Used to resolve the internal `[[Class]]` of values</span></div><div class="line">    <span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</div><div class="line"></div><div class="line">    <span class="comment">// Used to resolve the decompiled source of functions</span></div><div class="line">    <span class="keyword">var</span> fnToString = <span class="built_in">Function</span>.prototype.toString;</div><div class="line"></div><div class="line">    <span class="comment">// Used to detect host constructors (Safari &gt; 4; really typed array specific)</span></div><div class="line">    <span class="keyword">var</span> reHostCtor = <span class="regexp">/^\[object .+?Constructor\]$/</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Compile a regexp using a common native method as a template.</span></div><div class="line">    <span class="comment">// We chose `Object#toString` because there's a good chance it is not being mucked with.</span></div><div class="line">    <span class="keyword">var</span> reNative = <span class="built_in">RegExp</span>(<span class="string">'^'</span> +</div><div class="line">            <span class="comment">// Coerce `Object#toString` to a string</span></div><div class="line">        <span class="built_in">String</span>(toString)</div><div class="line">            <span class="comment">// Escape any special regexp characters</span></div><div class="line">            .replace(<span class="regexp">/[.*+?^$&#123;&#125;()|[\]\/\\]/g</span>, <span class="string">'\\$&amp;'</span>)</div><div class="line">            <span class="comment">// Replace mentions of `toString` with `.*?` to keep the template generic.</span></div><div class="line">            <span class="comment">// Replace thing like `for ...` to support environments like Rhino which add extra info</span></div><div class="line">            <span class="comment">// such as method arity.</span></div><div class="line">            .replace(<span class="regexp">/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g</span>, <span class="string">'$1.*?'</span>) + <span class="string">'$'</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isNative</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> type = <span class="keyword">typeof</span> value;</div><div class="line">        <span class="keyword">return</span> type == <span class="string">'function'</span></div><div class="line">            <span class="comment">// Use `Function#toString` to bypass the value's own `toString` method</span></div><div class="line">            <span class="comment">// and avoid being faked out.</span></div><div class="line">            ? reNative.test(fnToString.call(value))</div><div class="line">            <span class="comment">// Fallback to a host object check because some environments will represent</span></div><div class="line">            <span class="comment">// things like typed arrays as DOM methods which may not conform to the</span></div><div class="line">            <span class="comment">// normal native pattern.</span></div><div class="line">            : (value &amp;&amp; type == <span class="string">'object'</span> &amp;&amp; reHostCtor.test(toString.call(value))) || <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// export however you want</span></div><div class="line">    <span class="built_in">module</span>.exports = isNative;</div><div class="line">&#125;());</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line">isNative(alert); <span class="comment">// true</span></div><div class="line">isNative(myCustomFunction); <span class="comment">// false</span></div></pre></td></tr></table></figure><p>上面代码看上去并不那么优雅，但最终实现了我们想要的功能。</p><p><a href="http://davidwalsh.name/detect-native-function" target="_blank" rel="external">深入阅读</a></p><h2><span id="插入样式规则-insertrule">插入样式规则 insertRule</span></h2><p>我们可以通过 <code>document.querySelectorAll</code> 来获取到一些节点，然后依次为这些节点设置样式，但更有效的方法在样式表中是通过选择器来设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sheet = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Create the &lt;style&gt; tag</span></div><div class="line">    <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Add a media (and/or media query) here if you'd like!</span></div><div class="line">    <span class="comment">// style.setAttribute('media', 'screen')</span></div><div class="line">    <span class="comment">// style.setAttribute('media', 'only screen and (max-width : 1024px)')</span></div><div class="line"></div><div class="line">    <span class="comment">// WebKit hack :(</span></div><div class="line">    style.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">''</span>));</div><div class="line"></div><div class="line">    <span class="comment">// Add the &lt;style&gt; element to the page</span></div><div class="line">    <span class="built_in">document</span>.head.appendChild(style);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> style.sheet;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// Usage</span></div><div class="line">sheet.insertRule(<span class="string">"header &#123; float: left; opacity: 0.8; &#125;"</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure><p>对于一些动态的重度 AJAX 的网站来说，这个函数非常有用，通过选择器来设置样式，你就不再需要为符合这个选择器的每个元素单独设置（现在不要这样做，将来更不要）。</p><p><a href="http://davidwalsh.name/add-rules-stylesheets" target="_blank" rel="external">深入阅读</a></p><h2><span id="元素匹配-matchesselector">元素匹配 matchesSelector</span></h2><p>通常，我们在进一步操作之前都需要验证输入的合法性，以确保数据的有效性和真实性等。但我们如何验证一个给定的元素是否满足指定的选择器呢？看下面的 <code>matchesSelector</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchesSelector</span>(<span class="params">el, selector</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = Element.prototype;</div><div class="line">    <span class="keyword">var</span> f = p.matches</div><div class="line">        || p.webkitMatchesSelector</div><div class="line">        || p.mozMatchesSelector</div><div class="line">        || p.msMatchesSelector</div><div class="line">        || <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> [].indexOf.call(<span class="built_in">document</span>.querySelectorAll(s), <span class="keyword">this</span>) !== <span class="number">-1</span>;</div><div class="line">        &#125;;</div><div class="line">    <span class="keyword">return</span> f.call(el, selector);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line">matchesSelector(<span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>), <span class="string">'div.someSelector[some-attribute=true]'</span>);</div></pre></td></tr></table></figure><p><a href="http://davidwalsh.name/element-matches-selector" target="_blank" rel="external">深入阅读</a></p><h2><span id="生成随机数-random">生成随机数 random</span></h2><p>在 <code>min</code> 和 <code>max</code> 之间生成一个随机数，如果 <code>integer</code> 为 <code>true</code> 那么将生成随机整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">rand</span>(<span class="params">min, max, integer</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> r = <span class="built_in">Math</span>.random() * (max - min) + min; </div><div class="line">  <span class="keyword">return</span> integer ? r|<span class="number">0</span> : r;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(rand(<span class="number">2</span>,<span class="number">5</span>)); <span class="comment">// float random between 2 and 5 inclusive</span></div><div class="line"><span class="built_in">console</span>.log(rand(<span class="number">1</span>,<span class="number">100</span>,<span class="literal">true</span>)); <span class="comment">// integer random between 1 and 100</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考原文：&lt;a href=&quot;http://davidwalsh.name/essential-javascript-functions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;7 Essential JavaScript Functions&lt;/a&gt; 以下是意译。&lt;/p&gt;
&lt;p&gt;早期，由于浏览器厂商对 JavaScript 实现不同，我们通常需要一些简单的函数来实现某些边缘特性，甚至某些基本特性，比如 &lt;code&gt;addEventListener&lt;/code&gt; 和 &lt;code&gt;attachEvent&lt;/code&gt;。现在，虽然时代进步了，但仍有一些函数需要开发者掌握，以便于性能优化和快速开发。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Essential" scheme="http://bubkoo.com/tags/essential/"/>
    
  </entry>
  
  <entry>
    <title>fetch API 简介</title>
    <link href="http://bubkoo.com/2015/05/08/introduction-to-fetch/"/>
    <id>http://bubkoo.com/2015/05/08/introduction-to-fetch/</id>
    <published>2015-05-08T11:39:23.000Z</published>
    <updated>2015-05-08T11:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>十多年来，我们一直使用 XMLHttpRequest（XHR）来发送异步请求，XHR 很实用，但并不是一个设计优良的 API，在设计上并不符合职责分离原则，输入、输出以及状态都杂糅在同一对象中，并用事件机制来跟踪状态变化。并且，基于事件的模型与最近流行的 Promise 和 generator 异步编程模型不太友好。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="external">Fetch API</a> 旨在修正上述缺陷，它提供了与 HTTP 语义相同的 JS 语法，简单来说，它引入了 <code>fetch()</code> 这个实用的方法来获取网络资源。</p><p>在 <a href="https://fetch.spec.whatwg.org/" target="_blank" rel="external">Fetch 规范</a>中对 API 进行了定义，它结合 ServiceWorkers，尝试做到如下优化：</p><ol><li>改善离线体验</li><li>保持可扩展性</li></ol><p>写这篇文章时，Fetch API 已被 Firefox 39（Nightly）以及 Chrome 42（dev）支持。在 github 上有相应的 <a href="https://github.com/github/fetch" target="_blank" rel="external">polyfill</a>。</p><a id="more"></a><h2><span id="特征检查">特征检查</span></h2><p>可以通过检查 <code>Headers</code>、<code>Request</code>、<code>Response</code> 或 <code>fetch</code> 在 window 或 worker 作用域中是否存在，来检查是否支持 Fetch API。</p><h2><span id="简单示例">简单示例</span></h2><p>Fetch API 中最常用的是 <code>fetch()</code> 方法，该方法最简单的形式是，接受一个 URL 参数并返回以一个 promise 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">"/data.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="comment">// res instanceof Response == true.</span></div><div class="line">  <span class="keyword">if</span> (res.ok) &#123;</div><div class="line">    res.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(data.entries);</div><div class="line">    &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Looks like the response wasn't perfect, got status"</span>, res.status);</div><div class="line">  &#125;</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Fetch failed!"</span>, e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>如果是提交一个POST请求，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">"http://www.example.org/submit.php"</span>, &#123;</div><div class="line">  method: <span class="string">"POST"</span>,</div><div class="line">  headers: &#123;</div><div class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span></div><div class="line">  &#125;,</div><div class="line">  body: <span class="string">"firstName=Nikhil&amp;favColor=blue&amp;password=easytoguess"</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (res.ok) &#123;</div><div class="line">    alert(<span class="string">"Perfect! Your settings are saved."</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.status == <span class="number">401</span>) &#123;</div><div class="line">    alert(<span class="string">"Oops! You are not authorized."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  alert(<span class="string">"Error submitting form!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><code>fetch()</code> 方法的参数和 <code>Request()</code> 构造函数的参数完全一致，所以你可以传任意复杂的参数来实现更强大的 <code>fetch()</code>，下面将详细介绍。</p><h2><span id="headers">Headers</span></h2><p>Fetch 引入了 3 个接口，分别是 <code>Headers</code>，<code>Request</code> 和 <code>Response</code>。他们直接对应于的 HTTP 中相应的概念，但是基于隐私和安全考虑，也有些区别，例如支持 CORS 规则以及保证 cookies 不能被第三方获取。</p><p> <a href="https://fetch.spec.whatwg.org/#headers-class" target="_blank" rel="external">Headers 接口</a>是一个简单的键值对：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> content = <span class="string">"Hello World"</span>;</div><div class="line"><span class="keyword">var</span> reqHeaders = <span class="keyword">new</span> Headers();</div><div class="line">reqHeaders.append(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span></div><div class="line">reqHeaders.append(<span class="string">"Content-Length"</span>, content.length.toString());</div><div class="line">reqHeaders.append(<span class="string">"X-Custom-Header"</span>, <span class="string">"ProcessThisImmediately"</span>);</div></pre></td></tr></table></figure><p>也可以给构造函数传一个多维数组或 JS 字面量对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">reqHeaders = <span class="keyword">new</span> Headers(&#123;</div><div class="line">  <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>,</div><div class="line">  <span class="string">"Content-Length"</span>: content.length.toString(),</div><div class="line">  <span class="string">"X-Custom-Header"</span>: <span class="string">"ProcessThisImmediately"</span>,</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>Headers 的内容可被检索：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(reqHeaders.has(<span class="string">"Content-Type"</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(reqHeaders.has(<span class="string">"Set-Cookie"</span>)); <span class="comment">// false</span></div><div class="line">reqHeaders.set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>);</div><div class="line">reqHeaders.append(<span class="string">"X-Custom-Header"</span>, <span class="string">"AnotherValue"</span>);</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(reqHeaders.get(<span class="string">"Content-Length"</span>)); <span class="comment">// 11</span></div><div class="line"><span class="built_in">console</span>.log(reqHeaders.getAll(<span class="string">"X-Custom-Header"</span>)); <span class="comment">// ["ProcessThisImmediately", "AnotherValue"]</span></div><div class="line"> </div><div class="line">reqHeaders.delete(<span class="string">"X-Custom-Header"</span>);</div><div class="line"><span class="built_in">console</span>.log(reqHeaders.getAll(<span class="string">"X-Custom-Header"</span>)); <span class="comment">// []</span></div></pre></td></tr></table></figure><p>一些操作只在 ServiceWorkers 中可用，但这些 API 使得操作 header 更为方便。</p><p>由于 header 可以在发送请求时被发送或在收到响应时被接收，并规定了那些参数可写，所以在 <code>Headers</code> 对象中有个一 <code>guard</code> 属性，来指定哪些参数可以被改变。</p><p>可能的值如下：</p><ul><li><code>&quot;none&quot;</code>：默认值</li><li><code>&quot;request&quot;</code>：<code>Request.headers</code> 对象只读</li><li><code>&quot;request-no-cors&quot;</code>：在 <code>no-cors</code> 模式下，<code>Request.headers</code> 对象只读</li><li><code>&quot;response&quot;</code>：<code>Response.headers</code> 对象只读</li><li><code>&quot;immutable&quot;</code>：通常在 ServiceWorkers 中使用，所有 Header 对象都为只读</li></ul><p>在<a href="https://fetch.spec.whatwg.org/" target="_blank" rel="external">规范</a>中对每个 <code>guard</code> 属性值有更详细的描述。例如，当 <code>guard</code> 为 <code>request</code> 时，你将不能添加或修改header 的 <code>Content-Length</code> 属性。</p><p>如果使用了一个不合法的 <a href="https://fetch.spec.whatwg.org/#concept-header-name" target="_blank" rel="external">HTTP Header 名</a>，那么 Headers 的方法通常都抛出 TypeError 异常。如果不小心写入了一个只读属性，也会抛出一个 TypeError 异常。除此以外，失败了将不抛出任何异常。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = Response.error();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  res.headers.set(<span class="string">"Origin"</span>, <span class="string">"http://mybank.com"</span>);</div><div class="line">&#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Cannot pretend to be a bank!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="request">Request</span></h2><p>通过构造一个 <code>Request</code> 对象来获取网络资源，构造函数需要 <code>URL</code>、<code>method</code> 和 <code>headers</code> 参数，同时也可以提供请求体（body）、请求模式（mode）、<code>credentials</code> 和 <code>cache hints</code> 等参数。</p><p>最简单的形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> Request(<span class="string">"/index.html"</span>);</div><div class="line"><span class="built_in">console</span>.log(req.method); <span class="comment">// "GET"</span></div><div class="line"><span class="built_in">console</span>.log(req.url); <span class="comment">// "http://example.com/index.html"</span></div></pre></td></tr></table></figure><p>也可以将一个 <code>Request</code> 对象传给构造函数，这将返回该对象的一个副本（这与 <code>clone()</code> 方法不同，后面将介绍）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> copy = <span class="keyword">new</span> Request(req);</div><div class="line"><span class="built_in">console</span>.log(copy.method); <span class="comment">// "GET"</span></div><div class="line"><span class="built_in">console</span>.log(copy.url); <span class="comment">// "http://example.com/index.html"</span></div></pre></td></tr></table></figure><p>同时，这种形式通常只在 ServiceWorkers 中使用。</p><p>除 <code>URL</code> 之外的参数只能通过第二个参数传递，该参数是一个键值对：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> uploadReq = <span class="keyword">new</span> Request(<span class="string">"/uploadImage"</span>, &#123;</div><div class="line">  method: <span class="string">"POST"</span>,</div><div class="line">  headers: &#123;</div><div class="line">    <span class="string">"Content-Type"</span>: <span class="string">"image/png"</span>,</div><div class="line">  &#125;,</div><div class="line">  body: <span class="string">"image data"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><code>mode</code> 参数用来决定是否允许跨域请求，以及哪些 <code>response</code> 属性可读。可选的 <code>mode</code> 值为 <code>&quot;same-origin&quot;</code>、<code>&quot;no-cors&quot;</code>（默认）以及 <code>&quot;cors&quot;</code>。</p><h3><span id="same-origin">same-origin</span></h3><p>该模式很简单，如果一个请求是跨域的，那么将返回一个 <code>error</code>，这样确保所有的请求遵守同源策略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arbitraryUrl = <span class="built_in">document</span>.getElementById(<span class="string">"url-input"</span>).value;</div><div class="line">fetch(arbitraryUrl, &#123; <span class="attr">mode</span>: <span class="string">"same-origin"</span> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Response succeeded?"</span>, res.ok);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Please enter a same-origin URL!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3><span id="no-cors">no-cors</span></h3><p>该模式允许来自 CDN 的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的 method 只能是<code>HEAD</code>、<code>GET</code> 或 <code>POST</code>。此外，如果 ServiceWorkers 拦截了这些请求，它不能随意添加或者修改除<a href="https://fetch.spec.whatwg.org/#simple-header" target="_blank" rel="external">这些</a>之外 Header 属性。第三，JS 不能访问 Response 对象中的任何属性，这确保了跨域时 ServiceWorkers 的安全和隐私信息泄漏问题。</p><h3><span id="cors">cors</span></h3><p>该模式通常用于跨域请求，用来从第三方提供的 API 获取数据。该模式遵守 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS 协议</a>，并只有有限的一些 Header 被暴露给 Response 对象，但是 body 是可读的。例如，获取一个 Flickr <a href="https://www.flickr.com/services/api/flickr.interestingness.getList.html" target="_blank" rel="external">最感兴趣</a>的照片的清单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> URLSearchParams();</div><div class="line">u.append(<span class="string">'method'</span>, <span class="string">'flickr.interestingness.getList'</span>);</div><div class="line">u.append(<span class="string">'api_key'</span>, <span class="string">'&lt;insert api key here&gt;'</span>);</div><div class="line">u.append(<span class="string">'format'</span>, <span class="string">'json'</span>);</div><div class="line">u.append(<span class="string">'nojsoncallback'</span>, <span class="string">'1'</span>);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> apiCall = fetch(<span class="string">'https://api.flickr.com/services/rest?'</span> + u);</div><div class="line"> </div><div class="line">apiCall.then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> response.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</div><div class="line">    <span class="comment">// photo is a list of photos.</span></div><div class="line">    <span class="keyword">return</span> json.photos.photo;</div><div class="line">  &#125;);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">photos</span>) </span>&#123;</div><div class="line">  photos.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">photo</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(photo.title);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>你将无法从 Headers 中读取 <code>Date</code> 属性，因为 Flickr 在 <code>Access-Control-Expose-Headers</code> 中设置了不允许读取它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.headers.get(<span class="string">"Date"</span>); <span class="comment">// null</span></div></pre></td></tr></table></figure><p>另外，<code>credentials</code> 属性决定了是否可以跨域访问 cookie 。该属性与 XHR 的<br><code>withCredentials</code> 标志相同，但是只有三个值，分别是 <code>omit</code>（默认）、<code>same-origin</code> 和 <code>include</code>。</p><p>Request 对象也提供了客户端缓存机制（caching hints）。这个属性还在安全复审阶段。Firefox 提供了这个属性，但目前还不起作用。</p><p>Request 对象还有两个与 ServiceWorks 拦截有关的只读属性。其中一个是<code>referrer</code>，表示该 Request 的来源，可能为空。另外一个是 <code>context</code>，是一个非常大的<a href="https://fetch.spec.whatwg.org/#requestcredentials" target="_blank" rel="external">枚举集合</a>，定义了获得的资源的种类，它可能是 <code>image</code> 当请求来自于 <code>img</code> 标签时，可能是 <code>worker</code> 如果是一个 Worker 脚本，等等。如果使用 <code>fetch()</code> 函数，这个值是 <code>fetch</code>。</p><h2><span id="response">Response</span></h2><p>Response 对象通常在 <code>fetch()</code> 的回调中获得，也可以通过 JS 构造，不过这通常只在 ServiceWorkers 中使用。</p><p>Response 对象中最常见的属性是 <code>status</code>（整数，默认值是 <code>200</code>）和<code>statusText</code>（默认值是 <code>&quot;OK&quot;</code>）。还有一个 <code>ok</code> 属性，这是 <code>status</code> 值为 <code>200~299</code> 时的语法糖。</p><p>另外，还有一个 <code>type</code> 属性，它的值可能是 <code>&quot;basic&quot;</code>、<code>&quot;cors&quot;</code>、<code>&quot;default&quot;</code>、<code>&quot;error&quot;</code> 或 <code>&quot;opaque&quot;</code>。</p><ul><li><code>&quot;basic&quot;</code>：同域的响应，除 <code>Set-Cookie</code> 和 <code>Set-Cookie2</code> 之外的所有 Header 可用</li><li><code>&quot;cors&quot;</code>：Response 从一个合法的跨域请求获得，<a href="https://fetch.spec.whatwg.org/#concept-filtered-response-cors" target="_blank" rel="external">某些</a> Header 和 body 可读</li><li><code>&quot;error&quot;</code>：网络错误。Response 对象的 <code>status</code> 属性为 <code>0</code>，<code>headers</code> 属性为空并且不可写。当 Response 对象从 <code>Response.error()</code> 中得到时，就是这种类型</li><li><code>&quot;opaque&quot;</code>：在 <code>&quot;no-cors&quot;</code> 模式下请求了跨域资源。依靠<a href="https://fetch.spec.whatwg.org/#concept-filtered-response-opaque" target="_blank" rel="external">服务端来做限制</a></li></ul><p>当 <code>type</code> 属性值为 <code>&quot;error&quot;</code> 时会导致 <code>fetch()</code> 方法的 Promise 被 reject，reject 回调的参数为 TypeError 对象。</p><p>还有一些属性只在 ServerWorker 下有效。在 ServerWorker 下返回一个 Response 的正确方式为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  event.respondWith(<span class="keyword">new</span> Response(<span class="string">"Response body"</span>, &#123;</div><div class="line">    headers: &#123; <span class="string">"Content-Type"</span> : <span class="string">"text/plain"</span> &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>如你所见，Response 构造函数接收两个参数：返回的 body 和一个键值对对象，通过该对象来设置 <code>status</code>、<code>statusText</code> 和 <code>headers</code> 属性。</p><p>静态方法 <code>Response.error()</code> 将返回一个错误响应，<code>Response.redirect(url, status)</code> 将返回一个跳转响应。</p><h2><span id="处理-body">处理 body</span></h2><p>在 Request 和 Response 对象中都可能有 <code>body</code> 属性，并且 <code>body</code> 可以是各种类型，比较复杂，所以前面我们故意先跳过它，在这里单独拿出来讲解。</p><p><code>body</code> 可以是以下任何一种类型的实例：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="external">ArrayBuffer</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView" target="_blank" rel="external">ArrayBufferView</a> (Uint8Array and friends)</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="external">Blob</a>/<a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank" rel="external">File</a></li><li>string</li><li><a href="https://url.spec.whatwg.org/#interface-urlsearchparams" target="_blank" rel="external">URLSearchParams</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" target="_blank" rel="external">FormData</a> —— 目前不被 Gecko 和 Blink 支持，Firefox 预计在版本 39 和 Fetch 的其他部分一起推出</li></ul><p>此外，Request 和 Response 都为操作 <code>body</code> 提供了以下方法，这些方法都返回一个使用实际内容 resolve 的 Promise 对象。</p><ul><li>arrayBuffer()</li><li>blob()</li><li>json()</li><li>text()</li><li>formData()</li></ul><p>所以，在处理非文本的数据方面，Fetch API 比 XHR 更为便利。</p><p>设置请求体：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> form = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.getElementById(<span class="string">'login-form'</span>));</div><div class="line">fetch(<span class="string">"/login"</span>, &#123;</div><div class="line">  method: <span class="string">"POST"</span>,</div><div class="line">  body: form</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>Responses 构造函数的第一个参数是响应体：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = <span class="keyword">new</span> Response(<span class="keyword">new</span> File([<span class="string">"chunk"</span>, <span class="string">"chunk"</span>], <span class="string">"archive.zip"</span>,</div><div class="line">&#123;<span class="attr">type</span>: <span class="string">"application/zip"</span>&#125;)                  </div><div class="line">);</div></pre></td></tr></table></figure><p>Request 和 Response（扩展的 <code>fetch()</code> 方法）都能够<a href="https://fetch.spec.whatwg.org/#concept-bodyinit-extract" target="_blank" rel="external">自动识别</a>自己的内容类型，Request 还可以自动设置 <code>Content-Type</code> 头，如果开发者没有设置它的话。</p><h2><span id="流和克隆">流和克隆</span></h2><p>非常重要的一点是，Request 和 Response 的 body 只能被读取一次！它们有一个属性叫 <code>bodyUsed</code>，读取一次之后设置为 <code>true</code>，之后就不能再被读取了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = <span class="keyword">new</span> Response(<span class="string">"one time use"</span>);</div><div class="line"><span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">// false</span></div><div class="line">res.text().then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">// true</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">// true</span></div><div class="line"> </div><div class="line">res.text().catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Tried to read already consumed Response"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这样设计的目的是为了之后兼容<a href="https://streams.spec.whatwg.org/" target="_blank" rel="external">基于流</a>的 API，我们的目的是当数据到达时就进行相应的处理，这样就使得 JavaScript 可以处理大文件例如视频，并且可以支持实时压缩和编辑。</p><p>有时候，我们希望能多次访问 body，例如，你可能想使用即将支持的 <a href="http://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#cache-objects" target="_blank" rel="external">Cache API</a> 来缓存 Request 和 Response，以便于可以离线使用，Cache 要求 body 能被再次读取。</p><p>那么，如何让 body 能被多次读取呢？API 为这两个对象提供了一个 <code>clone()</code> 方法。调用这个方法可以得到一个克隆对象，对象中包含全新的 body。不过要记得，<code>clone()</code> 必须要在使用 body 之前调用，也就是先 <code>clone()</code> 再读使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> sheep = <span class="keyword">new</span> Response(<span class="string">"Dolly"</span>);</div><div class="line">  <span class="built_in">console</span>.log(sheep.bodyUsed); <span class="comment">// false</span></div><div class="line">  <span class="keyword">var</span> clone = sheep.clone();</div><div class="line">  <span class="built_in">console</span>.log(clone.bodyUsed); <span class="comment">// false</span></div><div class="line"> </div><div class="line">  clone.text();</div><div class="line">  <span class="built_in">console</span>.log(sheep.bodyUsed); <span class="comment">// false</span></div><div class="line">  <span class="built_in">console</span>.log(clone.bodyUsed); <span class="comment">// true</span></div><div class="line"> </div><div class="line">  evt.respondWith(cache.add(sheep.clone()).then(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sheep;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2><span id="未来的改进">未来的改进</span></h2><p>为了支持流，Fetch 最终将提供可以中断执行和得到读取进度的 API。这些在 XHR 中有，但是想要实现基于 Promise 的 Fetch API 有些麻烦。</p><p>你可以加入 <a href="https://whatwg.org/mailing-list" target="_blank" rel="external">WHATWG 的邮件组</a>参与 <a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WHATWG&amp;component=Fetch&amp;resolution=---" target="_blank" rel="external">Fetch</a> 和 <a href="https://github.com/slightlyoff/ServiceWorker/issues" target="_blank" rel="external">ServiceWorker</a> 的讨论，为改进 API 贡献自己的力量。</p><p>为了创造更好的互联网而努力！</p><p><em>感谢 Andrea Marchesini, Anne van Kesteren 和 Ben Kelly 感谢他们对规范和实现所做的努力。</em><div class="div j-quote"><p><strong>参考资源：</strong></p><ul><li><a href="https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/" target="_blank" rel="external">This API is so Fetching!</a></li><li><a href="http://updates.html5rocks.com/2015/03/introduction-to-fetch" target="_blank" rel="external">Introduction to fetch()</a></li><li><a href="http://www.w3ctech.com/topic/854" target="_blank" rel="external">【翻译】这个API很“迷人”——(新的Fetch API)</a></li></ul></div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;十多年来，我们一直使用 XMLHttpRequest（XHR）来发送异步请求，XHR 很实用，但并不是一个设计优良的 API，在设计上并不符合职责分离原则，输入、输出以及状态都杂糅在同一对象中，并用事件机制来跟踪状态变化。并且，基于事件的模型与最近流行的 Promise 和 generator 异步编程模型不太友好。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fetch API&lt;/a&gt; 旨在修正上述缺陷，它提供了与 HTTP 语义相同的 JS 语法，简单来说，它引入了 &lt;code&gt;fetch()&lt;/code&gt; 这个实用的方法来获取网络资源。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fetch 规范&lt;/a&gt;中对 API 进行了定义，它结合 ServiceWorkers，尝试做到如下优化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;改善离线体验&lt;/li&gt;
&lt;li&gt;保持可扩展性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;写这篇文章时，Fetch API 已被 Firefox 39（Nightly）以及 Chrome 42（dev）支持。在 github 上有相应的 &lt;a href=&quot;https://github.com/github/fetch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;polyfill&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="fetch" scheme="http://bubkoo.com/tags/fetch/"/>
    
  </entry>
  
  <entry>
    <title>弹性盒模型指南</title>
    <link href="http://bubkoo.com/2015/04/17/a-visual-guide-to-css3-flexbox-properties/"/>
    <id>http://bubkoo.com/2015/04/17/a-visual-guide-to-css3-flexbox-properties/</id>
    <published>2015-04-17T13:10:40.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Flexbox 布局是 CSS3 中一种新的布局模型，被称为<a href="http://www.w3.org/TR/css-flexbox/" target="_blank" rel="external">弹性盒模型</a>。该模型是为了改进容器中内容的对齐、方向和排序方式，即使是动态，甚至是未知大小的容器。弹性盒模型的主要特点是，可以在不同屏幕尺寸下以最佳的方式，修改其子项的高度或宽度来填充容器的可用空间。</p><p>许多设计师和开发人员认为这种布局使用起来更加简单，弹性盒模型的使元素的定位更加简单，从而某些复杂的布局可以用更少的代码来实现，进而简化了开发过程。Flexbox 布局算法是基于方向的，这与基于垂直和水平的 block 和 inline 布局不同。弹性盒模型可用于小应用或组建的布局，然而对于大型应用应该使用 <a href="http://www.w3.org/TR/css-grid/" target="_blank" rel="external">Grid 布局</a>。</p><p>本文将用可视化的方式介绍 Flex 如何影响我们的布局。</p><a id="more"></a><h2><span id="基础">基础</span></h2><p>开始之前，我们先简单介绍一下弹性盒模型。弹性盒模型由一个弹性容器（flex container）和其直接子元素（flex items）构成。</p><p><img src="http://bubkoo.qiniudn.com/CSS3-Flexbox-Model.jpg" alt=""></p><p>上图描述了弹性盒模型的构成，更多信息可以参考 <a href="http://www.w3.org/TR/css-flexbox/#box-model" target="_blank" rel="external">W3C</a>。</p><p>弹性盒模型从 2009 年被提出到现在经过了很多次的迭代和语法修改，为了避免给读者造成困惑，本文只采用最新（2014年2月）的语法规范。如果需要兼容旧浏览器，你可以从<a href="https://css-tricks.com/using-flexbox/" target="_blank" rel="external">这篇文章</a>找到一些最佳实践。</p><p><strong>兼容最新规范的浏览器：</strong></p><ul><li>Chrome 29+</li><li>Firefox 28+</li><li>Internet Explorer 11+</li><li>Opera 17+</li><li>Safari 6.1+（需要 -webkit- 前缀）</li><li>Android 4.4+</li><li>iOS 7.1+（需要 -webkit- 前缀）</li></ul><p><a href="http://caniuse.com/#search=flex" target="_blank" rel="external">这里</a>有详细的浏览器兼容和支持列表。</p><h2><span id="使用">使用</span></h2><p>在容器上设置 <code>display</code> 样式属性，只需要在父容器上设置该属性，其所有的直接子元素将自动成为弹性子项。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果要显示为行内元素，可以这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">display</span>: -webkit-inline-flex; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">display</span>: inline-flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="弹性容器属性">弹性容器属性</span></h2><h3><span id="flex-direction">flex-direction</span></h3><p>定义子项在容器中的布局方式，水平布局和垂直布局。</p><p><strong>取值：</strong></p><ul><li><code>row</code> 横向从左到右排列（左对齐），默认的排列方式</li><li><code>row-reverse</code> 反转横向排列（右对齐，从后往前排，最后一项排在最前面）</li><li><code>column</code> 纵向排列</li><li><code>column-reverse</code> 反转纵向排列，从后往前排，最后一项排在最上面</li></ul><p><strong>注意：</strong><code>row</code> 和 <code>row-reverse</code> 依赖于书写模式，在 <code>RTL</code> 模式下，它们将分别被反转。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-flex-direction</span>: row; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">flex-direction</span>:         row;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-flex-direction-row.jpg" alt="在 LTR 上下文中，子项从左往右排列"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-flex-direction</span>: row-reverse; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">flex-direction</span>:         row-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-flex-direction-row-reverse.jpg" alt="在 LTR 上下文中，子项从右往左排列"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-flex-direction</span>: column; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">flex-direction</span>:         column;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-flex-direction-column.jpg" alt="从上往下排列"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-flex-direction</span>: column-reverse; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">flex-direction</span>:         column-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-flex-direction-column-reverse.jpg" alt="从下往上排列"></p><h3><span id="flex-wrap">flex-wrap</span></h3><p>设置弹性盒模型子元素超出父容器时是否换行。默认值为 <code>nowrap</code>。</p><p><strong>取值：</strong></p><ul><li><code>nowrap</code> 当子元素溢出父容器时不换行</li><li><code>wrap</code> 当子元素溢出父容器时自动换行</li><li><code>wrap-reverse</code> 反转 <code>wrap</code> 排列</li></ul><p><strong>注意：</strong>该属性也依赖文档的书写模式，在 <code>RTL</code> 模式下行排列的方式将相应地被反转。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-flex-wrap</span>: nowrap; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">flex-wrap</span>:         nowrap;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-flex-wrap-nowrap.jpg" alt="默认情况下，所有子项都不换行，子项将缩小自己来适应容器的大小"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-flex-wrap</span>: wrap; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">flex-wrap</span>:         wrap;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-flex-wrap-wrap.jpg" alt="从左到右，从上到下显示为多行"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-flex-wrap</span>: wrap-reverse; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">flex-wrap</span>:         wrap-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-flex-wrap-wrap-reverse.jpg" alt="从左到右，从下到上显示为多行"></p><h3><span id="flex-flow">flex-flow</span></h3><p>该属性是 <code>flex-direction</code> 和 <code>flex-wrap</code> 的简写。默认值为 <code>row nowrap</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">flex-flow</span>:         &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="justify-content">justify-content</span></h3><p>该属性定义了子项的水平对齐方式，默认值为 <code>flex-start</code>。当弹性盒里一行上的所有子元素都不能伸缩或已经达到其最大值时，这一属性可协助对多余的空间进行分配。当元素溢出某行时，这一属性同样会在对齐上进行控制。</p><p><strong>取值：</strong></p><ul><li><code>flex-start</code> 弹性盒子元素将向行起始位置对齐。该行的第一个子元素的主起始位置的边界将与该行的主起始位置的边界对齐，同时所有后续的伸缩盒项目与其前一个项目对齐</li><li><code>flex-end</code> 弹性盒子元素将向行结束位置对齐。该行的第一个子元素的主结束位置的边界将与该行的主结束位置的边界对齐，同时所有后续的伸缩盒项目与其前一个项目对齐</li><li><code>center</code> 弹性盒子元素将向行中间位置对齐。该行的子元素将相互对齐并在行中居中对齐，同时第一个元素与行的主起始位置的边距等同与最后一个元素与行的主结束位置的边距（如果剩余空间是负数，则保持两端相等长度的溢出）</li><li><code>space-between</code> 弹性盒子元素会平均地分布在行里。如果最左边的剩余空间是负数，或该行只有一个子元素，则该值等效于 <code>flex-start</code>。在其它情况下，第一个元素的边界与行的主起始位置的边界对齐，同时最后一个元素的边界与行的主结束位置的边距对齐，而剩余的伸缩盒项目则平均分布，并确保两两之间的空白空间相等</li><li><code>space-around</code> 弹性盒子元素会平均地分布在行里，两端保留子元素与子元素之间间距大小的一半。如果最左边的剩余空间是负数，或该行只有一个伸缩盒项目，则该值等效于’center’。在其它情况下，伸缩盒项目则平均分布，并确保两两之间的空白空间相等，同时第一个元素前的空间以及最后一个元素后的空间为其他空白空间的一半</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-justify-content</span>: flex-start; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">justify-content</span>:         flex-start;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-justify-content-flex-start.jpg" alt="在 LTR 上下文中，子项依次对齐到容器的左边界"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-justify-content</span>: flex-end; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">justify-content</span>:         flex-end;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-justify-content-flex-end.jpg" alt="在 LTR 上下文中，子项依次对齐到容器的右边界"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-justify-content</span>: center; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">justify-content</span>:         center;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-justify-content-center.jpg" alt="在容器的中心对齐"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-justify-content</span>: space-between; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">justify-content</span>:         space-between;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-justify-content-space-between.jpg" alt="子项以相同间距排列，并对齐到容器的左右边界"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-justify-content</span>: space-around; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">justify-content</span>:         space-around;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-justify-content-space-around.jpg" alt="每个子项的左右都有相同的间距"></p><h3><span id="align-items">align-items</span></h3><p>该属性定义了子项的侧轴对齐方式。默认值为 <code>stretch</code>。</p><p><strong>取值：</strong></p><ul><li><code>stretch</code> 如果指定侧轴大小的属性值为 <code>auto</code>，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照 <code>min/max-width/height</code> 属性的限制</li><li><code>flex-start</code> 弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界</li><li><code>flex-end</code> 弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界</li><li><code>center</code> 弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）</li><li><code>baseline</code> 如弹性盒子元素的行内轴与侧轴为同一条，则该值与 <code>flex-start</code> 等效。其它情况下，该值将参与基线对齐</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-items</span>: stretch; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">align-items</span>:         stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-align-items-stretch.jpg" alt="子项将填充整个高度或宽度"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-items</span>: flex-start; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">align-items</span>:         flex-start;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-align-items-flex-start.jpg" alt="子项将紧靠容器的上（左）边缘"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-items</span>: flex-end; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">align-items</span>:         flex-end;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-align-items-flex-end.jpg" alt="子项将紧靠容器的下（右）边缘"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-items</span>: center; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">align-items</span>:         center;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-align-items-center.jpg" alt=""></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-items</span>: baseline; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">align-items</span>:         baseline;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-align-items-baseline.jpg" alt=""></p><p><strong>提示：</strong><a href="http://www.w3.org/TR/css-flexbox/#flex-baselines" target="_blank" rel="external">这里</a>有关于 baseline 计算方式的详细介绍。</p><h3><span id="align-content">align-content</span></h3><p>该属性定义弹性容器中包含多行时，行之间的水平排列方式。默认值为 <code>stretch</code>。</p><p><strong>取值：</strong></p><ul><li><code>stretch</code> 各行将会伸展以占用剩余的空间。如果剩余的空间是负数，该值等效于 <code>flex-start</code>。在其它情况下，剩余空间被所有行平分，以扩大它们的侧轴尺寸</li><li><code>flex-start</code> 各行向弹性盒容器的起始位置堆叠。弹性盒容器中第一行的侧轴起始边界紧靠住该弹性盒容器的侧轴起始边界，之后的每一行都紧靠住前面一行</li><li><code>flex-end</code> 各行向弹性盒容器的结束位置堆叠。弹性盒容器中最后一行的侧轴起结束界紧靠住该弹性盒容器的侧轴结束边界，之后的每一行都紧靠住前面一行</li><li><code>center</code> 各行向弹性盒容器的中间位置堆叠。各行两两紧靠住同时在弹性盒容器中居中对齐，保持弹性盒容器的侧轴起始内容边界和第一行之间的距离与该容器的侧轴结束内容边界与第最后一行之间的距离相等。（如果剩下的空间是负数，则各行会向两个方向溢出的相等距离。）</li><li><code>space-between</code> 各行在弹性盒容器中平均分布。如果剩余的空间是负数或弹性盒容器中只有一行，该值等效于 <code>flex-start</code>。在其它情况下，第一行的侧轴起始边界紧靠住弹性盒容器的侧轴起始内容边界，最后一行的侧轴结束边界紧靠住弹性盒容器的侧轴结束内容边界，剩余的行则按一定方式在弹性盒窗口中排列，以保持两两之间的空间相等</li><li><code>space-around</code> 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。如果剩余的空间是负数或弹性盒容器中只有一行，该值等效于’center’。在其它情况下，各行会按一定方式在弹性盒容器中排列，以保持两两之间的空间相等，同时第一行前面及最后一行后面的空间是其他空间的一半</li></ul><p><strong>注意：</strong>该属性只在弹性容器中包含多行时才有效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-content</span>: stretch; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">align-content</span>:         stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-align-content-stretch.jpg" alt="每行之后都分配相同的空间"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-content</span>: flex-start; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">align-content</span>:         flex-start;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-align-content-flex-start.jpg" alt=""></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-content</span>: flex-end; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">align-content</span>:         flex-end;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-align-content-flex-end.jpg" alt=""></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-content</span>: center; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">align-content</span>:         center;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-align-content-center.jpg" alt=""></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-content</span>: space-between; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">align-content</span>:         space-between;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-align-content-space-between.jpg" alt=""></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-content</span>: space-around; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">align-content</span>:         space-around;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-align-content-space-around.jpg" alt=""></p><h3><span id="注意">注意</span></h3><ul><li>所有的 <code>column-*</code> 属性对弹性容器无效</li><li><code>::first-line</code> 和 <code>::first-letter</code> 伪元素也不适用于弹性容器</li></ul><h2><span id="弹性子项属性">弹性子项属性</span></h2><h3><span id="order">order</span></h3><p>该属性规定了弹性子项在容器中的显示顺序，默认情况下子项将按照其在文档流中的顺序显示。数值小的排在前面。可以为负值。默认值为 <code>0</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-item</span> &#123;</div><div class="line">  <span class="attribute">-webkit-order</span>: &lt;integer&gt;; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">order</span>:         &lt;integer&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-order.jpg" alt=""></p><h3><span id="flex-grow">flex-grow</span></h3><p>定义子项对父容器剩余空间的划分比例。不允许负值。默认值为<code>0</code>，如果没有显示定义该属性，是不会拥有分配剩余空间权利的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-item</span> &#123;</div><div class="line">  <span class="attribute">-webkit-flex-grow</span>: &lt;number&gt;; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">flex-grow</span>:         &lt;number&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-flex-grow-1.jpg" alt="如果子项的 flex-grow 值相同，那么他们将拥有相同的大小"></p><p><img src="http://bubkoo.qiniudn.com/flexbox-flex-grow-2.jpg" alt="第二项将比其他项都大"></p><h3><span id="flex-shrink">flex-shrink</span></h3><p>定义子项对父容器超出空间的消化比例。不允许负值。默认值为 <code>1</code>，如果没有显示定义该属性，将会自动按照默认值 <code>1</code> 在所有因子相加之后计算比率来进行空间收缩。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-item</span> &#123;</div><div class="line">  <span class="attribute">-webkit-flex-shrink</span>: &lt;number&gt;; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">flex-shrink</span>:         &lt;number&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-flex-shrink.jpg" alt="默认情况下所有子项都将参与消化超出空间，如果某项设置为 0 将不参与消化超出空间的消化，从而保持其本身的大小"></p><h3><span id="flex-basis">flex-basis</span></h3><p>设置子项在划分父容器剩余空间和消化超出空间之前的基准宽度或高度。默认值为 <code>auto</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-item</span> &#123;</div><div class="line">  <span class="attribute">-webkit-flex-basis</span>: auto | &lt;width&gt;; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">flex-basis</span>:         auto | &lt;width&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-flex-basis.jpg" alt="显示指定了第四项的大小"></p><h3><span id="flex">flex</span></h3><p>该属性是 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 的简写。默认值为 <code>0 1 auto</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-item</span> &#123;</div><div class="line">  <span class="attribute">-webkit-flex</span>: none | auto | [ &lt;flex-grow&gt; &lt;flex-shrink&gt;? || &lt;flex-basis&gt; ]; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">flex</span>:         none | auto | [ &lt;flex-grow&gt; &lt;flex-shrink&gt;? || &lt;flex-basis&gt; ];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="align-self">align-self</span></h3><p>设置子项的对其方式。默认值为 <code>auto</code>。</p><p><strong>取值：</strong></p><ul><li><code>auto</code> 如果 <code>align-self</code> 的值为 <code>auto</code> ，则其计算值为元素的父元素的 <code>align-items</code> 值，如果其没有父元素，则计算值为 <code>stretch</code></li><li><code>flex-start</code> 弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界</li><li><code>flex-end</code> 弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界</li><li><code>center</code> 弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）</li><li><code>baseline</code> 如弹性盒子元素的行内轴与侧轴为同一条，则该值与 <code>flex-start</code> 等效。其它情况下，该值将参与基线对齐</li><li><code>stretch</code> 如果指定侧轴大小的属性值为 <code>auto</code>，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照 <code>min/max-width/height</code> 属性的限制</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-item</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-self</span>: auto | flex-start | flex-end | center | baseline | stretch; <span class="comment">/* Safari */</span></div><div class="line">  <span class="attribute">align-self</span>:         auto | flex-start | flex-end | center | baseline | stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/flexbox-align-self.jpg" alt=""></p><h3><span id="注意">注意</span></h3><p><code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 对弹性子项无效。</p><h2><span id="参考资源">参考资源</span></h2><ul><li><a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties" target="_blank" rel="external">A Visual Guide to CSS3 Flexbox Properties</a></li><li><a href="http://bocoup.com/weblog/dive-into-flexbox/" target="_blank" rel="external">Dive into Flexbox</a></li><li><a href="http://css.doyoe.com/" target="_blank" rel="external">CSS 参考手册</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flexbox 布局是 CSS3 中一种新的布局模型，被称为&lt;a href=&quot;http://www.w3.org/TR/css-flexbox/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;弹性盒模型&lt;/a&gt;。该模型是为了改进容器中内容的对齐、方向和排序方式，即使是动态，甚至是未知大小的容器。弹性盒模型的主要特点是，可以在不同屏幕尺寸下以最佳的方式，修改其子项的高度或宽度来填充容器的可用空间。&lt;/p&gt;
&lt;p&gt;许多设计师和开发人员认为这种布局使用起来更加简单，弹性盒模型的使元素的定位更加简单，从而某些复杂的布局可以用更少的代码来实现，进而简化了开发过程。Flexbox 布局算法是基于方向的，这与基于垂直和水平的 block 和 inline 布局不同。弹性盒模型可用于小应用或组建的布局，然而对于大型应用应该使用 &lt;a href=&quot;http://www.w3.org/TR/css-grid/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Grid 布局&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文将用可视化的方式介绍 Flex 如何影响我们的布局。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://bubkoo.com/categories/css/"/>
    
    
      <category term="CSS3" scheme="http://bubkoo.com/tags/css3/"/>
    
      <category term="Flexbox" scheme="http://bubkoo.com/tags/flexbox/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 规范（ES6）</title>
    <link href="http://bubkoo.com/2015/04/05/javascript-style-guide/"/>
    <id>http://bubkoo.com/2015/04/05/javascript-style-guide/</id>
    <published>2015-04-05T20:26:37.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Airbnb 的 <a href="https://github.com/airbnb/javascript/blob/master/README.md" target="_blank" rel="external">ES5 规范</a>写的非常好，现在添加了 ES6 的部分。</p><p>另外<a href="http://www.ruanyifeng.com/" target="_blank" rel="external">阮一峰老师</a>的 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6 入门</a>值得参考。</p><a id="more"></a><h2><span id="类型">类型</span></h2><ul><li><p>原始类型：值传递</p><ul><li><code>string</code></li><li><code>number</code></li><li><code>boolean</code></li><li><code>null</code></li><li><code>undefined</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> bar = foo;</div><div class="line"></div><div class="line">bar = <span class="number">9</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo, bar); <span class="comment">// =&gt; 1, 9</span></div></pre></td></tr></table></figure><ul><li><p>复杂类型：引用传递</p><ul><li><code>object</code></li><li><code>array</code></li><li><code>function</code> </li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">const</span> bar = foo;</div><div class="line"></div><div class="line">bar[<span class="number">0</span>] = <span class="number">9</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo[<span class="number">0</span>], bar[<span class="number">0</span>]); <span class="comment">// =&gt; 9, 9</span></div></pre></td></tr></table></figure><h2><span id="引用">引用</span></h2><ul><li><p>为引用使用 <code>const</code> 关键字，而不是 <code>var</code></p><blockquote><p>这样确保你不能修改引用类型，否则可能会导致一些 bug 或难以理解的代码。 </p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</div></pre></td></tr></table></figure><ul><li><p>如果你必须修改引用，使用 <code>let</code> 代替 <code>var</code></p><blockquote><p>因为 <code>let</code> 是块作用域的，而 <code>var</code> 是函数作用域。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  count += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good, use the let.</span></div><div class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  count += <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>let</code> 和 <code>const</code> 都是块作用域的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// const and let only exist in the blocks they are defined in.</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line">  <span class="keyword">const</span> b = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure><h2><span id="对象">对象</span></h2><ul><li>使用对象字面量创建对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> item = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> item = &#123;&#125;;</div></pre></td></tr></table></figure><ul><li>不要使用<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Reserved_Words" target="_blank" rel="external">保留字（reserved words）</a>作为键，否则在 IE8 下将出错，<a href="https://github.com/airbnb/javascript/issues/61" target="_blank" rel="external">issue</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> superman = &#123;</div><div class="line">  class: 'superhero',</div><div class="line">  <span class="keyword">default</span>: &#123; <span class="attr">clark</span>: <span class="string">'kent'</span> &#125;,</div><div class="line">  private: <span class="literal">true</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> superman = &#123;</div><div class="line">  klass: <span class="string">'superhero'</span>,</div><div class="line">  defaults: &#123; <span class="attr">clark</span>: <span class="string">'kent'</span> &#125;,</div><div class="line">  hidden: <span class="literal">true</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>使用易读的同义词代替保留字</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> superman = &#123;</div><div class="line">  class: 'alien'</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> superman = &#123;</div><div class="line">  klass: <span class="string">'alien'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> superman = &#123;</div><div class="line">  type: <span class="string">'alien'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li><p>创建对象时使用计算的属性名，而不要在创建对象后使用对象的动态特性</p><blockquote><p>这样可以在同一个位置定义对象的所有属性。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKey</span>(<span class="params">k</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`a key named <span class="subst">$&#123;k&#125;</span>`</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// bad</span></div><div class="line">  <span class="keyword">const</span> obj = &#123;</div><div class="line">    id: <span class="number">5</span>,</div><div class="line">    name: <span class="string">'San Francisco'</span></div><div class="line">  &#125;;</div><div class="line">  obj[getKey(<span class="string">'enabled'</span>)] = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="comment">// good</span></div><div class="line">  <span class="keyword">const</span> obj = &#123;</div><div class="line">    id: <span class="number">5</span>,</div><div class="line">    name: <span class="string">'San Francisco'</span>,</div><div class="line">    [getKey(<span class="string">'enabled'</span>)]: <span class="literal">true</span></div><div class="line">  &#125;;</div></pre></td></tr></table></figure><ul><li>使用定义对象方法的简短形式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> atom = &#123;</div><div class="line">  value: <span class="number">1</span>,</div><div class="line"></div><div class="line">  addValue: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> atom.value + value;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> atom = &#123;</div><div class="line">  value: <span class="number">1</span>,</div><div class="line"></div><div class="line">  addValue(value) &#123;</div><div class="line">    <span class="keyword">return</span> atom.value + value;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li><p>使用定义对象属性的简短形式</p><blockquote><p>书写起来更加简单，并且可以自描述。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> lukeSkywalker = <span class="string">'Luke Skywalker'</span>;</div><div class="line"></div><div class="line">  <span class="comment">// bad</span></div><div class="line">  <span class="keyword">const</span> obj = &#123;</div><div class="line">    lukeSkywalker: lukeSkywalker</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// good</span></div><div class="line">  <span class="keyword">const</span> obj = &#123;</div><div class="line">    lukeSkywalker</div><div class="line">  &#125;;</div></pre></td></tr></table></figure><ul><li><p>将所有简写的属性写在对象定义的最顶部</p><blockquote><p>这样可以更加方便地知道哪些属性使用了简短形式。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> anakinSkywalker = <span class="string">'Anakin Skywalker'</span>;</div><div class="line">  <span class="keyword">const</span> lukeSkywalker = <span class="string">'Luke Skywalker'</span>;</div><div class="line"></div><div class="line">  <span class="comment">// bad</span></div><div class="line">  <span class="keyword">const</span> obj = &#123;</div><div class="line">    episodeOne: <span class="number">1</span>,</div><div class="line">    twoJedisWalkIntoACantina: <span class="number">2</span>,</div><div class="line">    lukeSkywalker,</div><div class="line">    episodeThree: <span class="number">3</span>,</div><div class="line">    mayTheFourth: <span class="number">4</span>,</div><div class="line">    anakinSkywalker</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// good</span></div><div class="line">  <span class="keyword">const</span> obj = &#123;</div><div class="line">    lukeSkywalker,</div><div class="line">    anakinSkywalker,</div><div class="line">    episodeOne: <span class="number">1</span>,</div><div class="line">    twoJedisWalkIntoACantina: <span class="number">2</span>,</div><div class="line">    episodeThree: <span class="number">3</span>,</div><div class="line">    mayTheFourth: <span class="number">4</span></div><div class="line">  &#125;;</div></pre></td></tr></table></figure><h2><span id="数组">数组</span></h2><ul><li>使用字面量语法创建数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> items = [];</div></pre></td></tr></table></figure><ul><li>如果你不知道数组的长度，使用 <code>push</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> someStack = [];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line">someStack[someStack.length] = <span class="string">'abracadabra'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">someStack.push(<span class="string">'abracadabra'</span>);</div></pre></td></tr></table></figure><ul><li>使用 <code>...</code> 来拷贝数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> len = items.length;</div><div class="line"><span class="keyword">const</span> itemsCopy = [];</div><div class="line"><span class="keyword">let</span> i;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">  itemsCopy[i] = items[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure><ul><li>使用 <code>Array.from</code> 将类数组对象转换为数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.foo'</span>);</div><div class="line"><span class="keyword">const</span> nodes = <span class="built_in">Array</span>.from(foo);</div></pre></td></tr></table></figure><h2><span id="解构-destructuring">解构 Destructuring</span></h2><ul><li><p>访问或使用对象的多个属性时请使用对象的解构赋值</p><blockquote><p>解构赋值避免了为这些属性创建临时变量或对象。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> firstName = user.firstName;</div><div class="line">  <span class="keyword">const</span> lastName = user.lastName;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; firstName, lastName &#125; = obj;</div><div class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用数组解构赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> first = arr[<span class="number">0</span>];</div><div class="line"><span class="keyword">const</span> second = arr[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> [first, second] = arr;</div></pre></td></tr></table></figure><ul><li><p>函数有多个返回值时使用对象解构，而不是数组解构</p><blockquote><p>这样你就可以随时添加新的返回值或任意改变返回值的顺序，而不会导致调用失败。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">    <span class="comment">// then a miracle occurs</span></div><div class="line">    <span class="keyword">return</span> [left, right, top, bottom];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// the caller needs to think about the order of return data</span></div><div class="line">  <span class="keyword">const</span> [left, __, top] = processInput(input);</div><div class="line"></div><div class="line">  <span class="comment">// good</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">    <span class="comment">// then a miracle occurs</span></div><div class="line">    <span class="keyword">return</span> &#123; left, right, top, bottom &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// the caller selects only the data they need</span></div><div class="line">  <span class="keyword">const</span> &#123; left, right &#125; = processInput(input);</div></pre></td></tr></table></figure><h2><span id="字符串">字符串</span></h2><ul><li>使用单引号 <code>&#39;&#39;</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Bob Parr"</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">'Bob Parr'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> fullName = <span class="string">"Bob "</span> + <span class="keyword">this</span>.lastName;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> fullName = <span class="string">'Bob '</span> + <span class="keyword">this</span>.lastName;</div></pre></td></tr></table></figure><ul><li>超过80个字符的字符串应该使用字符串连接换行</li><li>注：如果过度使用长字符串连接可能会对性能有影响。<a href="http://jsperf.com/ya-string-concat" target="_blank" rel="external">jsPerf</a> &amp; <a href="https://github.com/airbnb/javascript/issues/40" target="_blank" rel="external">Discussion</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that \</span></div><div class="line"><span class="string">was thrown because of Batman. \</span></div><div class="line"><span class="string">When you stop to think about \</span></div><div class="line"><span class="string">how Batman had anything to do \</span></div><div class="line"><span class="string">with this, you would get nowhere \</span></div><div class="line"><span class="string">fast.'</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that '</span> +</div><div class="line">  <span class="string">'was thrown because of Batman.'</span> +</div><div class="line">  <span class="string">'When you stop to think about '</span> +</div><div class="line">  <span class="string">'how Batman had anything to do '</span> +</div><div class="line">  <span class="string">'with this, you would get nowhere '</span> +</div><div class="line">  <span class="string">'fast.'</span>;</div></pre></td></tr></table></figure><ul><li><p>编程构建字符串时，使用字符串模板而不是字符串连接</p><blockquote><p>模板给你一个可读的字符串，简洁的语法与适当的换行和字符串插值特性。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'How are you, '</span> + name + <span class="string">'?'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [<span class="string">'How are you, '</span>, name, <span class="string">'?'</span>].join();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">`How are you, <span class="subst">$&#123;name&#125;</span>?`</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="函数">函数</span></h2><ul><li><p>使用函数声明而不是函数表达式</p><blockquote><p>函数声明拥有函数名，在调用栈中更加容易识别。并且，函数声明会整体提升，而函数表达式只会提升变量本身。这条规则也可以这样描述，始终使用<a href="https://github.com/airbnb/javascript/tree/es6?utm_source=javascriptweekly&amp;utm_medium=email#arrow-functions" target="_blank" rel="external">箭头函数</a>来代替函数表达式。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>函数表达式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// immediately-invoked function expression (IIFE)</span></div><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet. Please follow me.'</span>);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><ul><li>绝对不要在一个非函数块（if，while，等等）里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同</li><li>注：ECMA-262 把 <code>块</code> 定义为一组语句，函数声明不是一个语句。阅读 <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf#page=97" target="_blank" rel="external">ECMA-262</a> 对这个问题的说明</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (currentUser) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Nope.'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (currentUser) &#123;</div><div class="line">  <span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Yup.'</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>绝对不要把参数命名为 <code>arguments</code>, 这将会覆盖函数作用域内传过来的 <code>arguments</code> 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">nope</span>(<span class="params">name, options, arguments</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">yup</span>(<span class="params">name, options, args</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>永远不要使用 <code>arguments</code>，使用 <code>...</code> 操作符来代替</p><blockquote><p><code>...</code> 操作符可以明确指定你需要哪些参数，并且得到的是一个真实的数组，而不是 <code>arguments</code> 这样的类数组对象。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用函数参数默认值语法，而不是修改函数的实参</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// really bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</div><div class="line">  <span class="comment">// No! We shouldn't mutate function arguments.</span></div><div class="line">  <span class="comment">// Double bad: if opts is falsy it'll be set to an object which may</span></div><div class="line">  <span class="comment">// be what you want but it can introduce subtle bugs.</span></div><div class="line">  opts = opts || &#123;&#125;;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// still bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (opts === <span class="keyword">void</span> <span class="number">0</span>) &#123;</div><div class="line">    opts = &#123;&#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="箭头函数-arrow-functions">箭头函数 Arrow Functions</span></h2><ul><li><p>当必须使用函数表达式时（例如传递一个匿名函数时），请使用箭头函数</p><blockquote><p>箭头函数提供了更简洁的语法，并且箭头函数中 <code>this</code> 对象的指向是不变的，<code>this</code> 对象绑定定义时所在的对象，这通常是我们想要的。如果该函数的逻辑非常复杂，请将该函数提取为一个函数声明。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * x;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> x * x</div><div class="line">&#125;);</div></pre></td></tr></table></figure><ul><li>总是用括号包裹参数，省略括号只适用于单个参数，并且还降低了程序的可读性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div><div class="line"></div><div class="line">  <span class="comment">// good</span></div><div class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</div></pre></td></tr></table></figure><h2><span id="构造函数">构造函数</span></h2><ul><li><p>总是使用 <code>class</code> 关键字，避免直接修改 <code>prototype</code></p><blockquote><p><code>class</code> 语法更简洁，也更易理解。</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params">contents = []</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>._queue = [...contents];</div><div class="line">&#125;</div><div class="line">Queue.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">  <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(contents = []) &#123;</div><div class="line">    <span class="keyword">this</span>._queue = [...contents];</div><div class="line">  &#125;</div><div class="line">  pop() &#123;</div><div class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">    <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>使用 <code>extends</code> 关键字来继承</p><blockquote><p>这是一个内置的继承方式，并且不会破坏 <code>instanceof</code> 原型检查。</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">  <span class="keyword">const</span> inherits = <span class="built_in">require</span>(<span class="string">'inherits'</span>);</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">PeekableQueue</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    Queue.apply(<span class="keyword">this</span>, contents);</div><div class="line">  &#125;</div><div class="line">  inherits(PeekableQueue, Queue);</div><div class="line">  PeekableQueue.prototype.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// good</span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">PeekableQueue</span> <span class="keyword">extends</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">    peek() &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><ul><li>在方法中返回 <code>this</code> 以方便链式调用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">Jedi.prototype.jump = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.jumping = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Jedi.prototype.setHeight = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.height = height;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> luke = <span class="keyword">new</span> Jedi();</div><div class="line">luke.jump(); <span class="comment">// =&gt; true</span></div><div class="line">luke.setHeight(<span class="number">20</span>); <span class="comment">// =&gt; undefined</span></div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jedi</span> </span>&#123;</div><div class="line">  jump() &#123;</div><div class="line">    <span class="keyword">this</span>.jumping = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setHeight(height) &#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> luke = <span class="keyword">new</span> Jedi();</div><div class="line"></div><div class="line">luke.jump()</div><div class="line">  .setHeight(<span class="number">20</span>);</div></pre></td></tr></table></figure><ul><li>可以写一个自定义的toString()方法，但是确保它工作正常并且不会有副作用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jedi</span> </span>&#123;</div><div class="line">  contructor(options = &#123;&#125;) &#123;</div><div class="line">    <span class="keyword">this</span>.name = options.name || <span class="string">'no name'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`Jedi - <span class="subst">$&#123;<span class="keyword">this</span>.getName()&#125;</span>`</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="模块">模块</span></h2><ul><li><p>总是在非标准的模块系统中使用标准的 <code>import</code> 和 <code>export</code> 语法，我们总是可以将标准的模块语法转换成支持特定模块加载器的语法。 </p><blockquote><p>模块是未来的趋势，那么我们为何不现在就开始使用。</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> AirbnbStyleGuide = <span class="built_in">require</span>(<span class="string">'./AirbnbStyleGuide'</span>);</div><div class="line"><span class="built_in">module</span>.exports = AirbnbStyleGuide.es6;</div><div class="line"></div><div class="line"><span class="comment">// ok</span></div><div class="line"><span class="keyword">import</span> AirbnbStyleGuide <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> AirbnbStyleGuide.es6;</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</div></pre></td></tr></table></figure><ul><li><p>不要使用通配符 <code>*</code> 的 <code>import</code></p><blockquote><p>这样确保了只有一个默认的 <code>export</code> 项</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> AirbnbStyleGuide <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">import</span> AirbnbStyleGuide <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</div></pre></td></tr></table></figure><ul><li><p>不要直接从一个 <code>import</code> 上 <code>export</code></p><blockquote><p>虽然一行代码看起来更简洁，但是有一个明确的 <code>import</code> 和一个明确的 <code>export</code> 使得代码行为更加明确。</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="comment">// filename es6.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./airbnbStyleGuide'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="comment">// filename es6.js</span></div><div class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</div></pre></td></tr></table></figure><h2><span id="iterators-和-generators">Iterators 和 Generators</span></h2><ul><li><p>不要使用迭代器（Iterators）。优先使用 JavaScript 中 <code>map</code> 和 <code>reduce</code> 这类高阶函数来代替 <code>for-of</code> 循环</p><blockquote><p>处理纯函数的返回值更加容易并且没有副作用</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line">  <span class="comment">// bad</span></div><div class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> numbers) &#123;</div><div class="line">    sum += num;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  sum === <span class="number">15</span>;</div><div class="line"></div><div class="line">  <span class="comment">// good</span></div><div class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</div><div class="line">  numbers.forEach(<span class="function">(<span class="params">num</span>) =&gt;</span> sum += num);</div><div class="line">  sum === <span class="number">15</span>;</div><div class="line"></div><div class="line">  <span class="comment">// best (use the functional force)</span></div><div class="line">  <span class="keyword">const</span> sum = numbers.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> total + num, <span class="number">0</span>);</div><div class="line">  sum === <span class="number">15</span>;</div></pre></td></tr></table></figure><ul><li><p>不要使用 generators</p><blockquote><p>它们不太容易转换为 ES5 的语法。</p></blockquote></li></ul><h2><span id="属性">属性</span></h2><ul><li>使用点 <code>.</code> 操作符来访问属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> luke = &#123;</div><div class="line">  jedi: <span class="literal">true</span>,</div><div class="line">  age: <span class="number">28</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> isJedi = luke[<span class="string">'jedi'</span>];</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> isJedi = luke.jedi;</div></pre></td></tr></table></figure><ul><li>当使用变量访问属性时使用中括号 <code>[]</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> luke = &#123;</div><div class="line">  jedi: <span class="literal">true</span>,</div><div class="line">  age: <span class="number">28</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProp</span>(<span class="params">prop</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> luke[prop];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> isJedi = getProp(<span class="string">'jedi'</span>);</div></pre></td></tr></table></figure><h2><span id="变量">变量</span></h2><ul><li>总是使用 <code>const</code> 来声明变量，否则将生成全局变量，我们应该避免污染全局命名空间</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">superPower = <span class="keyword">new</span> SuperPower();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> superPower = <span class="keyword">new</span> SuperPower();</div></pre></td></tr></table></figure><ul><li><p>为每个变量都使用 <code>const</code> 关键字声明</p><blockquote><p>这种方式更加容易添加新变量，并且不必担忧将 <code>,</code> 错误写成 <code>;</code> 而导致生成全局变量。 </p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> items = getItems(),</div><div class="line">    goSportsTeam = <span class="literal">true</span>,</div><div class="line">    dragonball = <span class="string">'z'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="comment">// (compare to above, and try to spot the mistake)</span></div><div class="line"><span class="keyword">const</span> items = getItems(),</div><div class="line">    goSportsTeam = <span class="literal">true</span>;</div><div class="line">    dragonball = <span class="string">'z'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> items = getItems();</div><div class="line"><span class="keyword">const</span> goSportsTeam = <span class="literal">true</span>;</div><div class="line"><span class="keyword">const</span> dragonball = <span class="string">'z'</span>;</div></pre></td></tr></table></figure><ul><li>将所有 <code>const</code> 变量放在一起，然后将所有 <code>let</code> 变量放在一起</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">let</span> i, len, dragonball,</div><div class="line">    items = getItems(),</div><div class="line">    goSportsTeam = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">let</span> i;</div><div class="line"><span class="keyword">let</span> items = getItems();</div><div class="line"><span class="keyword">let</span> dragonball;</div><div class="line"><span class="keyword">let</span> goSportsTeam = <span class="literal">true</span>;</div><div class="line"><span class="keyword">let</span> len;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> goSportsTeam = <span class="literal">true</span>;</div><div class="line"><span class="keyword">const</span> items = getItems();</div><div class="line"><span class="keyword">let</span> dragonball;</div><div class="line"><span class="keyword">let</span> i;</div><div class="line"><span class="keyword">let</span> length;</div></pre></td></tr></table></figure><ul><li><p>在必要的时候声明变量，并且将其放在合适的位置</p><blockquote><p><code>let</code> 和 <code>const</code> 是块级作用域的，而不是函数作用域。</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// good</span></div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    test();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'doing stuff..'</span>);</div><div class="line"></div><div class="line">    <span class="comment">//..other stuff..</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> name = getName();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (name === <span class="string">'test'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// bad</span></div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> name = getName();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// good</span></div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> name = getName();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h2><span id="变量提升-hoisting">变量提升 Hoisting</span></h2><ul><li>通过 <code>var</code> 声明的变量将被提升到作用域的顶部，但他们的赋值不会被提升。通过 <code>const</code> 和 <code>let</code> 声明的变量不存在变量提升，这里有一个新概念，称为“<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let" target="_blank" rel="external">暂时性死区（ Temporal Dead Zones (TDZ)）</a>”。有必要理解  <a href="http://es-discourse.com/t/why-typeof-is-no-longer-safe/15" target="_blank" rel="external"><code>typeof</code> 不再是一个百分之百安全的操作</a>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// we know this wouldn't work (assuming there</span></div><div class="line"><span class="comment">// is no notDefined global variable)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(notDefined); <span class="comment">// =&gt; throws a ReferenceError</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// creating a variable declaration after you</span></div><div class="line"><span class="comment">// reference the variable will work due to</span></div><div class="line"><span class="comment">// variable hoisting. Note: the assignment</span></div><div class="line"><span class="comment">// value of `true` is not hoisted.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(declaredButNotAssigned); <span class="comment">// =&gt; undefined</span></div><div class="line">  <span class="keyword">var</span> declaredButNotAssigned = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// The interpreter is hoisting the variable</span></div><div class="line"><span class="comment">// declaration to the top of the scope,</span></div><div class="line"><span class="comment">// which means our example could be rewritten as:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> declaredButNotAssigned;</div><div class="line">  <span class="built_in">console</span>.log(declaredButNotAssigned); <span class="comment">// =&gt; undefined</span></div><div class="line">  declaredButNotAssigned = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// using const and let</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(declaredButNotAssigned); <span class="comment">// =&gt; throws a ReferenceError</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> declaredButNotAssigned); <span class="comment">// =&gt; throws a ReferenceError</span></div><div class="line">  <span class="keyword">const</span> declaredButNotAssigned = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>匿名函数表达式提升了对应的变量名，但赋值过程没有被提升</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(anonymous); <span class="comment">// =&gt; undefined</span></div><div class="line"></div><div class="line">  anonymous(); <span class="comment">// =&gt; TypeError anonymous is not a function</span></div><div class="line"></div><div class="line">  <span class="keyword">let</span> anonymous = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'anonymous function expression'</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>命名的函数表达式提升了对应的变量名，函数名和函数体没有被提升</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(named); <span class="comment">// =&gt; undefined</span></div><div class="line"></div><div class="line">  named(); <span class="comment">// =&gt; TypeError named is not a function</span></div><div class="line"></div><div class="line">  superPower(); <span class="comment">// =&gt; ReferenceError superPower is not defined</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">superPower</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Flying'</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// the same is true when the function name</span></div><div class="line"><span class="comment">// is the same as the variable name.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(named); <span class="comment">// =&gt; undefined</span></div><div class="line"></div><div class="line">  named(); <span class="comment">// =&gt; TypeError named is not a function</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">named</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'named'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>函数声明将被提升</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  superPower(); <span class="comment">// =&gt; Flying</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">superPower</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Flying'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>更多细节可以参考 <a href="http://www.adequatelygood.com/" target="_blank" rel="external">Ben Cherry</a> 的 <a href="http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting" target="_blank" rel="external">JavaScript Scoping &amp; Hoisting</a></li></ul><h2><span id="比较运算符和等号">比较运算符和等号</span></h2><ul><li>使用 <code>===</code> 和 <code>!==</code> 而不是 <code>==</code> 和 <code>!=</code></li><li><p>比较运算通过 <code>ToBoolean</code> 强制转换并遵循一下规则：</p><ul><li><code>Object</code> - <code>true</code></li><li><code>Undefined</code> - <code>false</code></li><li><code>Null</code> - <code>false</code></li><li><code>Booleans</code> - 被转换为对应的值</li><li><code>Number</code> - 值为 <code>+0</code>，<code>-0</code>，<code>NaN</code> 时为 <code>false</code>，否则为 <code>true</code></li><li><code>String</code> - 空字符串 <code>&#39;&#39;</code> 为 <code>false</code>，否则为 <code>true</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="number">0</span>]) &#123;</div><div class="line">  <span class="comment">// true</span></div><div class="line">  <span class="comment">// An array is an object, objects evaluate to true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用快捷方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (name !== <span class="string">''</span>) &#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (name) &#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (collection.length &gt; <span class="number">0</span>) &#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (collection.length) &#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>更多细节请阅读 <a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108" target="_blank" rel="external">Truth Equality and JavaScript</a> </li></ul><h2><span id="块">块</span></h2><ul><li>给所有多行的块使用大括号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (test)</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (test) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (test) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用 <code>if...else</code> 这样的多行块时，请将 <code>else</code> 和 <code>if</code> 的结束括号放在同一行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (test) &#123;</div><div class="line">  thing1();</div><div class="line">  thing2();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  thing3();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (test) &#123;</div><div class="line">  thing1();</div><div class="line">  thing2();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  thing3();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="注释">注释</span></h2><ul><li>使用 <code>/** ... */</code> 进行多行注释，包括描述，指定类型以及参数值和返回值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="comment">// make() returns a new element</span></div><div class="line"><span class="comment">// based on the passed in tag name</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// @param &lt;String&gt; tag</span></div><div class="line"><span class="comment">// @return &lt;Element&gt; element</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">tag</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> element;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * make() returns a new element</span></div><div class="line"><span class="comment"> * based on the passed in tag name</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param &lt;String&gt; tag</span></div><div class="line"><span class="comment"> * @return &lt;Element&gt; element</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">tag</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用 <code>//</code> 进行单行注释，将注释放在被注释对象的上面，并在注释之前保留一个空行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> active = <span class="literal">true</span>;  <span class="comment">// is current tab</span></div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="comment">// is current tab</span></div><div class="line"><span class="keyword">const</span> active = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'fetching type...'</span>);</div><div class="line">  <span class="comment">// set the default type to 'no type'</span></div><div class="line">  <span class="keyword">const</span> type = <span class="keyword">this</span>._type || <span class="string">'no type'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> type;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'fetching type...'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// set the default type to 'no type'</span></div><div class="line">  <span class="keyword">const</span> type = <span class="keyword">this</span>._type || <span class="string">'no type'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> type;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用 <code>// FIXME:</code> 来注释一个问题</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// <span class="doctag">FIXME:</span> shouldn't use a global here</span></div><div class="line">  total = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用 <code>// TODO:</code> 来注释一个问题的解决方案</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// <span class="doctag">TODO:</span> total should be configurable by an options param</span></div><div class="line">  <span class="keyword">this</span>.total = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="空白">空白</span></h2><ul><li>将 <code>tab</code> 设置为 <code>2</code> 个空格缩进</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">∙∙∙∙<span class="keyword">const</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">∙<span class="keyword">const</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">∙∙<span class="keyword">const</span> name;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>前大括号前放置一个空格</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line">dog.set(<span class="string">'attr'</span>,&#123;</div><div class="line">  age: <span class="string">'1 year'</span>,</div><div class="line">  breed: <span class="string">'Bernese Mountain Dog'</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">dog.set(<span class="string">'attr'</span>, &#123;</div><div class="line">  age: <span class="string">'1 year'</span>,</div><div class="line">  breed: <span class="string">'Bernese Mountain Dog'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><ul><li>运算符之间用空格分隔</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> x=y+<span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> x = y + <span class="number">5</span>;</div></pre></td></tr></table></figure><ul><li>文件末尾使用单个换行符</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;)(<span class="keyword">this</span>);</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;)(<span class="keyword">this</span>);↵</div><div class="line">↵</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// good</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;)(<span class="keyword">this</span>);↵</div></pre></td></tr></table></figure><ul><li>方法链式调用时保持适当的缩进，并且使用前置的 <code>.</code> 来表示该行是一个方法调用，而不是一个新语句</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">$(<span class="string">'#items'</span>).find(<span class="string">'.selected'</span>).highlight().end().find(<span class="string">'.open'</span>).updateCount();</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line">$(<span class="string">'#items'</span>).</div><div class="line">  find(<span class="string">'selected'</span>).</div><div class="line">    highlight().</div><div class="line">    end().</div><div class="line">  find(<span class="string">'.open'</span>).</div><div class="line">    updateCount();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">$(<span class="string">'#items'</span>)</div><div class="line">  .find(<span class="string">'.selected'</span>)</div><div class="line">    .highlight()</div><div class="line">    .end()</div><div class="line">  .find(<span class="string">'.open'</span>)</div><div class="line">    .updateCount();</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> leds = stage.selectAll(<span class="string">'.led'</span>).data(data).enter().append(<span class="string">'svg:svg'</span>).class(<span class="string">'led'</span>, <span class="literal">true</span>)</div><div class="line">    .attr(<span class="string">'width'</span>,  (radius + margin) * <span class="number">2</span>).append(<span class="string">'svg:g'</span>)</div><div class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)</div><div class="line">    .call(tron.led);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> leds = stage.selectAll(<span class="string">'.led'</span>)</div><div class="line">    .data(data)</div><div class="line">  .enter().append(<span class="string">'svg:svg'</span>)</div><div class="line">    .class(<span class="string">'led'</span>, <span class="literal">true</span>)</div><div class="line">    .attr(<span class="string">'width'</span>,  (radius + margin) * <span class="number">2</span>)</div><div class="line">  .append(<span class="string">'svg:g'</span>)</div><div class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)</div><div class="line">    .call(tron.led);</div></pre></td></tr></table></figure><ul><li>在语句块之后和下一语句之前都保持一个空行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> baz;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> baz;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  &#125;,</div><div class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> obj;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">return</span> obj;</div></pre></td></tr></table></figure><h2><span id="逗号">逗号</span></h2><ul><li>不要将逗号放前面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> story = [</div><div class="line">    once</div><div class="line">  , upon</div><div class="line">  , aTime</div><div class="line">];</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> story = [</div><div class="line">  once,</div><div class="line">  upon,</div><div class="line">  aTime</div><div class="line">];</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> hero = &#123;</div><div class="line">    firstName: <span class="string">'Bob'</span></div><div class="line">  , <span class="attr">lastName</span>: <span class="string">'Parr'</span></div><div class="line">  , <span class="attr">heroName</span>: <span class="string">'Mr. Incredible'</span></div><div class="line">  , <span class="attr">superPower</span>: <span class="string">'strength'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> hero = &#123;</div><div class="line">  firstName: <span class="string">'Bob'</span>,</div><div class="line">  lastName: <span class="string">'Parr'</span>,</div><div class="line">  heroName: <span class="string">'Mr. Incredible'</span>,</div><div class="line">  superPower: <span class="string">'strength'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>不要添加多余的逗号，否则将在 IE6/7 和 IE9 的怪异模式下导致错误。同时，某些 ES3 的实现会计算多数组的长度，这在 ES5 中有<a href="http://es5.github.io/#D" target="_blank" rel="external">澄清</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">  <span class="keyword">const</span> hero = &#123;</div><div class="line">    firstName: <span class="string">'Kevin'</span>,</div><div class="line">    lastName: <span class="string">'Flynn'</span>,</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> heroes = [</div><div class="line">    <span class="string">'Batman'</span>,</div><div class="line">    <span class="string">'Superman'</span>,</div><div class="line">  ];</div><div class="line"></div><div class="line">  <span class="comment">// good</span></div><div class="line">  <span class="keyword">const</span> hero = &#123;</div><div class="line">    firstName: <span class="string">'Kevin'</span>,</div><div class="line">    lastName: <span class="string">'Flynn'</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> heroes = [</div><div class="line">    <span class="string">'Batman'</span>,</div><div class="line">    <span class="string">'Superman'</span></div><div class="line">  ];</div></pre></td></tr></table></figure><h2><span id="分号">分号</span></h2><ul><li>句末一定要添加分号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> name = <span class="string">'Skywalker'</span></div><div class="line">  <span class="keyword">return</span> name</div><div class="line">&#125;)()</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> name = <span class="string">'Skywalker'</span>;</div><div class="line">  <span class="keyword">return</span> name;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// good (guards against the function becoming an argument when two files with IIFEs are concatenated)</span></div><div class="line">;<span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> name = <span class="string">'Skywalker'</span>;</div><div class="line">  <span class="keyword">return</span> name;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><h2><span id="类型转换">类型转换</span></h2><ul><li>在语句的开始执行类型转换</li><li>字符串：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  =&gt; this.reviewScore = 9;</span></div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> totalScore = <span class="keyword">this</span>.reviewScore + <span class="string">''</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> totalScore = <span class="built_in">String</span>(<span class="keyword">this</span>.reviewScore);</div></pre></td></tr></table></figure><ul><li>对数字使用 parseInt 并且总是带上类型转换的基数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> inputValue = <span class="string">'4'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> val = <span class="keyword">new</span> <span class="built_in">Number</span>(inputValue);</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> val = +inputValue;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> val = inputValue &gt;&gt; <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> val = <span class="built_in">parseInt</span>(inputValue);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> val = <span class="built_in">Number</span>(inputValue);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> val = <span class="built_in">parseInt</span>(inputValue, <span class="number">10</span>);</div></pre></td></tr></table></figure><ul><li>不管是出于一些奇特的原因，还是 <code>parseInt</code> 是一个瓶颈而需要位运算来解决某些<a href="http://jsperf.com/coercion-vs-casting/3" target="_blank" rel="external">性能问题</a>，请为你的代码注释为什么要这样做</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// good</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * parseInt was the reason my code was slow.</span></div><div class="line"><span class="comment"> * Bitshifting the String to coerce it to a</span></div><div class="line"><span class="comment"> * Number made it a lot faster.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> val = inputValue &gt;&gt; <span class="number">0</span>;</div></pre></td></tr></table></figure><ul><li><strong>注意：</strong>使用位移运算时要特别小心。<code>Number</code> 在 JavaScript 中表示为 <a href="http://es5.github.io/#x4.3.19" target="_blank" rel="external">64 位的值</a>，但位移运算总是返回一个 32 位的整数（<a href="http://es5.github.io/#x11.7" target="_blank" rel="external">source</a>），对大于 32 位的整数进行位移运算会导致意外的结果（<a href="https://github.com/airbnb/javascript/issues/109" target="_blank" rel="external">讨论</a>）。32 位最大整数为 <code>2,147,483,647</code>：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2147483647</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; 2147483647</span></div><div class="line"><span class="number">2147483648</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; -2147483648</span></div><div class="line"><span class="number">2147483649</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; -2147483647</span></div></pre></td></tr></table></figure><ul><li>布尔值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> hasAge = <span class="keyword">new</span> <span class="built_in">Boolean</span>(age);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> hasAge = <span class="built_in">Boolean</span>(age);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> hasAge = !!age;</div></pre></td></tr></table></figure><h2><span id="命名约定">命名约定</span></h2><ul><li>避免单个字符名，让你的变量名有描述意义</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">q</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ..stuff..</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>命名对象、函数和实例时使用小驼峰命名规则</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> OBJEcttsssss = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> this_is_my_object = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> <span class="keyword">this</span>-is-my-object = &#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> user(&#123;</div><div class="line">  name: <span class="string">'Bob Parr'</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> thisIsMyObject = &#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisIsMyFunction</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(&#123;</div><div class="line">  name: <span class="string">'Bob Parr'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><ul><li>命名构造函数或类时使用大驼峰命名规则</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">user</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = options.name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> bad = <span class="keyword">new</span> user(&#123;</div><div class="line">  name: <span class="string">'nope'</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(options) &#123;</div><div class="line">    <span class="keyword">this</span>.name = options.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> good = <span class="keyword">new</span> User(&#123;</div><div class="line">  name: <span class="string">'yup'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><ul><li>命名私有属性时前面加个下划线 <code>_</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">this</span>.__firstName__ = <span class="string">'Panda'</span>;</div><div class="line"><span class="keyword">this</span>.firstName_ = <span class="string">'Panda'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">this</span>._firstName = <span class="string">'Panda'</span>;</div></pre></td></tr></table></figure><ul><li>保存对 <code>this</code> 的引用时使用 <code>_this</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(self);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(that);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(_this);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>导出单一一个类时，确保你的文件名就是你的类名</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file contents</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckBox</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = CheckBox;</div><div class="line"></div><div class="line"><span class="comment">// in some other file</span></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> CheckBox = <span class="built_in">require</span>(<span class="string">'./checkBox'</span>);</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> CheckBox = <span class="built_in">require</span>(<span class="string">'./check_box'</span>);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> CheckBox = <span class="built_in">require</span>(<span class="string">'./CheckBox'</span>);</div></pre></td></tr></table></figure><ul><li>导出一个默认小驼峰命名的函数时，文件名应该就是导出的方法名</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeStyleGuide</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> makeStyleGuide;</div></pre></td></tr></table></figure><ul><li>导出单例、函数库或裸对象时，使用大驼峰命名规则</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> AirbnbStyleGuide = &#123;</div><div class="line">  es6: &#123;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> AirbnbStyleGuide;</div></pre></td></tr></table></figure><h2><span id="访问器">访问器</span></h2><ul><li>属性的访问器函数不是必须的</li><li>如果你确实有存取器函数的话使用 <code>getVal()</code> 和 <code>setVal(&#39;hello&#39;)</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">dragon.age();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">dragon.getAge();</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line">dragon.age(<span class="number">25</span>);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">dragon.setAge(<span class="number">25</span>);</div></pre></td></tr></table></figure><ul><li>如果属性是布尔值，使用 <code>isVal()</code> 或 <code>hasVal()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">if</span> (!dragon.age()) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">if</span> (!dragon.hasAge()) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>可以创建get()和set()函数，但是要保持一致性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jedi</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">  options || (options = &#123;&#125;);</div><div class="line">  <span class="keyword">var</span> lightsaber = options.lightsaber || <span class="string">'blue'</span>;</div><div class="line">  <span class="keyword">this</span>.set(<span class="string">'lightsaber'</span>, lightsaber);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Jedi.prototype.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>[key] = val;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Jedi.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>[key];</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2><span id="事件">事件</span></h2><ul><li>当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据里而不用找出并更新那个事件的事件处理器</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">$(<span class="keyword">this</span>).trigger(<span class="string">'listingUpdated'</span>, listing.id);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">$(<span class="keyword">this</span>).on(<span class="string">'listingUpdated'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e, listingId</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something with listingId</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// good</span></div><div class="line">$(<span class="keyword">this</span>).trigger(<span class="string">'listingUpdated'</span>, &#123; <span class="attr">listingId</span> : listing.id &#125;);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">$(<span class="keyword">this</span>).on(<span class="string">'listingUpdated'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e, data</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something with data.listingId</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2><span id="jquery">jQuery</span></h2><ul><li>为 jQuery 对象命名时添加 <code>$</code> 前缀</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> sidebar = $(<span class="string">'.sidebar'</span>);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> $sidebar = $(<span class="string">'.sidebar'</span>);</div></pre></td></tr></table></figure><ul><li>缓存 jQuery 的查询结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setSidebar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  $(<span class="string">'.sidebar'</span>).hide();</div><div class="line"></div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line"></div><div class="line">  $(<span class="string">'.sidebar'</span>).css(&#123;</div><div class="line">    <span class="string">'background-color'</span>: <span class="string">'pink'</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setSidebar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> $sidebar = $(<span class="string">'.sidebar'</span>);</div><div class="line">  $sidebar.hide();</div><div class="line"></div><div class="line">  <span class="comment">// ...stuff...</span></div><div class="line"></div><div class="line">  $sidebar.css(&#123;</div><div class="line">    <span class="string">'background-color'</span>: <span class="string">'pink'</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>对DOM查询使用级联的 <code>$(&#39;.sidebar ul&#39;)</code> 或 <code>$(&#39;.sidebar ul&#39;)</code>，<a href="http://jsperf.com/jquery-find-vs-context-sel/16" target="_blank" rel="external">jsPerf</a></li><li>在指定作用域进行查询时使用 <code>find</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">$(<span class="string">'ul'</span>, <span class="string">'.sidebar'</span>).hide();</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line">$(<span class="string">'.sidebar'</span>).find(<span class="string">'ul'</span>).hide();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">$(<span class="string">'.sidebar ul'</span>).hide();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">$(<span class="string">'.sidebar &gt; ul'</span>).hide();</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">$sidebar.find(<span class="string">'ul'</span>).hide();</div></pre></td></tr></table></figure><h2><span id="ecmascript-5-兼容性">ECMAScript 5 兼容性</span></h2><ul><li>参考 <a href="https://twitter.com/kangax/" target="_blank" rel="external">Kangax</a> 的 <a href="http://kangax.github.com/es5-compat-table/" target="_blank" rel="external">ES5 compatibility table</a></li></ul><h2><span id="ecmascript-6-新特性">ECMAScript 6 新特性</span></h2><p>下面是本文涉及到的 ES6 新特性：</p><h2><span id="性能">性能</span></h2><ul><li><a href="http://kellegous.com/j/2013/01/26/layout-performance/" target="_blank" rel="external">On Layout &amp; Web Performance</a></li><li><a href="http://jsperf.com/string-vs-array-concat/2" target="_blank" rel="external">String vs Array Concat</a></li><li><a href="http://jsperf.com/try-catch-in-loop-cost" target="_blank" rel="external">Try/Catch Cost In a Loop</a></li><li><a href="http://jsperf.com/bang-function" target="_blank" rel="external">Bang Function</a></li><li><a href="http://jsperf.com/jquery-find-vs-context-sel/13" target="_blank" rel="external">jQuery Find vs Context, Selector</a></li><li><a href="http://jsperf.com/innerhtml-vs-textcontent-for-script-text" target="_blank" rel="external">innerHTML vs textContent for script text</a></li><li><a href="http://jsperf.com/ya-string-concat" target="_blank" rel="external">Long String Concatenation</a></li><li>Loading…</li></ul><h2><span id="资源">资源</span></h2><p><strong>Read This</strong></p><ul><li><a href="http://es5.github.com/" target="_blank" rel="external">Annotated ECMAScript 5.1</a></li></ul><p><strong>工具</strong></p><ul><li>Code Style Linters<ul><li><a href="http://www.jshint.com/" target="_blank" rel="external">JSHint</a> - <a href="https://github.com/airbnb/javascript/blob/master/linters/jshintrc" target="_blank" rel="external">Airbnb Style .jshintrc</a></li><li><a href="https://github.com/jscs-dev/node-jscs" target="_blank" rel="external">JSCS</a> - <a href="https://github.com/jscs-dev/node-jscs/blob/master/presets/airbnb.json" target="_blank" rel="external">Airbnb Style Preset</a></li></ul></li></ul><p><strong>其它规范</strong></p><ul><li><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml" target="_blank" rel="external">Google JavaScript Style Guide</a></li><li><a href="http://docs.jquery.com/JQuery_Core_Style_Guidelines" target="_blank" rel="external">jQuery Core Style Guidelines</a></li><li><a href="https://github.com/rwldrn/idiomatic.js/" target="_blank" rel="external">Principles of Writing Consistent, Idiomatic JavaScript</a></li></ul><p><strong>其它风格</strong></p><ul><li><a href="https://gist.github.com/4135065" target="_blank" rel="external">Naming this in nested functions</a> - Christian Johansen</li><li><a href="https://github.com/airbnb/javascript/issues/52" target="_blank" rel="external">Conditional Callbacks</a> - Ross Allen</li><li><a href="http://sideeffect.kr/popularconvention/#javascript" target="_blank" rel="external">Popular JavaScript Coding Conventions on Github</a> - JeongHoon Byun</li><li><a href="http://benalman.com/news/2012/05/multiple-var-statements-javascript/" target="_blank" rel="external">Multiple var statements in JavaScript, not superfluous</a> - Ben Alman</li></ul><p><strong>更多文章</strong></p><ul><li><a href="http://javascriptweblog.wordpress.com/2010/10/25/understanding-javascript-closures/" target="_blank" rel="external">Understanding JavaScript Closures</a> - Angus Croll</li><li><a href="http://www.2ality.com/2013/06/basic-javascript.html" target="_blank" rel="external">Basic JavaScript for the impatient programmer</a> - Dr. Axel Rauschmayer</li><li><a href="http://youmightnotneedjquery.com/" target="_blank" rel="external">You Might Not Need jQuery</a> - Zack Bloom &amp; Adam Schwartz</li><li><a href="https://github.com/lukehoban/es6features" target="_blank" rel="external">ES6 Features</a> - Luke Hoban</li><li><a href="https://github.com/bendc/frontend-guidelines" target="_blank" rel="external">Frontend Guidelines</a> - Benjamin De Cock</li></ul><p><strong>书籍</strong></p><ul><li><a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742" target="_blank" rel="external">JavaScript: The Good Parts</a> - Douglas Crockford</li><li><a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752" target="_blank" rel="external">JavaScript Patterns</a> - Stoyan Stefanov</li><li><a href="http://www.amazon.com/JavaScript-Design-Patterns-Recipes-Problem-Solution/dp/159059908X" target="_blank" rel="external">Pro JavaScript Design Patterns</a>  - Ross Harmes and Dustin Diaz</li><li><a href="http://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309" target="_blank" rel="external">High Performance Web Sites: Essential Knowledge for Front-End Engineers</a> - Steve Souders</li><li><a href="http://www.amazon.com/Maintainable-JavaScript-Nicholas-C-Zakas/dp/1449327680" target="_blank" rel="external">Maintainable JavaScript</a> - Nicholas C. Zakas</li><li><a href="http://www.amazon.com/JavaScript-Web-Applications-Alex-MacCaw/dp/144930351X" target="_blank" rel="external">JavaScript Web Applications</a> - Alex MacCaw</li><li><a href="http://www.amazon.com/Pro-JavaScript-Techniques-John-Resig/dp/1590597273" target="_blank" rel="external">Pro JavaScript Techniques</a> - John Resig</li><li><a href="http://www.amazon.com/Smashing-Node-js-JavaScript-Everywhere-Magazine/dp/1119962595" target="_blank" rel="external">Smashing Node.js: JavaScript Everywhere</a> - Guillermo Rauch</li><li><a href="http://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X" target="_blank" rel="external">Secrets of the JavaScript Ninja</a> - John Resig and Bear Bibeault</li><li><a href="http://humanjavascript.com/" target="_blank" rel="external">Human JavaScript</a> - Henrik Joreteg</li><li><a href="http://superherojs.com/" target="_blank" rel="external">Superhero.js</a> - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy</li><li><a href="http://jsbooks.revolunet.com/" target="_blank" rel="external">JSBooks</a> - Julien Bouquillon</li><li><a href="http://manning.com/vinegar/" target="_blank" rel="external">Third Party JavaScript</a> - Ben Vinegar and Anton Kovalyov</li><li><a href="http://amzn.com/0321812182" target="_blank" rel="external">Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript</a> - David Herman</li></ul><p><strong>播客</strong></p><ul><li><a href="http://dailyjs.com/" target="_blank" rel="external">DailyJS</a></li><li><a href="http://javascriptweekly.com/" target="_blank" rel="external">JavaScript Weekly</a></li><li><a href="http://javascriptweblog.wordpress.com/" target="_blank" rel="external">JavaScript, JavaScript…</a></li><li><a href="http://weblog.bocoup.com/" target="_blank" rel="external">Bocoup Weblog</a></li><li><a href="http://www.adequatelygood.com/" target="_blank" rel="external">Adequately Good</a></li><li><a href="http://www.nczonline.net/" target="_blank" rel="external">NCZOnline</a></li><li><a href="http://perfectionkills.com/" target="_blank" rel="external">Perfection Kills</a></li><li><a href="http://benalman.com/" target="_blank" rel="external">Ben Alman</a></li><li><a href="http://dmitry.baranovskiy.com/" target="_blank" rel="external">Dmitry Baranovskiy</a></li><li><a href="http://dustindiaz.com/" target="_blank" rel="external">Dustin Diaz</a></li><li><a href="http://net.tutsplus.com/?s=javascript" target="_blank" rel="external">nettuts</a></li></ul><p><strong>Podcasts</strong></p><ul><li><a href="http://devchat.tv/js-jabber/" target="_blank" rel="external">JavaScript Jabber</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Airbnb 的 &lt;a href=&quot;https://github.com/airbnb/javascript/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ES5 规范&lt;/a&gt;写的非常好，现在添加了 ES6 的部分。&lt;/p&gt;
&lt;p&gt;另外&lt;a href=&quot;http://www.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阮一峰老师&lt;/a&gt;的 &lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMAScript 6 入门&lt;/a&gt;值得参考。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Guide" scheme="http://bubkoo.com/tags/guide/"/>
    
  </entry>
  
  <entry>
    <title>创建自定义元素的最佳实践</title>
    <link href="http://bubkoo.com/2015/02/02/best-practice-for-creating-custom-elements/"/>
    <id>http://bubkoo.com/2015/02/02/best-practice-for-creating-custom-elements/</id>
    <published>2015-02-02T11:23:14.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>越来越多的文章和讨论都是关于什么是 web 组件，什么是自定义元素，它们有什么好处以及如何使用它们，这些概念也逐渐进入开发人员的视野。如果你还不知道创建自定义元素的概念，请参考阅读<a href="http://www.smashingmagazine.com/2014/03/04/introduction-to-custom-elements/" target="_blank" rel="external">详细介绍自定义元素</a>。</p><p>尽管这些新概念还没有在开发中大量使用，我认为是时候讨论一下使用它们的最佳实践。本文将通过对比分析两种创建自定义元素方法的优缺点，最后得出创建自定义元素的最佳实践。</p><a id="more"></a><h2><span id="方法一全新的自定义元素">方法一：全新的自定义元素</span></h2><p>第一种方法是，在 DOM 中注册一个全新的自定义元素。下面例子中，我注册并使用了一个全新的按钮元素，并将其命名为 <code>new-button</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//JS file</div><div class="line">document.registerElement('new-button');</div><div class="line"><span class="comment">&lt;!-- HTML file --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">new-button</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">new-button</span>&gt;</span></div></pre></td></tr></table></figure><p>我认为该方法有两个主要的缺点。</p><p>第一，如果在用户浏览器 JS 被禁用或由于其他原因没有被运行（运行异常、由于文件太大或网络问题导致 JS 文件还没加载完成），这个按钮将无效，而用户看到的仅仅是元素内部的文字。</p><p>第二，这个全新的元素只会继承标准的 <a href="https://developer.mozilla.org/en/docs/Web/API/HTMLElement" target="_blank" rel="external">HTMLElement API</a> 接口，为了让其具有按钮的行为，我们还需要手动添加<a href="https://developer.mozilla.org/en/docs/Web/API/HTMLButtonElement" target="_blank" rel="external">按钮的方法和属性</a>：所有表单的属性、可访问性、行为特性、有效性方法，当然，还有最基本的提交表单的能力。</p><h2><span id="方法二扩展现有元素">方法二：扩展现有元素</span></h2><p>第二种方法是扩展现有元素，并继承现有元素的所有属性。下面例子中，通过指定 <code>extends</code> 选项来使 <code>new-button</code> 元素继承自现有按钮，然后通过 <code>is</code> 属性来标记该元素扩展出了哪个自定义元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//JS file</div><div class="line">document.registerElement('new-button', &#123;</div><div class="line">  extends: 'button'</div><div class="line">&#125;);</div><div class="line"><span class="comment">&lt;!-- HTML file --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"new-button"</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure><p>通过这种方式，<code>new-button</code> 元素获得了按钮的所有属性和行为，而不需要像方法一那样人为指定。并且，如果由于某些原因 JS 不能执行，用户仍然可以看到一个常见的按钮，并可以点击按钮来提交表单。</p><p>在 <a href="https://github.com/" target="_blank" rel="external">Github</a> 上有一个扩展自 <code>time</code> 元素的实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">is</span>=<span class="string">"relative-time"</span> <span class="attr">datetime</span>=<span class="string">"…"</span>&gt;</span>Jan 27, 2015<span class="tag">&lt;/<span class="name">time</span>&gt;</span></div></pre></td></tr></table></figure><p>当 JS 运行正常并且浏览器支持自定义元素时，自定义的 <code>relative-time</code> 元素将显示一个相对的时间 (2 hours ago)；否则就是一个标准的 <code>time</code> 元素，显示一个绝对时间 (Jan 27, 2015)。</p><h2><span id="最佳实践">最佳实践</span></h2><p>显然，方法二比方法一好，事实上，我还找不到方法二的缺点。</p><p><a href="http://jsfiddle.net/stopsatgreen/ru0fqxco/" target="_blank" rel="external">这里</a>有一个示例，演示了如何通过方法二来扩展一个自定义按钮，并添加了一个自定义的属性。运行该示例需要 Chrome、Opera 或 Firefox 浏览器，并将 <code>dom.webcomponents.enabled</code> 选项打开。</p><p>在我看来，创建自定义元素时，应该优先考虑扩展自现有元素。对开发人员来说，自定义元素能够继承和访问那些经过多年测试的属性和方法；对用户来说，如果 JS 运行失败，这些自定义元素也可以回滚为基本元素，保证了页面的可访问性。</p><p>该方法唯一的难点在于选择合适的元素来扩展，例如，如果定义一个 <code>google-maps</code> 元素，我应该扩展自一个空白的 <code>div</code> 元素还是 <code>img</code> 元素呢？这是一个重要的选择，你的选择应该保障用户能完成他们的工作，即便是使用一些局限的方式（当自定义元素失效时）。尽管如此，我不认为这是我们使用该最佳实践的障碍。</p><h2><span id="结论">结论</span></h2><p>老实说，这并不是一个新的最佳实践（其他语言也有类似的最佳实践）。当使用 JS 创建自定义的 UI 元素时，应充分考虑到元素的可访问性、行为特性和能够在不兼容时回滚为基本的元素。正如 <a href="https://twitter.com/rogerjohansson/status/558585728314376194" target="_blank" rel="external">Roger Johansson</a> 所说：</p><blockquote><p>当你一定要创建一个自定义的 <code>select</code> 元素时，请一定要保证为所有平台复制原生 <code>select</code> 元素的所有功能。</p></blockquote><h2><span id="扩展阅读">扩展阅读</span></h2><ul><li><a href="http://w3c.github.io/webcomponents/spec/custom/" target="_blank" rel="external">Custom Elements Specification</a></li><li><a href="http://www.html5rocks.com/zh/tutorials/webcomponents/customelements/" target="_blank" rel="external">Custom Elements</a></li><li><a href="http://www.smashingmagazine.com/2014/03/04/introduction-to-custom-elements/" target="_blank" rel="external">Detailed Introduction To Custom Elements</a></li><li><a href="http://developer.telerik.com/featured/web-components-ready-production/" target="_blank" rel="external">Why Web Components Are Ready For Production</a></li><li><a href="http://www.broken-links.com/2013/04/04/creating-custom-icon-font-using-icomoon/" target="_blank" rel="external">Creating a custom icon font using IcoMoon</a></li><li><a href="http://www.broken-links.com/2014/08/28/css-variables-updating-custom-properties-javascript/" target="_blank" rel="external">CSS Variables: Access Custom Properties with JavaScript</a></li><li><a href="http://www.broken-links.com/2013/03/25/removing-the-whitespace-from-inline-block-elements/" target="_blank" rel="external">Removing the whitespace from inline block elements</a></li></ul><p class="j-quote">参考原文：<a href="http://www.broken-links.com/2015/01/27/best-practice-creating-custom-elements/" target="_blank" rel="external">Best Practice for Creating Custom Elements</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越来越多的文章和讨论都是关于什么是 web 组件，什么是自定义元素，它们有什么好处以及如何使用它们，这些概念也逐渐进入开发人员的视野。如果你还不知道创建自定义元素的概念，请参考阅读&lt;a href=&quot;http://www.smashingmagazine.com/2014/03/04/introduction-to-custom-elements/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;详细介绍自定义元素&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;尽管这些新概念还没有在开发中大量使用，我认为是时候讨论一下使用它们的最佳实践。本文将通过对比分析两种创建自定义元素方法的优缺点，最后得出创建自定义元素的最佳实践。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML/CSS" scheme="http://bubkoo.com/categories/html-css/"/>
    
    
      <category term="Custom Elements" scheme="http://bubkoo.com/tags/custom-elements/"/>
    
  </entry>
  
  <entry>
    <title>自定义元素：在 HTML 中定义新元素</title>
    <link href="http://bubkoo.com/2015/02/02/create-custom-elements/"/>
    <id>http://bubkoo.com/2015/02/02/create-custom-elements/</id>
    <published>2015-02-02T00:35:35.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="引言">引言</span></h2><p>现在的 web 严重缺乏表现力。你只要瞧一眼“现代”的 web 应用，比如 GMail，就会明白了：</p><p><img src="http://bubkoo.qiniudn.com/gmail-dom.png" alt="现代 web 应用：使用 div 堆砌而成"></p><p>堆砌 <code>&lt;div&gt;</code> 的方式一点都不现代。然而可悲的是，这就是我们构建 web 应用的方式。在现有基础上我们不应该有更高的追求吗？</p><a id="more"></a><h3><span id="时髦的标记行动起来">时髦的标记，行动起来！</span></h3><p>HTML 为我们提供了一个完美的文档组织工具，然而 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/" target="_blank" rel="external">HTML 规范</a>定义的元素却很有限。</p><p>假如 GMail 的标记不那么糟糕，而是像下面这样漂亮，那会怎样？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">hangout-module</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">hangout-chat</span> <span class="attr">from</span>=<span class="string">"Paul, Addy"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">hangout-discussion</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">hangout-message</span> <span class="attr">from</span>=<span class="string">"Paul"</span> <span class="attr">profile</span>=<span class="string">"profile.png"</span></span></div><div class="line"><span class="tag">          <span class="attr">profile</span>=<span class="string">"118075919496626375791"</span> <span class="attr">datetime</span>=<span class="string">"2013-07-17T12:02"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Feelin' this Web Components thing.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Heard of it?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">hangout-message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">hangout-discussion</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">hangout-chat</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">hangout-chat</span>&gt;</span>...<span class="tag">&lt;/<span class="name">hangout-chat</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">hangout-module</span>&gt;</span></div></pre></td></tr></table></figure><p>真是令人耳目一新！这个应用太合理了，既<strong>有意义</strong>，又<strong>容易理解</strong>。最妙的是，它是<strong>可维护</strong>的，只要查看声明结构就可以清楚地知道它的作用。</p><blockquote><p>自定义元素，救救我们！就指望你了！</p></blockquote><h2><span id="赶紧开始吧">赶紧开始吧</span></h2><p><a href="http://w3c.github.io/webcomponents/spec/custom/" target="_blank" rel="external">自定义元素</a><strong>允许开发者定义新的 HTML 元素类型</strong>。该规范只是 <a href="http://w3c.github.io/webcomponents/explainer/" target="_blank" rel="external">Web 组件</a>模块提供的众多新 API 中的一个，但它也很可能是最重要的一个。没有自定义元素带来的以下特性，Web 组件都不会存在：</p><ol><li>定义新的 HTML/DOM 元素</li><li>基于其他元素创建扩展元素</li><li>给一个标签绑定一组自定义功能</li><li>扩展已有 DOM 元素的 API</li></ol><h3><span id="注册新元素">注册新元素</span></h3><p>使用 <code>document.registerElement()</code> 可以创建一个自定义元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo'</span>);</div><div class="line"><span class="built_in">document</span>.body.appendChild(<span class="keyword">new</span> XFoo());</div></pre></td></tr></table></figure><p>方法 <code>document.registerElement()</code> 的第一个参数是元素的标签名。规范中规定这个标签名<strong>必须包括一个连字符（-）</strong>。因此，诸如<code>&lt;x-tags&gt;</code>、<code>&lt;my-element&gt;</code> 和 <code>&lt;my-awesome-app&gt;</code>都是合法的标签名，而 <code>&lt;tabs&gt;</code> 和 <code>&lt;foo_bar&gt;</code> 则不是。这个限定使解析器能很容易地区分自定义元素和 HTML 规范定义的元素，同时确保了 HTML 增加新标签时的向前兼容。</p><p>第二个参数是一个（可选的）对象，用于描述该元素的<code>prototype</code>。在这里可以为元素添加自定义功能（例如：公开属性和方法）。稍后详述。</p><p>自定义元素默认继承自<code>HTMLElement</code>，因此上一个示例等同于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo'</span>, &#123;</div><div class="line">    prototype: <span class="built_in">Object</span>.create(HTMLElement.prototype)</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>调用 <code>document.registerElement(&#39;x-foo&#39;)</code> 向浏览器注册了这个新元素，并返回一个可以用来创建 <code>&lt;x-foo&gt;</code> 元素实例的构造函数。如果你不想使用构造函数，也可以使用其他实例化元素的技术。</p><p class="j-warning">提示：如果你不希望将构造函数放在 <code>window</code> 全局对象上，还可以把它放进命名空间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myapp = &#123;&#125;; </div><div class="line">myapp.XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo'</span>);</div></pre></td></tr></table></figure><h3><span id="扩展原生元素">扩展原生元素</span></h3><p>假设平淡无奇的原生 <code>&lt;button&gt;</code> 元素不能满足你的需求，你想将其增强为一个“超级按钮”，可以通过创建一个继承 <code>HTMLButtonElement.prototype</code> 的新元素，来扩展 <code>&lt;button&gt;</code> 元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MegaButton = <span class="built_in">document</span>.registerElement(<span class="string">'mega-button'</span>, &#123;</div><div class="line">    prototype: <span class="built_in">Object</span>.create(HTMLButtonElement.prototype)</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p class="j-dot">要创建扩展自<strong>元素 B</strong> 的<strong>元素 A</strong>，<strong>元素 A</strong> 必须继承<strong>元素 B</strong> 的 <code>prototype</code>。</p><p>这类自定义元素被称为扩展型自定义元素。它们以继承某个特定 <code>HTMLElement</code> 的方式表达了“元素 X 是一个 Y”：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"mega-button"</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="元素如何提升">元素如何提升</span></h3><p>为什么 HTML 解析器对非标准的标签没报错？比如，我们在页面中声明一个 <code>&lt;randomtag&gt;</code>，一切都很和谐。根据 HTML 规范的表述：</p><blockquote><p>非规范定义的元素必须使用 <code>HTMLUnknownElement</code> 接口。</p></blockquote><p><code>&lt;randomtag&gt;</code> 是非标准的，它会继承 <code>HTMLUnknownElement</code>。</p><p>对自定义元素来说，情况就不一样了。拥有合法元素名的自定义元素将继承<code>HTMLElement</code>。你可以按 Ctrl+Shift+J 打开控制台，运行下面这段代码，得到的结果将是 <code>true</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// “tabs”不是一个合法的自定义元素名</span></div><div class="line"><span class="built_in">document</span>.createElement(<span class="string">'tabs'</span>).__proto__ === HTMLUnknownElement.prototype</div><div class="line"></div><div class="line"><span class="comment">// “x-tabs”是一个合法的自定义元素名</span></div><div class="line"><span class="built_in">document</span>.createElement(<span class="string">'x-tabs'</span>).__proto__ == HTMLElement.prototype</div></pre></td></tr></table></figure><p class="j-dot">在不支持 <code>document.registerElement()</code> 的浏览器中，<code>&lt;x-tabs&gt;</code> 仍为 <code>HTMLUnknownElement</code>。</p><h3><span id="unresolved-元素">Unresolved 元素</span></h3><p>由于自定义元素是通过脚本执行 <code>document.registerElement()</code> 注册的，因此 它们可能在元素定义被注册到浏览器之前就已经声明或创建过了。例如：你可以先在页面中声明 <code>&lt;x-tabs&gt;</code>，以后再调用 <code>document.registerElement(&#39;x-tabs&#39;)</code>。</p><p>在被提升到其定义之前，这些元素被称为 unresolved 元素。它们是拥有合法自定义元素名的 HTML 元素，只是还没有注册成为自定义元素。</p><p>下面这个表格看起来更直观一些：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">继承自</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">unresolved 元素</td><td style="text-align:left"><code>HTMLElement</code></td><td style="text-align:left"><code>&lt;x-tabs&gt;</code>、<code>&lt;my-element&gt;</code>、<code>&lt;my-awesome-app&gt;</code></td></tr><tr><td style="text-align:left">未知元素</td><td style="text-align:left"><code>HTMLUnknownElement</code></td><td style="text-align:left"><code>&lt;tabs&gt;</code>、<code>&lt;foo_bar&gt;</code></td></tr></tbody></table><blockquote><p>把 unresolved 元素想象成尚处于中间状态，它们都是等待被浏览器提升的潜在候选者。浏览器说：“你具备一个新元素的全部特征，我保证会在赋予你定义的时候将你提升为一个元素”。</p></blockquote><h2><span id="实例化元素">实例化元素</span></h2><p>我们创建普通元素用到的一些技术也可以用于自定义元素。和所有标准定义的元素一样，自定义元素既可以在 HTML 中声明，也可以通过 JavaScript 在 DOM 中创建。</p><h3><span id="实例化自定义标签">实例化自定义标签</span></h3><p>声明元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">x-foo</span>&gt;</span><span class="tag">&lt;/<span class="name">x-foo</span>&gt;</span></div></pre></td></tr></table></figure><p>在 JS 中创建 DOM：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xFoo = <span class="built_in">document</span>.createElement(<span class="string">'x-foo'</span>);</div><div class="line">xFoo.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    alert(<span class="string">'Thanks!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>使用 <code>new</code> 操作符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xFoo = <span class="keyword">new</span> XFoo();</div><div class="line"><span class="built_in">document</span>.body.appendChild(xFoo);</div></pre></td></tr></table></figure><h3><span id="实例化类型扩展元素">实例化类型扩展元素</span></h3><p>实例化类型扩展自定义元素的方法和自定义标签惊人地相似。</p><p>声明元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- &lt;button&gt; “是一个”超级按钮 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"mega-button"</span>&gt;</span></div></pre></td></tr></table></figure><p>在 JS 中创建 DOM：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> megaButton = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>, <span class="string">'mega-button'</span>);</div><div class="line"><span class="comment">// megaButton instanceof MegaButton === true</span></div></pre></td></tr></table></figure><p>这是接收第二个参数为 <code>is=&quot;&quot;</code> 属性的 <code>document.createElement()</code> 重载版本。</p><p>使用 new 操作符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> megaButton = <span class="keyword">new</span> MegaButton();</div><div class="line"><span class="built_in">document</span>.body.appendChild(megaButton);</div></pre></td></tr></table></figure><p>现在，我们已经学习了如何使用 <code>document.registerElement()</code> 来向浏览器注册一个新标签。但这还不够，接下来我们要向新标签添加属性和方法。</p><h2><span id="添加-js-属性和方法">添加 JS 属性和方法</span></h2><p>自定义元素最强大的地方在于，你可以在元素定义中加入属性和方法，给元素绑定特定的功能。你可以把它想象成一种给你的元素创建公开 API 的方法。</p><p>这里有一个完整的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XFooProto = <span class="built_in">Object</span>.create(HTMLElement.prototype);</div><div class="line"></div><div class="line"><span class="comment">// 1. 为 x-foo 创建 foo() 方法</span></div><div class="line">XFooProto.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'foo() called'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 2. 定义一个只读的“bar”属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(XFooProto, <span class="string">"bar"</span>, &#123;<span class="attr">value</span>: <span class="number">5</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 3. 注册 x-foo 的定义</span></div><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo'</span>, &#123;<span class="attr">prototype</span>: XFooProto&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 4. 创建一个 x-foo 实例</span></div><div class="line"><span class="keyword">var</span> xfoo = <span class="built_in">document</span>.createElement(<span class="string">'x-foo'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 5. 插入页面</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(xfoo);</div></pre></td></tr></table></figure><p>构造 <code>prototype</code> 的方法多种多样，如果你不喜欢上面这种方式，再看一个更简洁的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo'</span>, &#123;</div><div class="line">  prototype: <span class="built_in">Object</span>.create(HTMLElement.prototype, &#123;</div><div class="line">    bar: &#123;</div><div class="line">      get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</div><div class="line">    &#125;,</div><div class="line">    foo: &#123;</div><div class="line">      value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">'foo() called'</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>以上两种方式，第一种使用了 ES5 的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external"><code>Object.defineProperty</code></a>，第二种则使用了 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/get" target="_blank" rel="external"><code>get/set</code></a>。</p><h3><span id="生命周期回调方法">生命周期回调方法</span></h3><p>元素可以定义一些特殊方法，在其生存期内的关键时间点注入它们。这些方法各自有特定的名称和用途，它们被恰如其分地命名为生命周期回调：</p><table><thead><tr><th style="text-align:left">回调名称</th><th style="text-align:left">调用时间点</th></tr></thead><tbody><tr><td style="text-align:left"><code>createdCallback</code></td><td style="text-align:left">创建元素实例</td></tr><tr><td style="text-align:left"><code>attachedCallback</code></td><td style="text-align:left">向文档插入实例</td></tr><tr><td style="text-align:left"><code>detachedCallback</code></td><td style="text-align:left">从文档中移除实例</td></tr><tr><td style="text-align:left"><code>attributeChangedCallback(attrName, oldVal, newVal)</code></td><td style="text-align:left">添加，移除，或修改一个属性</td></tr></tbody></table><p>示例：为 <code>&lt;x-foo&gt;</code> 定义 <code>createdCallback()</code> 和 <code>attachedCallback()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.create(HTMLElement.prototype);</div><div class="line"></div><div class="line">proto.createdCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;;</div><div class="line">proto.attachedCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo'</span>, &#123;<span class="attr">prototype</span>: proto&#125;);</div></pre></td></tr></table></figure><p>所有生命周期回调都是可选的，你可以只在需要关注的时间点定义它们。例如：假设你有一个很复杂的元素，它会在 <code>createdCallback()</code> 打开一个 IndexedDB 连接。在将其从 DOM 移除时，<code>detachedCallback()</code> 会做一些必要的清理工作。注意：不要过于依赖这些生命周期方法（比如用户直接关闭浏览器标签），仅将其作为可能的优化点。</p><p>另一个生命周期回调的例子是为元素设置默认的事件监听器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">proto.createdCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    alert(<span class="string">'Thanks!'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p>如果你的元素太笨重，是不会有人用它的。生命周期回调可以帮你大忙！</p></blockquote><h2><span id="添加标记">添加标记</span></h2><p>我们已经创建好了 <code>&lt;x-foo&gt;</code> 并添加了 API，但它还没有任何内容。不如我们给点 HTML 让它渲染？</p><p>生命周期回调在这个时候就派上用场了。我们甚至可以用 <code>createdCallback()</code> 给一个元素赋予一些默认的 HTML：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XFooProto = <span class="built_in">Object</span>.create(HTMLElement.prototype);</div><div class="line"></div><div class="line">XFooProto.createdCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.innerHTML = <span class="string">"&lt;b&gt;I'm an x-foo-with-markup!&lt;/b&gt;"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo-with-markup'</span>, &#123;<span class="attr">prototype</span>: XFooProto&#125;);</div></pre></td></tr></table></figure><p>实例化这个标签并在 DevTools 中观察（右击，选择“审查元素”），可以看到如下结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">▾<span class="tag">&lt;<span class="name">x-foo-with-markup</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>I'm an x-foo-with-markup!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">x-foo-with-markup</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="用-shadow-dom-封装内部实现">用 Shadow DOM 封装内部实现</span></h3><p><a href="http://www.html5rocks.com/tutorials/webcomponents/shadowdom/" target="_blank" rel="external">Shadow DOM</a> 本身是一个封装内容的强大工具，配合使用自定义元素就更神奇了！</p><p>Shadow DOM 为自定义元素提供了：</p><ol><li>一种隐藏内部实现的方法，从而将用户与血淋淋的实现细节隔离开。</li><li>简单有效的<a href="http://www.html5rocks.com/tutorials/webcomponents/shadowdom-201/" target="_blank" rel="external">样式隔离</a>。</li></ol><p>从 Shadow DOM 创建元素，跟创建一个渲染基础标记的元素非常类似，区别在于 <code>createdCallback()</code> 回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XFooProto = <span class="built_in">Object</span>.create(HTMLElement.prototype);</div><div class="line"></div><div class="line">XFooProto.createdCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 1. 为元素附加一个 shadow root。</span></div><div class="line">  <span class="keyword">var</span> shadow = <span class="keyword">this</span>.createShadowRoot();</div><div class="line"></div><div class="line">  <span class="comment">// 2. 填入标记。</span></div><div class="line">  shadow.innerHTML = <span class="string">"&lt;b&gt;I'm in the element's Shadow DOM!&lt;/b&gt;"</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> XFoo = <span class="built_in">document</span>.registerElement(<span class="string">'x-foo-shadowdom'</span>, &#123;<span class="attr">prototype</span>: XFooProto&#125;);</div></pre></td></tr></table></figure><p>我们并没有直接设置 <code>&lt;x-foo-shadowdom&gt;</code> 的 <code>innerHTML</code>，而是为其创建了一个用于填充标记的 Shadow Root。在 DevTools 中，你就会看到一个可以展开的 <code>#shadow-root</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">▾<span class="tag">&lt;<span class="name">x-foo-shadowdom</span>&gt;</span></div><div class="line">   ▾#shadow-root</div><div class="line">     <span class="tag">&lt;<span class="name">b</span>&gt;</span>I'm in the element's Shadow DOM!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">x-foo-shadowdom</span>&gt;</span></div></pre></td></tr></table></figure><p>这就是 Shadow Root！</p><h3><span id="从模板创建元素">从模板创建元素</span></h3><p><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#the-template-element" target="_blank" rel="external">HTML 模板</a>是另一组跟自定义元素完美融合的新 API。</p><p><a href="http://www.html5rocks.com/tutorials/webcomponents/template/" target="_blank" rel="external"><code>&lt;template&gt;</code> 元素</a>可用于声明 DOM 片段。它们可以被解析并在页面加载后插入，以及延迟到运行时才进行实例化。模板是声明自定义元素结构的理想方案。</p><p>示例：注册一个由 <code>&lt;template&gt;</code> 和 Shadow DOM 创建的元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"sdtemplate"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">    <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: orange; &#125;</span></div><div class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>I'm in Shadow DOM. My markup was stamped from a &amp;lt;template&amp;gt;.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.create(HTMLElement.prototype, &#123;</span></div><div class="line"><span class="undefined">  createdCallback: &#123;</span></div><div class="line"><span class="javascript">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">      <span class="keyword">var</span> t = <span class="built_in">document</span>.querySelector(<span class="string">'#sdtemplate'</span>);</span></div><div class="line"><span class="javascript">      <span class="keyword">var</span> clone = <span class="built_in">document</span>.importNode(t.content, <span class="literal">true</span>);</span></div><div class="line"><span class="javascript">      <span class="keyword">this</span>.createShadowRoot().appendChild(clone);</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined">&#125;);</span></div><div class="line"><span class="javascript"><span class="built_in">document</span>.registerElement(<span class="string">'x-foo-from-template'</span>, &#123;<span class="attr">prototype</span>: proto&#125;);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>短短几行做了很多事情，我们挨个来看都发生了些什么：</p><ol><li>在 HTML 中注册了一个新元素：<code>&lt;x-foo-from-template&gt;</code></li><li>这个元素的 DOM 是从一个 <code>&lt;template&gt;</code> 创建的</li><li>Shadow DOM 隐藏了该元素可怕的细节</li><li>Shadow DOM 也对元素的样式进行了隔离（比如 p {color: orange;} 不会把整个页面都搞成橙色）</li></ol><p>真不错！</p><h2><span id="为自定义元素增加样式">为自定义元素增加样式</span></h2><p>和其他 HTML 标签一样，自定义元素也可以用选择器定义样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">  app-panel &#123;</span></div><div class="line"><span class="undefined">    display: flex;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="css">  <span class="selector-attr">[is="x-item"]</span> &#123;</span></div><div class="line"><span class="undefined">    transition: opacity 400ms ease-in-out;</span></div><div class="line"><span class="css">    <span class="selector-tag">opacity</span>: 0<span class="selector-class">.3</span>;</span></div><div class="line"><span class="undefined">    flex: 1;</span></div><div class="line"><span class="undefined">    text-align: center;</span></div><div class="line"><span class="undefined">    border-radius: 50%;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="css">  <span class="selector-attr">[is="x-item"]</span><span class="selector-pseudo">:hover</span> &#123;</span></div><div class="line"><span class="css">    <span class="selector-tag">opacity</span>: 1<span class="selector-class">.0</span>;</span></div><div class="line"><span class="undefined">    background: rgb(255, 0, 255);</span></div><div class="line"><span class="undefined">    color: white;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="css">  <span class="selector-tag">app-panel</span> &gt; <span class="selector-attr">[is="x-item"]</span> &#123;</span></div><div class="line"><span class="undefined">    padding: 5px;</span></div><div class="line"><span class="undefined">    list-style: none;</span></div><div class="line"><span class="undefined">    margin: 0 7px;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">app-panel</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">is</span>=<span class="string">"x-item"</span>&gt;</span>Do<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">is</span>=<span class="string">"x-item"</span>&gt;</span>Re<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">is</span>=<span class="string">"x-item"</span>&gt;</span>Mi<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">app-panel</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="为使用-shadow-dom-的元素增加样式">为使用 Shadow DOM 的元素增加样式</span></h3><p>有了 Shadow DOM 场面就热闹得多了，它可以极大增强自定义元素的能力。</p><p>Shadow DOM 为元素增加了样式封装的特性。Shadow Root 中定义的样式不会暴露到宿主外部或对页面产生影响。<strong>对自定义元素来说，元素本身就是宿主</strong>。样式封装的属性也使得自定义元素能够为自己定义默认样式。</p><p>Shadow DOM 的样式是一个很大的话题！如果你想更多地了解它，推荐你阅读我写的其他文章：</p><ul><li>Polymer 文档：<a href="http://www.polymer-project.org/articles/styling-elements.html" target="_blank" rel="external">元素样式指南</a></li><li>发表于 <a href="http://www.html5rocks.com/" target="_blank" rel="external">html5rocks</a> 的 <a href="http://www.html5rocks.com/tutorials/webcomponents/shadowdom-201/" target="_blank" rel="external">Shadow DOM 201：CSS 和样式</a></li></ul><h3><span id="使用-unresolved-伪类避免无样式内容闪烁fouc">使用 :unresolved 伪类避免无样式内容闪烁（FOUC）</span></h3><p>为了缓解无样式内容闪烁的影响，自定义元素规范提出了一个新的 CSS 伪类 <code>:unresolved</code>。在浏览器调用你的 <code>createdCallback()</code>（见生命周期回调方法一节）之前，这个伪类都可以匹配到 unresolved 元素。一旦产生调用，就意味着元素已经完成提升，成为它被定义的形态，该元素就不再是一个 unresolved 元素了。</p><p class="j-dot">Chrome 29 已经原生支持 CSS :unresolved 伪类。</p><p>示例：注册后渐显的 <code>&lt;x-foo&gt;</code> 标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">  x-foo &#123;</span></div><div class="line"><span class="undefined">    opacity: 1;</span></div><div class="line"><span class="undefined">    transition: opacity 300ms;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="css">  <span class="selector-tag">x-foo</span><span class="selector-pseudo">:unresolved</span> &#123;</span></div><div class="line"><span class="undefined">    opacity: 0;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>请记住 <code>:unresolved</code> 伪类只能用于 unresolved 元素，而不能用于继承自 <code>HTMLUnkownElement</code> 的元素（见元素如何提升一节）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">  <span class="comment">/* 给所有 unresolved 元素添加边框 */</span></span></div><div class="line"><span class="css">  <span class="selector-pseudo">:unresolved</span> &#123;</span></div><div class="line"><span class="undefined">    border: 1px dashed red;</span></div><div class="line"><span class="undefined">    display: inline-block;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="css">  <span class="comment">/* unresolved 元素 x-panel 的文本内容为红色 */</span></span></div><div class="line"><span class="css">  <span class="selector-tag">x-panel</span><span class="selector-pseudo">:unresolved</span> &#123;</span></div><div class="line"><span class="undefined">    color: red;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="css">  <span class="comment">/* 定义注册后的 x-panel 文本内容为绿色 */</span></span></div><div class="line"><span class="undefined">  x-panel &#123;</span></div><div class="line"><span class="undefined">    color: green;</span></div><div class="line"><span class="undefined">    display: block;</span></div><div class="line"><span class="undefined">    padding: 5px;</span></div><div class="line"><span class="undefined">    display: block;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">panel</span>&gt;</span></div><div class="line">  I'm black because :unresolved doesn't apply to "panel".</div><div class="line">  It's not a valid custom element name.</div><div class="line"><span class="tag">&lt;/<span class="name">panel</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">x-panel</span>&gt;</span>I'm red because I match x-panel:unresolved.<span class="tag">&lt;/<span class="name">x-panel</span>&gt;</span></div></pre></td></tr></table></figure><p>了解更多 <code>:unresolved</code> 伪类的知识，请看 Polymer 文档<a href="http://www.polymer-project.org/articles/styling-elements.html#preventing-fouc" target="_blank" rel="external">元素样式指南</a>。</p><h2><span id="历史和浏览器支持">历史和浏览器支持</span></h2><h3><span id="特性检测">特性检测</span></h3><p>特性检测就是检查 <code>document.registerElement()</code> 是否存在：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">supportsCustomElements</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'registerElement'</span> <span class="keyword">in</span> <span class="built_in">document</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (supportsCustomElements()) &#123;</div><div class="line">  <span class="comment">// Good to go!</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// Use other libraries to create components.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="浏览器支持">浏览器支持</span></h3><p>Chrome 27 和 Firefox 23 都提供了对 <code>document.registerElement()</code> 的支持，不过之后规范又有一些演化。Chrome 31 将是第一个真正支持新规范的版本。</p><p class="j-dot">在 Chrome 31 中使用自定义元素，需要开启 about:flags 中的“实验性 web 平台特性（Experimental Web Platform features）”选项。</p><p>在浏览器支持稳定之前，也有一些很好的兼容方案：</p><ul><li>Google 的 <a href="http://polymer-project.org/" target="_blank" rel="external">Polymer</a> 集成了一个<a href="http://www.polymer-project.org/platform/custom-elements.html" target="_blank" rel="external">兼容方案</a></li><li>Mozilla 的 <a href="http://www.x-tags.org/" target="_blank" rel="external">x-tags</a></li></ul><h3><span id="htmlelementelement-怎么了">HTMLElementElement 怎么了？</span></h3><p>一直关注标准的人都知道曾经有一个 <code>&lt;element&gt;</code> 标签。它非常好用，你只要像下面这样就可以声明式地注册一个新元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">"my-element"</span>&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">element</span>&gt;</span></div></pre></td></tr></table></figure><p>然而，很不幸，在它的提升过程、边界案例，以及末日般的复杂场景中，需要处理大量的时序问题。<element> 因此被迫搁置。2013 年 8 月，Dimitri Glazkov 在 <a href="http://lists.w3.org/Archives/Public/public-webapps/2013JulSep/0287.html" target="_blank" rel="external">public-webapps</a> 邮件组中宣告移除 <code>&lt;element&gt;</code>。</element></p><p>值得注意的是，Polymer 实现了以 <code>&lt;polymer-element&gt;</code> 的形式声明式地注册元素。这是怎么做到的？它用的正是 <code>document.registerElement(&#39;polymer-element&#39;)</code> 以及我在从模板创建元素一节介绍的技术。</p><h2><span id="结语">结语</span></h2><p>自定义元素为我们提供了一个工具，通过它我们可以扩展 HTML 的词汇，赋予它新的特性，并把不同的 web 平台连接在一起。结合其他新的基本平台，如 Shadow DOM 和 <code>&lt;template&gt;</code>，我们领略了 web 组件的宏伟蓝图。标记语言将再次变得很时髦！</p><p>如果你对使用 web 组件感兴趣，建议你看看 <a href="http://polymer-project.org/" target="_blank" rel="external">Polymer</a>，就它已经够你玩的了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;现在的 web 严重缺乏表现力。你只要瞧一眼“现代”的 web 应用，比如 GMail，就会明白了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/gmail-dom.png&quot; alt=&quot;现代 web 应用：使用 div 堆砌而成&quot;&gt;&lt;/p&gt;
&lt;p&gt;堆砌 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 的方式一点都不现代。然而可悲的是，这就是我们构建 web 应用的方式。在现有基础上我们不应该有更高的追求吗？&lt;/p&gt;
    
    </summary>
    
      <category term="HTML/CSS" scheme="http://bubkoo.com/categories/html-css/"/>
    
    
      <category term="Custom Elements" scheme="http://bubkoo.com/tags/custom-elements/"/>
    
  </entry>
  
  <entry>
    <title>说说 tabindex 的那些事儿</title>
    <link href="http://bubkoo.com/2015/02/01/using-the-tabindex-attribute/"/>
    <id>http://bubkoo.com/2015/02/01/using-the-tabindex-attribute/</id>
    <published>2015-02-01T17:04:07.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.w3.org/html/wg/drafts/html/master/editing.html#attr-tabindex" target="_blank" rel="external">tabindex</a> 属性用于管理键盘焦点，决定元素是否能被选中，以及按下 <code>tab</code> 键过程中被选中的顺序，使用得当能够极大的提高应用的易用性，然而，不恰当地使用时可以键盘用户对应用的可用性。到底如何使用？设置为 <code>0</code> 会有什么效果？设置为 <code>-1</code> 会有什么效果？本文将为你揭晓。</p><a id="more"></a><p>要理解为什么 <code>tabindex</code> 属性对可用性有如此大的影响，有必要知道一些键盘交互的方式。键盘用户通常会使用 <code>tab</code> 键将光标从一个可获取焦点的元素有序地移动到下一个元素。</p><p>像链接和 <code>form</code> 表单元素默认都是<a href="http://www.w3.org/html/wg/drafts/html/master/dom.html#interactive-content-0" target="_blank" rel="external">可获取焦点</a>的，他们的默认焦点顺序取决于他们在源代码中出现的顺序。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>Username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"password"</span>&gt;</span>Password:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Log in"</span>&gt;</span></div></pre></td></tr></table></figure><p>按下 <code>tab</code> 键时将依次选中用户名输入框、密码输入框和登录按钮，这三个元素默认就是可获取焦点的，并且焦点顺序与其在源码中的顺序一致。也就是说，对此并不需要显示设置 <code>tabindex</code> 属性，浏览器将有效地处理它们。</p><h2><span id="tabindex0">tabindex=0</span></h2><p>当 <code>tabindex</code> 设置为 <code>0</code> 时，元素的 tab 键序与其在源码中的顺序一致。默认情况下，如果元素本身是可获取焦点的就没有必要设置 <code>tabindex</code> 属性。但，如果你想让一个不能获取焦点的元素，比如 <code>&lt;span&gt;</code> 或 <code>&lt;div&gt;</code>，也被包含在 <code>tab</code> 键序列表中，那么设置 <code>tabindex = 0</code> 就可以使这些元素按其在源码中的顺序出现在 tab 键序中。</p><p>值得一提的是，那些可获取焦点的元素使用起来比较方便，例如，当你使用 <code>&lt;button&gt;</code> 或 <code>&lt;input type=&quot;checkbox&quot;&gt;</code>，键盘焦点和交互由浏览器自动处理。当你使用其他元素来构建自定义组件时，你需要人为地提供键盘焦点和交互支持。 </p><h2><span id="tabindex-1">tabindex=-1</span></h2><p>当 <code>tabindex</code> 被设置为像 <code>-1</code> 一样的负数时，该元素就变成可由代码获取焦点，但其本身并不在 tab 键序列表中。也就是说，在按下 <code>tab</code> 键时，该元素不能获取到焦点，但是可以通过代码来获取到焦点。</p><p>请看下面例子，表单返回错误汇总信息时，将通过代码使其获取到焦点，并将其放置在表单的顶部，这样屏幕阅读器或屏幕放大器用户就能得到提示，以便他们能够纠正错误，同时对于键盘用户，这个元素并不会出现在 tab 键序中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">role</span>=<span class="string">"group"</span> <span class="attr">id</span>=<span class="string">"errorSummary"</span> <span class="attr">aria-labelledby</span>=<span class="string">"errorSummaryHeading"</span> <span class="attr">tabindex</span>=<span class="string">"-1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"errorSummaryHeading"</span>&gt;</span>Your information contains three errors<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h2><span id="tabindex1">tabindex=1+</span></h2><p>当 <code>tabindex</code> 设置为一个正数时，情况就复杂了。它可以使一个元素不按页面顺序来获取焦点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>Username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">tabindex</span>=<span class="string">"3"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"password"</span>&gt;</span>Password:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">tabindex</span>=<span class="string">"1"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Log in"</span> <span class="attr">tabindex</span>=<span class="string">"2"</span>&gt;</span></div></pre></td></tr></table></figure><p>在上面例子中，视觉预期的 tab 顺序是：用户名输入框，密码输入框，最后是登陆按钮。然而，这里设置的 <code>tabindex</code> 属性，将使其变得不可预期，焦点移动顺序分别是：密码输入框，登陆按钮，最后才是用户名输入框。</p><p>当你意识到密码输入框是表单中第一个能获取到焦点的元素时，事情也许已经变糟。不管在密码输入框之前有多少个可获取焦点的元素，<code>tabindex=1</code> 就意味着它将是页面上第一个可获得焦点的元素，而与视觉样式和源码顺序无关。</p><h2><span id="总结">总结</span></h2><p><code>tabindex</code> 属性很常用，它可以改善或破坏键盘用户对页面的可用性。使用该属性时，请谨记：</p><ul><li><code>tabindex=0</code> 可以使一个元素按自然顺序出现在 tab 键序中，同时，尽量使用默认可获取焦点的元素。</li><li><code>tabindex=-1</code> 可以使一个元素可由代码获取到焦点，但其本身并不在 tab 键序中。</li><li>避免设置 <code>tabindex=1+</code>。</li></ul><h2><span id="参考阅读">参考阅读</span></h2><ul><li><a href="http://www.w3.org/html/wg/drafts/html/master/dom.html#interactive-content" target="_blank" rel="external">可交互元素的定义</a></li><li><a href="http://www.w3.org/html/wg/drafts/html/master/editing.html#attr-tabindex" target="_blank" rel="external">tabindex 的定义</a></li><li>ARIA – <a href="http://www.w3.org/WAI/PF/aria-practices/#kbd_focus" target="_blank" rel="external">providing keyboard focus</a></li></ul><p class="j-quote">原文：<a href="http://www.paciellogroup.com/blog/2014/08/using-the-tabindex-attribute" target="_blank" rel="external">Using the tabindex attribute</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.w3.org/html/wg/drafts/html/master/editing.html#attr-tabindex&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tabindex&lt;/a&gt; 属性用于管理键盘焦点，决定元素是否能被选中，以及按下 &lt;code&gt;tab&lt;/code&gt; 键过程中被选中的顺序，使用得当能够极大的提高应用的易用性，然而，不恰当地使用时可以键盘用户对应用的可用性。到底如何使用？设置为 &lt;code&gt;0&lt;/code&gt; 会有什么效果？设置为 &lt;code&gt;-1&lt;/code&gt; 会有什么效果？本文将为你揭晓。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML/CSS" scheme="http://bubkoo.com/categories/html-css/"/>
    
    
      <category term="tabindex" scheme="http://bubkoo.com/tags/tabindex/"/>
    
  </entry>
  
  <entry>
    <title>理解和解决 IE 内存泄露问题</title>
    <link href="http://bubkoo.com/2015/01/31/understanding-and-solving-internet-explorer-leak-patterns/"/>
    <id>http://bubkoo.com/2015/01/31/understanding-and-solving-internet-explorer-leak-patterns/</id>
    <published>2015-01-31T00:04:06.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在过去，内存泄漏并没有为 Web 开发人员带来巨大的问题。页面保持着相对简单，并且在页面之间的跳转时可以释放内存资源，即便还存在内存泄露，那也是小到可以被忽略。</p><p>现在，新的 Web 应用达到更高的水准，页面可能运行数小时而不跳转，通过 Web 服务动态检索和更新页面。JavaScript 语言特性也被发挥到极致，通过复杂的事件绑定、面向对象和闭包等特性构成了整个 Web 应用。面对这些变化，内存泄露问题变得越来越突出，尤其是之前那些通过刷新（导航）隐藏的内存泄露问题。</p><p>庆幸的是，如果你知道如何排查问题，内存泄露可以很轻易地被清除。即便是面对一些最麻烦的问题，如果你知道解决方案，也只需要少量的工作。虽然页面仍可能存在一些小的内存泄露，但是那些最明显的可以轻易地被清除。</p><p><img src="http://bubkoo.qiniudn.com/memory-leak.jpg" alt="Memory Leaks"></p><a id="more"></a><h2><span id="内存泄露的形式">内存泄露的形式</span></h2><p>下面将讨论内存泄露的几种形式，并为每种形式列举了一些常见的例子。其中一个很好的例子是 JavaScript 的闭包特性，还有一个例子是在事件绑定中使用闭包，当你熟悉本示例后，你可以找到并修复许多内存泄露，同时也可能忽略一些其他和闭包相关的内存泄露问题。</p><p>我们先看看内存泄露的形式：</p><ul><li>循环引用（Circular References） - 当 IE 浏览器的 COM 组件与脚本引擎对象之间相互引用时，将导致内存泄露，这是最常见的形式。</li><li>闭包（Closures） - 闭包是循环引用的特殊形式，也是目前 Web 架构中使用最多的一种语言特性。闭包很容易被发现，因为它们依赖于特定的语言关键字，可以通过简单的搜索来查找。</li><li>页面交叉泄露（Cross-Page Leaks） - 页面交叉泄漏其实是一种较小的泄漏，它通常在你浏览过程中，由于内部对象 book-keeping 引起。我们将讨论 DOM 插入顺序问题，在示例中你将发现只需要微小的改动就可以避免 book-keeping 对象的产生。</li><li>伪泄露（Pseudo-Leaks） — 严格来说并不算真正的内存泄露，不过如果你不了解它，你将会在可用内存越来越少时非常懊恼。为了演示这个问题，我们将通过重写 <code>script</code> 元素中的内容来引发大量内存的“泄漏”。</li></ul><h2><span id="循环引用-circular-references">循环引用 Circular References</span></h2><p>循环引用基本上是所有内存泄漏的根源。通常，脚本引擎通过垃圾回收机制（GC）来处理循环引用，但某些未知的因素可能阻止资源的释放。对于 IE 来说，未知因素可能是，脚本引擎无法得知某些 DOM 的状态，从而无法释放 DOM 所占用的内存。请看下图：</p><p><img src="http://bubkoo.qiniudn.com/Basic-Circular-Reference-Pattern.gif" alt="图 1. 循环引用"></p><p>循环引用引起内存泄露的根源在于 COM 的引用计数。脚本引擎将维持对 DOM 对象的引用，直到所有的引用被移除（引用计数为 0）时才回收和清理 DOM 对象。在上面示例中，脚本引擎有两个引用：脚本引擎作用域和 DOM 对象的扩展（expando）属性，当终止脚本引擎时，第一个引用会被释放，DOM 对象引用由于在等待脚本引擎的释放而不会被释放。也许你会认为检测和修复这类问题非常简单，但这个示例只是问题的冰山一角。你可能会在 30 个对象链的末尾发生循环引用，这样的问题排查起来将是一场噩梦。</p><p>如果你想知道这种泄露的代码长什么样，请看下面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"JScript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> myGlobalObject;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">SetupLeak</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="comment">// First set up the script scope to element reference</span></span></div><div class="line"><span class="undefined">            myGlobalObject =</span></div><div class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="comment">// Next set up the element to script scope reference</span></span></div><div class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>).expandoProperty =</span></div><div class="line"><span class="undefined">                myGlobalObject;</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">BreakLeak</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>).expandoProperty =</span></div><div class="line"><span class="javascript">                <span class="literal">null</span>;</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"SetupLeak()"</span> <span class="attr">onunload</span>=<span class="string">"BreakLeak()"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"LeakedDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>在页面卸载前，将 DOM 对象的扩展属性赋值为 <code>null</code>，这样脚本引擎就知道对象之间的引用没有了，并能正常清理引用并释放 DOM 对象。值得一提的是，作为开发人员应该比脚本引擎更加清楚对象之间的引用关系。</p><p>这只是一种最基本的情况，循环引用可能还有更多更复杂的表现形式。在面向对象的 JS 中，一个通常用法是通过封装 JS 对象来扩充 DOM 对象，为了方便访问彼此，常常会把 DOM 对象的引用作为 JS 对象的属性，同时也会在 DOM 的扩展属性上保持着对 JS 对象的引用。这是一个非常直观的循环引用问题，但经常容易被忽略。要破坏这样的循环引用可能会更复杂，当然你也可以使用上面介绍的方式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"JScript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">Encapsulator</span>(<span class="params">element</span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="comment">// Set up our element</span></span></div><div class="line"><span class="javascript">            <span class="keyword">this</span>.elementReference = element;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="comment">// Make our circular reference</span></span></div><div class="line"><span class="javascript">            element.expandoProperty = <span class="keyword">this</span>;</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">SetupLeak</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="comment">// The leak happens all at once</span></span></div><div class="line"><span class="javascript">            <span class="keyword">new</span> Encapsulator(<span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>));</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">BreakLeak</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>).expandoProperty =</span></div><div class="line"><span class="javascript">                <span class="literal">null</span>;</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"SetupLeak()"</span> <span class="attr">onunload</span>=<span class="string">"BreakLeak()"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"LeakedDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>针对该问题还有更复杂的解决方案，在对象初始化时记录所有需要手动释放的元素和属性，然后在文档卸载前一并清理掉，但大多数时候你可能会再次造成其他内存泄漏，而问题并没有得到解决。</p><h2><span id="闭包-closures">闭包 Closures</span></h2><p>由于闭包经常会在不知不觉中创建出循环引用，所以它对内存泄露有不可推卸的责任。在闭包释放前，我们很难判断父函数的参数和局部变量能否被释放。事实上闭包已经成为一种很常见的变成策略，我们也经常会遇到闭包导致内存泄露这类问题，而可用的解决方案却很少。在详细了解闭包背后的问题和导致内存泄露的对象后，我们将结合循环引用的图示，找出那些泄露的对象。</p><p><img src="http://bubkoo.qiniudn.com/Circular-References-with-Closures.gif" alt="闭包引起的循环引用"></p><p>通常，循环引用是由两个对象直接相互引用造成的，而闭包是从父函数的作用域带入间接引用。一般情况下，函数的局部变量和参数只能在该函数的生命周期中使用，一旦形成闭包，而闭包可以独立于父函数的生命周期而存在，并且这些变量和参数将会和闭包一同存在。在下面示例中，参数 1 在函数调用结束后会被正常释放。引入闭包后，将形成一个额外的引用，并且该引用在闭包释放前都不会被释放。如果你恰好将闭包函数放入了 DOM 事件的回调函数中，那么在事件回调返回前你必须手动清理该闭包。如果你将闭包作为 DOM 对象的一个扩展（expando）属性，那么你也需要将其设置为 <code>null</code> 来清除。</p><p>每次触发事件时都会创建出一个闭包，也就是说，当你触发两次事件时，就会得到两个独立的闭包，并且每个闭包都分别拥有对局部变量的引用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"JScript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">AttachEvents</span>(<span class="params">element</span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="comment">// This structure causes element to ref ClickEventHandler</span></span></div><div class="line"><span class="javascript">            element.attachEvent(<span class="string">"onclick"</span>, ClickEventHandler);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">ClickEventHandler</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">            &#123;</span></div><div class="line"><span class="javascript">                <span class="comment">// This closure refs element</span></span></div><div class="line"><span class="undefined">            &#125;</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">SetupLeak</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="comment">// The leak happens all at once</span></span></div><div class="line"><span class="javascript">            AttachEvents(<span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>));</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">BreakLeak</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head\</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"SetupLeak()"</span> <span class="attr">onunload</span>=<span class="string">"BreakLeak()"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"LeakedDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>处理这类问题不像处理一般循环引用那么简单，闭包被创建后，将被当作函数作用域中的一个局部对象，一旦函数执行完成，你将失去对闭包的引用。那么如果通过 <code>detachEvent</code> 方法来清除引用呢？在 Scott Isaacs 的 <a href="http://spaces.msn.com/members/siteexperts/Blog/cns!1pNcL8JwTfkkjv4gg6LkVCpw!338.entry" target="_blank" rel="external">MSN Spaces</a> 上有一个有趣的办法，将闭包保存在 DOM 对象的扩展属性上，当 <code>window</code> 执行 <code>unload</code> 事件时，解除事件绑定并清理扩展属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"JScript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">AttachEvents</span>(<span class="params">element</span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="comment">// In order to remove this we need to put</span></span></div><div class="line"><span class="javascript">            <span class="comment">// it somewhere. Creates another ref</span></span></div><div class="line"><span class="undefined">            element.expandoClick = ClickEventHandler;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="comment">// This structure causes element to ref ClickEventHandler</span></span></div><div class="line"><span class="javascript">            element.attachEvent(<span class="string">"onclick"</span>, element.expandoClick);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">ClickEventHandler</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">            &#123;</span></div><div class="line"><span class="javascript">                <span class="comment">// This closure refs element</span></span></div><div class="line"><span class="undefined">            &#125;</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">SetupLeak</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="comment">// The leak happens all at once</span></span></div><div class="line"><span class="javascript">            AttachEvents(<span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>));</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">BreakLeak</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>).detachEvent(<span class="string">"onclick"</span>,</span></div><div class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>).expandoClick);</span></div><div class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"LeakedDiv"</span>).expandoClick = <span class="literal">null</span>;</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"SetupLeak()"</span> <span class="attr">onunload</span>=<span class="string">"BreakLeak()"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"LeakedDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>在<a href="http://support.microsoft.com/default.aspx?scid=KB;EN-US;830555" target="_blank" rel="external">这篇文章</a>中建议非必要时尽量不要使用闭包。文章中的示例演示了如何避免使用闭包，即把事件回调函数放到全局作用域中，当闭包函数成为普通函数后，它将不再继承其父函数的参数和局部变量，所以我们也就不用担心基于闭包的循环引用了。</p><h2><span id="页面交叉泄露-cross-page-leaks">页面交叉泄露 Cross-Page Leaks</span></h2><p>由 DOM 插入顺序导致的内存泄露，大多数是因为创建的中间对象没有被清理干净引起的。将动态创建 DOM 元素插入到页面就是这样的例子，通过创建一个从子元素到父元素的临时作用域对象，将两个动态创建的元素附加在一起，然后将这两个元素添加到文档树中，这两个元素都将继承文档树的作用域对象，这样就导致刚刚创建的临时作用域对象泄露。下图展示了两种将新创建的元素附加到页面的两种方式。第一种方式是，依次将元素先添加到其父元素中，最后将整个子树添加到文档树中，如果同时满足其他条件，这种方式将导致中间对象的泄漏；另一种方式是，从上至下依次将动态创建的元素附加到文档数中，这样每次附加的元素都直接继承了原始文档树德作用域对象，从而不会生成任何中间对象，这种方式避免了潜在的内存泄露。</p><p><img src="http://bubkoo.qiniudn.com/DOM-Insertion-Order-Leak-Model.gif" alt="图 3. DOM 插入顺序引发的内存泄漏"></p><p>接下来我们来看一个内存泄漏的例子，该泄漏对大多数内存泄漏探测算法是透明的。因为代码中并没有暴露任何公共的元素，并且泄漏的对象非常小，你可能永远不会注意到该问题。为了引发内存泄露，动态创建的元素必须包含一个内联函数的脚本，当将两个元素附加在一起再插入到页面时，就会导致临时创建的脚本对象泄漏。由于泄漏的内存很小，我们需要重复运行数千次才能看到效果。事实上，这些对象的内存泄漏仅有几 bytes。运行下面的例子，然后导航到一个空白页面，你可以看到两个版本内存消耗的区别。采用第一种方式时，内存消耗稍高。这就是页面交叉内存泄露，这些内存将直到重启 IE 进程才会被销毁。如果采用第二种方式，随便运行示例多少次，内存消耗将不会持续攀升，这样就修复了该内存泄露。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"JScript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">LeakMemory</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="keyword">var</span> hostElement = <span class="built_in">document</span>.getElementById(<span class="string">"hostElement"</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="comment">// Do it a lot, look at Task Manager for memory response</span></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span></div><div class="line"><span class="undefined">            &#123;</span></div><div class="line"><span class="javascript">                <span class="keyword">var</span> parentDiv =</span></div><div class="line"><span class="javascript">                    <span class="built_in">document</span>.createElement(<span class="string">"&lt;div onClick='foo()'&gt;"</span>);</span></div><div class="line"><span class="javascript">                <span class="keyword">var</span> childDiv =</span></div><div class="line"><span class="javascript">                    <span class="built_in">document</span>.createElement(<span class="string">"&lt;div onClick='foo()'&gt;"</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">                <span class="comment">// This will leak a temporary object</span></span></div><div class="line"><span class="undefined">                parentDiv.appendChild(childDiv);</span></div><div class="line"><span class="undefined">                hostElement.appendChild(parentDiv);</span></div><div class="line"><span class="undefined">                hostElement.removeChild(parentDiv);</span></div><div class="line"><span class="undefined">                parentDiv.removeChild(childDiv);</span></div><div class="line"><span class="javascript">                parentDiv = <span class="literal">null</span>;</span></div><div class="line"><span class="javascript">                childDiv = <span class="literal">null</span>;</span></div><div class="line"><span class="undefined">            &#125;</span></div><div class="line"><span class="javascript">            hostElement = <span class="literal">null</span>;</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">CleanMemory</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="keyword">var</span> hostElement = <span class="built_in">document</span>.getElementById(<span class="string">"hostElement"</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="comment">// Do it a lot, look at Task Manager for memory response</span></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span></div><div class="line"><span class="undefined">            &#123;</span></div><div class="line"><span class="javascript">                <span class="keyword">var</span> parentDiv =</span></div><div class="line"><span class="javascript">                    <span class="built_in">document</span>.createElement(<span class="string">"&lt;div onClick='foo()'&gt;"</span>);</span></div><div class="line"><span class="javascript">                <span class="keyword">var</span> childDiv =</span></div><div class="line"><span class="javascript">                    <span class="built_in">document</span>.createElement(<span class="string">"&lt;div onClick='foo()'&gt;"</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">                <span class="comment">// Changing the order is important, this won't leak</span></span></div><div class="line"><span class="undefined">                hostElement.appendChild(parentDiv);</span></div><div class="line"><span class="undefined">                parentDiv.appendChild(childDiv);</span></div><div class="line"><span class="undefined">                hostElement.removeChild(parentDiv);</span></div><div class="line"><span class="undefined">                parentDiv.removeChild(childDiv);</span></div><div class="line"><span class="javascript">                parentDiv = <span class="literal">null</span>;</span></div><div class="line"><span class="javascript">                childDiv = <span class="literal">null</span>;</span></div><div class="line"><span class="undefined">            &#125;</span></div><div class="line"><span class="javascript">            hostElement = <span class="literal">null</span>;</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"LeakMemory()"</span>&gt;</span>Memory Leaking Insert<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"CleanMemory()"</span>&gt;</span>Clean Insert<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"hostElement"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>需要澄清的是，这里的解决方案违背了一些最佳实践。引发该泄漏的关键在于，动态创建的 DOM 元素包含内联的脚本。如果我们仍采用第一种方式，但元素上不包含任何脚本，将不会发生内存泄漏。在构建较大子树时，第二种方式效率更高，我们可以得到一个更优的解决方案。在第二种方案中，新创建的元素都没有绑定任何脚本，所以你可以放心地构建出子树，当将子树添加到文档树后，再回来绑定元素的事件，只要记住循环引用和闭包的原则，在你的代码中就不会产生新的内存泄漏。</p><p>需要指出的是，并不是所有内存泄漏都容易排查，就像 DOM 插入顺序这样的内存泄漏问题，问题本身非常小，需要通过数千次的迭代才会暴露出来。通常你会认为最佳实践是安全的，但上面示例表明，即便是最佳实践也可能会发生内存泄漏。而我们的解决方案是改进了最佳实践，甚至引入一个新的最佳实践方案来消除内存泄漏。</p><h2><span id="伪泄露-pseudo-leaks">伪泄露 Pseudo-Leaks</span></h2><h2><span id="总结">总结</span></h2><p class="j-quote">原文：<a href="https://msdn.microsoft.com/en-us/library/bb250448.aspx" target="_blank" rel="external">Understanding and Solving Internet Explorer Leak Patterns</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在过去，内存泄漏并没有为 Web 开发人员带来巨大的问题。页面保持着相对简单，并且在页面之间的跳转时可以释放内存资源，即便还存在内存泄露，那也是小到可以被忽略。&lt;/p&gt;
&lt;p&gt;现在，新的 Web 应用达到更高的水准，页面可能运行数小时而不跳转，通过 Web 服务动态检索和更新页面。JavaScript 语言特性也被发挥到极致，通过复杂的事件绑定、面向对象和闭包等特性构成了整个 Web 应用。面对这些变化，内存泄露问题变得越来越突出，尤其是之前那些通过刷新（导航）隐藏的内存泄露问题。&lt;/p&gt;
&lt;p&gt;庆幸的是，如果你知道如何排查问题，内存泄露可以很轻易地被清除。即便是面对一些最麻烦的问题，如果你知道解决方案，也只需要少量的工作。虽然页面仍可能存在一些小的内存泄露，但是那些最明显的可以轻易地被清除。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/memory-leak.jpg&quot; alt=&quot;Memory Leaks&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Leak" scheme="http://bubkoo.com/tags/leak/"/>
    
      <category term="IE" scheme="http://bubkoo.com/tags/ie/"/>
    
      <category term="Closures" scheme="http://bubkoo.com/tags/closures/"/>
    
  </entry>
  
  <entry>
    <title>如何修复那些奇怪的 JavaScript 错误</title>
    <link href="http://bubkoo.com/2015/01/25/Strange-JavaScript-Errors-and-How-to-Fix-Them/"/>
    <id>http://bubkoo.com/2015/01/25/Strange-JavaScript-Errors-and-How-to-Fix-Them/</id>
    <published>2015-01-25T21:47:02.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>调试 JavaScript 也许是一场噩梦：一些错误非常难理解，并且给出的错误行号并不是总是很有帮助。如果有一个列表，列举这些错误的意思和如何修复它们，将对我们非常有帮助。</p><p>本文列举了 JavaScript 中一些奇怪的错误。对于相同的错误不同的浏览器可能给出不同的提示，所以分别给出了不同的例子。</p><a id="more"></a><h2><span id="如何阅读错误">如何阅读错误</span></h2><p>进入正题之前，我们先快速分析一下错误消息的结构，这对我们理解错误消息非常有用，同时也将有助于你理解那些没有在本文中列举的错误。</p><p>Chrome 中一个典型的错误看起来像这样：</p><blockquote><p>Uncaught TypeError: undefined is not a function</p></blockquote><p>该错误的结构如下：</p><ol><li><strong>Uncaught TypeError: </strong>该部分并不是很有用。<code>Uncaught</code> 表示该错误没有被 <code>catch</code> 语句捕获，<code>TypeError</code> 是错误名。</li><li><strong>undefined is not a function: </strong>是消息体，需要从字面上理解。例如本例中，它的字面意思是，代码尝试将 <code>undefined</code> 当作函数使用。</li></ol><p>其他基于 webkit 的浏览器，比如 Safari，错误消息与 Chrome 基本一样。Firefox 的错误消息与上面非常相似，但并不总是都包含第一部分，最近版本的 IE 的错误消息也比 Chrome 的简单，但在这里，更简单并不意味着更好。</p><p>下面看看我们经常会遇到的一些错误。</p><h2><span id="uncaught-typeerror-undefined-is-not-a-function">Uncaught TypeError: undefined is not a function</span></h2><p>同类错误：</p><ul><li>number is not a function</li><li>object is not a function</li><li>string is not a function</li><li>Unhandled Error: ‘foo’ is not a function</li><li>Function Expected</li></ul><p>尝试将一个值（value）当作函数使用，但该值并不是一个函数。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="literal">undefined</span>;</div><div class="line">foo();</div></pre></td></tr></table></figure><p>这个错误很常见，当调用对象中的一个方法，但写错了方法名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.getElementByID(<span class="string">'foo'</span>);</div></pre></td></tr></table></figure><p>访问对象中不存在的属性时将返回 <code>undefined</code>，上面代码就将出现该错误。</p><p>其他类似的错误，比如“number is not a function”发生在尝试将一个 <code>Number</code> 当作函数使用时。</p><p><strong>如何修复：</strong>确保函数名正确。对于该错误，行号通常准确地指向了错误发生的位置。</p><h2><span id="uncaught-referenceerror-invalid-left-hand-side-in-assignment">Uncaught ReferenceError: Invalid left-hand side in assignment</span></h2><p>同类错误：</p><ul><li>Uncaught exception: ReferenceError: Cannot assign to ‘functionCall()’</li><li>Uncaught exception: ReferenceError: Cannot assign to ‘this’</li></ul><p>当尝试给一个不能被赋值的变量赋值时将发生该错误。看下面的典型例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(doSomething() = <span class="string">'somevalue'</span>)</div></pre></td></tr></table></figure><p>在上面例子中，开发人员不小心将 <code>==</code> 写成了 <code>=</code>，错误消息“left-hand side in assignment”指等号左边包含不能被赋值的变量。</p><p><strong>如何修复：</strong>确保不给函数函数的返回值或 <code>this</code> 关键字赋值。</p><h2><span id="uncaught-typeerror-converting-circular-structure-to-json">Uncaught TypeError: Converting circular structure to JSON</span></h2><p>同类错误：</p><ul><li>Uncaught exception: TypeError: JSON.stringify: Not an acyclic Object</li><li>TypeError: cyclic object value</li><li>Circular reference in value argument not supported</li></ul><p>该错误总是发生在使用 <code>JSON.stringify</code> 序列化一个存在循环引用的对象时。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123; &#125;;</div><div class="line"><span class="keyword">var</span> b = &#123; <span class="attr">a</span>: a &#125;;</div><div class="line">a.b = b;</div><div class="line"><span class="built_in">JSON</span>.stringify(a);</div></pre></td></tr></table></figure><p>由于上面 <code>a</code> 和 <code>b</code> 两个对象都彼此相互引用，结果导致对象不能被转换为 JSON 字符串。</p><p><strong>如何修复：</strong>移除将要被转换为 JSON 字符串对象内部的循环引用。</p><h2><span id="unexpected-token">Unexpected token ;</span></h2><p>同类错误：</p><ul><li>Expected )</li><li>missing ) after argument list</li></ul><p>通常发生在缺少括号或分号时。</p><p>该错误中所谓的符号（token）可以多种多样，如“Unexpected token ]”或“Expected {”等等。</p><p><strong>如何修复：</strong>该错误提示的行号有时并不能指向正确的位置，这增加了修复难度。</p><ul><li>错误信息中包含“[ ] { } ( )”时，通常是因为缺少配对的部分，检查所有括号，保证都是配对的。这种情况下，行号通常指向了其他位置，问不是错误的位置。</li><li>异常的 <code>/</code> 和正则表达式有关，行号指向了正确的位置。</li><li>异常的 <code>;</code> 通常发生在对象、数组或函数调用时参数列表内部包含 <code>;</code>，行号也指向了正确的位置。</li></ul><h2><span id="uncaught-syntaxerror-unexpected-token-illegal">Uncaught SyntaxError: Unexpected token ILLEGAL</span></h2><p>同类错误：</p><ul><li>Unterminated String Literal</li><li>Invalid Line Terminator</li></ul><p>字符串字面量缺少闭合的引号。</p><p><strong>如何修复：</strong>确保所有字符串都包含闭合的引号。</p><h2><span id="uncaught-typeerror-cannot-read-property-foo-of-null-uncaught-typeerror-cannot-read-property-foo-of-undefined">Uncaught TypeError: Cannot read property ‘foo’ of null, Uncaught TypeError: Cannot read property ‘foo’ of undefined</span></h2><p>同类错误：</p><ul><li>TypeError: someVal is null</li><li>Unable to get property ‘foo’ of undefined or null reference</li></ul><p>尝试将 <code>null</code> 过 <code>undefined</code> 作为一个对象使用，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> someVal = <span class="literal">null</span>;</div><div class="line"><span class="built_in">console</span>.log(someVal.foo);</div></pre></td></tr></table></figure><p><strong>如何修复：</strong>通常是由于书写失误导致，确保错误提示的行号附近的变量都是书写正确的。</p><h2><span id="uncaught-typeerror-cannot-set-property-foo-of-null-uncaught-typeerror-cannot-set-property-foo-of-undefined">Uncaught TypeError: Cannot set property ‘foo’ of null, Uncaught TypeError: Cannot set property ‘foo’ of undefined</span></h2><p>同类错误：</p><ul><li>TypeError: someVal is undefined</li><li>Unable to set property ‘foo’ of undefined or null reference</li></ul><p>尝试为值为 <code>null</code> 或 <code>undefined</code> 的对象的属性赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> someVal = <span class="literal">null</span>;</div><div class="line">someVal.foo = <span class="number">1</span>;</div></pre></td></tr></table></figure><p><strong>如何修复：</strong>这也通常是由于书写错误导致，检查错误提示的行号附近的变量名是否正确。</p><h2><span id="uncaught-rangeerror-maximum-call-stack-size-exceeded">Uncaught RangeError: Maximum call stack size exceeded</span></h2><p>同类错误：</p><ul><li>Uncaught exception: RangeError: Maximum recursion depth exceeded</li><li>too much recursion</li><li>Stack overflow</li></ul><p>通常是由程序逻辑问题，导致了无限递归的函数调用。</p><p><strong>如何修复：</strong>检查函数的递归调用，确保函数不是无限递归的。</p><h2><span id="uncaught-urierror-uri-malformed">Uncaught URIError: URI malformed</span></h2><p>同类错误：URIError: malformed URI sequence</p><p>无效的 <code>decodeURIComponent</code> 调用将导致该错误。</p><p><strong>如何修复：</strong>确保行号所指位置的 <code>decodeURIComponent</code> 调用的参数正确。</p><h2><span id="xmlhttprequest-cannot-load-httpsomeurl-no-access-control-allow-origin-header-is-present-on-the-requested-resource">XMLHttpRequest cannot load . No ‘Access-Control-Allow-Origin’ header is present on the requested resource</span></h2><p>同类错误：Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at <a href="http://some/url/" target="_blank" rel="external">http://some/url/</a></p><p>该错误总是由使用 <code>XMLHttpRequest</code> 时导致。</p><p><strong>如何修复：</strong>确保请求的 url 满足<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">同源策略</a>。</p><h2><span id="invalidstateerror-an-attempt-was-made-to-use-an-object-that-is-not-or-is-no-longer-usable">InvalidStateError: An attempt was made to use an object that is not, or is no longer, usable</span></h2><p>同类错误：</p><ul><li>InvalidStateError</li><li>DOMException code 11</li></ul><p>该错误表示调用对象的方法时，对象的状态不对。在使用 <code>XMLHttpRequest</code> 时，在其准备好之前尝试调用其中的方法将导致该错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.setRequestHeader(<span class="string">'Some-Header'</span>, <span class="string">'val'</span>);</div></pre></td></tr></table></figure><p>上例中将导致错误，因为 <code>setRequestHeader</code> 方法只能在 <code>xhr.open</code> 之后调用。</p><p><strong>如何修复：</strong>检查行号指示的位置，确保代码运行在合适的时间，或在这之前添加必要的函数调用（比如<code>xhr.open</code>）。</p><p class="j-quote">原文：<a href="http://davidwalsh.name/fix-javascript-errors" target="_blank" rel="external">JavaScript Errors and How to Fix Them</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调试 JavaScript 也许是一场噩梦：一些错误非常难理解，并且给出的错误行号并不是总是很有帮助。如果有一个列表，列举这些错误的意思和如何修复它们，将对我们非常有帮助。&lt;/p&gt;
&lt;p&gt;本文列举了 JavaScript 中一些奇怪的错误。对于相同的错误不同的浏览器可能给出不同的提示，所以分别给出了不同的例子。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Errors" scheme="http://bubkoo.com/tags/errors/"/>
    
      <category term="Exceptions" scheme="http://bubkoo.com/tags/exceptions/"/>
    
  </entry>
  
  <entry>
    <title>在 Express 开发中使用 nodemon</title>
    <link href="http://bubkoo.com/2014/12/02/use-nodemon-with-node-applications/"/>
    <id>http://bubkoo.com/2014/12/02/use-nodemon-with-node-applications/</id>
    <published>2014-12-02T03:28:38.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://camo.githubusercontent.com/fd1ea21338ceeef34920e44e97d099f3c47a78c3/687474703a2f2f6e6f64656d6f6e2e696f2f6e6f64656d6f6e2e737667" alt="nodemon"></p><p><a href="http://nodemon.io/" target="_blank" rel="external">nodemon</a> 是一款非常实用的工具，用来监控 NodeJS 源代码的任何变化和自动重启你的服务器，这样我们只需要刷新页面就能看到你的改动。这里还有个一个工具 <a href="http://supervisord.org/" target="_blank" rel="external">supervisor</a> 也能实现同样的功能，但相比起来 nodemon 更加灵活轻量，内存占用更少。</p><a id="more"></a><h2><span id="安装">安装</span></h2><p>使用 npm 将 nodemon 安装到全局：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g nodemon</div></pre></td></tr></table></figure><h2><span id="使用">使用</span></h2><p>nodemon 会将你输入的启动命令包裹起来，所以你可以使用任何可以使用的启动参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nodemon [your node app]</div></pre></td></tr></table></figure><p>使用 <code>-h</code> 或者 <code>--help</code> 来查看完整的帮助：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nodemon -h</div></pre></td></tr></table></figure><p>使用 nodemon 非常简单，如果我们的应用接受 host 和 port 两个参数，那么我们可以这样来启动我们的应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nodemon ./server.js localhost 8080</div></pre></td></tr></table></figure><p>nodemon 同样能监视和运行 <a href="http://jashkenas.github.com/coffee-script/" target="_blank" rel="external">coffee-script</a> 应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nodemon server.coffee</div></pre></td></tr></table></figure><p>如果没有指定启动脚本，nodemon 将检查 <code>package.json</code> 文件，并运行 <code>main</code> 属性指定的文件，如果没有发现 <code>main</code> 属性，nodemon 将检查 <code>scripts.start</code> 属性指定的启动命令。因此如果同时指定了 <code>mian</code> 和 <code>scripts.start</code> 属性，那么 nodemon 将使用 <code>main</code> 属性指定的文件作为启动脚本。</p><p>你也可以传递 debug 标志给 nodemon：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nodemon --debug ./server.js 80</div></pre></td></tr></table></figure><h2><span id="手动重启">手动重启</span></h2><p>当 nodemon 运行时，如果你想手动重启你的应用，除了可以停止并重启 nodemon 之外，你还可以简单滴敲入 <code>rs</code> 并回车，然后 nodemon 将重启你的服务。</p><h2><span id="配置文件">配置文件</span></h2><p>nodemon 支持本地和全局配置文件。配置文件名为 <code>nodemon.json</code>，可以将其放在当前工作目录或者你的 <code>home</code> 目录。</p><p>配置文件可以接受任何命令行中支持的参数，启动 nodemon 时命令行中的参数将覆盖配置文件的设置，一个配置文件示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"verbose"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"ignore"</span>: [<span class="string">"*.test.js"</span>, <span class="string">"fixtures/*"</span>],</div><div class="line">  <span class="attr">"execMap"</span>: &#123;</div><div class="line">    <span class="attr">"rb"</span>: <span class="string">"ruby"</span>,</div><div class="line">    <span class="attr">"pde"</span>: <span class="string">"processing --sketch=&#123;&#123;pwd&#125;&#125; --run"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的 <code>nodemon.json</code> 配置文件是我的全局配置文件，因为配置文件中配置了支持运行 <code>ruby</code> 文件 和 <code>processing</code> 文件，然后我可以运行 <code>nodemon demo.pde</code> 来启动。</p><p>我的本地配置文件如下，注意 <code>json</code> 文件不支持注释，我这里仅仅为了作一些说明，如果你想直接复制过去使用，请记得移除文件中的注释：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// 手动重启对应的命令，默认为 rs，你可以按照自己的习惯做对应的修改，</span></div><div class="line">    <span class="comment">// 比如修改为 rb，那么 rb 将作为新的手动重启命令。</span></div><div class="line">    <span class="string">"restartable"</span>: <span class="string">"rs"</span>,</div><div class="line">    <span class="string">"verbose"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="string">"env"</span>: &#123;</div><div class="line">        <span class="string">"NODE_ENV"</span>: <span class="string">"development"</span>,</div><div class="line">        <span class="comment">// 端口</span></div><div class="line">        <span class="string">"PORT"</span>: <span class="string">"4000"</span> </div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 后缀名和对应的运行命令</span></div><div class="line">    <span class="string">"execMap"</span>: &#123;</div><div class="line">        <span class="comment">// 空后缀名是为了支持 ./bin/www 这样无后缀的文件。</span></div><div class="line">        <span class="string">""</span>: <span class="string">"node --debug"</span>, </div><div class="line">        <span class="comment">// js 文件的启动命令</span></div><div class="line">        <span class="string">"js"</span>: <span class="string">"node --debug"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 监视的文件和文件夹</span></div><div class="line">    <span class="string">"watch"</span>: [</div><div class="line">        <span class="string">"app/"</span>,</div><div class="line">        <span class="string">"bin/"</span>,</div><div class="line">        <span class="string">"routes/"</span>,</div><div class="line">        <span class="string">"views/"</span>,</div><div class="line">        <span class="string">"app.js"</span></div><div class="line">    ],</div><div class="line">    <span class="comment">// 忽略的文件和文件夹</span></div><div class="line">    <span class="string">"ignore"</span>: [</div><div class="line">        <span class="string">".git"</span>,</div><div class="line">        <span class="string">".idea"</span>,</div><div class="line">        <span class="string">"node_modules"</span></div><div class="line">    ],</div><div class="line">    <span class="comment">// 监视指定后缀名的文件</span></div><div class="line">    <span class="string">"ext"</span>: <span class="string">"js jade"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>完整的配置说明可以使用 <code>nodemon --help config</code> 来查看，或者看<a href="https://github.com/remy/nodemon/blob/master/doc/cli/config.txt" target="_blank" rel="external">这里</a>。</p><h2><span id="chrome-调试">Chrome 调试</span></h2><ol><li>安装 node-inspector：<code>npm install -g node-inspector</code>；</li><li>启动项目：<code>nodemon --debug xxx.js</code>，新开一个命令窗口，启动 node-inspector：<code>node-inspector</code>；</li><li><a href="http://127.0.0.1:8080/debug?port=5858" target="_blank" rel="external">http://127.0.0.1:8080/debug?port=5858</a> 访问 debug 页面，就可以开始 debug 了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/fd1ea21338ceeef34920e44e97d099f3c47a78c3/687474703a2f2f6e6f64656d6f6e2e696f2f6e6f64656d6f6e2e737667&quot; alt=&quot;nodemon&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://nodemon.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nodemon&lt;/a&gt; 是一款非常实用的工具，用来监控 NodeJS 源代码的任何变化和自动重启你的服务器，这样我们只需要刷新页面就能看到你的改动。这里还有个一个工具 &lt;a href=&quot;http://supervisord.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;supervisor&lt;/a&gt; 也能实现同样的功能，但相比起来 nodemon 更加灵活轻量，内存占用更少。&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS" scheme="http://bubkoo.com/categories/nodejs/"/>
    
    
      <category term="nodemon" scheme="http://bubkoo.com/tags/nodemon/"/>
    
      <category term="nodejs" scheme="http://bubkoo.com/tags/nodejs/"/>
    
      <category term="Express" scheme="http://bubkoo.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Partial Application in JavaScript</title>
    <link href="http://bubkoo.com/2014/11/13/Partial-Application-in-JavaScript/"/>
    <id>http://bubkoo.com/2014/11/13/Partial-Application-in-JavaScript/</id>
    <published>2014-11-13T10:32:45.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p><a href="http://en.wikipedia.org/wiki/Partial_application" target="_blank" rel="external">Partial Application</a>？不要被字面意思误解，这里要说的并不是 Application，而是 JavaScript 中的 <code>function</code>。可以这样来描述 Partial Application，一个接受多个参数的函数，预先给该函数绑定一些参数，并返回一个新的函数来接受剩下未绑定的参数。貌似有点像柯里化(currying)函数，但不尽然。</p><p>典型的柯里化函数定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.curry = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>, args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args.concat(</div><div class="line">        <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上面代码预先绑定函数参数列表左侧的参数到新返回的函数中，新函数接受右侧剩下的参数，相比起来 Partial Application 更加灵活。<br><a id="more"></a></p><h2><span id="分情况看看-partial-application">分情况看看 Partial Application</span></h2><h3><span id="from-the-left">From the Left</span></h3><p>这里和上面的柯里化类似，预先绑定函数左侧的参数，调用时传入右侧剩下的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn <span class="regexp">/*, args...*/</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line">  <span class="comment">// 将参数转换为数组，除开第一个参数</span></div><div class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 调用原来的方法，并将参数拼接到预先绑定的参数后面</span></div><div class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args.concat(slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>)));</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用也比较简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将传入的所有参数求和</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAllTheThings</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">    sum += <span class="built_in">arguments</span>[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 正常调用</span></div><div class="line">addAllTheThings(<span class="number">1</span>, <span class="number">2</span>);            <span class="comment">// 3</span></div><div class="line">addAllTheThings(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);         <span class="comment">// 6</span></div><div class="line">addAllTheThings(<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>); <span class="comment">// 55</span></div><div class="line"></div><div class="line"><span class="comment">// 预先绑定左侧参数</span></div><div class="line"><span class="keyword">var</span> addOne = partial(addAllTheThings, <span class="number">1</span>);</div><div class="line">addOne()                          <span class="comment">// 1</span></div><div class="line">addOne(<span class="number">2</span>);                        <span class="comment">// 3</span></div><div class="line">addOne(<span class="number">2</span>, <span class="number">3</span>);                     <span class="comment">// 6</span></div><div class="line">addOne(<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>);             <span class="comment">// 55</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> addTen = partial(addAllTheThings, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line">addTen();                         <span class="comment">// 10</span></div><div class="line">addTen(<span class="number">2</span>);                        <span class="comment">// 12</span></div><div class="line">addTen(<span class="number">2</span>, <span class="number">3</span>);                     <span class="comment">// 15</span></div><div class="line">addTen(<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>);             <span class="comment">// 64</span></div></pre></td></tr></table></figure><h3><span id="from-the-right">From the Right</span></h3><p>实现方式类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialRight</span>(<span class="params">fn <span class="regexp">/*, args...*/</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 将剩下参数拼接在预先绑定参数的左侧 </span></div><div class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>).concat(args));</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wedgie</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + <span class="string">' gives '</span> + b + <span class="string">' a wedgie.'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> joeGivesWedgie = partial(wedgie, <span class="string">'Joe'</span>);</div><div class="line">joeGivesWedgie(<span class="string">'Ron'</span>);    <span class="comment">// "Joe gives Ron a wedgie."</span></div><div class="line">joeGivesWedgie(<span class="string">'Bob'</span>);    <span class="comment">// "Joe gives Bob a wedgie."</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> joeReceivesWedgie = partialRight(wedgie, <span class="string">'Joe'</span>);</div><div class="line">joeReceivesWedgie(<span class="string">'Ron'</span>); <span class="comment">// "Ron gives Joe a wedgie."</span></div><div class="line">joeReceivesWedgie(<span class="string">'Bob'</span>); <span class="comment">// "Bob gives Joe a wedgie."</span></div></pre></td></tr></table></figure><p>上面代码需要注意的是，如果使用时给函数传递不止一个参数，那么预先绑定的参数将不起任何作用。更加健壮的代码需要将函数参数的个数也考虑进来。</p><h3><span id="from-anywhere">From Anywhere</span></h3><p>上面两种情况预先绑定的参数和后传入的参数都要求有一定顺序，而我们可能需要随机替换参数中的某些值，为了达到这个目的我们可以给预绑定的参数赋值为某个占位符，函数实际调用时，再用传入的参数来替换这些占位符，请看下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> partialAny = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">partialAny</span>(<span class="params">fn <span class="regexp">/*, args...*/</span></span>) </span>&#123;</div><div class="line">    <span class="comment">// 预先绑定的参数</span></div><div class="line">    <span class="keyword">var</span> orig = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// 后面传入的参数</span></div><div class="line">      <span class="keyword">var</span> partial = slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</div><div class="line">      <span class="keyword">var</span> args = [];</div><div class="line"></div><div class="line">      <span class="comment">// 如果预绑定的参数为占位符，则用传入的参数替换</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; orig.length; i++) &#123;</div><div class="line">        args[i] = orig[i] === partialAny._ ? partial.shift() : orig[i];</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 占位符替换结束后，将替换后的预绑定参数与剩余参数拼接为参数数组</span></div><div class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args.concat(partial));</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 定义参数占位符</span></div><div class="line">  partialAny._ = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> partialAny;</div><div class="line">&#125;());</div></pre></td></tr></table></figure><p>请看实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">r, g, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'#'</span> + r + g + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">hex(<span class="string">'11'</span>, <span class="string">'22'</span>, <span class="string">'33'</span>); <span class="comment">// "#112233"</span></div><div class="line"></div><div class="line"><span class="comment">// A more visually-appealing placeholder.</span></div><div class="line"><span class="keyword">var</span> __ = partialAny._;</div><div class="line"></div><div class="line"><span class="keyword">var</span> redMax = partialAny(hex, <span class="string">'ff'</span>, __, __);</div><div class="line">redMax(<span class="string">'11'</span>, <span class="string">'22'</span>);    <span class="comment">// "#ff1122"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> greenMax = partialAny(hex, __, <span class="string">'ff'</span>);</div><div class="line">greenMax(<span class="string">'33'</span>, <span class="string">'44'</span>);  <span class="comment">// "#33ff44"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> blueMax = partialAny(hex, __, __, <span class="string">'ff'</span>);</div><div class="line">blueMax(<span class="string">'55'</span>, <span class="string">'66'</span>);   <span class="comment">// "#5566ff"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> magentaMax = partialAny(hex, <span class="string">'ff'</span>, __, <span class="string">'ff'</span>);</div><div class="line">magentaMax(<span class="string">'77'</span>);      <span class="comment">// "#ff77ff"</span></div></pre></td></tr></table></figure><h3><span id="full-application">“Full” Application?</span></h3><p>如果给一个函数预先绑定了所有参数，那么这里的 partial 就失去了意义，看下面例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="comment">// 这里没有使用 arguments，而是直接使用了形参</span></div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这里已经绑定了所有参数</span></div><div class="line"><span class="keyword">var</span> alwaysNine = partial(add, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line">alwaysNine();     <span class="comment">// 9</span></div><div class="line">alwaysNine(<span class="number">1</span>);    <span class="comment">// 9 - 等于调用 add(4, 5, 1)</span></div><div class="line">alwaysNine(<span class="number">9001</span>); <span class="comment">// 9 - 等于调用 add(4, 5, 9001)</span></div></pre></td></tr></table></figure><h2><span id="使用-bind">使用 <code>bind()</code></span></h2><p>熟悉 <code>bind()</code> 的同学大概知道，<code>bind()</code> 方法不仅可以指定函数的执行上下文，还可以给函数预绑定一些参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> add2 = add.bind(<span class="literal">null</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line">add2(<span class="number">10</span>) === <span class="number">12</span>;</div></pre></td></tr></table></figure><p>我们通常的 DOM 事件绑定方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.setup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">'tweet'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.handleStreamEvent(<span class="string">'tweet'</span>, e, data);</div><div class="line">  &#125;.bind(<span class="keyword">this</span>));</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">'retweet'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.handleStreamEvent(<span class="string">'retweet'</span>, e, data);</div><div class="line">  &#125;.bind(<span class="keyword">this</span>));</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p> 如果 <code>tweet</code> 和 <code>retweet</code> 事件回调的内部逻辑差不多，这样组织代码非常不错，但是，还是有一些冗余代码，两个绑定都需要创建一个匿名函数，并在匿名函数上调用 <code>bind</code> 来绑定 <code>this</code>，确保上下文，然后在匿名函数内部调用绑定方法。</p><p> 其实我们有更简单的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.setup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">'tweet'</span>, <span class="keyword">this</span>.handleStreamEvent.bind(<span class="keyword">this</span>, <span class="string">'tweet'</span>));</div><div class="line">  <span class="keyword">this</span>.on(<span class="string">'retweet'</span>, <span class="keyword">this</span>.handleStreamEvent.bind(<span class="keyword">this</span>, <span class="string">'retweet'</span>));</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>代码非常清爽吧！这里，我们创建了两个 partially applied 的函数，绑定了 <code>this</code>，并分别预先传入 <code>tweet</code> 和 <code>retweet</code> 两个参数，当事件触发时，再分别传入 <code>e</code> 和 <code>data</code> 两个参数。</p><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://benalman.com/news/2012/09/partial-application-in-javascript" target="_blank" rel="external">Partial Application in JavaScript</a> by  <a href="http://benalman.com/" target="_blank" rel="external">BEN ALMAN</a></li><li><a href="http://ejohn.org/blog/partial-functions-in-javascript/" target="_blank" rel="external">Partial Application in JavaScript</a> by <a href="http://ejohn.org/" target="_blank" rel="external">John Resig</a></li><li><a href="http://passy.svbtle.com/partial-application-in-javascript-using-bind" target="_blank" rel="external">Partial Application in JavaScript using bind()</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Partial_application&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Partial Application&lt;/a&gt;？不要被字面意思误解，这里要说的并不是 Application，而是 JavaScript 中的 &lt;code&gt;function&lt;/code&gt;。可以这样来描述 Partial Application，一个接受多个参数的函数，预先给该函数绑定一些参数，并返回一个新的函数来接受剩下未绑定的参数。貌似有点像柯里化(currying)函数，但不尽然。&lt;/p&gt;
&lt;p&gt;典型的柯里化函数定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype.curry = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; fn = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, args = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.prototype.slice.call(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fn.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, args.concat(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.prototype.slice.call(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;)));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码预先绑定函数参数列表左侧的参数到新返回的函数中，新函数接受右侧剩下的参数，相比起来 Partial Application 更加灵活。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Partial Application" scheme="http://bubkoo.com/tags/partial-application/"/>
    
  </entry>
  
  <entry>
    <title>认识 D3 数据绑定的魔法</title>
    <link href="http://bubkoo.com/2014/10/24/thinking-about-D3-s-data-bingding/"/>
    <id>http://bubkoo.com/2014/10/24/thinking-about-D3-s-data-bingding/</id>
    <published>2014-10-24T17:19:30.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果用 <a href="http://d3js.org/" target="_blank" rel="external">D3</a> 来构建一个简单的散点图，我们需要创建一些<a href="http://www.w3.org/TR/SVG/shapes.html#CircleElement" target="_blank" rel="external">圆点（circle）</a>来展示你的数据。当你发现 D3 并没有提供内置的方法来同时创建多个 DOM 元素时，也许你会感到惊讶，但是，等等，<a href="https://www.destroyallsoftware.com/talks/wat" target="_blank" rel="external">为什么呢</a>？</p><a id="more"></a><p>当然，你可以使用 <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-append" target="_blank" rel="external">append</a> 方法来创建单个元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">svg.append(<span class="string">"circle"</span>)</div><div class="line">    .attr(<span class="string">"cx"</span>, d.x)</div><div class="line">    .attr(<span class="string">"cy"</span>, d.y)</div><div class="line">    .attr(<span class="string">"r"</span>, <span class="number">2.5</span>);</div></pre></td></tr></table></figure><p>这仅仅是一个圆点，我们需要的是一系列圆点，每个圆点代表一条数据。当然你可以用 <code>for</code> 循环来创建，但开始之前，请看看下面官方例子中的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">svg.selectAll(<span class="string">"circle"</span>)</div><div class="line">    .data(data)</div><div class="line">  .enter().append(<span class="string">"circle"</span>)</div><div class="line">    .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.x; &#125;)</div><div class="line">    .attr(<span class="string">"cy"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.y; &#125;)</div><div class="line">    .attr(<span class="string">"r"</span>, <span class="number">2.5</span>);</div></pre></td></tr></table></figure><p>对应的数据像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        <span class="string">"x"</span>: <span class="number">1.0</span>, </div><div class="line">        <span class="string">"y"</span>: <span class="number">1.1</span></div><div class="line">    &#125;, </div><div class="line">    &#123;</div><div class="line">        <span class="string">"x"</span>: <span class="number">2.0</span>, </div><div class="line">        <span class="string">"y"</span>: <span class="number">2.5</span></div><div class="line">    &#125;, </div><div class="line">    …</div><div class="line">]</div></pre></td></tr></table></figure><p>这段代码正是我们需要的，上面代码为每一条数据创建了一个圆，并使用单条数据的 <code>x</code> 和 <code>y</code> 属性来定位。天哪，<code>selectAll(&quot;circle&quot;)</code> 都干了什么？为什么为了创建一些新元素需要先选择这些明明都不存在的元素？</p><p>这就是 D3 的规范，告诉 D3 你需要什么，而不是告诉它具体怎么做。我们需要圆点来展示我们的数据，每个圆点对应一条数据。所以我们告诉 D3 对 “circle” 的选集应该和我们的数据对应起来，而不是直接告诉 D3 来创建这些圆点。这个概念称为数据连接：</p><style>svg {    font: 10px sans-serif;}circle {    fill: none;    fill-opacity: .2;    stroke: black;    stroke-width: 1.5px;}</style><svg width="600" height="265"><g transform="translate(0,150)"><g transform="translate(240)"><circle r="110" style="fill: rgb(49, 130, 189)"/></g><text x="240" y="-125" dy=".35em" text-anchor="middle" style="font-weight: bold">数据集合</text><text x="210" dy=".35em" text-anchor="middle">Enter</text><text x="300" dy=".35em" text-anchor="middle">Update</text><g transform="translate(360)"><circle r="110" style="fill: rgb(230, 85, 13)"/></g><text x="360" y="-125" dy=".35em" text-anchor="middle" style="font-weight: bold">元素集合</text><text x="400" dy=".35em" text-anchor="middle">Exit</text></g></svg><p>那些已经和数据绑定的元素构成中间的 <em>update</em> 集合；而那些数据集合中存在，但在元素集合中还不存在的部分构成左边的 <em>enter</em> 集合，代表那些将被添加的元素；同理，那些在数据集合中不存在，而在元素集合中存在的元素构成了右边的 <em>exit</em> 集合，代表那些将被移除的元素。</p><p>现在我们可以揭开数据绑定 (data-join) 的神秘面纱：</p><ol><li>首先，<code>svg.selectAll(&quot;circle&quot;)</code> 返回一个空选集，因为当前 SVG 还没有任何子元素，该选集的父节点是这个 SVG 容器。</li><li>然后将该选集与数据绑定，产生三个新的子选集，分别代表三种可能的状态：<em>enter</em>、<em>update</em> 和 <em>exit</em>。由于当前选集为空，所以 <em>update</em> 和 <em>exit</em> 子选集也为空，<em>enter</em> 子选集就包含了每条数据对应的元素的占位符。</li><li><em>update</em> 子选集直接通过 <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data" target="_blank" rel="external"><code>selection.data</code></a> 返回，<em>enter</em> 和 <em>exit</em> 子选集分别通过 <code>selection.enter</code> 和 <code>selection.exit</code> 返回。</li><li>那些缺少的元素通过对 <em>enter</em> 子选集调用 <code>selection.append</code> 方法来添加到 SVG 中，这样就为每条数据添加了一个新的圆点到 SVG 中。</li></ol><p>数据绑定意味着在数据和元素之间建立了一种关系，然后通过 <em>enter</em>、<em>update</em> 和 <em>exit</em> 三个子选集来实现这种关系。</p><p>但是为什么要这么麻烦呢？为什么不直接创建这些元素？数据绑定的优点在于更具通用性。上面代码仅仅处理了 <em>enter</em> 子选集，这对于静态数据足够了，我们可以方便地扩展上面的代码，只需要对 <em>update</em> 和 <em>exit</em> 稍作修改，就可以使其支持动态数据可视化。这意味着，我们可以实现<a href="http://bost.ocks.org/mike/path/" target="_blank" rel="external">实时数据</a>的可视化。</p><p>请看下面操作三个子集的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> circle = svg.selectAll(<span class="string">"circle"</span>)</div><div class="line">    .data(data);</div><div class="line"></div><div class="line">circle.exit().remove();</div><div class="line"></div><div class="line">circle.enter().append(<span class="string">"circle"</span>)</div><div class="line">    .attr(<span class="string">"r"</span>, <span class="number">2.5</span>);</div><div class="line"></div><div class="line">circle</div><div class="line">    .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.x; &#125;)</div><div class="line">    .attr(<span class="string">"cy"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.y; &#125;);</div></pre></td></tr></table></figure><p>上面这段代码将重新计算数据绑定，并维护数据和元素之间的关系。如果新数据集小于旧集合，那些 <em>exit</em> 子选集中的多余元素将被移除；如果新数据集大于旧集合，那些 <em>enter</em> 子选集中的元素将被添加到 SVG 中；如果新数据集恰好与旧集合同样大小，那么所有这些元素仅仅会更新自身的位置，没有元素被添加或移除。</p><p>数据绑定使我们的代码更加清晰，我们只需要处理这三个子选集，而不需要 <code>if</code> 语句或 <code>for</code> 循环，如果三个子选集都为空，意味着我们不需要进行任何操作。</p><p>数据绑定还可以方便我们对某子选集做一些针对性的处理，例如，我们可以在 <em>enter</em> 子选集设置元素的一些不变属性（比如，圆的半径 <code>r</code>）而不是 <em>update</em> 子选集。同时，通过子选集最小化了 DOM 变化，极大提高了渲染性能。我们还可以正对性对某子选集设置动画效果，例如，对添加的元素设置动画：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">circle.enter().append(<span class="string">"circle"</span>)</div><div class="line">    .attr(<span class="string">"r"</span>, <span class="number">0</span>)</div><div class="line">  .transition()</div><div class="line">    .attr(<span class="string">"r"</span>, <span class="number">2.5</span>);</div></pre></td></tr></table></figure><p>同样，对移除的元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">circle.exit().transition()</div><div class="line">    .attr(<span class="string">"r"</span>, <span class="number">0</span>)</div><div class="line">    .remove();</div></pre></td></tr></table></figure><p>【全文完】</p><p><strong>下面看一个栗子</strong></p><style>.enter {  font: bold 48px monospace;  fill: green;}.update {  font: bold 48px monospace;  fill: #333;}</style><p><svg id="demo1"/></p><script charset="utf-8" src="/js/lib/d3.min.js"></script><script>(function(){    var alphabet = "abcdefghijklmnopqrstuvwxyz".split("");    var width  = 600,        height = 500;    var svg = d3.select("#demo1")        .attr("width", width)        .attr("height", height)      .append("g")        .attr("transform", "translate(10," + (height / 2) + ")");    function update(data) {      // DATA JOIN      // Join new data with old elements, if any.      var text = svg.selectAll("text")          .data(data);      // UPDATE      // Update old elements as needed.      text.attr("class", "update");      // ENTER      // Create new elements as needed.      text.enter().append("text")          .attr("class", "enter")          .attr("x", function(d, i) { return i * 32; })          .attr("dy", ".35em");      // ENTER + UPDATE      // Appending to the enter selection expands the update selection to include      // entering elements; so, operations on the update selection after appending to      // the enter selection will apply to both entering and updating nodes.      text.text(function(d) { return d; });      // EXIT      // Remove old elements as needed.      text.exit().remove();    }    // The initial display.    update(alphabet);    // Grab a random sample of letters from the alphabet, in alphabetical order.    setInterval(function() {      update(shuffle(alphabet)          .slice(0, Math.floor(Math.random() * 26))          .sort());    }, 1500);    // Shuffles the input array.    function shuffle(array) {      var m = array.length, t, i;      while (m) {        i = Math.floor(Math.random() * m--);        t = array[m], array[m] = array[i], array[i] = t;      }      return array;    }})();</script><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">text</span> &#123;</div><div class="line">  <span class="attribute">font</span>: bold <span class="number">48px</span> monospace;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.enter</span> &#123;</div><div class="line">  <span class="attribute">fill</span>: green;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.update</span> &#123;</div><div class="line">  <span class="attribute">fill</span>: <span class="number">#333</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> alphabet = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>.split(<span class="string">""</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> width = <span class="number">960</span>,</div><div class="line">    height = <span class="number">500</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> svg = d3.select(<span class="string">"body"</span>).append(<span class="string">"svg"</span>)</div><div class="line">    .attr(<span class="string">"width"</span>, width)</div><div class="line">    .attr(<span class="string">"height"</span>, height)</div><div class="line">  .append(<span class="string">"g"</span>)</div><div class="line">    .attr(<span class="string">"transform"</span>, <span class="string">"translate(32,"</span> + (height / <span class="number">2</span>) + <span class="string">")"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">data</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// DATA JOIN</span></div><div class="line">  <span class="comment">// Join new data with old elements, if any.</span></div><div class="line">  <span class="keyword">var</span> text = svg.selectAll(<span class="string">"text"</span>)</div><div class="line">      .data(data);</div><div class="line"></div><div class="line">  <span class="comment">// UPDATE</span></div><div class="line">  <span class="comment">// Update old elements as needed.</span></div><div class="line">  text.attr(<span class="string">"class"</span>, <span class="string">"update"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// ENTER</span></div><div class="line">  <span class="comment">// Create new elements as needed.</span></div><div class="line">  text.enter().append(<span class="string">"text"</span>)</div><div class="line">      .attr(<span class="string">"class"</span>, <span class="string">"enter"</span>)</div><div class="line">      .attr(<span class="string">"x"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123; <span class="keyword">return</span> i * <span class="number">32</span>; &#125;)</div><div class="line">      .attr(<span class="string">"dy"</span>, <span class="string">".35em"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// ENTER + UPDATE</span></div><div class="line">  <span class="comment">// Appending to the enter selection expands the update selection to include</span></div><div class="line">  <span class="comment">// entering elements; so, operations on the update selection after appending to</span></div><div class="line">  <span class="comment">// the enter selection will apply to both entering and updating nodes.</span></div><div class="line">  text.text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d; &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// EXIT</span></div><div class="line">  <span class="comment">// Remove old elements as needed.</span></div><div class="line">  text.exit().remove();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// The initial display.</span></div><div class="line">update(alphabet);</div><div class="line"></div><div class="line"><span class="comment">// Grab a random sample of letters from the alphabet, in alphabetical order.</span></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  update(shuffle(alphabet)</div><div class="line">      .slice(<span class="number">0</span>, <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">26</span>))</div><div class="line">      .sort());</div><div class="line">&#125;, <span class="number">1500</span>);</div><div class="line"></div><div class="line"><span class="comment">// Shuffles the input array.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> m = array.length, t, i;</div><div class="line">  <span class="keyword">while</span> (m) &#123;</div><div class="line">    i = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * m--);</div><div class="line">    t = array[m], array[m] = array[i], array[i] = t;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果用 &lt;a href=&quot;http://d3js.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;D3&lt;/a&gt; 来构建一个简单的散点图，我们需要创建一些&lt;a href=&quot;http://www.w3.org/TR/SVG/shapes.html#CircleElement&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;圆点（circle）&lt;/a&gt;来展示你的数据。当你发现 D3 并没有提供内置的方法来同时创建多个 DOM 元素时，也许你会感到惊讶，但是，等等，&lt;a href=&quot;https://www.destroyallsoftware.com/talks/wat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;为什么呢&lt;/a&gt;？&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="D3" scheme="http://bubkoo.com/tags/d3/"/>
    
      <category term="Visualizations" scheme="http://bubkoo.com/tags/visualizations/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3 详解 第八章 求值策略</title>
    <link href="http://bubkoo.com/2014/07/13/ecma-262-3-in-detail-chapter-8-evaluation-strategy/"/>
    <id>http://bubkoo.com/2014/07/13/ecma-262-3-in-detail-chapter-8-evaluation-strategy/</id>
    <published>2014-07-13T23:22:39.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>此文译自 <a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">Dmitry A. Soshnikov</a> 的 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 8. Evaluation strategy</a>.</p><h2><span id="概述">概述</span></h2><p>本文将讨论在 ECMAScript 中向函数传递参数的策略。</p><p>计算机科学里对这种策略一般称为“evaluation strategy”，即在编程语言中求解或计算某些表达式的值的一系列规则。将参数传递给函数是其中的一个案例。</p><p>写这篇文章的原因是因为论坛上有一些类似的讨论，大家都呼吁给出 ECMAScript 中参数传递策略的最精确的说明。本文给出了相应的定义，希望对大家有所帮助。</p><p>很多程序员都确信在 JavaScript 中（甚至其它一些语言)，对象是按引用传参，而原始值类型按值传参，此外，很多文章和书籍都说到这个“事实”，但有多人真正理解这个术语，而且又有多少是正确的？我们本篇讲逐一讲解。</p><a id="more"></a><h2><span id="概论">概论</span></h2><p>需要注意的是，一般有 2 中赋值策略：严格，意思是说参数在进入程序之前是经过计算过的；非严格，意思是参数的计算是根据计算要求才去计算（也就是相当于延迟计算）。</p><p>然而，我们这里讨论的是基本的函数传参策略，从 ECMAScript 出发点来说是非常重要的。</p><p>首先需要知道，在 ECMAScript 中（甚至其他语言，诸如  C，JAVA，Python 和 Ruby 中）都是用了严格的参数传递策略。</p><p>另外，参数的计算顺序也是非常重要的，在 ECMAScript 中是从左到右的，而在其他一些语言的实现是从右自左的。</p><p>严格的传参策略也分为几种子策略，其中最重要的一些策略我们在本章详细讨论。</p><p>下面讨论的策略不是全部都用在 ECMAScript 中，所以在讨论这些策略的具体行为的时候，我们使用了伪代码来展示。</p><h3><span id="按值传递">按值传递</span></h3><p>很多开发人员知道这种策略。参数的值是调用者（caller）传递的对象值的拷贝，函数内部改变参数的值不会影响到函数外部的对象。一般来说，通过重新分配内存（这里不关注重新分配内存是如何实现的 – 可以是堆栈或动态内存分配的方式），将外部对象的值拷贝到新分配的内存，并用于函数内部的计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bar = <span class="number">10</span></div><div class="line"> </div><div class="line">procedure foo(barArg):</div><div class="line">  barArg = <span class="number">20</span>;</div><div class="line">end</div><div class="line"> </div><div class="line">foo(bar)</div><div class="line"> </div><div class="line"><span class="comment">// foo内部改变值不会影响内部的bar的值</span></div><div class="line">print(bar) <span class="comment">// 10</span></div></pre></td></tr></table></figure><p>但是，如果参数不是原始值，而是一个负复杂的对象，将带来很大的性能问题，C++就有这个问题，将结构作为值传进函数的时候 —— 就是完整的拷贝。</p><p>我们来给一个一般的例子，假设一个函数接受两个参数，第一个是对象的值，第二个是一个布尔标志，用来标记是否完全（给对象重新赋值）修改传入的对象，还是只修改对象中的某些属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注：以下都是伪代码，不是JS实现</span></div><div class="line">bar = &#123;</div><div class="line">  x: <span class="number">10</span>,</div><div class="line">  y: <span class="number">20</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line">procedure foo(barArg, isFullChange):</div><div class="line"> </div><div class="line">  <span class="keyword">if</span> isFullChange:</div><div class="line">    barArg = &#123;<span class="attr">z</span>: <span class="number">1</span>, <span class="attr">q</span>: <span class="number">2</span>&#125;</div><div class="line">    exit</div><div class="line">  end</div><div class="line"> </div><div class="line">  barArg.x = <span class="number">100</span></div><div class="line">  barArg.y = <span class="number">200</span></div><div class="line"> </div><div class="line">end</div><div class="line"> </div><div class="line">foo(bar)</div><div class="line"> </div><div class="line"><span class="comment">// 按值传递，外部的对象不被改变</span></div><div class="line">print(bar) <span class="comment">// &#123;x: 10, y: 20&#125;</span></div><div class="line"> </div><div class="line"><span class="comment">// 完全改变对象（赋新值）</span></div><div class="line">foo(bar, <span class="literal">true</span>)</div><div class="line"> </div><div class="line"><span class="comment">//也没有改变</span></div><div class="line">print(bar) <span class="comment">// &#123;x: 10, y: 20&#125;, 而不是&#123;z: 1, q: 2&#125;</span></div></pre></td></tr></table></figure><h3><span id="按引用传递">按引用传递</span></h3><p>按引用传递接收的不是值的拷贝，而是对象的隐式引用，也就是该对象在外部的直接引用地址。函数内部对参数的任何改变都是影响该对象在函数外部的值，因为两者引用的是同一个对象，也就是说：这时候参数就相当于外部对象的一个别名。</p><p>伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">procedure foo(barArg, isFullChange):</div><div class="line"> </div><div class="line">  <span class="keyword">if</span> isFullChange:</div><div class="line">    barArg = &#123;<span class="attr">z</span>: <span class="number">1</span>, <span class="attr">q</span>: <span class="number">2</span>&#125;</div><div class="line">    exit</div><div class="line">  end</div><div class="line"> </div><div class="line">  barArg.x = <span class="number">100</span></div><div class="line">  barArg.y = <span class="number">200</span></div><div class="line"> </div><div class="line">end</div><div class="line"> </div><div class="line"><span class="comment">// 使用和上例相同的对象</span></div><div class="line">bar = &#123;</div><div class="line">  x: <span class="number">10</span>,</div><div class="line">  y: <span class="number">20</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 按引用调用的结果如下： </span></div><div class="line">foo(bar)</div><div class="line"> </div><div class="line"><span class="comment">// 对象的属性值已经被改变了</span></div><div class="line">print(bar) <span class="comment">// &#123;x: 100, y: 200&#125;</span></div><div class="line"> </div><div class="line"><span class="comment">// 重新赋新值也影响到了该对象</span></div><div class="line">foo(bar, <span class="literal">true</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 此刻该对象已经是一个新对象了</span></div><div class="line">print(bar) <span class="comment">// &#123;z: 1, q: 2&#125;</span></div></pre></td></tr></table></figure><p>该策略可以更有效地传递复杂对象，例如带有大量属性的大结构对象。</p><h3><span id="按共享传递">按共享传递</span></h3><p>大家都熟知上面两个策略，而这个策略可能大家不太了解（确切地讲，它是学术上的策略）。但是，就像我们很快就会看到的那样，这正是在 ECMAScript 参数传递策略中起着关键作用的策略。</p><p>这个策略还有一些代名词：“按对象传递”或“按对象共享传递”。</p><p>该策略是 1974 年由 Barbara Liskov 为 CLU 编程语言提出的。</p><p>该策略的要点是：函数接收的是对象引用的拷贝，该引用拷贝和形参以及其值相关联。</p><p>这里出现的引用，我们不能称之为“按引用传递”，因为函数接收的参数不是直接的对象别名，而是该引用地址的拷贝。</p><p>最重要的区别就是：函数内部给参数重新赋新值不会影响到外部的对象（按引用传递会改变）。但是，由于形参拥有地址拷贝，和外部指向同一个对象（也就是说，外部对象并不是像按值传递那样完整拷贝），改变参数对象的<em>属性值</em>将会影响到外部的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">procedure foo(barArg, isFullChange):</div><div class="line"> </div><div class="line">  <span class="keyword">if</span> isFullChange:</div><div class="line">    barArg = &#123;<span class="attr">z</span>: <span class="number">1</span>, <span class="attr">q</span>: <span class="number">2</span>&#125;</div><div class="line">    exit</div><div class="line">  end</div><div class="line"> </div><div class="line">  barArg.x = <span class="number">100</span></div><div class="line">  barArg.y = <span class="number">200</span></div><div class="line"> </div><div class="line">end</div><div class="line"></div><div class="line"><span class="comment">//还是使用这个对象结构</span></div><div class="line">bar = &#123;</div><div class="line">  x: <span class="number">10</span>,</div><div class="line">  y: <span class="number">20</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 按共享传递会影响对象 </span></div><div class="line">foo(bar)</div><div class="line"> </div><div class="line"><span class="comment">// 对象的属性被修改了</span></div><div class="line">print(bar) <span class="comment">// &#123;x: 100, y: 200&#125;</span></div><div class="line"> </div><div class="line"><span class="comment">// 重新赋值没有起作用</span></div><div class="line">foo(bar, <span class="literal">true</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 依然是上面的值</span></div><div class="line">print(bar) <span class="comment">// &#123;x: 100, y: 200&#125;</span></div></pre></td></tr></table></figure><p>这个策略假定参数是对象而不是原始值。</p><p class="j-quote">可以在 <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-1-lexical-environments-common-theory/" target="_blank" rel="external">Lexical Environments</a> 这篇文章的 <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-1-lexical-environments-common-theory/#name-binding" target="_blank" rel="external">Name binding</a> 获取更多关于该策略的细节。 </p><h4><span id="按共享传递是按值传递的特例">按共享传递是按值传递的特例</span></h4><p>按共享传递的策略在很多语言中都是用到了，比如 Java，ECMAScript，Python，Ruby，Visual Basic 等。</p><p>此外，Python 已经使用该策略。至于其他语言也可以用这个术语，因为其他的名称往往会让大家感觉到混乱。</p><p>大多数情况下，例如在 Java，ECMAScript 或 Visual Basic 中，这一策略也称之为按值传递 —— 意味着：特殊值 —— 引用拷贝（副本）。</p><p>一方面，传递给函数内部用的参数仅仅是绑定值（引用地址）的一个名称，并不会影响外部的对象。</p><p>另一方面，如果不深入研究，这些术语真的容易被误解，因为很多论坛都在说如何将对象传递给 JavaScript 函数。</p><p>一般理论确实有按值传递的说法：但这时候这个值就是我们所说的地址拷贝（副本），因此并没有破坏规则。</p><p>在 Ruby 中，这个策略称为按引用传递。再说一下：它不是按照结构的拷贝来传递（例如，不是按值传递)，而另一方面，我们没有处理原始对象的引用，并且不能修改它；因此，这个跨术语的概念可能更会造成混乱。</p><p>一般理论中没有按引用传递的特例的描述，而有按值传递的特例的。</p><p>然而，有必要理解上述提到的所有语言（Java，ECMAScript，Python，Ruby，其他）中所使用的术语，实际上都是<em>按共享传递</em>的策略。</p><h4><span id="按共享策略与指针">按共享策略与指针</span></h4><p>对于 С/С++，这个策略在思想上和按指针值传递是一样的，但有一个重要的区别 —— 该策略可以取消引用指针以及完全改变对象。但在一般情况下，分配一个值（地址）指针到新的内存块（即之前引用的内存块保持不变）；通过指针改变对象属性的话会影响到外部对象。</p><p>因此，和指针类别，我们可以明显看到，这是按地址值传递。 在这种情况下，按共享传递只是“语法糖”，像指针赋值行为一样（但不能取消引用），或者像引用一样修改属性（不需要取消引用操作），有时候，它可以被命名为“安全指针”。</p><p>然而，С/С+ +如果在没有明显指针的解引用的情况下，引用对象属性的时候，还具有特殊的语法糖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj-&gt;x instead of (*obj).x</div></pre></td></tr></table></figure><p>和 C++ 关系最为紧密的这种意识形态可以从“智能指针”的实现中看到，例如，在 <code>boost::shared_ptr</code> 里，重载了赋值操作符以及拷贝构造函数，而且还使用了对象的引用计数器，通过 GC 删除对象。这种数据类型，甚至有类似的名字 – 共享 _ptr。</p><h2><span id="ecmascript-实现">ECMAScript 实现</span></h2><p>现在我们知道了 ECMAScript 中将对象作为参数传递的策略了 —— 按共享传递：修改参数的属性将会影响到外部，而重新赋值将不会影响到外部对象。但是，正如我们上面提到的，其中的 ECMAScript 开发人员一般都称之为是：按值传递，只不过该值是引用地址的拷贝。</p><p>JavaScript 发明人布伦丹·艾希也写到了：传递的是引用的拷贝（地址副本）。所以论坛里大家曾说的按值传递，在这种解释下，也是对的。</p><p>更确切地说，这种行为可以理解为简单的赋值，我们可以看到，内部是完全不同的对象，只不过引用的是相同的值 —— 也就是地址副本。</p><p>ECMAScript 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span>&#125;;</div><div class="line"><span class="keyword">var</span> bar = foo;</div><div class="line"> </div><div class="line">alert(bar === foo); <span class="comment">// true</span></div><div class="line"> </div><div class="line">bar.x = <span class="number">100</span>;</div><div class="line">bar.y = <span class="number">200</span>;</div><div class="line"> </div><div class="line">alert([foo.x, foo.y]); <span class="comment">// [100, 200]</span></div></pre></td></tr></table></figure><p>即两个标识符（名称绑定）绑定到内存中的同一个对象， 共享这个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo value: addr(<span class="number">0xFF</span>) =&gt; &#123;<span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125; (address <span class="number">0xFF</span>) &lt;= bar value: addr(<span class="number">0xFF</span>)</div></pre></td></tr></table></figure><p>而重新赋值分配，绑定是新的对象标识符（新地址），而不影响已经先前绑定的对象 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bar = &#123;<span class="attr">z</span>: <span class="number">1</span>, <span class="attr">q</span>: <span class="number">2</span>&#125;;</div><div class="line"> </div><div class="line">alert([foo.x, foo.y]); <span class="comment">// [100, 200] – 没改变</span></div><div class="line">alert([bar.z, bar.q]); <span class="comment">// [1, 2] – 但现在引用的是新对象</span></div></pre></td></tr></table></figure><p>即现在 <code>foo</code> 和 <code>bar</code>，有不同的值和不同的地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo value: addr(<span class="number">0xFF</span>) =&gt; &#123;<span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125; (address <span class="number">0xFF</span>)</div><div class="line">bar value: addr(<span class="number">0xFA</span>) =&gt; &#123;<span class="attr">z</span>: <span class="number">1</span>, <span class="attr">q</span>: <span class="number">2</span>&#125; (address <span class="number">0xFA</span>)</div></pre></td></tr></table></figure><p>再强调一下，这里所说对象的值是地址，而不是对象结构本身，将变量赋值给另外一个变量 —— 是赋值值的引用。因此两个变量引用的是同一个内存地址。下一个赋值却是新地址，是解析与旧对象的地址绑定，然后绑定到新对象的地址上，这就是和按引用传递的最重要区别。</p><p>此外，如果只考虑 ECMA-262 标准所提供的抽象层次，我们在算法里看到的只有“值”这个概念，实现传递的“值”（可以是原始值，也可以是对象），但是按照我们上面的定义，也可以完全称之为“按值传递”，因为引用地址也是值。</p><p>然而，为了避免误解（为什么外部对象的属性可以在函数内部改变），这里依然需要考虑实现层面的细节 —— 我们看到的按共享传递，或者换句话讲 —— 按安全指针传递，而安全指针不可能去解除引用和改变对象的，但可以去修改该对象的属性值。</p><h2><span id="术语版本">术语版本</span></h2><p>让我们来定义 ECMAScript 中该策略的术语版本。</p><p>可以称之为“按值传递” —— 这里所说的值是一个特殊的值，也就是该值是地址副本。从这个层面我们可以说：ECMAScript 中除了异常之外的对象都是按值传递的，这实际上是 ECMAScript 抽象的层面。</p><p>分为如下两种情况时，可专门称之为“按共享传递”。1：原始值按值传递；2：对象按共享传递。通过这个正好可以看到传统的按值传递和按引用传递的区别。</p><h2><span id="总结">总结</span></h2><p>希望本文有助于大家对传值策略有个宏观的了解，并讨论了 ECMAScript 的传值策略。一如既往，如果有任何问题，欢迎讨论。</p><h2><span id="扩展阅读">扩展阅读</span></h2><p>External articles:</p><ul><li><a href="http://en.wikipedia.org/wiki/Evaluation_strategy" target="_blank" rel="external">Evaluation strategy</a></li><li><a href="http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value" target="_blank" rel="external">Call by value</a></li><li><a href="http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference" target="_blank" rel="external">Call by reference</a></li><li><a href="http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" target="_blank" rel="external">Call by sharing</a></li></ul><p>ECMA-262-5 in detail:</p><ul><li><a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-1-lexical-environments-common-theory/#name-binding" target="_blank" rel="external">Name binding</a> section of the <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-1-lexical-environments-common-theory/" target="_blank" rel="external">Lexical Environments</a> chapter</li></ul><p class="j-dot"><strong>Translated by:</strong> Dmitry A. Soshnikov.<br><strong>Published on:</strong> 2010-04-10<br><br><strong>Originally written by:</strong> Dmitry A. Soshnikov [ru, <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-8-evaluation-strategy/" target="_blank" rel="external">read »</a>]<br><strong>With additions by:</strong> Zeroglif<br><br><strong>Originally published on:</strong> 2009-08-11</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文译自 &lt;a href=&quot;http://dmitrysoshnikov.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dmitry A. Soshnikov&lt;/a&gt; 的 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMA-262-3 in detail. Chapter 8. Evaluation strategy&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文将讨论在 ECMAScript 中向函数传递参数的策略。&lt;/p&gt;
&lt;p&gt;计算机科学里对这种策略一般称为“evaluation strategy”，即在编程语言中求解或计算某些表达式的值的一系列规则。将参数传递给函数是其中的一个案例。&lt;/p&gt;
&lt;p&gt;写这篇文章的原因是因为论坛上有一些类似的讨论，大家都呼吁给出 ECMAScript 中参数传递策略的最精确的说明。本文给出了相应的定义，希望对大家有所帮助。&lt;/p&gt;
&lt;p&gt;很多程序员都确信在 JavaScript 中（甚至其它一些语言)，对象是按引用传参，而原始值类型按值传参，此外，很多文章和书籍都说到这个“事实”，但有多人真正理解这个术语，而且又有多少是正确的？我们本篇讲逐一讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ECMAScript" scheme="http://bubkoo.com/tags/ecmascript/"/>
    
      <category term="ECMA-262-3" scheme="http://bubkoo.com/tags/ecma-262-3/"/>
    
      <category term="Evaluation strategy" scheme="http://bubkoo.com/tags/evaluation-strategy/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3 详解 第七章 面向对象(二)：ECMAScript 实现</title>
    <link href="http://bubkoo.com/2014/06/22/ecma-262-3-in-detail-chapter-7-2-oop-ecmascript-implementation/"/>
    <id>http://bubkoo.com/2014/06/22/ecma-262-3-in-detail-chapter-7-2-oop-ecmascript-implementation/</id>
    <published>2014-06-22T18:57:22.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>此文译自 <a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">Dmitry A. Soshnikov</a> 的 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 7.2. OOP: ECMAScript implementation</a>.</p><h2><span id="概述">概述</span></h2><p>这一章的第二部分是关于 EMCAScript 中的面向对象编程。在第一部分中我们讨论了 OOP 的基本理论并勾画出和 ECMAScript 的相似之处。在阅读第二部分之前，如果有必要，我还是建议首先阅读这一章的<a href="http://bubkoo.com/2014/06/21/ecma-262-3-in-detail-chapter-7-1-oop-the-general-theory/">第一部分 概论</a>，因为后面将会用到其中的一些术语。</p><a id="more"></a><h2><span id="ecmascript-中-oop-的实现">ECMAScript 中 OOP 的实现</span></h2><p>在回顾了概论中的一些重点之后，我们终于回到了 ECMAScript 本身。现在，我们已经了解了它的 OOP 方式，让我们再来准确地给出一个定义：</p><blockquote><p>ECMAScript 是一种面向对象语言，支持基于原型的委托式继承。</p></blockquote><p>我们将从最基本的数据类型来分析，首先需要注意的是，ECMAScript中将实体（数据）分为原始值（primitive values）和对象。因此，一些文章中所说的“在 JavaScript 里，一切都是对象”是不正确的（不完整的）。原始值涉及到数据的几种具体类型，让我们来讨论一下相关的细节。</p><h3><span id="数据类型">数据类型</span></h3><p>虽然 ECMAScript 是动态转化类型的弱类型（“鸭子类型”）语言，但它也是有数据类型的。也就是说，一个对象在某个时刻要属于一个实实在在的类型。</p><p>标准中定义了九种类型，而在 ECMAScript 程序中只有六种是可以直接访问的：</p><ul><li>Undefined</li><li>Null</li><li>Boolean</li><li>Number</li><li>String</li><li>Object</li></ul><p>另外三种类型只能在实现级别中被访问（没有一个 ECMAScript 对象能够访问这些类型），它们在规范中被用来解释一些运算的行为，或用来储存中间值，等等。这几种类型如下：</p><ul><li>Reference</li><li>List</li><li>Completion</li></ul><p>简单地说，引用（Reference）类型用来解释诸如 <code>delete</code>，<code>typeof</code>，<code>this</code> 等运算，它由一个基本对象（base object）和属性名组成。列表（List）类型用来解释参数列表的行为（在 <code>new</code> 表达式和函数调用中）。完成（Completion）类型用来解释 <code>break</code>，<code>continue</code>，<code>return</code> 和 <code>throw</code> 语句的行为。</p><h4><span id="原始类型">原始类型</span></h4><p>回头来看六种用于 ECMAScript 程序的数据类型，前五种是原始值类型，包括 <code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code>。</p><p>原始值类型例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> d = <span class="string">'test'</span>;</div><div class="line"><span class="keyword">var</span> e = <span class="number">10</span>;</div></pre></td></tr></table></figure><p>这些值是在底层上直接实现的，他们不是 <code>object</code>，所以没有原型，没有构造函数。</p><p>如果没有正确地理解而只是用 <code>typeof</code> 运算来返回类型，那么得到的结果将可能是错误的。其中一个例子是关于 <code>null</code> 值。当对 <code>null</code> 进行 <code>typeof</code> 运算时，返回值是 <code>object</code>，而 <code>null</code> 实际的类型应该是 <code>Null</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// "object"</span></div></pre></td></tr></table></figure><p>其原因是 <code>null</code> 的返回值是根据规范表格中的描述 —— “对于（<code>typeof</code> 运算中）<code>null</code> 的值应该返回 <code>object</code> 字符串”来实现的。</p><p>规范中并没有澄清这一点，但是 Brendan Eich（JavaScript 发明者）提到，<code>null</code> 和 <code>undefined</code> 不同，<code>null</code> 主要用在对象的场合中，换句话说，本质上更接近于对象（它意味着一个对象的“空引用”，可能是为将来的操作预留位置）。但是，在一些草案中，将这个现象描述为一个普通的 bug。最后结果是，让它保持原样（返回 <code>object</code>），虽然 ECMA-262-3 中定义 <code>null</code> 的类型为 <code>Null</code>。</p><h4><span id="对象类型">对象类型</span></h4><p>Object 类型是唯一用来表示 ECMAScript 对象的类型。</p><blockquote><p>Object 是一种无序的键值对的集合。</p></blockquote><p>对象中的键称为属性。属性（的值）可以是原始值也可以是其他对象。当属性的值是函数时，它们被称为方法。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = &#123; <span class="comment">// 对象"x"有三个属性: a, b, c</span></div><div class="line">  a: <span class="number">10</span>, <span class="comment">// 原始值</span></div><div class="line">  b: &#123;<span class="attr">z</span>: <span class="number">100</span>&#125;,     <span class="comment">// 另一个对象</span></div><div class="line">  c: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 函数(方法)</span></div><div class="line">    alert(<span class="string">'method x.c'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">alert(x.a);   <span class="comment">// 10</span></div><div class="line">alert(x.b);   <span class="comment">// [object Object]</span></div><div class="line">alert(x.b.z); <span class="comment">// 100</span></div><div class="line">x.c();        <span class="comment">// 'method x.c'</span></div></pre></td></tr></table></figure><h5><span id="动态的本资">动态的本资</span></h5><p>正如我们在本章的第一部分中所注意到的，ES 中的对象是完全动态的。这意味着我们可以在程序执行的任何时候添加、修改和删除对象的属性。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// add new property</span></div><div class="line">foo.y = <span class="number">20</span>;</div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// &#123;x: 10, y: 20&#125;</span></div><div class="line"> </div><div class="line"><span class="comment">// change property value to function</span></div><div class="line">foo.x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'foo.x'</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">foo.x(); <span class="comment">// 'foo.x'</span></div><div class="line"> </div><div class="line"><span class="comment">// delete property</span></div><div class="line"><span class="keyword">delete</span> foo.x;</div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// &#123;y: 20&#125;</span></div></pre></td></tr></table></figure><p>有些属性（只读属性 (read-only)、已删除属性或不可配置 (non-configurable) 的属性）不能被修改。我们将稍后在内部属性里讲解。</p><p>注意，ES5 中标准化的静态对象（static object）不能扩展新属性，也不能修改或删除现有属性。这些被称为冻结的对象（frozen objects）。可以通过使用 <code>Object.freeze(o)</code> 方法来获得这些对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// freeze the object</span></div><div class="line"><span class="built_in">Object</span>.freeze(foo);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(foo)); <span class="comment">// true</span></div><div class="line"> </div><div class="line"><span class="comment">// can't modify</span></div><div class="line">foo.x = <span class="number">100</span>;</div><div class="line"> </div><div class="line"><span class="comment">// can't extend</span></div><div class="line">foo.y = <span class="number">200</span>;</div><div class="line"> </div><div class="line"><span class="comment">// can't delete</span></div><div class="line"><span class="keyword">delete</span> foo.x;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// &#123;x: 10&#125;</span></div></pre></td></tr></table></figure><p>同样，可以通过 <code>Object.preventExtensions(o)</code> 方法来防止扩展，或者通过 <code>Object.defineProperty(o)</code> 方法来具体控制属性的内部参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span> : <span class="number">10</span>&#125;;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.defineProperty(foo, <span class="string">"y"</span>, &#123;</div><div class="line">  value: <span class="number">20</span>,</div><div class="line">  writable: <span class="literal">false</span>, <span class="comment">// read-only</span></div><div class="line">  configurable: <span class="literal">false</span> <span class="comment">// non-configurable</span></div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// can't modify</span></div><div class="line">foo.y = <span class="number">200</span>;</div><div class="line"> </div><div class="line"><span class="comment">// can't delete</span></div><div class="line"><span class="keyword">delete</span> foo.y; <span class="comment">// false</span></div><div class="line"> </div><div class="line"><span class="comment">// prevent extensions</span></div><div class="line"><span class="built_in">Object</span>.preventExtensions(foo);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(foo)); <span class="comment">// false</span></div><div class="line"> </div><div class="line"><span class="comment">// can't add new properties</span></div><div class="line">foo.z = <span class="number">30</span>;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(foo); &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span>&#125;</div></pre></td></tr></table></figure><h5><span id="内置对象-原生对象和宿主对象">内置对象、原生对象和宿主对象</span></h5><p>同样需要注意的是，区分的原生对象（native objects），内置对象（built-in objects）和宿主对象（host objects）。</p><p>内置对象和原生对象是由 ECMAScript 规范和实现器来定义的，它们之间的区别并不大。原生对象（native objects）是指由 ECMAScript 实现器提供的全部对象（其中一些是内助对象，另一些可以是在程序扩展中创建的，比如用户定义的对象）。</p><p>内置对象（built-in objects）是原生对象的子类型，它们会在程序开始前预先建立到 ECMAScript 中（比如<code>parseInt</code>，<code>Math</code> 等等）。</p><p>宿主对象（host objects）是由宿主环境（通常是一个浏览器）提供的对象，比如 <code>window</code>，<code>alert</code> 等。</p><p>注意，宿主对象可能是 ES 自身实现的，完全符合规范的语义。从这点来说，他们能称为“原生宿主”对象（尽快很理论），不过规范没有定义“原生宿主”对象的概念。</p><h5><span id="boolean-string-和-number-对象"><code>Boolean</code>、<code>String</code> 和 <code>Number</code> 对象</span></h5><p>另外，规范也定义了一些原生的特殊包装类，这些对象是：</p><ul><li>Boolean-object</li><li>String-object</li><li>Number-object</li></ul><p>这些对象的创建，是通过相应的内置构造器创建，并且包含原生值作为其内部属性，这些对象可以转换省原始值，反之亦然。</p><p>示例 —— 与原始类型对应的对象的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>);</div><div class="line"><span class="keyword">var</span> e = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</div><div class="line"> </div><div class="line"><span class="comment">// converting to primitive</span></div><div class="line"><span class="comment">// conversion: ToPrimitive</span></div><div class="line"><span class="comment">// applying as a function, without "new" keyword</span></div><div class="line">с = <span class="built_in">Boolean</span>(c);</div><div class="line">d = <span class="built_in">String</span>(d);</div><div class="line">e = <span class="built_in">Number</span>(e);</div><div class="line"> </div><div class="line"><span class="comment">// back to Object</span></div><div class="line"><span class="comment">// conversion: ToObject</span></div><div class="line">с = <span class="built_in">Object</span>(c);</div><div class="line">d = <span class="built_in">Object</span>(d);</div><div class="line">e = <span class="built_in">Object</span>(e);</div></pre></td></tr></table></figure><p>此外，也有对象是由特殊的内置构造函数创建： Function（函数对象构造器）、Array（数组构造器） RegExp（正则表达式构造器）、Math（数学模块）、 Date（日期的构造器）等等，这些对象也是Object对象类型的值，他们彼此的区别是由内部属性管理的，我们在下面讨论这些内容。</p><h5><span id="字面量-literal">字面量 Literal</span></h5><p>对于以下三种对象的值：对象（object）, 数组（array）, 正则表达式（regexp expression），有一个简短的（和完整的内建构造式创建方式相比，）表示法，分别成为：对象初始化器（object initialiser），数组初始化器（array initialiser），正则表达式字面量（regexp expression literal）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// equivalent to new Array(1, 2, 3);</span></div><div class="line"><span class="comment">// or array = new Array();</span></div><div class="line"><span class="comment">// array[0] = 1;</span></div><div class="line"><span class="comment">// array[1] = 2;</span></div><div class="line"><span class="comment">// array[2] = 3;</span></div><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"> </div><div class="line"><span class="comment">// equivalent to</span></div><div class="line"><span class="comment">// var object = new Object();</span></div><div class="line"><span class="comment">// object.a = 1;</span></div><div class="line"><span class="comment">// object.b = 2;</span></div><div class="line"><span class="comment">// object.c = 3;</span></div><div class="line"><span class="keyword">var</span> object = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// equivalent to new RegExp("^\\d+$", "g")</span></div><div class="line"><span class="keyword">var</span> re = <span class="regexp">/^\d+$/g</span>;</div></pre></td></tr></table></figure><p>注意，如果将名称绑定 —— Object，Array，RegExp 重新复制到新的对象上，之后使用字面量表示法的语法在不同实现器中可能会有所不同。例如在目前的 Rhino 实现器或者旧的 1.7 版的 SpiderMonkey 中，使用字面量表示法将会创建和构造式名称相对应的新的值类型的对象。在另一些实现器中（包括目前的 Spider 和 TraceMonkey）字面量表示法的语义不会随着构造式名称绑定到新的对象上而改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getClass = <span class="built_in">Object</span>.prototype.toString;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span> = <span class="built_in">Number</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Object</span>;</div><div class="line">alert([foo, getClass.call(foo)]); <span class="comment">// 0, "[object Number]"</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> bar = &#123;&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// in Rhino, SpiderMonkey 1.7 - 0, "[object Number]"</span></div><div class="line"><span class="comment">// in other: still "[object Object]", "[object Object]"</span></div><div class="line">alert([bar, getClass.call(bar)]);</div><div class="line"> </div><div class="line"><span class="comment">// the same with Array name</span></div><div class="line"><span class="built_in">Array</span> = <span class="built_in">Number</span>;</div><div class="line"> </div><div class="line">foo = <span class="keyword">new</span> <span class="built_in">Array</span>;</div><div class="line">alert([foo, getClass.call(foo)]); <span class="comment">// 0, "[object Number]"</span></div><div class="line"> </div><div class="line">bar = [];</div><div class="line"> </div><div class="line"><span class="comment">// in Rhino, SpiderMonkey 1.7 - 0, "[object Number]"</span></div><div class="line"><span class="comment">// in other: still "", "[object Object]"</span></div><div class="line">alert([bar, getClass.call(bar)]);</div><div class="line"> </div><div class="line"><span class="comment">// but for RegExp, semantics of the literal</span></div><div class="line"><span class="comment">// isn't being changed in all tested implementations</span></div><div class="line"> </div><div class="line"><span class="built_in">RegExp</span> = <span class="built_in">Number</span>;</div><div class="line"> </div><div class="line">foo = <span class="keyword">new</span> <span class="built_in">RegExp</span>;</div><div class="line">alert([foo, getClass.call(foo)]); <span class="comment">// 0, "[object Number]"</span></div><div class="line"> </div><div class="line">bar = <span class="regexp">/(?!)/g</span>;</div><div class="line">alert([bar, getClass.call(bar)]); <span class="comment">// /(?!)/g, "[object RegExp]"</span></div></pre></td></tr></table></figure><h6><span id="正则表达式字面量和regexp对象">正则表达式字面量和RegExp对象</span></h6><p>注意，虽然在 ES3 中，两种正则表达式的情况（字面量形式和对象形式）在语义上是相等的，但是还是有所不同。正则字面量只是一个实例，它在解析阶段创建；而 <code>RegExp</code> 构造式创建的总是一个新的对象。这将产生一些问题，比如当 <code>test</code> 失败时正则对象的 <code>lastIndex</code> 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</div><div class="line">  <span class="keyword">var</span> re = <span class="regexp">/ecma/g</span>;</div><div class="line">  alert(re.lastIndex); <span class="comment">// 0, 4, 0, 4</span></div><div class="line">  alert(re.test(<span class="string">"ecmascript"</span>)); <span class="comment">// true, false, true, false</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// in contrast with</span></div><div class="line"> </div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</div><div class="line">  <span class="keyword">var</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"ecma"</span>, <span class="string">"g"</span>);</div><div class="line">  alert(re.lastIndex); <span class="comment">// 0, 0, 0, 0</span></div><div class="line">  alert(re.test(<span class="string">"ecmascript"</span>)); <span class="comment">// true, true, true, true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意，ES5 中问题已经被解决，正则字面量也总是创建新的对象。</p><h5><span id="关联数组">关联数组</span></h5><p>在各种文章和讨论中，常常把 JavaScript 对象（这里通常是特指通过声明的形式 —— 通过对象初始化器 <code>{}</code> 创建的对象）称为哈希表（hash-tables）或者简称 —— hash(从 Ruby 和 Perl 中来的术语)、关联数组（associative arrays，从 PHP 中来的术语）、字典（dictionaries，从 Python 中来的术语），等等。</p><p>使用这些术语主要是从具体的技术中带来的习惯。事实上，它们确实足够相似，在“键值对”储存的方式上完全符合关联数组或哈希表的数据结构。并且哈希表的抽象数据类型可能并且常常也在实现器级别上使用到。</p><p>然而，虽然术语本身是对思想的一种概念式的描述，但是涉及到 ECMAScript，（用关联数组来描述对象）在技术上是不正确的。因为 ECMAScript 中只有一种对象类型，而在它的以“键值对”方式储存的“子类型”方面，其他的对象也可以使用这种方式。因此，没有针对这种储存方式而定义的特殊的独立的术语（hash或者其他）。任何对象，无论它的内部属性是什么，都可以以这种方式储存：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;;</div><div class="line">a[<span class="string">'y'</span>] = <span class="number">20</span>;</div><div class="line">a.z = <span class="number">30</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);</div><div class="line">b.x = <span class="number">10</span>;</div><div class="line">b.y = <span class="number">20</span>;</div><div class="line">b[<span class="string">'z'</span>] = <span class="number">30</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">''</span>);</div><div class="line">c.x = <span class="number">10</span>;</div><div class="line">c.y = <span class="number">20</span>;</div><div class="line">c[<span class="string">'z'</span>] = <span class="number">30</span>;</div><div class="line"> </div><div class="line"><span class="comment">// etc. – with any object "subtype"</span></div></pre></td></tr></table></figure><p>而且，由于 ES 中对象的委托的特性它可以是非空的，因此术语 hash 也是不合适的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = &#123;&#125;; <span class="comment">// create "empty" "hash"</span></div><div class="line"> </div><div class="line">alert(a[<span class="string">"x"</span>]); <span class="comment">// 10, but it's not empty</span></div><div class="line">alert(a.toString); <span class="comment">// function</span></div><div class="line"> </div><div class="line">a[<span class="string">"y"</span>] = <span class="number">20</span>; <span class="comment">// add new pair to "hash"</span></div><div class="line">alert(a[<span class="string">"y"</span>]); <span class="comment">// 20</span></div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.prototype.y = <span class="number">20</span>; <span class="comment">// and property into the prototype</span></div><div class="line"> </div><div class="line"><span class="keyword">delete</span> a[<span class="string">"y"</span>]; <span class="comment">// remove</span></div><div class="line">alert(a[<span class="string">"y"</span>]); <span class="comment">// but key and value are still here – 20</span></div></pre></td></tr></table></figure><p>注意，ES5 中提供了标准化的创建没有属性的对象的能力 —— 它们的原型会被设为 <code>null</code>。这是通过 <code>Object.create(null)</code> 方法来实现的。从这个角度上说，这些对象是纯粹的哈希表。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> aHashTable = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="built_in">console</span>.log(aHashTable.toString); <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>同样，一些属性可能有特殊的读写器（getters/setters），所以可能产生混乱：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"foo"</span>);</div><div class="line">a[<span class="string">'length'</span>] = <span class="number">10</span>;</div><div class="line">alert(a[<span class="string">'length'</span>]); <span class="comment">// 3</span></div></pre></td></tr></table></figure><p>然而，即使考虑 hash 可以有原型的情况（例如在 Ruby 或 Python 中，有 hash-objects 委托的类），在 ES 中这个属于还是不合适的，因为各种属性访问器（即 <code>.</code> 和 <code>[]</code>）之间没有语义上的区别。</p><p>同样，在 ES 中一个“属性（property）”的概念在语义上并不细分为“键（key）”，“数组索引（array index）”，“方法（method）”或“属性（property）”。它们都是属性，在原型链的测试中都符合读写算法的一般规则。</p><p>在下面的 Ruby 的例子中我们能看到语义上的区别，因此在术语上可以做出区分。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">a = &#123;&#125;</div><div class="line">a.<span class="keyword">class</span> <span class="comment"># Hash</span></div><div class="line"> </div><div class="line">a.length <span class="comment"># 0</span></div><div class="line"> </div><div class="line"><span class="comment"># new "key-value" pair</span></div><div class="line">a[<span class="string">'length'</span>] = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="comment"># but semantics for the dot notation</span></div><div class="line"><span class="comment"># remains other and means access</span></div><div class="line"><span class="comment"># to the "property/method", but not to the "key"</span></div><div class="line"> </div><div class="line">a.length <span class="comment"># 1</span></div><div class="line"> </div><div class="line"><span class="comment"># and the bracket notation</span></div><div class="line"><span class="comment"># provides access to "keys" of a hash</span></div><div class="line"> </div><div class="line">a[<span class="string">'length'</span>] <span class="comment"># 10</span></div><div class="line"> </div><div class="line"><span class="comment"># we can augment dynamically Hash class</span></div><div class="line"><span class="comment"># with new properties/methods and they via</span></div><div class="line"><span class="comment"># delegation will be available for already created objects</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hash</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">z</span></span></div><div class="line">    <span class="number">100</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"> </div><div class="line"><span class="comment"># a new "property" is available</span></div><div class="line"> </div><div class="line">a.z <span class="comment"># 100</span></div><div class="line"> </div><div class="line"><span class="comment"># but not a "key"</span></div><div class="line"> </div><div class="line">a[<span class="string">'z'</span>] <span class="comment"># nil</span></div></pre></td></tr></table></figure><p>总之，ECMA-262-3 标准中没有关于 hash (或者其他类似概念)的定义。然而如果只是从理论的数据结构的角度上说，也可以这样称呼对象。</p><h5><span id="类型转换">类型转换</span></h5><p>将对象转换为原始值可以通过 <code>valueOf</code> 方法。正如我们注意到的，将构造式（或具体类型）作为函数调用，换句话说不带 <code>new</code> 看运算符，结果也是将一个对象类型转换为一个原始值。这种转换事实上隐含了 <code>valueOf</code> 方法的调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> primitiveA = <span class="built_in">Number</span>(a); <span class="comment">// implicit "valueOf" call</span></div><div class="line"><span class="keyword">var</span> alsoPrimitiveA = a.valueOf(); <span class="comment">// explicit</span></div><div class="line"> </div><div class="line">alert([</div><div class="line">  <span class="keyword">typeof</span> a, <span class="comment">// "object"</span></div><div class="line">  <span class="keyword">typeof</span> primitiveA, <span class="comment">// "number"</span></div><div class="line">  <span class="keyword">typeof</span> alsoPrimitiveA <span class="comment">// "number"</span></div><div class="line">]);</div></pre></td></tr></table></figure><p>这种方法允许对象参与不同的运算，比如相加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);</div><div class="line"> </div><div class="line">alert(a + b); <span class="comment">// 3</span></div><div class="line"> </div><div class="line"><span class="comment">// or even so</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> c = &#123;</div><div class="line">  x: <span class="number">10</span>,</div><div class="line">  y: <span class="number">20</span>,</div><div class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> d = &#123;</div><div class="line">  x: <span class="number">30</span>,</div><div class="line">  y: <span class="number">40</span>,</div><div class="line">  <span class="comment">// the same .valueOf</span></div><div class="line">  <span class="comment">// functionality as "с" object has,</span></div><div class="line">  <span class="comment">// borrow it:</span></div><div class="line">  valueOf: c.valueOf</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">alert(c + d); <span class="comment">// 100</span></div></pre></td></tr></table></figure><p><code>valueOf</code> 方法的默认值根据对象的类型而定。对于一些对象，它返回的是 <code>this</code> 值 —— 例如<code>Object.prototype.valueOf</code>；对于另一些则是可计算的值，例如，<code>Date.prototype.valueOf()</code>，会返回 date 的 time 值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">alert(a.valueOf() === a); <span class="comment">// true, "valueOf" returned this value</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">alert(d.valueOf()); <span class="comment">// time</span></div><div class="line">alert(d.valueOf() === d.getTime()); <span class="comment">// true</span></div></pre></td></tr></table></figure><p>同样，有另一个原始值可以表示对象——字符串表示。这是和 <code>toString</code> 方法相关的，这种方法在一些运算中同样会自动调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">100</span>;</div><div class="line">  &#125;,</div><div class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'__test'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// in this operation</span></div><div class="line"><span class="comment">// toString method is</span></div><div class="line"><span class="comment">// called automatically</span></div><div class="line">alert(a); <span class="comment">// "__test"</span></div><div class="line"> </div><div class="line"><span class="comment">// but here - the .valueOf() method</span></div><div class="line">alert(a + <span class="number">10</span>); <span class="comment">// 110</span></div><div class="line"> </div><div class="line"><span class="comment">// but if there is no</span></div><div class="line"><span class="comment">// valueOf method, it</span></div><div class="line"><span class="comment">// will be replaced with the</span></div><div class="line"><span class="comment">//toString method</span></div><div class="line"><span class="keyword">delete</span> a.valueOf;</div><div class="line">alert(a + <span class="number">10</span>); <span class="comment">// "_test10"</span></div></pre></td></tr></table></figure><p>定义在 <code>Object.prototype</code> 上的 <code>toString</code> 方法有特殊的含义。它返回的是内部属性 <code>[[Class]]</code> 的值，我们将在下面讨论到。</p><p>除了将对象转换为原始值之外，相反也可以把原始值转换为对象。</p><p>其中一种显示转换为对象的方式就是将内建的 Object 构造式作为函数使用（虽然对于一些类型而言加上 <code>new</code> 运算符也可以）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n = <span class="built_in">Object</span>(<span class="number">1</span>); <span class="comment">// [object Number]</span></div><div class="line"><span class="keyword">var</span> s = <span class="built_in">Object</span>(<span class="string">'test'</span>); <span class="comment">// [object String]</span></div><div class="line"> </div><div class="line"><span class="comment">// also for some types it is</span></div><div class="line"><span class="comment">// possible to call Object with new operator</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">true</span>); <span class="comment">// [object Boolean]</span></div><div class="line"> </div><div class="line"><span class="comment">// but applied with arguments,</span></div><div class="line"><span class="comment">// new Object creates a simple object</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// [object Object]</span></div><div class="line"> </div><div class="line"><span class="comment">// in case if argument for Object function</span></div><div class="line"><span class="comment">// is already object value,</span></div><div class="line"><span class="comment">// it simply returns</span></div><div class="line"><span class="keyword">var</span> a = [];</div><div class="line">alert(a === <span class="keyword">new</span> <span class="built_in">Object</span>(a)); <span class="comment">// true</span></div><div class="line">alert(a === <span class="built_in">Object</span>(a)); <span class="comment">// true</span></div></pre></td></tr></table></figure><p>关于调用内建构造器时是否加上 <code>new</code> 运算符，并没有一般规则，而是根据具体的构造器而定。例如 Array 和 Function 构造器无论在作为构造式调用（使用 <code>new</code>），还是作为函数调用（不使用 <code>new</code>），结果都是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [object Array]</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [object Array]</span></div><div class="line"><span class="keyword">var</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// [object Array]</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> d = <span class="built_in">Function</span>(<span class="string">''</span>); <span class="comment">// [object Function]</span></div><div class="line"><span class="keyword">var</span> e = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">''</span>); <span class="comment">// [object Function]</span></div></pre></td></tr></table></figure><p>在使用一些运算符时，也可能会发生显式和隐式的类型转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line"> </div><div class="line"><span class="comment">// implicit</span></div><div class="line"><span class="keyword">var</span> c = a + b; <span class="comment">// 3, number</span></div><div class="line"><span class="keyword">var</span> d = a + b + <span class="string">'5'</span> <span class="comment">// "35", string</span></div><div class="line"> </div><div class="line"><span class="comment">// explicit</span></div><div class="line"><span class="keyword">var</span> e = <span class="string">'10'</span>; <span class="comment">// "10", string</span></div><div class="line"><span class="keyword">var</span> f = +e; <span class="comment">// 10, number</span></div><div class="line"><span class="keyword">var</span> g = <span class="built_in">parseInt</span>(e, <span class="number">10</span>); <span class="comment">// 10, number</span></div><div class="line"> </div><div class="line"><span class="comment">// etc.</span></div></pre></td></tr></table></figure><h5><span id="属性的内部参数">属性的内部参数</span></h5><p>所有的属性都可以有一些内部参数：</p><ul><li>{ReadOnly} ——（有这个内部属性时）对属性写入值的尝试会被忽略；ReadOnly 的属性可以通过宿主环境的行为而改变，因此 ReadOnly 并不等于“常量”</li><li>{DontEnum} —— 属性不能通过 <code>for...in</code> 循环枚举</li><li>{DontDelete} —— 对这个属性的 <code>delete</code> 运算将会被忽略</li><li>{Internal} —— 属性是内部的，它没有名称并且只在实现器级别上使用。这类属性不能通过 ECMAScript 程序访问。</li></ul><p>注意，在 ES5 中，{ReadOnly}，{DontEnum}，{DontDelete} 分别被重命名为 [[Writable]]，[[Enumerable]] 和 [[Configurable]]，并且可以通过 <code>Object.defineProperty</code> 以及类似方法来手动管理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;&#125;;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.defineProperty(foo, <span class="string">"x"</span>, &#123;</div><div class="line">  value: <span class="number">10</span>,</div><div class="line">  writable: <span class="literal">true</span>, <span class="comment">// aka &#123;ReadOnly&#125; = false</span></div><div class="line">  enumerable: <span class="literal">false</span>, <span class="comment">// aka &#123;DontEnum&#125; = true</span></div><div class="line">  configurable: <span class="literal">true</span> <span class="comment">// &#123;DontDelete&#125; = false</span></div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(foo.x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line"><span class="comment">// attributes set is called a descriptor</span></div><div class="line"><span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(foo, <span class="string">"x"</span>);</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(desc.enumerable); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(desc.writable); <span class="comment">// true</span></div><div class="line"><span class="comment">// etc.</span></div></pre></td></tr></table></figure><h5><span id="内部属性和方法">内部属性和方法</span></h5><p>对象也可以有一些内部属性，这些属性是实现器级别的，不能在 ECMAScript 程序中直接访问（然而正如我们下面将看到的，一些实现器也允许访问其中的一些属性）。这些属性在管理上是有两个外加的中括号 <code>[[]]</code>。</p><p>我们将会接触它们中的一部分（所有对象中必需的那些）；其他属性的描述可以在规范中找到。</p><p>每一个对象都需要实现如下的属性和方法：</p><ul><li>[[Prototype]] —— 对象的原型（在下面会详细谈到）</li><li>[[Class]] —— 一个用于表示对象类型的字符串(例如Object, Array, Function，等)；它用于区分对象</li><li>[[Get]] —— 一种获取属性值的方法</li><li>[[Put]] —— 一种设定属性值的方法</li><li>[[CanPut]] —— 检查是否可以写入相关属性</li><li>[[HasProperty]] —— 检查对象是否已经有了相关属性</li><li>[[Delete]] —— 将属性从对象中删除</li><li>[[DefaultValue]] —— 返回和对象相关的原始值（为了获得这个值调用了 <code>valueOf</code> 方法，对于一些对象，可能抛出 <code>TypeError</code> 异常）</li></ul><p>在 ES 程序中，可以通过 <code>Object.prototype.toString()</code> 方法来间接获得对象的 <code>[[Class]]</code> 属性。(译注：注意和对象的一些分支类型的 <code>toString</code> 方法相区别，比如<code>Array.prototype.toString</code>)。这个方法将返回如下字符串<code>[object + [[Class]] + ]</code>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getClass = <span class="built_in">Object</span>.prototype.toString;</div><div class="line"> </div><div class="line">getClass.call(&#123;&#125;); <span class="comment">// [object Object]</span></div><div class="line">getClass.call([]); <span class="comment">// [object Array]</span></div><div class="line">getClass.call(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)); <span class="comment">// [object Number]</span></div><div class="line"><span class="comment">// etc.</span></div></pre></td></tr></table></figure><p>这个特性常常被用来检查对象的类型，然而需要注意的是，在规范中，宿主对象(host objects)的内部属性 <code>[[Class]]</code> 可以是任何值，包括内置对象的 <code>[[Class]]</code> 属性的值，这样理论上就不能 100% 保证检测正确性。例如，<code>document.childNodes.item(...)</code>的属性 <code>[[Class]]</code> 在 IE 中返回为 <code>String</code>（而在其他实现器中则是 <code>Function</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in IE - "String", in other - "Function"</span></div><div class="line">alert(getClass.call(<span class="built_in">document</span>.childNodes.item));</div></pre></td></tr></table></figure><h3><span id="构造函数">构造函数</span></h3><p>所以，如我们上面所说，在 ECMAScript 中的对象是通过所谓的构造函数来创建的。</p><blockquote><p>构造函数是一个函数，用来创建并初始化新创建的对象。</p></blockquote><p>创建（内存分配）的过程是由构造器函数的内部方法 <code>[[Construct]]</code> 负责的。这个内部方法的行为是指定好的，所有的构造器函数都使用这个方法来为新对象分配内存。</p><p>初始化的过程是通过在新创建的对象的上下文中调用函数来管理的，它由构造器函数的内部方法 <code>[[Call]]</code> 负责。</p><p>注意，在用户代码中，只有初始化阶段是可以访问的。虽然，即使在初始化阶段中我们也能够返回不同的对象而无视在创建阶段中生成的 <code>this</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// update newly created object</span></div><div class="line">  <span class="keyword">this</span>.x = <span class="number">10</span>;</div><div class="line">  <span class="comment">// but return different object</span></div><div class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log(a.x, a); <span class="literal">undefined</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure><p>根据<a href="http://bubkoo.com/2014/06/12/ecma-262-3-in-detail-chapter-5-functions/">第五章 函数</a>中讨论过的函数对象创建的算法我们看到，函数是一个原生对象，它有若干内部属性其中包括 <code>[[Call]]</code> 和 <code>[[Construct]]</code>，它还有显式的属性 <code>prototype</code> —— 未来对象的原型的引用（注：NativeObject是对于native object原生对象的约定，在下面的伪代码中使用）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">F = <span class="keyword">new</span> NativeObject();</div><div class="line"> </div><div class="line">F.[[Class]] = <span class="string">"Function"</span></div><div class="line"> </div><div class="line">.... <span class="comment">// 其它属性</span></div><div class="line"> </div><div class="line">F.[[Call]] = <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span> // function自身</span></div><div class="line"><span class="xml"> </span></div><div class="line"><span class="xml">F.[[Construct]] = internalConstructor // 普通的内部构造函数</span></div><div class="line"><span class="xml"> </span></div><div class="line"><span class="xml">.... // 其它属性</span></div><div class="line"><span class="xml"> </span></div><div class="line"><span class="xml">// F构造函数创建的对象原型</span></div><div class="line"><span class="xml">__objectPrototype = &#123;&#125;;</span></div><div class="line"><span class="xml">__objectPrototype.constructor = F // &#123;DontEnum&#125;</span></div><div class="line"><span class="xml">F.prototype = __objectPrototype</span></div></pre></td></tr></table></figure><p>因此，除了 <code>[[Class]]</code> 属性（值为 <code>Function</code>），<code>[[Call]]</code> 属性在对象区分方面起到主要作用，内部属性 <code>[[Call]]</code> 的对象被当做函数调用。这样的对象用 <code>typeof</code> 运算操作符的话返回的是 <code>function</code>。然而它主要是和原生对象有关，有些情况的实现中用 <code>typeof</code> 获取值的是不一样的，例如：<code>window.alert (...)</code>在 IE 中的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IE浏览器中 - "Object", "object", 其它浏览器 - "Function", "function"</span></div><div class="line">alert(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>.alert));</div><div class="line">alert(<span class="keyword">typeof</span> <span class="built_in">window</span>.alert); <span class="comment">// "Object"</span></div></pre></td></tr></table></figure><p>内部方法 <code>[[Construct]]</code> 由构造器函数的 <code>new</code> 运算符激活。如我们所说，这个方法负责内存的分配以及对象的创建。如果没有参数，函数构造器的调用括号可以省略：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">x</span>) </span>&#123; <span class="comment">// constructor А</span></div><div class="line">  <span class="keyword">this</span>.x = x || <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 不传参数的话，括号也可以省略</span></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A; <span class="comment">// or new A();</span></div><div class="line">alert(a.x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line"><span class="comment">// 显式传入参数x</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A(<span class="number">20</span>);</div><div class="line">alert(b.x); <span class="comment">// 20</span></div></pre></td></tr></table></figure><p>我们同样知道，构造器内部的 <code>this</code> 的值（在初始化阶段）是新创建的对象。</p><p>让我们来看看对象创建的算法。</p><h4><span id="对象创建的算法">对象创建的算法</span></h4><p>内部方法 <code>[[Construct]]</code> 的行为可以描述为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">F.[[Construct]](initialParameters):</div><div class="line"> </div><div class="line">O = <span class="keyword">new</span> NativeObject();</div><div class="line"> </div><div class="line"><span class="comment">// 属性[[Class]]被设置为"Object"</span></div><div class="line">O.[[Class]] = <span class="string">"Object"</span></div><div class="line"> </div><div class="line"><span class="comment">// 引用F.prototype的时候获取该对象g</span></div><div class="line"><span class="keyword">var</span> __objectPrototype = F.prototype;</div><div class="line"> </div><div class="line"><span class="comment">// 如果__objectPrototype是对象，就:</span></div><div class="line">O.[[Prototype]] = __objectPrototype</div><div class="line"><span class="comment">// 否则:</span></div><div class="line">O.[[Prototype]] = <span class="built_in">Object</span>.prototype;</div><div class="line"><span class="comment">// 这里O.[[Prototype]]是Object对象的原型</span></div><div class="line"> </div><div class="line"><span class="comment">// 新创建对象初始化的时候应用了F.[[Call]]</span></div><div class="line"><span class="comment">// 将this设置为新创建的对象O</span></div><div class="line"><span class="comment">// 参数和F里的initialParameters是一样的</span></div><div class="line">R = F.[[Call]](initialParameters); <span class="keyword">this</span> === O;</div><div class="line"><span class="comment">// 这里R是[[Call]]的返回值</span></div><div class="line"><span class="comment">// 在JS里看，像这样:</span></div><div class="line"><span class="comment">// R = F.apply(O, initialParameters);</span></div><div class="line"> </div><div class="line"><span class="comment">// 如果R是对象</span></div><div class="line"><span class="keyword">return</span> R</div><div class="line"><span class="comment">// 否则</span></div><div class="line"><span class="keyword">return</span> O</div></pre></td></tr></table></figure><p>注意两个主要特点：</p><p>首先，所创建的对象的原型是从“当前”时刻下构造器函数的 <code>prototype</code> 属性而来的（意味着由一个构造器创建的两个对象的原型可以是不同的，因为函数的 <code>prototype</code> 属性同样是可变的）。</p><p>其次，正如上面提到的，如果对象初始化时 <code>[[Call]]</code> 返回的是对象，那么它将作为整个 <code>new</code> 表达式的返回值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">A.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line">alert(a.x); <span class="comment">// 10 – 从原型上得到</span></div><div class="line"> </div><div class="line"><span class="comment">// 设置.prototype属性为新对象</span></div><div class="line"><span class="comment">// 为什么显式声明.constructor属性将在下面说明</span></div><div class="line">A.prototype = &#123;</div><div class="line">  <span class="keyword">constructor</span>: A,</div><div class="line">  y: 100</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">var b = new A();</div><div class="line">// 对象"b"有了新属性</div><div class="line">alert(b.x); // undefined</div><div class="line">alert(b.y); // 100 – 从原型上得到</div><div class="line"> </div><div class="line">// 但a对象的原型依然可以得到原来的结果</div><div class="line">alert(a.x); // 10 - 从原型上得到</div><div class="line"> </div><div class="line">function B() &#123;</div><div class="line">  <span class="keyword">this</span>.x = <span class="number">10</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 如果"B"构造函数没有返回（或返回this）</span></div><div class="line"><span class="comment">// 那么this对象就可以使用，但是下面的情况返回的是array</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</div><div class="line">alert(b.x); <span class="comment">// undefined</span></div><div class="line">alert(<span class="built_in">Object</span>.prototype.toString.call(b)); <span class="comment">// [object Array]</span></div></pre></td></tr></table></figure><p>让我们来详细了解一下原型</p><h3><span id="原型">原型</span></h3><p>每个对象都有一个原型（一些系统对象除外）。原型通信是通过内部的、隐式的、不可直接访问 <code>[[Prototype]]</code> 原型属性来进行的，原型可以是一个对象，也可以是 <code>null</code> 值。</p><h4><span id="constructor-属性"><code>constructor</code> 属性</span></h4><p>上面的例子中有两个重点。其中之一是关于函数原型属性的 <code>constructor</code> 属性的。</p><p>正如我们在函数对象创建的算法中看到的，在函数创建时设定了函数原型属性的 <code>constructor</code> 属性。这个属性的值是循环引用函数本身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line">alert(a.constructor); <span class="comment">// function A() &#123;&#125;, by delegation</span></div><div class="line">alert(a.constructor === A); <span class="comment">// true</span></div></pre></td></tr></table></figure><p>对于这个情况常常有一种误解 —— <code>constructor</code> 属性被错误地当做了所创建对象的自有属性。然而正如我们看到的，这个属性属于原型而对象通过继承访问。</p><p>通过继承的 <code>constructor</code> 属性，实例对象可以间接引用原型对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">A.prototype.x = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line">alert(a.constructor.prototype); <span class="comment">// [object Object]</span></div><div class="line"> </div><div class="line">alert(a.x); <span class="comment">// 10, via delegation</span></div><div class="line"><span class="comment">// the same as a.[[Prototype]].x</span></div><div class="line">alert(a.constructor.prototype.x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">alert(a.constructor.prototype.x === a.x); <span class="comment">// true</span></div></pre></td></tr></table></figure><p>注意，虽然函数的 <code>prototype</code> 属性和原型的 <code>constructor</code> 属性都可以在对象创建后重定义，但是这种情况下对象可能失去上面的引用机制。</p><p>如果我们在初始的原型中新增或者修改已有属性（通过函数的 <code>prototype</code> 属性），实例将可以看到这些新增或修改后的结果。</p><p>但是，如果我们完全改变函数的 <code>prototype</code> 属性（通过赋值为一个新对象），对于初始构造函数的引用将会丢失（初始的原型也是一样，不能通过 <code>.contructor.prototype</code> 访问）。这是因为新创建的对象没有了 <code>constructor</code> 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">A.prototype = &#123;</div><div class="line">  x: <span class="number">10</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line">alert(a.x); <span class="comment">// 10</span></div><div class="line">alert(a.constructor === A); <span class="comment">// false!</span></div></pre></td></tr></table></figure><p>因此必须手动添加对构造器的引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">A.prototype = &#123;</div><div class="line">  <span class="keyword">constructor</span>: A,</div><div class="line">  x: 10</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">var a = new A();</div><div class="line">alert(a.x); // 10</div><div class="line">alert(a.<span class="keyword">constructor</span> === A); // true</div></pre></td></tr></table></figure><p>注意，虽然手动储存 <code>constructor</code> 属性可以避免丢失对构造器的引用，但是它没有 <code>{DontEnum}</code> 内部参数，因此会在 <code>prototype</code> 的 <code>for...in</code> 循环中枚举到（而函数创建过程中自动设定的这个属性有 <code>{DontEnum}</code>）。</p><p>在 ES5 中引入了控制属性的 <code>[[Enumerable]]</code> 内部参数的方法：<code>defineProperty</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.defineProperty(foo, <span class="string">"y"</span>, &#123;</div><div class="line">  value: <span class="number">20</span>,</div><div class="line">  enumerable: <span class="literal">false</span> <span class="comment">// aka &#123;DontEnum&#125; = true</span></div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(foo.x, foo.y); <span class="comment">// 10, 20</span></div><div class="line"> </div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> foo) &#123;</div><div class="line">  <span class="built_in">console</span>.log(k); <span class="comment">// only "x"</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> xDesc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(foo, <span class="string">"x"</span>);</div><div class="line"><span class="keyword">var</span> yDesc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(foo, <span class="string">"y"</span>);</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(</div><div class="line">  xDesc.enumerable, <span class="comment">// true</span></div><div class="line">  yDesc.enumerable  <span class="comment">// false</span></div><div class="line">);</div></pre></td></tr></table></figure><h4><span id="显式-prototype-和隐式-prototype-属性">显式 <code>prototype</code> 和隐式 <code>[[Prototype]]</code> 属性</span></h4><p>一个对象的原型（<code>[[Prototype]]</code> 内部属性）常常不容易正确地和函数 <code>prototype</code> 属性的显式引用区分开来。是的，它们确实引用的是同一个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.[[Prototype]] ----&gt; Prototype &lt;---- A.prototype</div></pre></td></tr></table></figure><p>而且，实例的 <code>[[Prototype]]</code> 正是从构造器的 <code>prototype</code> 属性上获得值 —— 在对象创建时。</p><p>但是，对于构造器的 <code>prototype</code> 属性的重置不会影响到已创建的对象的原型。改变的只是构造器的 <code>prototype</code> 属性！这意味着之后创建的新对象将会有新的原型。但是已创建的对象（在构造器的 <code>prototype</code> 改变之前创建的），引用的还是旧的原型并且这个引用将不能再被改变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// was before changing of A.prototype</span></div><div class="line">a.[[Prototype]] ----&gt; Prototype &lt;---- A.prototype</div><div class="line"> </div><div class="line"><span class="comment">// became after</span></div><div class="line">A.prototype ----&gt; New prototype <span class="comment">// new objects will have this prototype</span></div><div class="line">a.[[Prototype]] ----&gt; Prototype <span class="comment">// reference to old prototype</span></div></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">A.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line">alert(a.x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">A.prototype = &#123;</div><div class="line">  <span class="keyword">constructor</span>: A,</div><div class="line">  x: 20</div><div class="line">  y: 30</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 译注：</div><div class="line">// 原本对象的 [[Prototype]] 属性和 A.prototype 引用的是同一个对象</div><div class="line">// 这里直接将修改了 A.prototype 的引用</div><div class="line">// 修改不会影响到已经创建的对象，已经创建对象的 [[Prototype]] 属性还是引用到之前的对象</div><div class="line">// 注意：A.prototype.xxx 的方式与上面方式的不同</div><div class="line"> </div><div class="line">// object "а" delegates to</div><div class="line">// the old prototype via</div><div class="line">// implicit [[Prototype]] reference</div><div class="line">alert(a.x); // 10</div><div class="line">alert(a.y) // undefined</div><div class="line"> </div><div class="line">var b = new A();</div><div class="line"> </div><div class="line">// but new objects at creation</div><div class="line">// get reference to new prototype</div><div class="line">alert(b.x); // 20</div><div class="line">alert(b.y) // 30</div></pre></td></tr></table></figure><p>因此，在一些文章中声称的“动态改变原型将会影响到所有对象，它们将拥有新的原型”的说法是不正确的。只有在原型改变后创建的对象才受这些新的原型的影响。</p><p>这里的主要规则是：对象的原型是在对象创建时设定的，在这之后不能改变为新的对象。只有当它和构造器的 <code>prototype</code> 的显示引用指向的是同一个对象时，才能通过构造器的 <code>prototype</code> 新增或者修改对象原型的属性。</p><h4><span id="非标准的-__proto__-属性">非标准的 <code>__proto__</code> 属性</span></h4><p>然而，一些实现器，比如 SpiderMonkey，提供了对于对象原型的显示引用，通过一个非标准的 <code>__proto__</code> 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">A.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line">alert(a.x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> __newPrototype = &#123;</div><div class="line">  <span class="keyword">constructor</span>: A,</div><div class="line">  x: 20,</div><div class="line">  y: 30</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 将原型指向一个新对象</div><div class="line">A.prototype = __newPrototype;</div><div class="line"> </div><div class="line">var b = new A();</div><div class="line">alert(b.x); // 20</div><div class="line">alert(b.y); // 30</div><div class="line"> </div><div class="line">// 对象 "a" 仍然引用老对象</div><div class="line">alert(a.x); // 10</div><div class="line">alert(a.y); // undefined</div><div class="line"> </div><div class="line">// 显式修改原型</div><div class="line">a.__proto__ = __newPrototype;</div><div class="line"> </div><div class="line">// 此时，对象 "а" 引用到了新对象</div><div class="line">alert(a.x); // 20</div><div class="line">alert(a.y); // 30</div></pre></td></tr></table></figure><p>注意，ES5 中的 <code>Object.getPropertyOf(o)</code> 方法，可以直接返回一个对象的 <code>[[Prototype]]</code> 属性 —— 实例的初始原型。然而和 <code>__proto__</code> 不同，这个方法只是一个 getter，它不允许设定原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(foo) == <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></div></pre></td></tr></table></figure><h4><span id="对象独立于构造函数">对象独立于构造函数</span></h4><p>由于一个实例对象的原型是独立于它的构造函数和构造函数的 <code>prototype</code> 属性的，构造函数在完成了它的主要目的 – 创建对象 – 之后可以被删除。原型对象将仍然存在，并通过 <code>[[Prototype]]</code> 属性引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">A.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line">alert(a.x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line"><span class="comment">// 设置A为null - 显示引用构造函数</span></div><div class="line">A = <span class="literal">null</span>;</div><div class="line"> </div><div class="line"><span class="comment">// 但如果.constructor属性没有改变的话，</span></div><div class="line"><span class="comment">// 依然可以通过它创建对象</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> a.constructor();</div><div class="line">alert(b.x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line"><span class="comment">// 隐式的引用也删除掉</span></div><div class="line"><span class="keyword">delete</span> a.constructor.prototype.constructor;</div><div class="line"><span class="keyword">delete</span> b.constructor.prototype.constructor;</div><div class="line"> </div><div class="line"><span class="comment">// 通过A的构造函数再也不能创建对象了</span></div><div class="line"><span class="comment">// 但这2个对象依然有自己的原型</span></div><div class="line">alert(a.x); <span class="comment">// 10</span></div><div class="line">alert(b.x); <span class="comment">// 10</span></div></pre></td></tr></table></figure><h4><span id="instanceof-操作符的特性"><code>instanceof</code> 操作符的特性</span></h4><p>对一个原型的显示引用 —— 通过构造器的 <code>prototype</code> 属性，是和 <code>instanceof</code> 运算的工作相关的。</p><p>这个运算直接工作于原型链上而不是通过构造函数。关于这一点常常有一种误解，那就是，当进行下面这种检查方式时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (foo <span class="keyword">instanceof</span> Foo) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>它不是表示检查对象foo是否由构造器Foo创建！</strong></p><p><code>instanceof</code> 运算所做的只是获取一个对象的原型 —— <code>foo.[[Prototype]]</code>，并且检查它在原型链中的存在情况，（对于运算符右边则分析它的原型属性）对比分析 <code>Foo.prototype</code>。<code>instanceof</code> 运算由构造器的内部方法 <code>[[HasInstance]]</code> 激活。</p><p>让我们来一个示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">A.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line">alert(a.x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">alert(a <span class="keyword">instanceof</span> A); <span class="comment">// true</span></div><div class="line"> </div><div class="line"><span class="comment">// 如果设置原型为null</span></div><div class="line">A.prototype = <span class="literal">null</span>;</div><div class="line"> </div><div class="line"><span class="comment">// ..."a"依然可以通过a.[[Prototype]]访问原型</span></div><div class="line">alert(a.x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line"><span class="comment">// 不过，instanceof操作符不能再正常使用了</span></div><div class="line"><span class="comment">// 因为它是从构造函数的prototype属性来实现的</span></div><div class="line">alert(a <span class="keyword">instanceof</span> A); <span class="comment">// 错误，A.prototype不是对象</span></div></pre></td></tr></table></figure><p>而另一方面，可能通过一个构造器创建的对象，但在 <code>instanceof</code> 检查另一个构造器时返回 <code>true</code>。而这只需要将对象的 <code>[[Property]]</code> 和新的构造器的 <code>prototype</code> 属性设为同一个对象即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</div><div class="line"> </div><div class="line">alert(b <span class="keyword">instanceof</span> B); <span class="comment">// true</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> __proto = &#123;</div><div class="line">  <span class="keyword">constructor</span>: C</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">C.prototype = __proto;</div><div class="line">b.__proto__ = __proto;</div><div class="line"> </div><div class="line">alert(b instanceof C); // true</div><div class="line">alert(b instanceof B); // false</div></pre></td></tr></table></figure><h4><span id="原型可以存放方法并共享属性">原型可以存放方法并共享属性</span></h4><p>ECMAScript 中原型最有用的就是作为对象方法、默认状态和共享属性的储存器。</p><p>的确，对象可以有自身的状态，但方法通常都是相同的。因此，为了内存占用的性能优化，方法通常定义在原型中。这意味着，通过一个构造器创建的所有实例，总是共用相同的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x || <span class="number">100</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">A.prototype = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="comment">// 初始化上下文</span></div><div class="line">  <span class="comment">// 使用额外的对象</span></div><div class="line"> </div><div class="line">  <span class="keyword">var</span> _someSharedVar = <span class="number">500</span>;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_someHelper</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'internal helper: '</span> + _someSharedVar);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">method1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'method1: '</span> + <span class="keyword">this</span>.x);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">method2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'method2: '</span> + <span class="keyword">this</span>.x);</div><div class="line">    _someHelper();</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// 原型自身</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="keyword">constructor</span>: A,</div><div class="line">    method1: method1,</div><div class="line">    method2: method2</div><div class="line">  &#125;;</div><div class="line"> </div><div class="line">&#125;)();</div><div class="line"> </div><div class="line">var a = new A(10);</div><div class="line">var b = new A(20);</div><div class="line"> </div><div class="line">a.method1(); // method1: 10</div><div class="line">a.method2(); // method2: 10, internal helper: 500</div><div class="line"> </div><div class="line">b.method1(); // method1: 20</div><div class="line">b.method2(); // method2: 20, internal helper: 500</div><div class="line"> </div><div class="line">// 2个对象使用的是原型里相同的方法</div><div class="line">alert(a.method1 === b.method1); // true</div><div class="line">alert(a.method2 === b.method2); // true</div></pre></td></tr></table></figure><h3><span id="读写属性">读写属性</span></h3><p>正如我们提到过的，对于属性的读写是通过内部方法 <code>[[Get]]</code> 和 <code>[[Put]]</code> 来管理的。这两个方法是通过属性访问器激活的 —— 点符号或中括号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写入</span></div><div class="line">foo.bar = <span class="number">10</span>; <span class="comment">// 调用了[[Put]]</span></div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(foo.bar); <span class="comment">// 10, 调用了[[Get]]</span></div><div class="line"><span class="built_in">console</span>.log(foo[<span class="string">'bar'</span>]); <span class="comment">// 效果一样</span></div></pre></td></tr></table></figure><p>让我们通过伪代码来展示这些方法的工作原理。</p><h4><span id="get-方法"><code>[[Get]]</code> 方法</span></h4><p>除了对象的自有属性外，<code>[[Get]]</code> 方法也考虑到了对象原型链中的属性。因此原型中的属性也像对象的自有属性一样可以被访问到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">O.[[Get]](P):</div><div class="line"> </div><div class="line"><span class="comment">// 如果是自己的属性，就返回</span></div><div class="line"><span class="keyword">if</span> (O.hasOwnProperty(P)) &#123;</div><div class="line">  <span class="keyword">return</span> O.P;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 否则，继续分析原型</span></div><div class="line"><span class="keyword">var</span> __proto = O.[[Prototype]];</div><div class="line"> </div><div class="line"><span class="comment">// 如果原型是null，返回undefined</span></div><div class="line"><span class="comment">// 这是可能的：最顶层Object.prototype.[[Prototype]]是null</span></div><div class="line"><span class="keyword">if</span> (__proto === <span class="literal">null</span>) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 否则，对原型链递归调用[[Get]]，在各层的原型中查找属性</span></div><div class="line"><span class="comment">// 直到原型为null</span></div><div class="line"><span class="keyword">return</span> __proto.[[Get]](P)</div></pre></td></tr></table></figure><p>请注意，因为 <code>[[Get]]</code> 在如下情况也会返回<code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.someObject) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里，在 <code>window</code> 里没有找到 <code>someObject</code> 属性，然后会在原型里找，原型的原型里找，以此类推，如果都找不到，按照定义就返回 <code>undefined</code>。</p><p>注意，对于实际的存在性是由 <code>in</code> 运算负责的。它同样考虑原型链中的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="string">'someObject'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它帮助避免了一些情况中上面的检测失效，比如属性值为 <code>false</code> 的情况将不会通过，即使属性是确实存在的。</p><h4><span id="put-方法"><code>[[Put]]</code> 方法</span></h4><p><code>[[Put]]</code> 方法可以创建、更新对象自身的属性，并且掩盖原型里的同名属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">O.[[Put]](P, V):</div><div class="line"> </div><div class="line"><span class="comment">// 如果不能给属性写值，就退出</span></div><div class="line"><span class="keyword">if</span> (!O.[[CanPut]](P)) &#123;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 如果对象没有自身的属性，就创建它</span></div><div class="line"><span class="comment">// 所有的attributes特性都是false</span></div><div class="line"><span class="keyword">if</span> (!O.hasOwnProperty(P)) &#123;</div><div class="line">  createNewProperty(O, P, <span class="attr">attributes</span>: &#123;</div><div class="line">    ReadOnly: <span class="literal">false</span>,</div><div class="line">    DontEnum: <span class="literal">false</span>,</div><div class="line">    DontDelete: <span class="literal">false</span>,</div><div class="line">    Internal: <span class="literal">false</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 如果属性存在就设置值，但不改变attributes特性</span></div><div class="line">O.P = V</div><div class="line"> </div><div class="line"><span class="keyword">return</span>;</div></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">100</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> foo = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(foo.x); <span class="comment">// 100, 继承属性</span></div><div class="line"> </div><div class="line">foo.x = <span class="number">10</span>; <span class="comment">// [[Put]]</span></div><div class="line"><span class="built_in">console</span>.log(foo.x); <span class="comment">// 10, 自身属性</span></div><div class="line"> </div><div class="line"><span class="keyword">delete</span> foo.x;</div><div class="line"><span class="built_in">console</span>.log(foo.x); <span class="comment">// 重新是100,继承属性</span></div></pre></td></tr></table></figure><p>请注意，不能掩盖原型里的只读属性，赋值结果将忽略，这是由内部方法 <code>[[CanPut]]</code> 控制的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 例如，属性length是只读的，我们来掩盖一下length试试</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperString</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">/* nothing */</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line">SuperString.prototype = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> SuperString();</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(foo.length); <span class="comment">// 3, "abc"的长度</span></div><div class="line"> </div><div class="line"><span class="comment">// 尝试掩盖</span></div><div class="line">foo.length = <span class="number">5</span>;</div><div class="line"><span class="built_in">console</span>.log(foo.length); <span class="comment">// 依然是3</span></div></pre></td></tr></table></figure><p>在 ES5 的严格模式下，如果掩盖只读属性的话，会抛出 <code>TypeError</code> 错误。</p><h4><span id="属性访问器">属性访问器</span></h4><p>内部方法 <code>[[Get]]</code> 和 <code>[[Put]]</code> 在 ECMAScript 里是通过点符号或者索引法来激活的，如果属性标示符是合法的名字的话，可以通过 <code>.</code> 来访问，而索引方运行动态定义名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">testProperty</span>: <span class="number">10</span>&#125;;</div><div class="line"> </div><div class="line">alert(a.testProperty); <span class="comment">// 10, 点</span></div><div class="line">alert(a[<span class="string">'testProperty'</span>]); <span class="comment">// 10, 索引</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> propertyName = <span class="string">'Property'</span>;</div><div class="line">alert(a[<span class="string">'test'</span> + propertyName]); <span class="comment">// 10, 动态属性通过索引的方式</span></div></pre></td></tr></table></figure><p>这里有一个非常重要的特性——属性访问器总是使用 ToObject 规范来对待 <code>.</code> 左边的值。这种隐式转化和这句“在 JavaScript 中一切都是对象”有关系，（然而，当我们已经知道了，JavaScript 里不是所有的值都是对象）。</p><p>如果对原始值进行属性访问器取值，访问之前会先对原始值进行对象包装（包括原始值），然后通过包装的对象进行访问属性，属性访问以后，包装对象就会被删除。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// 原始值</span></div><div class="line"> </div><div class="line"><span class="comment">// 但是可以访问方法（就像对象一样）</span></div><div class="line">alert(a.toString()); <span class="comment">// "10"</span></div><div class="line"> </div><div class="line"><span class="comment">// 此外，我们可以在a上创建一个心属性</span></div><div class="line">a.test = <span class="number">100</span>; <span class="comment">// 好像是没问题的</span></div><div class="line"> </div><div class="line"><span class="comment">// 但，[[Get]]方法没有返回该属性的值，返回的却是undefined</span></div><div class="line">alert(a.test); <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>那么，为什么整个例子里的原始值可以访问 <code>toString</code> 方法，而不能访问新创建的 <code>test</code> 属性呢？</p><p>答案很简单：</p><p>首先，正如我们所说，使用属性访问器以后，它已经不是原始值了，而是一个包装过的中间对象（整个例子是使用 <code>new Number(a)</code>），而 <code>toString</code> 方法这时候是通过原型链查找到的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 执行a.toString()的原理:</span></div><div class="line"> </div><div class="line"><span class="number">1.</span> wrapper = <span class="keyword">new</span> <span class="built_in">Number</span>(a);</div><div class="line"><span class="number">2.</span> wrapper.toString(); <span class="comment">// "10"</span></div><div class="line"><span class="number">3.</span> <span class="keyword">delete</span> wrapper;</div></pre></td></tr></table></figure><p>接下来，<code>[[Put]]</code> 方法创建新属性时候，也是通过包装装的对象进行的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 执行a.test = 100的原理：</span></div><div class="line"> </div><div class="line"><span class="number">1.</span> wrapper = <span class="keyword">new</span> <span class="built_in">Number</span>(a);</div><div class="line"><span class="number">2.</span> wrapper.test = <span class="number">100</span>;</div><div class="line"><span class="number">3.</span> <span class="keyword">delete</span> wrapper;</div></pre></td></tr></table></figure><p>我们看到，在第 3 步的时候，包装的对象以及删除了，随着新创建的属性页被删除了 —— 删除包装对象本身。</p><p>然后使用 <code>[[Get]]</code> 获取 <code>test</code> 值的时候，再一次创建了包装对象，但这时候包装的对象已经没有 <code>test</code> 属性了，所以返回的是 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 执行a.test的原理:</span></div><div class="line"> </div><div class="line"><span class="number">1.</span> wrapper = <span class="keyword">new</span> <span class="built_in">Number</span>(a);</div><div class="line"><span class="number">2.</span> wrapper.test; <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>这种方式解释了原始值的读取方式，另外，任何原始值如果经常用在访问属性的话，时间效率考虑，都是直接用一个对象替代它；与此相反，如果不经常访问，或者只是用于计算的话，到可以保留这种形式。</p><h3><span id="继承">继承</span></h3><p>如我们所知，ECMAScript 使用基于原型的委托式继承。</p><p>（对象的）原型(式继承)是链式的，称为原型链。</p><p>事实上，所有委托的实现和原型链分析的工作都简化为了上面提到的 <code>[[Get]]</code> 的工作。</p><p>如果你完全理解了上面 <code>[[Get]]</code> 方法的简单算法，关于 JavaScript 中继承的问题就不证自明了。</p><p>论坛中常常谈论 JavaScript 中的继承，我通过一个一行代码的例子来具体描述这门语言中的对象结构以及基于委托的继承。事实上我们可以不创建任何构造器或者对象，因为这门语言中已经到处是继承了。这行代码很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="number">1.</span>.toString()); <span class="comment">// "1"</span></div></pre></td></tr></table></figure><p>现在，我们已经知道了 <code>[[Get]]</code> 的算法和属性访问器，我们能看到这里面发生了什么：</p><ol><li>首先，从原始值 1 创建了包装对象new Number(1)</li><li>然后这个包装对象调用了继承的方法toString</li></ol><p>为什么发生了继承？因为 ES 中的对象可以有自有属性，而这种情况下创建的包装对象没有自有属性 <code>toString</code>，因此，它从原型中，即 <code>Number.prototype</code> 中继承了 <code>toString</code> 方法。</p><p>注意语法中的细节。上面例子中的两个点不是一个错误。第一个点是用作一个数值的分数部分，第二个点是属性访问器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>toString(); <span class="comment">// SyntaxError!</span></div><div class="line"> </div><div class="line">(<span class="number">1</span>).toString(); <span class="comment">// OK</span></div><div class="line"> </div><div class="line"><span class="number">1.</span>.toString(); <span class="comment">// OK</span></div><div class="line"> </div><div class="line"><span class="number">1</span>[<span class="string">'toString'</span>](); <span class="comment">// OK</span></div></pre></td></tr></table></figure><h4><span id="原型链">原型链</span></h4><p>让我们来看下如何为用户定义的对象创建原型链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'A.[[Call]] activated'</span>);</div><div class="line">  <span class="keyword">this</span>.x = <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line">A.prototype.y = <span class="number">20</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line">alert([a.x, a.y]); <span class="comment">// 10 (自身), 20 (继承)</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 最近的原型链方式就是设置对象的原型为另外一个新对象</span></div><div class="line">B.prototype = <span class="keyword">new</span> A();</div><div class="line"> </div><div class="line"><span class="comment">// 修复原型的constructor属性，否则的话是A了 </span></div><div class="line">B.prototype.constructor = B;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</div><div class="line">alert([b.x, b.y]); <span class="comment">// 10, 20, 2个都是继承的</span></div><div class="line"> </div><div class="line"><span class="comment">// [[Get]] b.x:</span></div><div class="line"><span class="comment">// b.x (no) --&gt;</span></div><div class="line"><span class="comment">// b.[[Prototype]].x (yes) - 10</span></div><div class="line"> </div><div class="line"><span class="comment">// [[Get]] b.y</span></div><div class="line"><span class="comment">// b.y (no) --&gt;</span></div><div class="line"><span class="comment">// b.[[Prototype]].y (no) --&gt;</span></div><div class="line"><span class="comment">// b.[[Prototype]].[[Prototype]].y (yes) - 20</span></div><div class="line"> </div><div class="line"><span class="comment">// where b.[[Prototype]] === B.prototype,</span></div><div class="line"><span class="comment">// and b.[[Prototype]].[[Prototype]] === A.prototype</span></div></pre></td></tr></table></figure><p>这种方法有两个特性：</p><p>首先，<code>B.prototype</code> 将包含 <code>x</code> 属性。虽然第一眼看去似乎这是不正确的。因为 <code>x</code> 属性是定义在 <code>A</code> 中的自有属性，所以预期也它是 <code>B</code> 构造器产生的对象的自有属性（就像 <code>A</code> 产生的对象 <code>a</code> 那样）。</p><p>在一般的原型式继承中，当一个对象没有所需的自有属性时将会委托一个原型。这个机制背后的逻辑是可能构造器 <code>B</code> 创建的对象不需要属性 <code>x</code>。相反，在基于类的继承模式中，（类）所有的属性都复制给了类的后裔。</p><p>然而，如果还是有必要让属性 <code>x</code> 成为构造器 <code>B</code> 创建的对象的自有属性的话（模拟基于类的方式），也有几种技术可以实现，其中一种我们将在下面看到。</p><p>第二点，其实已经不算是特点而是一个缺点 —— 当后裔原型创建时（e.g. <code>B.prototype = new A()</code>）会执行父构造器的代码。我们看到 <code>A.[[Call]] activated</code> 的消息出现了两次，构造器 <code>A</code> 创建对象 <code>a</code> 时以及 <code>A</code> 创建的新对象被用作 <code>B.prototype</code> 时。</p><p>一个更严重的例子是当父构造器抛出异常时：可能，对于构造器创建的真实对象而言这种检查是需要的，但很明显，将这些父对象作为原型时再检查是完全不能接受的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">param</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!param) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="string">'Param required'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.param = param;</div><div class="line">&#125;</div><div class="line">A.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A(<span class="number">20</span>);</div><div class="line">alert([a.x, a.param]); <span class="comment">// 10, 20</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">B.prototype = <span class="keyword">new</span> A(); <span class="comment">// Error</span></div></pre></td></tr></table></figure><p>同样，父构造器中的大量运算也将会是这种方式的一个缺点。</p><p>为了解决这些“特性”和问题，现在的程序员使用的是我们下面展示的这种原型链的标准模式。这个技巧的主要目的是创建一个用来链接原型的中间包装构造器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'A.[[Call]] activated'</span>);</div><div class="line">  <span class="keyword">this</span>.x = <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line">A.prototype.y = <span class="number">20</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line">alert([a.x, a.y]); <span class="comment">// 10 (own), 20 (inherited)</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 或者简单的A.apply(this, arguments);</span></div><div class="line">  B.superproto.constructor.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 通过创建空的构造器来链接原型</span></div><div class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">F.prototype = A.prototype;</div><div class="line">B.prototype = <span class="keyword">new</span> F();</div><div class="line">B.superproto = A.prototype; <span class="comment">// 显式引用父原型</span></div><div class="line"><span class="comment">// fix constructor</span></div><div class="line">B.prototype.constructor = B;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(); <span class="comment">// 'A.[[Call]] activated'</span></div><div class="line">alert([b.x, b.y]); <span class="comment">// 10 (own), 20 (inherited)</span></div></pre></td></tr></table></figure><p>注意，我们如何在 <code>b</code> 实例上创建了自有属性 <code>x</code>：在新创建的对象的上下文中通过 <code>B.superproto.constructor</code> 的引用来调用父构造式。</p><p>我们同样解决了创建子代原型时会不必要地调用父构造器的问题。</p><p>而为了避免每次重复链接原型部分（创建中间构造器，设置”superproto”，储存初始构造器等等），可以把这个部分封装在函数里：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">child, parent</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">  F.prototype = parent.prototype;</div><div class="line">  child.prototype = <span class="keyword">new</span> F();</div><div class="line">  child.prototype.constructor = child;</div><div class="line">  child.superproto = parent.prototype;</div><div class="line">  <span class="keyword">return</span> child;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>相应的继承：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">A.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">inherit(B, A); <span class="comment">// chaining prototypes</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</div><div class="line">alert(b.x); <span class="comment">// 10, found in the A.prototype</span></div></pre></td></tr></table></figure><p>这种包装有许多变体（在语法上），然而它们都是为了简化上面所说的过程。</p><p>例如，我们可以把中间构造器的声明提到外面来以便只执行一次：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">child, parent</span>) </span>&#123;</div><div class="line">    F.prototype = parent.prototype;</div><div class="line">    child.prototype = <span class="keyword">new</span> F;</div><div class="line">    child.prototype.constructor = child;</div><div class="line">    child.superproto = parent.prototype;</div><div class="line">    <span class="keyword">return</span> child;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>由于一个对象的原型是 <code>[[Prototype]]</code> 属性，这就意味着上面简化后 <code>F.prototype</code> 的重新使用不会影响到之前通过通过 <code>F</code> 继承的 child：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">A.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">inherit(B, A);</div><div class="line"> </div><div class="line">B.prototype.y = <span class="number">20</span>;</div><div class="line"> </div><div class="line">B.prototype.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">"B#foo"</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</div><div class="line">alert(b.x); <span class="comment">// 10, is found in A.prototype</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">inherit(C, B);</div><div class="line"> </div><div class="line"><span class="comment">// and using our "superproto" sugar</span></div><div class="line"><span class="comment">// we can call parent method with the same name</span></div><div class="line"> </div><div class="line">C.ptototype.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  C.superproto.foo.call(<span class="keyword">this</span>);</div><div class="line">  alert(<span class="string">"C#foo"</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> C();</div><div class="line">alert([c.x, c.y]); <span class="comment">// 10, 20</span></div><div class="line"> </div><div class="line">c.foo(); <span class="comment">// B#foo, C#foo</span></div></pre></td></tr></table></figure><p>注意，ES5 标准化了这种优化原型链的函数，它是 <code>Object.create</code> 方法。</p><p>ES3 中这个方法的简化版可以通过如下方式实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.create || <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">parent, properties</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">  F.prototype = parent.prototype;</div><div class="line">  <span class="keyword">var</span> child = <span class="keyword">new</span> F;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> properties) &#123;</div><div class="line">    child[k] = properties[k];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> child;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">//Usage:</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;;</div><div class="line"><span class="keyword">var</span> bar = <span class="built_in">Object</span>.create(foo, &#123;<span class="attr">y</span>: <span class="number">20</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(bar.x, bar.y); <span class="comment">// 10, 20</span></div></pre></td></tr></table></figure><p>同样，所有现存的模拟“JS中类式继承”的各种变体也都是基于这个原则。当然现在我们看到，事实上它甚至不是一个“基于类的继承的模拟”，而是一种简单的原型链的重用。</p><h2><span id="总结">总结</span></h2><p>这一章很长，有不少细节。我希望这些材料能有助于理解相关的主题。任何问题欢迎在评论中讨论。</p><h2><span id="扩展阅读">扩展阅读</span></h2><ul><li>4.2 — <a href="http://bclary.com/2004/11/07/#a-4.2" target="_blank" rel="external">Language Overview</a></li><li>4.3 — <a href="http://bclary.com/2004/11/07/#a-4.3" target="_blank" rel="external">Definitions</a></li><li>7.8.5 — <a href="http://bclary.com/2004/11/07/#a-7.8.5" target="_blank" rel="external">Regular Expression Literals</a></li><li>8 — <a href="http://bclary.com/2004/11/07/#a-8" target="_blank" rel="external">Types</a></li><li>9 — <a href="http://bclary.com/2004/11/07/#a-9" target="_blank" rel="external">Type Conversion</a></li><li>11.1.4 — <a href="http://bclary.com/2004/11/07/#a-11.1.4" target="_blank" rel="external">Array Initialiser</a></li><li>11.1.5 — <a href="http://bclary.com/2004/11/07/#a-11.1.5" target="_blank" rel="external">Object Initialiser</a></li><li>11.2.2 — <a href="http://bclary.com/2004/11/07/#a-11.2.2" target="_blank" rel="external">The new Operator</a></li><li>13.2.1 — <a href="http://bclary.com/2004/11/07/#a-13.2.1" target="_blank" rel="external">[[Call]]</a></li><li>13.2.2 — <a href="http://bclary.com/2004/11/07/#a-13.2.2" target="_blank" rel="external">[[Construct]]</a></li><li>15 — <a href="http://bclary.com/2004/11/07/#a-15" target="_blank" rel="external">Native ECMAScript Objects</a></li></ul><p class="j-dot"><strong>Translated by:</strong> Dmitry Soshnikov with additions by Garrett Smith.<br><strong>Published on:</strong> 2010-03-04<br><br><strong>Originally written by:</strong> Dmitry Soshnikov [ru, <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-7-2-oop-ecmascript-implementation/" target="_blank" rel="external">read »</a>]<br><strong>Originally published on:</strong> 2009-09-12 [ru]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文译自 &lt;a href=&quot;http://dmitrysoshnikov.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dmitry A. Soshnikov&lt;/a&gt; 的 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMA-262-3 in detail. Chapter 7.2. OOP: ECMAScript implementation&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;这一章的第二部分是关于 EMCAScript 中的面向对象编程。在第一部分中我们讨论了 OOP 的基本理论并勾画出和 ECMAScript 的相似之处。在阅读第二部分之前，如果有必要，我还是建议首先阅读这一章的&lt;a href=&quot;http://bubkoo.com/2014/06/21/ecma-262-3-in-detail-chapter-7-1-oop-the-general-theory/&quot;&gt;第一部分 概论&lt;/a&gt;，因为后面将会用到其中的一些术语。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ECMAScript" scheme="http://bubkoo.com/tags/ecmascript/"/>
    
      <category term="ECMA-262-3" scheme="http://bubkoo.com/tags/ecma-262-3/"/>
    
      <category term="OOP" scheme="http://bubkoo.com/tags/oop/"/>
    
      <category term="Prototype" scheme="http://bubkoo.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3 详解 第七章 面向对象(一)：概论</title>
    <link href="http://bubkoo.com/2014/06/21/ecma-262-3-in-detail-chapter-7-1-oop-the-general-theory/"/>
    <id>http://bubkoo.com/2014/06/21/ecma-262-3-in-detail-chapter-7-1-oop-the-general-theory/</id>
    <published>2014-06-21T18:57:22.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>此文译自 <a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">Dmitry A. Soshnikov</a> 的 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-1-oop-general-theory/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 7.1. OOP: The general theory</a>.</p><h2><span id="概述">概述</span></h2><p>本文主要讨论 ECMAScript 中面向对象编程。之前已经有大量的文章讨论过该话题了，但本文与那些文章不同，本文主要从理论方面来解析其内部原理。重点讨论对象创建算法，对象之间的关系（包含最基本的关系 – 继承）是如何形成的，并给出了明确的定义（我希望这可以消除一些文章中对于 JavaScript 中 OOP 的疑虑和混乱）。</p><a id="more"></a><h2><span id="概论-范式和思想">概论、范式和思想</span></h2><p>在开始讨论之前，有必要掌握一些 OOP 的基本特征，并弄清楚一些基本概念。</p><p>ECMAScript 支持包括结构化、面向对象、函数式、命令式等多重编程方式，某些情况下还支持面向对象的方式。但本文主要讨论面向对象编程，所以先给出 ECMAScript 中面向对象编程的定义：</p><blockquote><p>ECMAScript 是基于原型的面向对象编程语言。</p></blockquote><p>基于原型和基于静态类的 OOP 有许多直接的差异，下面我们一起来看看这些差异。</p><h3><span id="基于原型和基于类的特征">基于原型和基于类的特征</span></h3><p>注意，上一句话提到一个重点 – 基于<em>静态类</em>，“静态”一词说明静态对象和静态类是强类型的（strong typing）。</p><p>我们常常在各种文章和论坛中看到，JavaScript 被称为是（和一般的 OOP 相比）“另类”、“不同的”，其主要原因就是“类 vs. 原型”。然而，在一些实现中（比如，基于动态类的 Python 和 Ruby）这区别并不是那么重要了（而且除了一些情况外，JavaScript 也不是如此地“另类”，尽管在一定的思想特性上区别确实存在）。但是更基本的是下面这对区别“静态 + 类 vs. 动态 + 原型”。的确，基于静态类的实现（比如C++，Java）以及它们相关的属性/方法解析的机制与基于动态原型的实现相比有着明显的不同。</p><p>让我们来看一下这些范式的基本理论和关键概念。</p><h4><span id="基于静态类的模式">基于静态类的模式</span></h4><p>在基于类的模式中，有一个类（class）的概念，以及一个属于这个类的实例（instance）的概念。一个类的实例也常常被称为对象（objects）或范例（exemplars）。</p><h5><span id="类和对象">类和对象</span></h5><p>类是实例（即对象）的一般性特征的抽象的集合。</p><p>“集合”是更数学化的说法，也可以称它为类型（type）或者类别（classification）。</p><p>示例：（这里和下面的那些例子将使用伪代码）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C = Class &#123;a, b, c&#125; <span class="comment">// class C, 拥有a,b,c三个特征</span></div></pre></td></tr></table></figure><p>实例的特征是：属性（properties，对象的描述）和方法(methods，对象的行为)。</p><p>这些特征本身也可以被看作是对象：比如，一个属性是否可写，是否可配置，是否可设置（getter / setter），等等。</p><p>也就是说，对象储存的是一个<em>状态</em>（一个类中描述的所有属性的具体的值），而类定义的是它的实例的<em>严格不可改变的结构</em>（即存在的是这些还是另一些属性）和<em>严格不可改变的行为</em>（即存在的是这些还是另一些方法）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C = Class &#123;a, b, c, method1, method2&#125;</div><div class="line"> </div><div class="line">c1 = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>&#125; <span class="comment">// 类C是实例：对象с1</span></div><div class="line">c2 = &#123;<span class="attr">a</span>: <span class="number">50</span>, <span class="attr">b</span>: <span class="number">60</span>, <span class="attr">c</span>: <span class="number">70</span>&#125; <span class="comment">// 类C是实例：对象с2，拥有自己的状态（也就是属性值）</span></div></pre></td></tr></table></figure><h5><span id="层次继承">层次继承</span></h5><p>为了提高代码重用率，一个类能扩展（extend）别的类，从而引入额外的属性。这种机制被称为（分层）继承 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D = Class extends C = &#123;d, e&#125; <span class="comment">// &#123;a, b, c, d, e&#125;</span></div><div class="line">d1 = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>, <span class="attr">e</span>: <span class="number">50</span>&#125;</div></pre></td></tr></table></figure><p>当实例调用方法时，通常会先在自身的类中查找该方法，如果没找到就到直接父类去查找，如果还没找到，就到父类的父类去查找，如果查到继承的顶部还没查到，那结果就是：该对象没有类似的行为，也没办法获取结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d1.method1() <span class="comment">// D.method1 (no) -&gt; C.method1 (yes)</span></div><div class="line">d1.method5() <span class="comment">// D.method5 (no) -&gt; C.method5 (no) -&gt; no result</span></div></pre></td></tr></table></figure><p>方法在继承中不会复制到子类中而是通过继承层次查找，而属性在继承中总是复制的。我们在上面类 <code>C</code> 的子类 <code>D</code> 的例子中能看到这一现象：类 <code>C</code> 的属性 <code>a</code>，<code>b</code>，<code>c</code> 被复制到 <code>D</code> 上，而使得 <code>D</code> 的结构是 <code>{a, b, c, d, e}</code>。然而方法 <code>{method1, method2}</code> 没有被复制，而是继承。因此，在这方面的内存的占用是和继承层次成正比的。其主要缺陷是，即使当前对象不需要父类类中的某些属性，它仍然将全部拥有它们。</p><h5><span id="基于类的关键概念">基于类的关键概念</span></h5><p>因此，我们可以得到基于类模式的关键概念：</p><ul><li>要创建一个对象，首先需要定义它的类</li><li>即对象根据它自己的”形象和相似性“分类（结构和行为）而创建</li><li>方法的解析是通过一条严格的直接的不可改变的继承链来处理的</li><li>子孙类（以及根据它们创建的对象）包含继承链中的所有属性（即使其中的一些属性对于它们而言是不必要的）</li><li>类在创建后不能改变（根据静态的模式）它的实例的任何特征（无论是属性还是方法）</li><li>实例（还是由于静态的模式）不能拥有与它的类结构和行为不同的，任何额外的行为或属性</li></ul><h4><span id="基于原型的模式">基于原型的模式</span></h4><p>这里的基本概念是动态可变对象。</p><p>变动性（不只是值，还包括所有的特性）是和语言的动态性直接相关的。</p><p>对象能够独立储存它们全部的特性（属性和方法），而不需要类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">object = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">method</span>: fn&#125;;</div><div class="line">object.a; <span class="comment">// 10</span></div><div class="line">object.c; <span class="comment">// 30</span></div><div class="line">object.method();</div></pre></td></tr></table></figure><p>而且，由于动态性，它们可以简单地改变它们的特性（增加，删除，修改）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">object.method5 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;; <span class="comment">// 添加新方法</span></div><div class="line">object.d = <span class="number">40</span>;   <span class="comment">// 添加新属性 "d"</span></div><div class="line"><span class="keyword">delete</span> object.c; <span class="comment">// 删除属性 "с"</span></div><div class="line">object.a = <span class="number">100</span>;  <span class="comment">// 修改属性 "а"</span></div><div class="line"> </div><div class="line"><span class="comment">// 结果是: object: &#123;a: 100, b: 20, d: 40, method: fn, method5: fn&#125;;</span></div></pre></td></tr></table></figure><p>就是说，在赋值时，如果对象中不存在这个特性，那么特性被创建并初始化为传入值；如果特性已存在，则只是更新它的值。</p><p>在这种情况下，代码重用不是通过扩展类来实现的，（请注意，我们没有说类没办法改变，因为这里根本没有类的概念），而是通过原型来实现的。</p><blockquote><p>原型是一个对象，它是用来作为其他对象的原始拷贝，或者作为辅助对象，以便当其他对象它们没有所需要的特性而原型对象中已有时，委托（delegate）原型中这些特性。</p></blockquote><h5><span id="基于委托的模式">基于委托的模式</span></h5><p>任何对象都可以作为其他对象的原型，并且由于动态特性，对象可以在运行时动态地改变它的原型。</p><p>注意，现在我们考虑的是一般理论，而不涉及到具体的实现。当我们讨论到具体实现时（这里指 ECMAScript），我们会看到实现的一些独有特征。</p><p>实例（伪代码）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">x = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>&#125;;</div><div class="line">y = &#123;<span class="attr">a</span>: <span class="number">40</span>, <span class="attr">c</span>: <span class="number">50</span>&#125;;</div><div class="line">y.[[Prototype]] = x; <span class="comment">// x是y的原型</span></div><div class="line"> </div><div class="line">y.a; <span class="comment">// 40, 自身特性</span></div><div class="line">y.c; <span class="comment">// 50, 也是自身特性</span></div><div class="line">y.b; <span class="comment">// 20 – 从原型中获取: y.b (no) -&gt; y.[[Prototype]].b (yes): 20</span></div><div class="line"> </div><div class="line"><span class="keyword">delete</span> y.a; <span class="comment">// 删除自身的"а"</span></div><div class="line">y.a; <span class="comment">// 10 – 从原型中获取</span></div><div class="line"> </div><div class="line">z = &#123;<span class="attr">a</span>: <span class="number">100</span>, <span class="attr">e</span>: <span class="number">50</span>&#125;</div><div class="line">y.[[Prototype]] = z; <span class="comment">// 将y的原型修改为z</span></div><div class="line">y.a; <span class="comment">// 100 – 从原型z中获取</span></div><div class="line">y.e <span class="comment">// 50, 也是从从原型z中获取</span></div><div class="line"> </div><div class="line">z.q = <span class="number">200</span> <span class="comment">// 添加新属性到原型上</span></div><div class="line">y.q <span class="comment">// 修改也适用于y</span></div></pre></td></tr></table></figure><p>这个例子展示了和原型相关的重要特性和机制：当它作为辅助对象时，它的属性在其他对象中缺少相同属性时可以被委托使用。</p><p>这个机制被称为委托，并且基于它的原型模型是一个委托的原型（或基于委托的原型 ）。</p><p>引用的机制在这里称为发送一个消息给一个对象，当这个对象自身不能响应这个消息时，它委托它的原型（请求它应答这个消息）。</p><p>这个情况中的代码重用被称为基于委托的继承或者基于原型的继承。</p><p>由于任何对象都可以作为原型，这意味着原型也可以有它们自己的原型。这种原型间的连接组合被称为原型链。和静态类相似，原型链也是分级的（hierarchical），然而由于动态性，它可以很容易地重新排列，从而改变层级和结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">x = &#123;<span class="attr">a</span>: <span class="number">10</span>&#125;</div><div class="line"> </div><div class="line">y = &#123;<span class="attr">b</span>: <span class="number">20</span>&#125;</div><div class="line">y.[[Prototype]] = x</div><div class="line"> </div><div class="line">z = &#123;<span class="attr">c</span>: <span class="number">30</span>&#125;</div><div class="line">z.[[Prototype]] = y</div><div class="line"> </div><div class="line">z.a <span class="comment">// 10</span></div><div class="line"> </div><div class="line"><span class="comment">// z.a 在原型链里查到:</span></div><div class="line"><span class="comment">// z.a (no) -&gt;</span></div><div class="line"><span class="comment">// z.[[Prototype]].a (no) -&gt;</span></div><div class="line"><span class="comment">// z.[[Prototype]].[[Prototype]].a (yes): 10</span></div></pre></td></tr></table></figure><p>如果一个对象和它的原型链不能响应发出的消息，对象能够激活一个相应的系统信号来处理它是否能够继续调度和委派给另一条链。</p><p>许多实现都有这个系统信号，包括基于动态类的系统：SmallTalk 中的 <code>#doesNotUnderstand</code>；Ruby 中的 <code>method_missing</code>；Python 中的 <code>__getattr__</code>；PHP 中的 <code>__call</code>；某种 ECMAScript 实现中的 <code>__noSuchMethod__</code>，等等。</p><p>示例（SpiderMonkey 的 ECMAScript 的实现）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line"> </div><div class="line">  <span class="comment">// catch住不能响应消息的系统信号</span></div><div class="line">  __noSuchMethod__: <span class="function"><span class="keyword">function</span> (<span class="params">name, args</span>) </span>&#123;</div><div class="line">    alert([name, args]);</div><div class="line">    <span class="keyword">if</span> (name == <span class="string">'test'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'.test() method is handled'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> delegate[name].apply(<span class="keyword">this</span>, args);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> delegate = &#123;</div><div class="line">  square: <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a * a;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">alert(object.square(<span class="number">10</span>)); <span class="comment">// 100</span></div><div class="line">alert(object.test()); <span class="comment">// .test() method is handled</span></div></pre></td></tr></table></figure><p>也就是说，和基于静态类的实现不同，当无法响应消息时，其结论是：目前的对象不具有所要求的特性，但是如果尝试从原型链里获取，依然可能得到结果，或者该对象经过一系列变化以后拥有该特性。</p><p>对于 ECMAScript，具体的实现就是：使用基于委托的原型。然而，正如我们将从规范和实现里看到的，他们也有自身的特性。</p><h5><span id="串联模式">串联模式</span></h5><p>有必要说明几个符合定义的（即原型作为其他对象复制的原始对象）但没有在 ECMAScript 中使用的其他情况。</p><p>在这种情况下，当对象创建时，代码重用并不是通过委托（delegation），而是通过一个原型的实际拷贝。</p><p>这种使用原型的方式称为串联式原型。</p><p>当一个对象复制了它原型的所有特性之后，它可以像原型一样完全更改它的属性和方法（并且不像基于委托的原型模式中的修改原型特性那样，它的修改不会影响到现存的对象）。这种模式的优点是减少了调度和委托的时间，而缺点则是更多的内存占用。</p><h5><span id="鸭子类型">“鸭子”类型</span></h5><p>回到动态性上，与基于静态类的模式不同，在弱类型和动态对象模式中，某个对象是否具有完成某项工作的能力不是和它是哪个类型（类）相关，而是和它是否能响应某条消息相关（通过测试来确定它是否具有某种能力）。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在基于静态来的模型里</span></div><div class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> SomeClass) &#123;</div><div class="line">  <span class="comment">// 一些行为是运行的</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 在动态实现里</span></div><div class="line"><span class="comment">// 对象在此时是什么类型并不重要</span></div><div class="line"><span class="comment">// 因为突变、类型、特性可以自由重复的转变。</span></div><div class="line"><span class="comment">// 重要的对象是否可以响应test消息 </span></div><div class="line"><span class="keyword">if</span> (isFunction(object.test)) <span class="comment">// ECMAScript</span></div><div class="line"> </div><div class="line"><span class="keyword">if</span> object.respond_to?(:test) <span class="comment">// Ruby</span></div><div class="line"> </div><div class="line"><span class="keyword">if</span> hasattr(object, <span class="string">'test'</span>): <span class="comment">// Python</span></div></pre></td></tr></table></figure><p>行话中，这被称为“鸭子类型（duck typing）”。就是说，我们可以通过检查对象在某一时刻所拥有的特性集合来识别它，而不是通过看它在层级中的位置或它属于哪种具体类型。（译注：“当我们看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为是鸭子”）。</p><h5><span id="基于原型的模式的主要概念">基于原型的模式的主要概念</span></h5><p>那么，让我们来看下这个模式的主要特点：</p><ul><li>基本概念是对象（而不用先定义它的类）</li><li>对象是完全动态和可变的（并且，理论上可以完全从一种类型变成另一种类型）</li><li>对象没有严格的类来描述它们的结构和行为，对象不需要类</li><li>然而，虽然没有类，但是对象可以有原型，以便于当它们自身不能应答消息时委托原型</li><li>对象的原型可以在运行时的任何时刻改变</li><li>在基于委托的模式中，改变原型的特性将会影响到和这个原型相关的所有对象</li><li>在串联式原型模式中，原型是对象克隆的原始拷贝，因此变得完全独立，改变原型的特性不会影响到根据它克隆出的对象</li><li>如果不能响应一个消息，可以发信号给调用者，以便于采取额外的措施（比如改变调度）</li><li>对象的识别可以不通过它们的层级位置或者它们属于哪个具体的类型，而是通过对当前拥有的特性（鸭子模型）</li></ul><p>然而，我们还需要提到另一个模式。</p><h4><span id="基于动态类的模式">基于动态类的模式</span></h4><p>上面例子里展示的区别“类 vs. 原型 ”在这个基于动态类的模型中不是那么重要（尤其当原型链不变的时候，为了更准确地区分，它就应当被看做是一种静态的（statics）类）。可以用 Python 或 Ruby（或其他类似的语言）为例。这两种语言都使用了基于动态类的范式。然而在某些方面，又能看到基于原型的实现的特征。</p><p>在下面的例子中我们能够看到，就像在基于委托的原型中那样，我们能增加一个类（原型），然后它将影响到和它相关的对象，我们也能在运行时动态地改变对象的类（提供一个新的委托对象），等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></div><div class="line">        self.a = a</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.a * self.a</div><div class="line"> </div><div class="line">a = A(<span class="number">10</span>) <span class="comment"># 创建实例</span></div><div class="line">print(a.a) <span class="comment"># 10</span></div><div class="line"> </div><div class="line">A.b = <span class="number">20</span> <span class="comment"># 为类提供一个新属性</span></div><div class="line">print(a.b) <span class="comment"># 20 – 可以在"a"实例里访问到</span></div><div class="line"> </div><div class="line">a.b = <span class="number">30</span> <span class="comment"># 创建a自身的属性</span></div><div class="line">print(a.b) <span class="comment"># 30</span></div><div class="line"> </div><div class="line"><span class="keyword">del</span> a.b <span class="comment"># 删除自身的属性</span></div><div class="line">print(a.b) <span class="comment"># 20 - 再次从类里获取（原型）</span></div><div class="line"> </div><div class="line"><span class="comment"># 就像基于原型的模型</span></div><div class="line"><span class="comment"># 可以在运行时改变对象的原型</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span> <span class="comment"># 空类B</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"> </div><div class="line">b = B() <span class="comment"># B的实例</span></div><div class="line"> </div><div class="line">b.__class__ = A <span class="comment"># 动态改变类（原型）</span></div><div class="line"> </div><div class="line">b.a = <span class="number">10</span> <span class="comment"># 创建新属性</span></div><div class="line">print(b.square()) <span class="comment"># 100 - A类的方法这时候可用</span></div><div class="line"> </div><div class="line"><span class="comment"># 可以显示删除类上的引用</span></div><div class="line"><span class="keyword">del</span> A</div><div class="line"><span class="keyword">del</span> B</div><div class="line"> </div><div class="line"><span class="comment"># 但对象依然有隐式的引用，并且这些方法依然可用</span></div><div class="line">print(b.square()) <span class="comment"># 100</span></div><div class="line"> </div><div class="line"><span class="comment"># 但这时候不能再改变类了</span></div><div class="line"><span class="comment"># 这是实现的特性</span></div><div class="line">b.__class__ = dict <span class="comment"># error</span></div></pre></td></tr></table></figure><p>在 Ruby 中的情况也是类似的：使用的同样是完全动态的类（顺便说一句，与 ECMAScript 和 Ruby 不同，在当前版本的 Python 中，不能够增加内建的类/原型），我们能完全更改对象和类的特性（如果在类中增加属性或方法，这些改变将影响到现存的对象）；然而，它不能够动态地改变一个对象的类。</p><p>当然，由于这篇文章不是讲述 Python 和 Ruby 的，因此我们结束这些对比，然后开始讨论 ECMAScript。</p><p>但在这之前，我们仍需要来看一下一些 OOP 的实现中提供的附加的“语法糖”，因为相关的问题常常出现在 JavaScript 的文章中。</p><p>这一节主要用来让我们注意到下面说法是不正确的：“JavaScript 和 OOP 是不同的，它没有类，而只有原型”。我们有必要理解，并不是所有的基于类的实现都完全不同。并且，即使我们说“JavaScript 不同”，也有必要考虑到除了“类”的概念之外的其他相关特性。</p><h3><span id="各种oop实现中的附加特性">各种OOP实现中的附加特性</span></h3><p>在这一节中我们将快速浏览一下各种 OOP 实现中的附加特性以及代码重用的方式，和 ECMAScript 的 OOP 实现作一个对比。其原因是，在目前的一些 JavaScript 的文章中，OOP 的概念被局限在了一些习惯的实现方式上，而忽略了其他可能的不同实现方式；而这里的目的就是为了从语法和思路上证明这些被忽略的部分。当在某种（习惯的）实现方式上没有找到类似的“语法糖”时就草率地认为JavaScript 不是一个纯 OOP 语言，这是不正确的。</p><h5><span id="多态-polymorphism">多态 Polymorphism</span></h5><p>ECMAScript 中的对象在一些意义上是多态的。</p><p>例如，一个函数可以应用于不同的对象，就像原生对象的特性（因为这个值在进入执行上下文时确定的）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert([<span class="keyword">this</span>.a, <span class="keyword">this</span>.b]);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">test.call(&#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>&#125;); <span class="comment">// 10, 20</span></div><div class="line">test.call(&#123;<span class="attr">a</span>: <span class="number">100</span>, <span class="attr">b</span>: <span class="number">200</span>&#125;); <span class="comment">// 100, 200</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line"> </div><div class="line">test(); <span class="comment">// 1, 2</span></div></pre></td></tr></table></figure><p>不过，也有例外：<code>Date.prototype.getTime()</code> 方法，根据标准这个值总是应该有一个日期对象，否则就会抛出异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">Date</span>.prototype.getTime.call(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// time</span></div><div class="line">alert(<span class="built_in">Date</span>.prototype.getTime.call(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">''</span>))); <span class="comment">// TypeError</span></div></pre></td></tr></table></figure><p>或者，参数多态性，即函数可以接受多态性参数（比如数组的 <code>.sort</code> 方法和它的参数 —— 各种排序函数），顺便说一句，上面的例子也可以认为是一种参数多态性。</p><p>或者，原型里方法可以被定义为空，所有创建的对象应重新定义（实现）该方法（即“一个接口（签名），多个实现”）。</p><p>多态和我们上面提到的“鸭子”类型是有关的：即对象的类型和在层次结构中的位置不是那么重要，如果它拥有所有必要的特征，它就可以被接受（即通用接口很重要，实现则可以多种多样）。</p><h5><span id="封装-encapsulation">封装 Encapsulation</span></h5><p>关于封装，往往会有错误的看法。本节我们将讨论一些 OOP 实现里的语法糖 —— 也就是众所周知的修饰符：<code>private</code>, <code>protected</code> 和 <code>public</code>（<em>对象的访问级别</em>或<em>访问修饰符</em>）。</p><p>在这里我要提醒一下封装的主要目的：封装是一个抽象的增加，而不是选拔个直接往你的类里写入一些东西的隐藏“恶意黑客”。</p><p>这里有一个很大的错误：为了隐藏使用隐藏。</p><p>一些 OOP 实现中提供的访问等级（<code>private</code>, <code>protected</code>, <code>public</code>），最主要的是为了方便编程者（并且确实很方便）去更抽象地描述和构建系统。</p><p>这一点在一些实现中（比如上面提到过的 Python 和 Ruby）可以看到。一方面（在 Python 中），有 <code>__private</code> 和 <code>_protected</code> 属性（通过下划线的命名约定）可以用来禁止外部访问。另一方面，Python 又可以通过特殊的规则简单地重命名这些域（<code>_ClassName__field_name</code>），并通过这样的命名使得外部可以访问到。（译注：因此，封装的意义是为了抽象，而不是强制隐藏）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">      self.public = <span class="number">10</span></div><div class="line">      self.__private = <span class="number">20</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_private</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.__private</div><div class="line"> </div><div class="line"><span class="comment"># outside:</span></div><div class="line"> </div><div class="line">a = A() <span class="comment"># A的实例</span></div><div class="line"> </div><div class="line">print(a.public) <span class="comment"># OK, 30</span></div><div class="line">print(a.get_private()) <span class="comment"># OK, 20</span></div><div class="line">print(a.__private) <span class="comment"># 失败，因为只能在A里可用</span></div><div class="line"> </div><div class="line"><span class="comment"># 但在Python里，可以通过特殊规则来访问</span></div><div class="line"> </div><div class="line">print(a._A__private) <span class="comment"># OK, 20</span></div></pre></td></tr></table></figure><p>在 Ruby 中：一方面，可以定义私有和保护域的特性；另一方面，也有特殊的方法（比如<code>instance_variable_get</code>, <code>instance_variable_set</code>，等）来允许访问封装的数据。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @a = <span class="number">10</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">public_method</span></span></div><div class="line">    private_method(<span class="number">20</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"> </div><div class="line">private</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">private_method</span><span class="params">(b)</span></span></div><div class="line">    <span class="keyword">return</span> @a + b</div><div class="line">  <span class="keyword">end</span></div><div class="line"> </div><div class="line"><span class="keyword">end</span></div><div class="line"> </div><div class="line">a = A.new <span class="comment"># 新实例</span></div><div class="line"> </div><div class="line">a.public_method <span class="comment"># OK, 30</span></div><div class="line"> </div><div class="line">a.a <span class="comment"># 失败, <span class="doctag">@a</span> - 是私有的实例变量</span></div><div class="line"> </div><div class="line"><span class="comment"># "private_method"是私有的，只能在A类里访问</span></div><div class="line"> </div><div class="line">a.private_method <span class="comment"># 错误</span></div><div class="line"> </div><div class="line"><span class="comment"># 但是有特殊的元数据方法名，可以获取到数据</span></div><div class="line"> </div><div class="line">a.send(<span class="symbol">:private_method</span>, <span class="number">20</span>) <span class="comment"># OK, 30</span></div><div class="line">a.instance_variable_get(<span class="symbol">:</span>@a) <span class="comment"># OK, 10</span></div></pre></td></tr></table></figure><p>主要原因是：程序员本身希望访问到封装的（注意，这里我使用的词不是“隐藏的”）数据。并且如果这些数据被不正确地更改或者出现任何错误 —— 那完全是程序员的责任，而不是一个简单的“输入错误”或“有人随意改变了某些域”。但如果这样的情况（即访问封装的数据）频繁发生，那么我们可能还是需要注意到，这是一种<em>坏的编程习惯和风格</em>，因为通常而言最好只通过公共的 API 来和对象“交谈”。</p><p>重申一下，封装的基本目的，是将辅助的数据从用户端抽象出，而不是一种“创建防黑客的安全对象的方式”。在软件安全方面使用的是远比 <code>private</code> 修饰符更严格的措施。</p><p>通过封装辅助（局部）对象，我们为之后公共接口的行为改变提供了最小开支的可能性，将这些改变局部化并预测它们的位置。而这正是封装的主要目的。</p><p>同样，一个 <code>setter</code> 方法的主要目的是为了抽象那些复杂的计算。例如，<code>element.innerHTML setter</code> —— 我们简单地把语句抽象成 —— “现在，这个语句的 HTML 如下”，而在这个 <code>setter</code> 函数内部对 <code>innerHTML</code> 属性所做的将是复杂的运算和检查。这个情况下的问题主要是关于抽象，但是作为抽象度增加的封装过程也发生了。</p><p>封装的概念不仅和 OOP 相关。例如，它也可以是指一个简单的函数，封装了各种计算过程，而使得它能被抽象地使用（例如，对于用户来说不需要知道 <code>Math.round</code> 函数的内部实现，而只是简单地调用它）。这就是一个封装，并且注意，我并没有说到任何“私有、保护或者公共的”。</p><p>ECMAScript 在目前版本的规范中并没有定义 <code>private</code>，<code>protected</code>，<code>public</code> 修饰符。</p><p>然而，在实际中我们可能会看到一些“在 JS 中模拟封装”的说法。通常，使用封闭上下文来实现这个目的。但不幸的是，在实现这些“模拟”时，程序员们常常会生产出完全不抽象的 <code>getter</code>/<code>setter</code>（重复一下，这是不正确地理解封装）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">unction A() &#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> _a; <span class="comment">// "private" a</span></div><div class="line"> </div><div class="line">  <span class="keyword">this</span>.getA = <span class="function"><span class="keyword">function</span> <span class="title">_getA</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _a;</div><div class="line">  &#125;;</div><div class="line"> </div><div class="line">  <span class="keyword">this</span>.setA = <span class="function"><span class="keyword">function</span> <span class="title">_setA</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    _a = a;</div><div class="line">  &#125;;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line"> </div><div class="line">a.setA(<span class="number">10</span>);</div><div class="line">alert(a._a); <span class="comment">// undefined, "private"</span></div><div class="line">alert(a.getA()); <span class="comment">// 10</span></div></pre></td></tr></table></figure><p>这里，我们很容易理解，每一个创建的对象都会创建一对 <code>getA</code>/<code>setA</code> 方法，从而使得内存占用的问题直接和创建的对象数量成正比（如果方法定义在原型中则相反）。虽然，理论上可以通过联合对象来优化。</p><p>同样关于上面的方法，在一些关于 JavaScript 的文章中称为“特权方法”。为了澄清，注意，ECMAScript-262-3 中并没有定义任何“特权方法”的概念。</p><p>然而，它可以作为在构造函数中创建方法的一般方式，因为它符合这门语言的思路 —— 对象是完全可变的，并且拥有独立的特性（在构造函数中，可以通过条件语句来让一些对象获得某些方法而另一些对象没有，等等）。</p><p>此外，在 JavaScript 中，这种“隐藏”、“私有”的变量并非那么隐蔽（如果封装还是被误解为防止“恶意黑客”直接在某些域中写入值，而不是使用一个 <code>setter</code> 方法）。在一些实现器中（SpiderMonkey 1.7之前的版本），可以通过在 <code>eval</code> 函数中传入调用上下文来访问所需要的作用域链（并从而访问到其中的变量对象）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">'_a = 100'</span>, a.getA); <span class="comment">// 或者a.setA,因为"_a"两个方法的[[Scope]]上</span></div><div class="line">a.getA(); <span class="comment">// 100</span></div></pre></td></tr></table></figure><p>或者，在某些实现器中允许直接访问活动对象（比如 Rhino），就可以通过访问活动对象上的相应属性来改变内部变量的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Rhino</span></div><div class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> x = <span class="number">10</span>; <span class="comment">// "private"</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    print(x);</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line">foo(); <span class="comment">// 10</span></div><div class="line">foo.__parent__.x = <span class="number">20</span>;</div><div class="line">foo(); <span class="comment">// 20</span></div></pre></td></tr></table></figure><p>有时候，作为一种组织方式（也可以被视为一种封装）， JavaScript 中 <code>private</code> 和 <code>protected</code> 的数据通过一个前置的下划线来标识（但和 Python 中不同，这里只是为了命名上的方便）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _myPrivateData = <span class="string">'testString'</span>;</div></pre></td></tr></table></figure><p>对于括号括住执行上下文是经常使用，但对于真正的辅助数据，则和对象没有直接关联，只是方便从外部的API抽象出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="comment">// 初始化上下文</span></div><div class="line"> </div><div class="line">&#125;)();</div></pre></td></tr></table></figure><h5><span id="多重继承-multiple-inheritance">多重继承 Multiple inheritance</span></h5><p>多重继承是提高代码重用率的一个方便的特性（如果我们能继承一个类，为什么不一次继承十个？）。然而，它有一些缺点，因此在实现中并不流行。</p><p>ECMAScript 不支持多重继承（换句话说，只有一个对象可以用作直接原型），虽然它的祖先 Self 编程语言是有这个特性的。不过，在一些实现器中，比如 SpiderMonkey 中，通过使用 <code>__noSuchMethod__</code>，可以管理调度和委派到另一条可选的原型链中。</p><h5><span id="混入-mixins">混入 Mixins</span></h5><p><a href="http://en.wikipedia.org/wiki/Mixin" target="_blank" rel="external">混入（Mixins）</a>也是代码重用的一种方便的方式。混入已经被建议作为多重继承的替代。独立的元素可以混入到其他任何对象，从而扩展它们的功能（就是说对象可以混入多个对象）。ECMAScript-262-3 规范中没有定义“混入”的概念，然而根据混入的定义，并且由于 ECMAScript 中的对象是动态可变的，因此没有任何东西阻止对象混入其他对象，而是简单地增加它的特性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// helper for augmentation</span></div><div class="line"><span class="built_in">Object</span>.extend = <span class="function"><span class="keyword">function</span> (<span class="params">destination, source</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (property <span class="keyword">in</span> source) <span class="keyword">if</span> (source.hasOwnProperty(property)) &#123;</div><div class="line">    destination[property] = source[property];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> destination;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> X = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>&#125;;</div><div class="line"><span class="keyword">var</span> Y = &#123;<span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.extend(X, Y); <span class="comment">// mix Y into X</span></div><div class="line">alert([X.a, X.b, X.c, X.d]); <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span></div></pre></td></tr></table></figure><p>注意，我们在定义“混入”上加引号是因为我们提到过 ECMA-262-3 中没有这样一个概念，而且事实上并不是一个混入，而是为一个对象扩展了新的特性（相反，比如在 Ruby 中，存在正式的混入概念，混入创建了相关模块的引用（换句话说，事实上创建了用于委托的额外的对象（原型）），而不只是简单地将模块中的所有属性复制到对象上）。</p><h5><span id="性状-traits">性状 Traits</span></h5><p><a href="http://en.wikipedia.org/wiki/Trait_(computer_science" target="_blank" rel="external">性状（Traits）</a>)和 Mixins 相似，然而有一些自身的特性（其中最根本的是，根据定义，Traits 和 Mixins 不同，它不能有状态，而后者可能引起命名冲突）。在 ECMAScript 中，Traits<br>也可以通过和 Mixins<br>一样的方式模拟，而标准中并没有定义“Traits”的概念。</p><h5><span id="接口-interfaces">接口 Interfaces</span></h5><p>和 Mixins 以及 Traits 一样，接口也是在一些 OOP 实现中提供的。然而，和 Mixins 以及 Traits 不同的是，接口要求（实现它们的）类完全实现接口中方法签名的行为。</p><p>接口可以被看作是完全抽象类。但是，和抽象类(可以自己实现部分方法，然后把其他的定义为签名)不同，一个类只能单一继承，但是可以实现多个接口；由于这一点，接口（和 Mixins 一样）可以作为多种继承的替代。</p><p>ECMAScript-262-3 标准中既没有定义“接口”，也没有定义“抽象类”。然而，作为模拟，可以为对象添加“空”方法（或者在方法中抛出一个异常，以表示这个方法应该被实现）。</p><h5><span id="对象组合-object-composition">对象组合 Object composition</span></h5><p><a href="http://en.wikipedia.org/wiki/Object_composition" target="_blank" rel="external">对象组合（Object composition）</a>也是动态代码重用的一种技术。和继承不同，对象组合拥有更多的灵活性，并且实现了对动态可变代表的委托。而这一点反过来又成为基于委托的原型的基础。在动态可变原型中，对象可以聚集（其结果是创建了一个组合（composition）或者说，一个聚合（aggregation））其他对象以便于委托，然后当传递消息给对象时，委托这些对象。可以有多个委托，并且由于可变性，可以在运行时改变它们。</p><p>上面已经提到过的 <code>__noSuchMethod__</code> 方法可以作为一个例子，但是这里我们用另一个示例来说明如何准确使用委托：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _delegate = &#123;</div><div class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'_delegate.foo'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> agregate = &#123;</div><div class="line"> </div><div class="line">  delegate: _delegate,</div><div class="line"> </div><div class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.delegate.foo.call(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">&#125;;</div><div class="line"> </div><div class="line">agregate.foo(); <span class="comment">// delegate.foo</span></div><div class="line"> </div><div class="line">agregate.delegate = &#123;</div><div class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'foo from new delegate'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">agregate.foo(); <span class="comment">// foo from new delegate</span></div></pre></td></tr></table></figure><p>对象之间的这种关系被称为”has-a”，也就是说，是“内部包含”的关系而不是像继承那种“is-a”的关系。</p><p>明确组合的缺点（与继承相比的灵活性）是中间代码的增加。</p><p>AOP 特性 AOP features</p><p><a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="external">面向侧面编程（aspect-oriented programming）</a>的其中一个特性是函数修饰符。ECMA-262-3 中没有明确定义“函数修饰符”的概念（相反的，Python 中有正式的定义）。不过，拥有函数式参数的函数在某些方面是可以装饰和激活的（通过应用所谓的建议）：</p><p>最简单的装饰者例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkDecorator</span>(<span class="params">originalFunction</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (fooBar != <span class="string">'test'</span>) &#123;</div><div class="line">      alert(<span class="string">'wrong parameter'</span>);</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> originalFunction();</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'test function'</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> testWithCheck = checkDecorator(test);</div><div class="line"><span class="keyword">var</span> fooBar = <span class="literal">false</span>;</div><div class="line"> </div><div class="line">test(); <span class="comment">// 'test function'</span></div><div class="line">testWithCheck(); <span class="comment">// 'wrong parameter'</span></div><div class="line"> </div><div class="line">fooBar = <span class="string">'test'</span>;</div><div class="line">test(); <span class="comment">// 'test function'</span></div><div class="line">testWithCheck(); <span class="comment">// 'test function'</span></div></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>在这篇文章，我们理清了 OOP 的概论（我希望这些资料已经对你有用了），下一章节我们将继续面向对象编程之 ECMAScript 的实现 。</p><h2><span id="扩展阅读">扩展阅读</span></h2><ul><li><a href="http://web.media.mit.edu/~lieber/Lieberary/OOP/Delegation/Delegation.html\" target="_blank" rel="external">Using Prototypical Objects to Implement Shared Behavior in Object Oriented Systems (by Henry Lieberman)</a></li><li><a href="http://en.wikipedia.org/wiki/Prototype-based_programming" target="_blank" rel="external">Prototype-based programming</a></li><li><a href="http://en.wikipedia.org/wiki/Class_(computer_science)" target="_blank" rel="external">Class</a></li><li><a href="http://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="external">Object-oriented programming</a></li><li><a href="http://en.wikipedia.org/wiki/Abstraction_(computer_science)" target="_blank" rel="external">Abstraction</a></li><li><a href="http://en.wikipedia.org/wiki/Encapsulation_(computer_science)" target="_blank" rel="external">Encapsulation</a></li><li><a href="http://en.wikipedia.org/wiki/Type_polymorphism" target="_blank" rel="external">Polymorphism</a></li><li><a href="http://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" target="_blank" rel="external">Inheritance</a></li><li><a href="http://en.wikipedia.org/wiki/Multiple_inheritance" target="_blank" rel="external">Multiple inheritance</a></li><li><a href="http://en.wikipedia.org/wiki/Mixin" target="_blank" rel="external">Mixin</a></li><li><a href="http://en.wikipedia.org/wiki/Trait_(computer_science)" target="_blank" rel="external">Trait</a></li><li><a href="http://en.wikipedia.org/wiki/Interface_(computer_science)" target="_blank" rel="external">Interface</a></li><li><a href="http://en.wikipedia.org/wiki/Abstract_type" target="_blank" rel="external">Abstract class</a></li><li><a href="http://en.wikipedia.org/wiki/Object_composition" target="_blank" rel="external">Object composition</a></li><li><a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="external">Aspect-oriented programming</a></li><li><a href="http://en.wikipedia.org/wiki/Dynamic_programming_language" target="_blank" rel="external">Dynamic programming language</a></li></ul><p class="j-dot"><strong>Translated by:</strong> Dmitry A. Soshnikov, with help of Juriy “kangax” Zaytsev.<br><strong>Published on:</strong> 2010-03-04<br><br><strong>Originally written by:</strong> Dmitry A. Soshnikov [ru, <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-7-1-oop-general-theory/" target="_blank" rel="external">read »</a>]<br><strong>Originally published on:</strong> 2009-09-12 [ru]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文译自 &lt;a href=&quot;http://dmitrysoshnikov.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dmitry A. Soshnikov&lt;/a&gt; 的 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-7-1-oop-general-theory/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMA-262-3 in detail. Chapter 7.1. OOP: The general theory&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文主要讨论 ECMAScript 中面向对象编程。之前已经有大量的文章讨论过该话题了，但本文与那些文章不同，本文主要从理论方面来解析其内部原理。重点讨论对象创建算法，对象之间的关系（包含最基本的关系 – 继承）是如何形成的，并给出了明确的定义（我希望这可以消除一些文章中对于 JavaScript 中 OOP 的疑虑和混乱）。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ECMAScript" scheme="http://bubkoo.com/tags/ecmascript/"/>
    
      <category term="ECMA-262-3" scheme="http://bubkoo.com/tags/ecma-262-3/"/>
    
      <category term="OOP" scheme="http://bubkoo.com/tags/oop/"/>
    
      <category term="Prototype" scheme="http://bubkoo.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3 详解 第六章 闭包</title>
    <link href="http://bubkoo.com/2014/06/15/ecma-262-3-in-detail-chapter-6-closures/"/>
    <id>http://bubkoo.com/2014/06/15/ecma-262-3-in-detail-chapter-6-closures/</id>
    <published>2014-06-15T21:56:23.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">Dmitry A. Soshnikov</a> 的文章 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 6. Closures</a>.</p><p>其中大部分参考了 <a href="http://zh.blog.goddyzhao.me/" target="_blank" rel="external">goddyzhao</a> 的<a href="http://zh.blog.goddyzhao.me/post/11311499651/closures" target="_blank" rel="external">翻译</a>。</p><h2><span id="概述">概述</span></h2><p>本文将介绍在 JavaScript 中大家经常讨论的话题 – 闭包（Closure）。事实上，闭包是个老生常谈的话题了，管如此，这里还是要试着从理论角度来讨论下闭包，看看 ECMAScript 中的闭包内部究竟是如何工作的。</p><p>正如在此前文章中提到的，这些文章都是系列文章，相互之间都是有关联的。因此，为了更好的理解本文要介绍的内容， 建议先去阅读下<a href="http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/">第四章 作用域链</a>和<a href="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/">第二章 变量对象</a>。<br><a id="more"></a></p><h2><span id="概论">概论</span></h2><p>在开始讨论 ECMAScript 闭包之前，先来介绍下函数式编程（与 ECMA-262-3 标准无关）中一些基本定义。然而，为了更好的解释这些定义，这里还是拿 ECMAScript 来举例。</p><p>众所周知，在函数式语言中（ECMAScript 也支持这种风格），函数即是数据。就比方说，函数可以保存在变量中，可以当参数传递给其他函数，还可以当返回值返回等等。这类函数有特殊的名字和结构。</p><h3><span id="定义">定义</span></h3><blockquote><p>函数式参数（Funarg） —— 值为函数的参数。</p></blockquote><p>看下面例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">exampleFunc</span>(<span class="params">funArg</span>) </span>&#123;</div><div class="line">  funArg();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">exampleFunc(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'funArg'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>上面代码中，<code>funArg</code> 的实参是一个传递给 <code>exampleFunc</code> 的匿名函数。</p><blockquote><p>反过来，接受函数式参数的函数称为<em>高阶函数（high-order function 简称：HOF）</em>。</p></blockquote><p>还可以称作：<em>函数式函数</em>或者偏数理的叫法：<em>操作符函数</em>。上述例子中，<code>exampleFunc</code> 就是这样的函数。</p><p>此前提到的，函数不仅可以作为参数，还可以作为返回值。</p><blockquote><p>这类以函数为返回值的函数称为<em>带函数值的函数（functions with functional value or function valued functions）</em>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">functionValued</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'returned function is called'</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;)()();</div></pre></td></tr></table></figure><blockquote><p>可以以正常数据形式存在的函数（比方说：当参数传递，接受函数式参数或者以函数值返回）都称作<em>第一类函数</em>（一般说<em>第一类对象</em>）。</p></blockquote><p>在 ECMAScript 中，所有的函数都是第一类对象。</p><p>以自己作为参数的函数称为<em>自应用函数（auto-applicative function 或 self-applicative function）</em>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">selfApplicative</span>(<span class="params">funArg</span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">if</span> (funArg &amp;&amp; funArg === selfApplicative) &#123;</div><div class="line">    alert(<span class="string">'self-applicative'</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  selfApplicative(selfApplicative);</div><div class="line"> </div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>以自己为返回值的函数称为<em>自复制函数（auto-replicative function 或 self-replicative function）</em>。通常，“自复制”这个词用在文学作品中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">selfReplicative</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> selfReplicative;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>在函数式参数中定义的变量，在 <code>funarg</code> 激活时就能够访问了（因为存储上下文数据的变量对象每次在进入上下文阶段时就创建出来了）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params">funArg</span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="comment">// 激活funarg, 本地变量localVar可访问</span></div><div class="line">  funArg(<span class="number">10</span>); <span class="comment">// 20</span></div><div class="line">  funArg(<span class="number">20</span>); <span class="comment">// 30</span></div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">testFn(<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> localVar = <span class="number">10</span>;</div><div class="line">  alert(arg + localVar);</div><div class="line"> </div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>然而，我们知道（特别在<a href="http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/">第四章</a>中提到的），在 ECMAScript 中，函数是可以封装在父函数中的，并可以使用父函数上下文的变量。这个特性会引发 funarg 问题。</p><h3><span id="funarg-问题">Funarg 问题</span></h3><p>在<a href="http://en.wikipedia.org/wiki/Stack-oriented_programming_language" target="_blank" rel="external">面向堆栈的编程语言</a>中，函数的本地变量都是保存在堆栈上的，每当函数激活的时候，这些变量和函数参数都会压栈到该堆栈上。</p><p>当函数返回的时候，这些参数又会从堆栈中移除。这种模型对将函数作为函数式值使用的时候有很大的限制（比方说，作为返回值从父函数中返回）。绝大部分情况下，问题会出现在当函数有自由变量的时候。</p><blockquote><p>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量</p></blockquote><p>如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> localVar = <span class="number">10</span>;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params">innerParam</span>) </span>&#123;</div><div class="line">    alert(innerParam + localVar);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> innerFn;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> someFn = testFn();</div><div class="line">someFn(<span class="number">20</span>); <span class="comment">// 30</span></div></pre></td></tr></table></figure><p>上述例子中，对于 <code>innerFn</code> 函数来说，<code>localVar</code> 就属于自由变量。</p><p>对于采用<em>面向堆栈模型</em>来存储局部变量的系统而言，就意味着当 <code>testFn</code> 函数调用结束后，其局部变量都会从堆栈中移除。这样一来，当从外部对 <code>innerFn</code> 进行函数调用的时候，就会发生错误（因为 <code>localVar</code> 变量已经不存在了）。</p><p>而且，上述例子在 面向堆栈实现模型中，要想将 <code>innerFn</code> 以返回值返回根本是不可能的。因为它也是 <code>testFn</code> 函数的局部变量，也会随着 <code>testFn</code> 的返回而移除。</p><p>还有一个函数对象问题和当系统采用动态作用域，函数作为函数参数使用的时候有关。</p><p>看如下例子（伪代码）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> z = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(z);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(); <span class="comment">// 10 – 静态作用域和动态作用域情况下都是</span></div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> z = <span class="number">20</span>;</div><div class="line">  foo(); <span class="comment">// 10 – 静态作用域情况下, 20 – 动态作用域情况下</span></div><div class="line"> </div><div class="line">&#125;)();</div><div class="line"> </div><div class="line"><span class="comment">// 将foo函数以参数传递情况也是一样的</span></div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">funArg</span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> z = <span class="number">30</span>;</div><div class="line">  funArg(); <span class="comment">// 10 – 静态作用域情况下, 30 – 动态作用域情况下</span></div><div class="line"> </div><div class="line">&#125;)(foo);</div></pre></td></tr></table></figure><p>我们看到，采用动态作用域，变量（标识符）处理是通过动态堆栈来管理的。因此，自由变量是在当前活跃的动态链中查询的，而不是在函数创建的时候保存起来的静态作用域链中查询的。</p><p>这样就会产生冲突。比方说，即使 <code>z</code> 仍然存在（与之前从堆栈中移除变量的例子相反），还是会有这样一个问题：在不同的函数调用中，<code>z</code> 的值到底取哪个呢（从哪个上下文，哪个作用域中查询）？</p><p>上述描述的就是两类 funarg 问题 —— 取决于是否将函数以返回值返回（第一类问题）以及是否将函数当函数参数使用（第二类问题）。</p><p>为了解决上述问题，就引入了<em>闭包</em>的概念。</p><h3><span id="闭包">闭包</span></h3><blockquote><p>闭包是代码块和创建该代码块的上下文中数据的结合。</p></blockquote><p>让我们来看下面这个例子（伪代码）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">20</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(x); <span class="comment">// 自由变量 "x" == 20</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// foo的闭包</span></div><div class="line">fooClosure = &#123;</div><div class="line">  call: foo <span class="comment">// 对函数的引用</span></div><div class="line">  lexicalEnvironment: &#123;<span class="attr">x</span>: <span class="number">20</span>&#125; <span class="comment">// 查询自由变量的上下文</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上述例子中，<code>fooClosure</code> 部分是伪代码。对应的，在 ECMAScript 中，<code>foo</code> 函数已经有了一个内部属性 —— 创建该函数上下文的作用域链（<code>[[Scope]]</code>）。</p><p>这里 lexical 是不言而喻的，通常是省略的。上述例子中是为了强调在闭包创建的同时，上下文的数据就会保存起来。 当下次调用该函数的时候，自由变量就可以在保存的（闭包）上下文中找到了，正如上述代码所示，变量 <code>z</code> 的值总是10。</p><p>定义中我们使用的比较广义的词 —— “代码块”，然而，通常（在 ECMAScript 中）会使用我们经常用到的函数。当然，并不是所有对闭包的实现都会将闭包和函数绑在一起，比方说，在 Ruby 语言中，闭包就有可能是：一个程序对象（procedure object），一个 lambda 表达式或者是代码块。</p><p>对于要实现将局部变量在上下文销毁后仍然保存下来，基于堆栈的实现显然是不适用的（因为与基于堆栈的结构相矛盾）。 因此在这种情况下，上层作用域的闭包数据是通过动态分配内存的方式来实现的（基于“堆”的实现），配合使用垃圾回收器（garbage collector 简称 GC）和引用计数（reference counting）。这种实现方式比基于堆栈的实现性能要低，然而，任何一种实现总是可以优化的：可以分析函数是否使用了自由变量，函数式参数或者函数式值，然后根据情况来决定 —— 是将数据存放在堆栈中还是堆中。</p><h2><span id="ecmascript-闭包的实现">ECMAScript 闭包的实现</span></h2><p>讨论完理论部分，接下来让我们来介绍下 ECMAScript 中闭包究竟是如何实现的。这里还是有必要再次强调下：ECMAScript 只使用<a href="http://en.wikipedia.org/wiki/Scope_programming#Lexical_scoping" target="_blank" rel="external">静态（词法）作用域</a>（而诸如 Perl 这样的语言，既可以使用静态作用域也可以使用动态作用域进行变量声明）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">funArg</span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</div><div class="line"> </div><div class="line">  <span class="comment">// funArg的变量 "x" 是静态保存的，在该函数创建的时候就保存了</span></div><div class="line"> </div><div class="line">  funArg(); <span class="comment">// 10, 而不是 20</span></div><div class="line"> </div><div class="line">&#125;)(foo);</div></pre></td></tr></table></figure><p>从技术角度来说，创建该函数的上层上下文的数据是保存在函数的内部属性 <code>[[Scope]]</code> 中的。如果你还不了解什么是 <code>[[Scope]]</code>，建议你先阅读<a href="http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/">第四章</a>，该章节对 <code>[[Scope]]</code> 作了非常详细的介绍。如果你对 <code>[[Scope]]</code> 和作用域链的知识完全理解了的话，那对闭包也就完全理解了。</p><p>根据函数创建的算法，我们知道在 ECMAScript 中，所有的函数都是闭包，因为它们都是在创建的时候就保存了上层上下文的作用域链（除开异常的情况，不管这个函数后续是否会激活 —— <code>[[Scope]]</code> 在函数创建的时候就有了）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// foo is a closure</span></div><div class="line">foo: <span class="xml"><span class="tag">&lt;<span class="name">FunctionObject</span>&gt;</span> = &#123;</span></div><div class="line">  [[Call]]: &lt;code block of foo&gt;,</div><div class="line">  [[Scope]]: [</div><div class="line">    global: &#123;</div><div class="line">      x: 10</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  ... // other properties</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>正如此前提到过的，出于优化的目的，当函数不使用自由变量的时候，实现层可能就不会保存上层作用域链。然而，ECMAScript-262-3 标准中并未对此作任何说明；因此，严格来说 —— 所有函数都会在创建的时候将上层作用域链保存在 <code>[[Scope]]</code> 中。</p><p>在某些实现中，允许对闭包作用域直接进行访问。比如 Rhino，针对函数的 <code>[[Scope]]</code> 属性，对应有一个非标准的 <code>__parent__</code> 属性，在<a href="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/">第二章</a>中作过介绍：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</div><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(y);</div><div class="line">  &#125;;</div><div class="line"> </div><div class="line">&#125;)();</div><div class="line"> </div><div class="line">foo(); <span class="comment">// 20</span></div><div class="line">alert(foo.__parent__.y); <span class="comment">// 20</span></div><div class="line"> </div><div class="line">foo.__parent__.y = <span class="number">30</span>;</div><div class="line">foo(); <span class="comment">// 30</span></div><div class="line"> </div><div class="line"><span class="comment">// 还可以操作作用域链</span></div><div class="line">alert(foo.__parent__.__parent__ === global); <span class="comment">// true</span></div><div class="line">alert(foo.__parent__.__parent__.x); <span class="comment">// 10</span></div></pre></td></tr></table></figure><h3><span id="万能的-scope">“万能”的 <code>[[Scope]]</code></span></h3><p>这里还要注意的是：在 ECMAScript 中，同一个上下文中创建的闭包是共用一个 <code>[[Scope]]</code> 属性的。也就是说，某个闭包对其中的变量做修改会影响到其他闭包对其变量的读取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> firstClosure;</div><div class="line"><span class="keyword">var</span> secondClosure;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"> </div><div class="line">  firstClosure = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> ++x; &#125;;</div><div class="line">  secondClosure = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> --x; &#125;;</div><div class="line"> </div><div class="line">  x = <span class="number">2</span>; <span class="comment">// 对AO["x"]产生了影响, 其值在两个闭包的[[Scope]]中</span></div><div class="line"> </div><div class="line">  alert(firstClosure()); <span class="comment">// 3, 通过 firstClosure.[[Scope]]</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo();</div><div class="line"> </div><div class="line">alert(firstClosure()); <span class="comment">// 4</span></div><div class="line">alert(secondClosure()); <span class="comment">// 3</span></div></pre></td></tr></table></figure><p>正因为这个特性，很多人都会犯一个非常常见的错误：当在循环中创建了函数，然后将循环的索引值和每个函数绑定的时候，通常得到的结果不是预期的（预期是希望每个函数都能够获取各自对应的索引值）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [];</div><div class="line"> </div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</div><div class="line">  data[k] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(k);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">data[<span class="number">0</span>](); <span class="comment">// 3, 而不是 0</span></div><div class="line">data[<span class="number">1</span>](); <span class="comment">// 3, 而不是 1</span></div><div class="line">data[<span class="number">2</span>](); <span class="comment">// 3, 而不是 2</span></div></pre></td></tr></table></figure><p>上述例子就证明了 —— 同一个上下文中创建的闭包是共用一个 <code>[[Scope]]</code> 属性的。因此上层上下文中的变量 <code>k</code>是可以很容易就被改变的。</p><p>如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">activeContext.Scope = [</div><div class="line">  ... <span class="comment">// higher variable objects</span></div><div class="line">  &#123;<span class="attr">data</span>: [...], <span class="attr">k</span>: <span class="number">3</span>&#125; <span class="comment">// activation object</span></div><div class="line">];</div><div class="line"> </div><div class="line">data[<span class="number">0</span>].[[Scope]] === Scope;</div><div class="line">data[<span class="number">1</span>].[[Scope]] === Scope;</div><div class="line">data[<span class="number">2</span>].[[Scope]] === Scope;</div></pre></td></tr></table></figure><p>这样一来，在函数激活的时候，最终使用到的 <code>k</code> 就已经变成了 <code>3</code> 了。</p><p class="j-quote">这与所有变量都是在代码执行前创建好相关，即在进入上下文阶段时创建了所有变量，这个行为就是所谓的“变量提升”。</p><p>如下所示，创建一个额外的闭包就可以解决这个问题了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [];</div><div class="line"> </div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</div><div class="line">  data[k] = (<span class="function"><span class="keyword">function</span> <span class="title">_helper</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      alert(x);</div><div class="line">    &#125;;</div><div class="line">  &#125;)(k); <span class="comment">// 将 "k" 值传递进去</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 现在就对了</span></div><div class="line">data[<span class="number">0</span>](); <span class="comment">// 0</span></div><div class="line">data[<span class="number">1</span>](); <span class="comment">// 1</span></div><div class="line">data[<span class="number">2</span>](); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>上述例子中，函数 <code>_helper</code> 创建出来之后，通过参数 <code>k</code> 激活。其返回值也是个函数，该函数保存在对应的数组元素中。这种技术产生了如下效果：在函数激活时，每次 <code>_helper</code> 都会创建一个新的变量对象，其中含有参数 <code>x</code>，<code>x</code> 的值就是传递进来的 <code>k</code> 的值。这样一来，返回的函数的 <code>[[Scope]]</code> 就成了如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">data[<span class="number">0</span>].[[Scope]] === [</div><div class="line">  ... <span class="comment">// 更上层的变量对象</span></div><div class="line">  上层上下文的AO: &#123;<span class="attr">data</span>: [...], <span class="attr">k</span>: <span class="number">3</span>&#125;,</div><div class="line">  _helper上下文的AO: &#123;<span class="attr">x</span>: <span class="number">0</span>&#125;</div><div class="line">];</div><div class="line"> </div><div class="line">data[<span class="number">1</span>].[[Scope]] === [</div><div class="line">  ... <span class="comment">// 更上层的变量对象</span></div><div class="line">  上层上下文的AO: &#123;<span class="attr">data</span>: [...], <span class="attr">k</span>: <span class="number">3</span>&#125;,</div><div class="line">  _helper上下文的AO: &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;</div><div class="line">];</div><div class="line"> </div><div class="line">data[<span class="number">2</span>].[[Scope]] === [</div><div class="line">  ... <span class="comment">// 更上层的变量对象</span></div><div class="line">  上层上下文的AO: &#123;<span class="attr">data</span>: [...], <span class="attr">k</span>: <span class="number">3</span>&#125;,</div><div class="line">  _helper上下文的AO: &#123;<span class="attr">x</span>: <span class="number">2</span>&#125;</div><div class="line">];</div></pre></td></tr></table></figure><p>我们看到，这个时候函数的 <code>[[Scope]]</code> 属性就有了真正想要的值了，为了达到这样的目的，我们不得不在 <code>[[Scope]]</code> 中创建额外的变量对象。要注意的是，在返回的函数中，如果要获取 <code>k</code> 的值，那么该值还是会是 <code>3</code>。</p><p>顺便提一下，大量介绍 JavaScript 的文章都认为只有额外创建的函数才是闭包，这种说法是错误的。实践得出，这种方式是最有效的，然而，从理论角度来说，在 ECMAScript 中所有的函数都是闭包。</p><p>然而，上述提到的方法并不是唯一的方法。通过其他方式也可以获得正确的 <code>k</code> 的值，比如下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [];</div><div class="line"> </div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</div><div class="line">  (data[k] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="built_in">arguments</span>.callee.x);</div><div class="line">  &#125;).x = k; <span class="comment">// 将“k”存储为函数的一个属性</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 同样也是可行的</span></div><div class="line">data[<span class="number">0</span>](); <span class="comment">// 0</span></div><div class="line">data[<span class="number">1</span>](); <span class="comment">// 1</span></div><div class="line">data[<span class="number">2</span>](); <span class="comment">// 2</span></div></pre></td></tr></table></figure><h3><span id="funarg-和-return">Funarg 和 return</span></h3><p>另外一个特性是从闭包中返回。在 ECMAScript 中，闭包中的返回语句会将控制流返回给调用上下文（调用者）。而在其他语言中，比如 Ruby，有很多中形式的闭包，相应的处理闭包返回也都不同，下面几种方式都是可能的：可能直接返回给调用者，或者在某些情况下 —— 直接从上下文退出。</p><p>ECMAScript 标准的退出行为如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElement</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (element % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// 返回给函数"forEach"，</span></div><div class="line">      <span class="comment">// 而不会从getElement函数返回</span></div><div class="line">      alert(<span class="string">'found: '</span> + element); <span class="comment">// found: 2</span></div><div class="line">      <span class="keyword">return</span> element;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">  &#125;);</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">alert(getElement()); <span class="comment">// null, 而不是 2</span></div></pre></td></tr></table></figure><p>然而，在 ECMAScript 中通过 <code>try catch</code> 可以实现如下效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $<span class="keyword">break</span> = &#123;&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElement</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line"> </div><div class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</div><div class="line"> </div><div class="line">      <span class="keyword">if</span> (element % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 直接从getElement"返回"</span></div><div class="line">        alert(<span class="string">'found: '</span> + element); <span class="comment">// found: 2</span></div><div class="line">        $<span class="keyword">break</span>.data = element;</div><div class="line">        <span class="keyword">throw</span> $<span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="keyword">if</span> (e == $<span class="keyword">break</span>) &#123;</div><div class="line">      <span class="keyword">return</span> $<span class="keyword">break</span>.data;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">alert(getElement()); <span class="comment">// 2</span></div></pre></td></tr></table></figure><h3><span id="理论版本">理论版本</span></h3><p>通常，程序员会误认为，只有匿名函数才是闭包。其实并非如此，正如我们所看到的 —— 正是因为作用域链（静态），使得所有的函数都是闭包（与函数类型无关：匿名函数，FE，NFE，FD 都是闭包），这里只有一类函数除外，那就是通过 <code>Function</code> 构造器创建的函数，因为其 <code>[[Scope]]</code> 只包含全局对象。为了更好的澄清该问题，我们对 ECMAScript 中的闭包作两个定义（即两种闭包）。</p><p>ECMAScript中，闭包指的是：</p><ul><li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li><li>从实践角度：以下函数才算是闭包：<ul><li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li><li>在代码中引用了自由变量 </li></ul></li></ul><h2><span id="闭包实践">闭包实践</span></h2><p>实际使用的时候，闭包可以创建出非常优雅的设计，允许对 funarg 上定义的多种计算方式进行定制。如下就是数组排序的例子，它接受一个排序条件函数作为参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">  ... <span class="comment">// 排序条件</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>同样的例子还有，数组的 <code>map</code> 方法（并非所有的实现都支持数组 <code>map</code> 方法，SpiderMonkey 从 1.6 版本开始有支持），该方法根据函数中定义的条件将原数组映射到一个新的数组中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> element * <span class="number">2</span>;</div><div class="line">&#125;); <span class="comment">// [2, 4, 6]</span></div></pre></td></tr></table></figure><p>使用函数式参数，可以很方便的实现一个搜索方法，并且可以支持无穷多的搜索条件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">someCollection.find(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> element.someProperty == <span class="string">'searchCondition'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>还有应用函数，比如常见的 <code>forEach</code> 方法，将 funarg 应用到每个数组元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (element % <span class="number">2</span> != <span class="number">0</span>) &#123;</div><div class="line">    alert(element);</div><div class="line">  &#125;</div><div class="line">&#125;); <span class="comment">// 1, 3</span></div></pre></td></tr></table></figure><p>顺便提下，函数的 <code>apply</code> 和 <code>call</code> 方法，在函数式编程中也可以用作应用函数。 <code>apply</code> 和 <code>call</code> 已经在讨论 <code>this</code> 的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在 <code>apply</code> 中是参数列表，在 <code>call</code> 中是独立的参数）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert([].join.call(<span class="built_in">arguments</span>, <span class="string">';'</span>)); <span class="comment">// 1;2;3</span></div><div class="line">&#125;).apply(<span class="keyword">this</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div></pre></td></tr></table></figure><p>闭包还有另外一个非常重要的应用 —— 延迟调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(a); <span class="comment">// 10, 一秒钟后</span></div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure><p>也可以用于回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"><span class="comment">// only for example</span></div><div class="line">xmlHttpRequestObject.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 当数据就绪的时候，才会调用;</span></div><div class="line">  <span class="comment">// 这里，不论是在哪个上下文中创建，变量“x”的值已经存在了</span></div><div class="line">  alert(x); <span class="comment">// 10</span></div><div class="line">&#125;;</div><div class="line">..</div></pre></td></tr></table></figure><p>还可以用于封装作用域来隐藏辅助对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// initialization</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line">  object.getX = <span class="function"><span class="keyword">function</span> <span class="title">_getX</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">  &#125;;</div><div class="line"> </div><div class="line">&#125;)(foo);</div><div class="line"> </div><div class="line">alert(foo.getX()); <span class="comment">// get closured "x" – 10</span></div></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>本文介绍了更多关于 ECMAScript-262-3 的理论知识，而我认为，这些基础的理论有助于理解 ECMAScript 中闭包的概念。</p><h2><span id="扩展阅读">扩展阅读</span></h2><ul><li><a href="http://jibbering.com/faq/notes/closures/" target="_blank" rel="external">Javascript Closures (by Richard Cornford)</a></li><li><a href="http://en.wikipedia.org/wiki/Funarg_problem" target="_blank" rel="external">Funarg problem</a></li><li><a href="http://en.wikipedia.org/wiki/Closure_(computer_science)" target="_blank" rel="external">Closures</a></li></ul><p class="j-dot"><strong>Translated by:</strong> Dmitry Soshnikov.<br><strong>Published on:</strong> 2010-02-28<br><br><strong>Originally written by:</strong> Dmitry Soshnikov [ru, <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-6-closures/" target="_blank" rel="external">read »</a>]<br><strong>Originally published on:</strong> 2009-07-20 [ru]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;http://dmitrysoshnikov.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dmitry A. Soshnikov&lt;/a&gt; 的文章 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMA-262-3 in detail. Chapter 6. Closures&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;其中大部分参考了 &lt;a href=&quot;http://zh.blog.goddyzhao.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;goddyzhao&lt;/a&gt; 的&lt;a href=&quot;http://zh.blog.goddyzhao.me/post/11311499651/closures&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;翻译&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文将介绍在 JavaScript 中大家经常讨论的话题 – 闭包（Closure）。事实上，闭包是个老生常谈的话题了，管如此，这里还是要试着从理论角度来讨论下闭包，看看 ECMAScript 中的闭包内部究竟是如何工作的。&lt;/p&gt;
&lt;p&gt;正如在此前文章中提到的，这些文章都是系列文章，相互之间都是有关联的。因此，为了更好的理解本文要介绍的内容， 建议先去阅读下&lt;a href=&quot;http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/&quot;&gt;第四章 作用域链&lt;/a&gt;和&lt;a href=&quot;http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/&quot;&gt;第二章 变量对象&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ECMAScript" scheme="http://bubkoo.com/tags/ecmascript/"/>
    
      <category term="ECMA-262-3" scheme="http://bubkoo.com/tags/ecma-262-3/"/>
    
      <category term="Closure" scheme="http://bubkoo.com/tags/closure/"/>
    
      <category term="Funarg" scheme="http://bubkoo.com/tags/funarg/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3 详解 第五章 函数</title>
    <link href="http://bubkoo.com/2014/06/12/ecma-262-3-in-detail-chapter-5-functions/"/>
    <id>http://bubkoo.com/2014/06/12/ecma-262-3-in-detail-chapter-5-functions/</id>
    <published>2014-06-12T21:56:23.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">Dmitry A. Soshnikov</a> 的文章 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 5. Functions</a>.</p><p>其中大部分参考了 <a href="http://zh.blog.goddyzhao.me/" target="_blank" rel="external">goddyzhao</a> 的<a href="http://zh.blog.goddyzhao.me/post/11273713920/functions#_=_" target="_blank" rel="external">翻译</a>。</p><h2><span id="概述">概述</span></h2><p>本文将介绍 ECMAScript 中一个非常常见的对象 – 函数。我们将着重介绍函数都有哪些类型，不同类型的函数是如何影响上下文的变量对象的，以及每种类型的函数的作用域链中都包含什么，并回答诸如下面这样的问题：下面声明的函数有什么区别吗？（如果有，区别是什么）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上述方式创建的函数和如下方式创建的有什么不同？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面代码为什么要用一个括号包起来呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>本文和此前几篇文章都是有关联的，因此，要想完全搞懂这部分内容，建议先去阅读<a href="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/">第二章 变量对象</a>以及<a href="http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/">第四章 作用域链</a>。</p><p>下面，我们首先来看一下函数类型。</p><a id="more"></a><h2><span id="函数类型">函数类型</span></h2><p>ECMAScript 中包含三类函数，每一类都有各自的特性。</p><h3><span id="函数声明function-declaration">函数声明（Function Declaration）</span></h3><blockquote><p>函数声明（简称FD）是指这样的函数：</p><ul><li>一个必选的函数名</li><li>代码位置：要么是程序级别，要么在另一个函数体中</li><li>在进入上下文阶段时被创建</li><li>会影响变量对象</li><li>以如下方式声明：</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">exampleFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这类函数的主要特性是：只有它们可以影响变量对象（储存在上下文的 VO 中）。这个特性同时也解释了第二个重要点（它是变量对象特性的结果）—— 在代码执行阶段它们已经可用（因为 FD 在进入上下文阶段已经存在于 VO 中 —— 代码执行之前）。</p><p>例如（函数在其声明之前被调用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'foo'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从定义中还提到了非常重要的一点 —— 函数声明在代码中的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数声明可以直接在程序级别的全局上下文中</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalFD</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 或者直接在另外一个函数的函数体中</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFD</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>只有这两个位置可以声明函数，也就是说，在表达式的位置或者是代码块中进行函数声明都是不可以的。</p><p>介绍完了函数声明，接下来介绍函数表达式（function expression）。</p><h3><span id="函数表达式function-expression">函数表达式（Function Expression）</span></h3><blockquote><p>函数表达式（简称：FE）是指这样的函数：</p><ul><li>代码位置必须要在表达式的位置</li><li>函数名是可选的</li><li>不会影响变量对象</li><li>在执行代码阶段才被创建</li></ul></blockquote><p>这类函数的主要特性是：它们的代码总是在表达式的位置。最简单的表达式的例子就是赋值表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上述例子中将一个匿名函数赋值给了变量 <code>foo</code>，之后该函数就可以通过 <code>foo</code> 来访问了 ——  <code>foo()</code>。</p><p>正如定义中提到的，函数表达式也可以有名字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">_foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这里要注意的是，在函数表达式的外部可以通过变量 <code>foo</code> ——<code>foo()</code> 来访问，而在函数内部（比如递归调用），还可以用 <code>_foo</code>（译者注：但在外部是无法使用 <code>_foo</code> 的）。</p><p>当函数表达式有名字的时候，它很难和函数声明作区分。不过，如果仔细看这两者的定义的话，要区分它们还是很容易的：函数表达式总是在表达式的位置。 如下例子展示的各类 ECMAScript 表达式都属于函数表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在括号中(grouping operator)只可能是表达式</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 在数组初始化中 —— 同样也只能是表达式</span></div><div class="line">[<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;];</div><div class="line"> </div><div class="line"><span class="comment">// 逗号操作符也只能跟表达式</span></div><div class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure><p>定义中还提到函数表达式是在执行代码阶段创建的，并且不是存储在变量对象上的。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不论是在定义前还是定义后，FE都是无法访问的</span></div><div class="line"><span class="comment">// (因为它是在代码执行阶段创建出来的),</span></div><div class="line"> </div><div class="line">alert(foo); <span class="comment">// "foo" is not defined</span></div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 后面也没用，因为它根本就不在VO中</span></div><div class="line"> </div><div class="line">alert(foo);  <span class="comment">// "foo" is not defined</span></div></pre></td></tr></table></figure><p>问题来了，函数表达式要来干嘛？其实答案是很明显的 —— 在表达式中使用，从而避免对变量对象造成“污染”。最简单的例子就是将函数作为参数传递给另外一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">  callback();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'foo.bar'</span>);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">foo(<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'foo.baz'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>上述例子中，部分变量存储了对FE的引用，这样函数就会保留在内存中并在之后，可以通过变量来访问（因为变量是可以影响 VO 的）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'foo'</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">foo();</div></pre></td></tr></table></figure><p>另外一个例子是创建封装的闭包从外部上下文中隐藏辅助性数据（在下面的例子中我们使用 FE，它在创建后立即调用）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;&#125;;</div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line">  foo.bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(x);</div><div class="line">  &#125;;</div><div class="line"> </div><div class="line">&#125;)();</div><div class="line"> </div><div class="line">foo.bar(); <span class="comment">// 10;</span></div><div class="line"> </div><div class="line">alert(x); <span class="comment">// "x" 未定义</span></div></pre></td></tr></table></figure><p>我们看到函数 <code>foo.bar</code>（通过其 <code>[[Scope]]</code> 属性）获得了对函数 <code>initialize</code> 内部变量 <code>x</code> 的访问。 而同样的 <code>x</code> 在外部就无法访问到。很多库都使用这种策略来创建“私有”数据以及隐藏辅助数据。通常，这样的情况下 FE 的名字都会省略掉：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="comment">// 初始化作用域</span></div><div class="line"> </div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>还有一个 FE 的例子是：在执行代码阶段在条件语句中创建 FE，这种方式也不会影响 VO：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> bar = (foo % <span class="number">2</span> == <span class="number">0</span></div><div class="line">  ? <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="number">0</span>); &#125;</div><div class="line">  : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="number">1</span>); &#125;</div><div class="line">);</div><div class="line"> </div><div class="line">bar(); <span class="comment">// 0</span></div></pre></td></tr></table></figure><p>注意：ES5 标准的绑定函数，使函数正确绑定 <code>this</code> 的值，将其锁定在函数的任何调用中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> boundFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x;</div><div class="line">&#125;.bind(&#123;<span class="attr">x</span>: <span class="number">10</span>&#125;);</div><div class="line"> </div><div class="line">boundFn(); <span class="comment">// 10</span></div><div class="line">boundFn.call(&#123;<span class="attr">x</span>: <span class="number">20</span>&#125;); <span class="comment">// 仍然是 10</span></div></pre></td></tr></table></figure><p>绑定功能最常使用在事件监听或推迟（<code>setTimeout</code>）执行函数时，保证函数执行时 <code>this</code> 是指定的对象。</p><p>你可以在 ES5 系列的 <a href="http://dmitrysoshnikov.com/notes/note-1-ecmascript-bound-functions/" target="_blank" rel="external">appropriate chapter</a> 中获取更多关于绑定函数的细节。</p><h4><span id="有关括号的问题">“有关括号”的问题</span></h4><p>现在让我们来回答本文开始提到的问题 – “为什么立即执行的函数需要用括号将其包起来？”。答案就是：将函数限制为表达式语句。</p><p>标准中提到，表达式语句（ExpressionStatement）不能以左大括号 <code>{</code> 开始 —— 因为这样一来就和代码块冲突了， 也不能以 <code>function</code> 关键字开始，因为这样一来又和函数声明冲突了。也就是说，以如下所示的方式来定义一个立即执行的函数，解释器都会抛出错误，只是原因不同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;();</div><div class="line"> </div><div class="line"><span class="comment">// or with a name</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;();</div></pre></td></tr></table></figure><p>如果我们是在全局代码（程序级别）中这样定义函数，解释器会以函数声明来处理，因为它看到了是以 <code>function</code> 开始的。在第一个例子中，会抛出语法错误，原因是既然是个函数声明，则缺少函数名了（一个函数声明其名字是必须的）。</p><p>而在第二个例子中，看上去已经有了名字了（foo），应该会正确执行。然而，这里还是会抛出语法错误 —— 分组操作符内部缺少表达式。这里要注意的是，这个例子中，函数声明后面的()会被当组操作符来处理，而非函数调用的()。因此，如果我们有如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// "foo" 是函数声明</span></div><div class="line"><span class="comment">// 并且是在进入上下文的时候创建的</span></div><div class="line"> </div><div class="line">alert(foo); <span class="comment">// function</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  alert(x);</div><div class="line">&#125;(<span class="number">1</span>); <span class="comment">// 这里只是组操作符，并非调用!</span></div><div class="line"> </div><div class="line">foo(<span class="number">10</span>); <span class="comment">// 这里就是调用了, 10</span></div></pre></td></tr></table></figure><p>上述代码其实就是如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// function declaration</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 含表达式的组操作符</span></div><div class="line">(<span class="number">1</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 另外一个组操作符</span></div><div class="line"><span class="comment">// 包含一个函数表达式</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 这里面也是表达式</span></div><div class="line">(<span class="string">"foo"</span>);</div><div class="line"> </div><div class="line"><span class="comment">// etc</span></div></pre></td></tr></table></figure><p>如果我们定义一个如下代码（定义里包含一个语句），我们可能会说，定义歧义，会得到报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;alert(<span class="number">1</span>)&#125;</div></pre></td></tr></table></figure><p>根据规范，上述代码是错误的（一个表达式语句不能以 <code>function</code> 关键字开头）。然而，正如我们在后面要看到的，没有一种实现对其抛出错误， 它们各自按照自己的方式在处理。</p><p>那么究竟怎样才能创建一个立即执行的函数呢？答案很明显，它必须是个函数表达式，而不能是函数声明。而创建表达式最简单的方式就是使用上述提到的组操作符。因为在组操作符中只可能是表达式。 这样一来解释器也不会纠结了，会果断将其以 FE 的方式来处理。这样的函数将在执行阶段创建出来，然后立马执行，随后被移除（如果有没有对其的引用的话）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  alert(x);</div><div class="line">&#125;)(<span class="number">1</span>); <span class="comment">// 好了，这样就是函数调用了，而不再是组操作符了，1</span></div></pre></td></tr></table></figure><p>要注意的是，在下面的例子中，函数调用，其括号就不再是必须的了，因为函数本来就在表达式的位置了，解释器自然会以 FE 来处理，并且会在执行代码阶段创建该函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line"> </div><div class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x % <span class="number">2</span> != <span class="number">0</span> ? <span class="string">'yes'</span> : <span class="string">'no'</span>;</div><div class="line">  &#125;(<span class="number">1</span>)</div><div class="line"> </div><div class="line">&#125;;</div><div class="line"> </div><div class="line">alert(foo.bar); <span class="comment">// 'yes'</span></div></pre></td></tr></table></figure><p>因此，对“括号有关”问题的完整的回答则如下所示：</p><blockquote><p>如果要在函数创建后立马进行函数调用，并且函数不在表达式的位置时，括号就是必须的 —— 这样情况下，其实是手动的将其转换成了 FE。 而当解释器直接将其以 FE 的方式处理的时候，说明 FE 本身就在函数表达式的位置 —— 这个时候括号就不是必须的了。</p></blockquote><p>另外，除了使用括号的方式将函数转换成为FE之外，还有其他的方式，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'anonymous function is called'</span>);</div><div class="line">&#125;();</div><div class="line"> </div><div class="line"><span class="comment">// 或者这样</span></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'ECMAScript'</span>);</div><div class="line">&#125;();</div><div class="line"> </div><div class="line"><span class="comment">// 当然，还有其他很多方式</span></div><div class="line">...</div></pre></td></tr></table></figure><p>不过，括号是最通用也是最优雅的方式。</p><p>顺便提下，组操作符既可以包含没有调用括号的函数，又可以包含有调用括号的函数，这两者都是合法的 FE：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)();</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;());</div></pre></td></tr></table></figure><h4><span id="实现扩展函数语句">实现扩展：函数语句</span></h4><p>看如下代码，符合规范的解释器都无法解释这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(); <span class="comment">// 1 还是 0 ? 在不同引擎中测试</span></div></pre></td></tr></table></figure><p>这里有必要提下：根据标准，上述代码结构是不合法的，因为，此前我们就介绍过，函数声明是不能出现在代码块中的（这里 <code>if</code> 和 <code>else</code> 就包含代码块）。此前提到的，函数声明只能出现在两个位置：程序级别或者另外一个函数的函数体中。</p><p>为什么这种结构是错误的呢？因为在代码块中只允许语句。函数要想在这个位置出现的唯一可能就是要成为表达式语句。 但是，根据定义表达式语句又不能以左大括号开始（这样会与代码块冲突）也不能以 <code>function</code> 关键字开始（这样又会和 FD 冲突）。</p><p>然而，在错误处理部分，规范允许实现对程序语法进行扩展。而上述例子就是其中一种扩展。目前，所有的实现中都不会对上述情况抛出错误，都会以各自的方式进行处理。</p><p>因此根据规范，上述 <code>if-else</code> 中应当需要 FE。然而，绝大多数实现中都在进入上下文的时候在这里简单地创建了 FD，并且使用了最后一次的声明。最后 <code>foo</code> 函数显示了 <code>1</code>，尽管理论上 <code>else</code> 中的代码根本不会被执行到。</p><p>而 SpiderMonkey（TraceMonkey 也是）实现中，会将上述情况以两种方式来处理：一方面它不会将这样的函数以函数声明来处理（也就意味着函数会在执行代码阶段才会创建出来），然而，另外一方面，它们又不属于真正的函数表达式，因为在没有括号的情况是不能作函数调用的（同样会有解析错误 —— 和 FD 冲突），它们还是存储在变量对象中。</p><p>我认为 SpiderMonkey 单独引入了自己的中间函数类型 ——（FE+FD），这样的做法是正确的。这样的函数会根据时间和对应的条件正确创建出来，不像 FE。和 FD 有点类似，可以在外部对其进行访问。SpiderMonkey 将这种语法扩展命名为函数语句（Function Statement）（简称 FS）；这部分理论在 MDC 中有<a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Functions#Conditionally_defining_a_function" target="_blank" rel="external">具体介绍</a>。JavaScript 的发明者  Brendan Eich 也<a href="https://mail.mozilla.org/pipermail/es-discuss/2008-February/005314.html" target="_blank" rel="external">提到过</a>这类函数类型。</p><h4><span id="命名函数表达式nfe的特性">命名函数表达式（NFE）的特性</span></h4><p>当 FE 有名字之后（named function expression，简称：NFE），就产生了一个重要的特性。正如在定义中提到的，函数表达式是不会影响上下文的变量对象的（这就意味着不论是在定义前还是在定义后，都是不可能通过名字来进行调用的）。然而，FE 可以通过自己的名字进行递归调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar</span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">if</span> (bar) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  foo(<span class="literal">true</span>); <span class="comment">// "foo" name is available</span></div><div class="line"> </div><div class="line">&#125;)();</div><div class="line"> </div><div class="line"><span class="comment">// but from the outside, correctly, is not</span></div><div class="line"> </div><div class="line">foo(); <span class="comment">// "foo" is not defined</span></div></pre></td></tr></table></figure><p>这里 <code>foo</code> 这个名字究竟保存在哪里呢？在 <code>foo</code> 的活跃对象中吗？非也，因为在 <code>foo</code> 函数中根本就没有定义任何 <code>foo</code>。那么是在上层上下文的变量对象中吗？也不是，因为根据定义 —— FE 是不会影响 VO 的 —— 正如我们在外层对其调用的结果所看到的那样。那么，它究竟保存在哪里了呢？</p><p>不卖关子了，马上来揭晓。当解释器在执行代码阶段看到了有名字的 FE 之后，它会在创建 FE 之前，创建一个辅助型的特殊对象，并把它添加到当前的作用域链中。然后，再创建 FE，在这个时候（根据<a href="http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/">第四章 作用域链</a>的描述），函数拥有了 <code>[[Scope]]</code> 属性 —— 创建函数所在上下文的作用域链（这个时候，在 <code>[[Scope]]</code> 就有了那个特殊对象）。之后，特殊对象中唯一的属性 —— FE 的名字添加到了该对象中；其值就是对 FE 的引用。在最后，当前上下文退出的时候，就会把该特殊对象移除。 用伪代码来描述此算法就如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">specialObject = &#123;&#125;;</div><div class="line"> </div><div class="line">Scope = specialObject + Scope;</div><div class="line"> </div><div class="line">foo = FunctionExpression;</div><div class="line">foo.[[Scope]] = Scope;</div><div class="line">specialObject.foo = foo; <span class="comment">// &#123;DontDelete&#125;, &#123;ReadOnly&#125;</span></div><div class="line"> </div><div class="line"><span class="keyword">delete</span> Scope[<span class="number">0</span>]; <span class="comment">// 从作用域链的最前面移除specialObject</span></div></pre></td></tr></table></figure><p>这就是为什么在函数外是无法通过名字访问到该函数的（因为它并不在上层作用域中存在），而在函数内部却可以访问到。</p><p>而这里要注意的一点是：在某些实现中，比如 Rhino，FE 的名字并不是保存在特殊对象中的，而是保存在 FE 的活跃对象中。再比如微软的实现 —— JScript，则完全破坏了 FE 的规则，直接将该名字保存在上层作用域的变量对象中了，这样在外部也可以访问到。</p><h4><span id="nfe-和-spidermonkey">NFE 和 SpiderMonkey</span></h4><p>说到实现，部分版本的 SpiderMonkey 有一个与上述提到的特殊对象相关的特性，这个特性也可以看作是个 bug（既然所有的实现都是严格遵循标准的，那么这个就是标准的问题了）。此特性和标识符处理相关：作用域链的分析是二维的，在标识符查询的时候，还要考虑作用域链中每个对象的原型链。</p><p>当在 <code>Object.prototype</code> 对象上定义一个属性，并将该属性名指定为一个“根本不存在”的变量时，就能够体现该特性。 比如，下面例子中的变量 <code>x</code>，在作用域链查询过程中，一直到全局对象也是找不到 <code>x</code> 的。 然而，在 SpiderMonkey 中，全局对象继承自 <code>Object.prototype</code>，于是，对应的值就在该对象中找到了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(x); <span class="comment">// 10</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>活动对象是没有原型一说的。可以通过内部函数来证明。 如果在定义一个局部变量 <code>x</code> 并声明一个内部函数（FD 或者匿名的 FE），然后，在内部函数中引用变量 <code>x</code>，这个时候该变量会在上层函数上下文中查询到（理应如此），而不是在 <code>Object.prototype</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</div><div class="line"> </div><div class="line">  <span class="comment">// 函数声明</span></div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(x);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  bar(); <span class="comment">// 20, from AO(foo)</span></div><div class="line"> </div><div class="line">  <span class="comment">// 函数表达式也一样</span></div><div class="line"> </div><div class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(x); <span class="comment">// 20, also from AO(foo)</span></div><div class="line">  &#125;)();</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo();</div></pre></td></tr></table></figure><p>在有些实现中，存在这样的异常：它们会在活动对象上设置原型。比方说，在 Blackberry 的实现中，上述例子中变量 <code>x</code> 值就会变成 <code>10</code>。 因为 <code>x</code> 从 <code>Object.prototype</code> 中就找到了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AO(bar FD or anonymous FE) -&gt; no -&gt;</div><div class="line">AO(bar FD or anonymous FE).[[Prototype]] -&gt; yes - <span class="number">10</span></div></pre></td></tr></table></figure><p>当出现有名字的 FE 的特殊对象的时候，在 SpiderMonkey 中也是有同样的异常。该特殊对象是普通对象 —— “和通过 <code>new Object()</code> 表达式产生的一样”。相应地，它也应当继承自 <code>Object.prototype</code>，上述描述只针对 SpiderMonkey（1.7版本）。其他的实现（包括新的 TraceMonkey）是不会给这个特殊对象设置原型的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">    alert(x); <span class="comment">// 20, but not 10, as don't reach AO(foo)</span></div><div class="line"> </div><div class="line">    <span class="comment">// "x" is resolved by the chain:</span></div><div class="line">    <span class="comment">// AO(bar) - no -&gt; __specialObject(bar) -&gt; no</span></div><div class="line">    <span class="comment">// __specialObject(bar).[[Prototype]] - yes: 20</span></div><div class="line"> </div><div class="line">  &#125;)();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">20</span>;</div><div class="line"> </div><div class="line">foo();</div></pre></td></tr></table></figure><p class="j-quote">注意：在 ES5 中这个行为已经改变了，并且在当前版本的 Firefox 中，储存 FE 名字的对象不再继承自 <code>Object.prototype</code>。</p><h4><span id="nfe-和-jscript">NFE 和 JScript</span></h4><p>微软的实现 —— JScript，是 IE 的 JS 引擎（截至本文撰写时最新是 JScript5.8 —— IE8），该引擎与 NFE 相关的 bug 有很多。每个 bug 基本上都和 ECMA-262-3rd 规范是完全违背的。有些甚至会引发严重的错误。</p><p>第一，针对上述这样的情况，JScript 完全破坏了 FE 的规则：不应当将函数名字保存在变量对象中的。另外，FE 的名字应当保存在特殊对象中，并且只有在函数自身内部才可以访问（其他地方均不可以）。而 JScript 却将其直接保存在上层上下文的变量对象中。并且，JScript 居然还将 FE 以 FD 的方式处理，在进入上下文的时候就将其创建出来，并在定义之前就可以访问到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FE 保存在变量对象中</span></div><div class="line"><span class="comment">// 和FD一样，在定义前就可以通过名字访问到</span></div><div class="line">testNFE();</div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">testNFE</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'testNFE'</span>);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 同样的，在定义之后也可以通过名字访问到</span></div><div class="line">testNFE();</div></pre></td></tr></table></figure><p>正如大家所见，完全破坏了 FE 的规则。</p><p>第二，在声明同时，将 NFE 赋值给一个变量的时候，JScript 会创建两个不同的函数对象。 这种行为感觉完全不符合逻辑（特别是考虑到在 NFE 外层，其名字根本是无法访问到的）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'foo'</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">alert(<span class="keyword">typeof</span> bar); <span class="comment">// "function", NFE 在 VO 中了 – 这里就错了</span></div><div class="line"> </div><div class="line"><span class="comment">// 然后，还有更有趣的</span></div><div class="line">alert(foo === bar); <span class="comment">// false!</span></div><div class="line"> </div><div class="line">foo.x = <span class="number">10</span>;</div><div class="line">alert(bar.x); <span class="comment">// undefined</span></div><div class="line"> </div><div class="line"><span class="comment">// 然而，两个函数完全做的是同样的事情</span></div><div class="line"> </div><div class="line">foo(); <span class="comment">// "foo"</span></div><div class="line">bar(); <span class="comment">// "foo"</span></div></pre></td></tr></table></figure><p>然而，要注意的是： 当将 NFE 和赋值给变量这两件事情分开的话（比如，通过组操作符），在定义好后，再进行变量赋值，这样，两个对象就相同了，返回true：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> foo = bar;</div><div class="line"> </div><div class="line">alert(foo === bar); <span class="comment">// true</span></div><div class="line"> </div><div class="line">foo.x = <span class="number">10</span>;</div><div class="line">alert(bar.x); <span class="comment">// 10</span></div></pre></td></tr></table></figure><p>这个时候就好解释了。事实上，一开始的确创建了两个对象，不过之后就只剩下一个了。这里将 NFE 以 FD 的方式来处理，然后，当进入上下文的时候，FD <code>bar</code> 就创建出来了。 在这之后，到了执行代码阶段，又创建出了第二个对象 —— FE <code>bar</code>，该对象不会进行保存。相应的，由于没有变量对其进行引用，随后FE <code>bar</code> 对象就被移除了。 因此，这里就只剩下一个对象 —— FD <code>bar</code> 对象，对该对象的引用就赋值给了 <code>foo</code> 变量。</p><p>第三，通过 <code>arguments.callee</code> 对一个函数进行间接引用，它引用的是和激活函数名一致的对象（事实上是 —— 函数，因为有两个对象）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  alert([</div><div class="line">    <span class="built_in">arguments</span>.callee === foo,</div><div class="line">    <span class="built_in">arguments</span>.callee === bar</div><div class="line">  ]);</div><div class="line"> </div><div class="line">&#125;;</div><div class="line"> </div><div class="line">foo(); <span class="comment">// [true, false]</span></div><div class="line">bar(); <span class="comment">// [false, true]</span></div></pre></td></tr></table></figure><p>第四，JScript 会将 NFE 以 FD 来处理，但当遇到条件语句又不遵循此规则了。比如说，和 FD 那样，NFE 会在进入上下文的时候就创建出来，这样最后一次定义的就会被使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="number">1</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line"> </div><div class="line">  foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="number">2</span>);</div><div class="line">  &#125;;</div><div class="line"> </div><div class="line">&#125;</div><div class="line">bar(); <span class="comment">// 2</span></div><div class="line">foo(); <span class="comment">// 1</span></div></pre></td></tr></table></figure><p>上述行为从逻辑上也是可以解释通的：当进入上下文的时候，最后一次定义的FD <code>bar</code> 被创建出来（有 <code>alert(2)</code> 的函数），之后到了执行代码阶段又一个新的函数 —— FE <code>bar</code> 被创建出来，对其引用赋值给了变量 <code>foo</code>。因此（<code>if</code> 代码块中由于判断条件是 <code>false</code>，因此其代码块中的代码永远不会被执行到）<code>foo</code> 函数的调用会打印出 <code>1</code>。 尽管“逻辑上”是对的，但是这个仍然算是 IE 的 bug。因为它明显就破坏了实现的规则，所以我这里用了引号“逻辑上”。</p><p>第五个 JScript 中 NFE 的 bug 与给一个未受限的标识符赋值（也就是说，没有 <code>var</code> 关键字）来创建全局对象的属性相关。由于这里 NFE 会以 FD 的方式来处理，并相应地会保存在变量对象上，赋值给未受限的标识符（不是给变量而是给全局对象的一般属性），当函数名和标识符名字相同的时候，该属性就不会是全局的了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="comment">// 没有var，就不是局部变量，而是全局对象的属性</span></div><div class="line"> </div><div class="line">  foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"> </div><div class="line">&#125;)();</div><div class="line"> </div><div class="line"><span class="comment">// 然而，在匿名函数的外层，foo又是不可访问的</span></div><div class="line"> </div><div class="line">alert(<span class="keyword">typeof</span> foo); <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>这里从“逻辑上”又是可以解释通的：进入上下文时，函数声明在匿名函数本地上下文的活跃对象中。当进入执行代码阶段的时候，因为 <code>foo</code> 这个名字已经在 AO 中存在了（本地），相应地，赋值操作也只是简单的对 AO 中的 <code>foo</code> 进行更新而已。并没有在全局对象上创建新的属性。</p><h3><span id="通过-function-构造器创建的函数">通过 Function 构造器创建的函数</span></h3><p>这类函数有别于 FD 和 FE，有自己的专属特性： 它们的 <code>[[Scope]]</code> 属性中只包含全局对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</div><div class="line">  <span class="keyword">var</span> y = <span class="number">30</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'alert(x); alert(y);'</span>);</div><div class="line"> </div><div class="line">  bar(); <span class="comment">// 10, "y" is not defined</span></div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们看到 <code>bar</code> 函数的 <code>[[Scope]]</code> 属性并未包含 <code>foo</code> 上下文的 AO —— 变量 <code>y</code> 是无法访问的，并且变量 <code>x</code> 是来自全局上下文。顺便提下，这里要注意的是，<code>Function</code> 构造器可以通过 <code>new</code> 关键字和省略 <code>new</code> 关键字两种用法。上述例子中，这两种用法都是一样的。</p><p>此类函数其他特性则和<a href="http://bclary.com/2004/11/07/#a-13.1.1" target="_blank" rel="external">同类语法产生式</a>以及<a href="http://bclary.com/2004/11/07/#a-13.1.2" target="_blank" rel="external">联合对象</a>有关。 该机制在规范中建议在作优化的时候采用（当然，具体的实现者也完全有权利不使用这类优化）。比方说，有个 <code>100</code> 个元素的数组，在循环数组过程中会给数组每个元素赋值（函数），这个时候，实现的时候就可以采用联合对象的机制了。这样，最终所有的数组元素都会引用同一个函数（只有一个函数）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"> </div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</div><div class="line">  a[k] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 这里就可以使用联合对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是，通过 <code>Function</code> 构造器创建的函数就无法使用联合对象了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"> </div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k $lt; <span class="number">100</span>; k++) &#123;</div><div class="line">  a[k] = <span class="built_in">Function</span>(<span class="string">''</span>); <span class="comment">// 只能是100个不同的函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面是另外一个和联合对象相关的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">z</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> z * z;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> x = foo();</div><div class="line"><span class="keyword">var</span> y = foo();</div></pre></td></tr></table></figure><p>上述例子，在实现过程中同样可以使用联合对象。来使得 <code>x</code> 和 <code>y</code> 引用同一个对象，因为函数（包括它们内部的 <code>[[Scope]]</code> 属性）物理上是不可分辨的。 因此，通过 <code>Function</code> 构造器创建的函数总是会占用更多内存资源。</p><h2><span id="函数创建的算法">函数创建的算法</span></h2><p>如下所示使用伪代码表示的函数创建的算法（不包含联合对象的步骤）。有助于理解 ECMAScript 中的函数对象。此算法对所有函数类型都是一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">F = <span class="keyword">new</span> NativeObject();</div><div class="line"> </div><div class="line"><span class="comment">// 属性 [[Class]] is "Function"</span></div><div class="line">F.[[Class]] = <span class="string">"Function"</span></div><div class="line"> </div><div class="line"><span class="comment">// 函数对象的原型</span></div><div class="line">F.[[Prototype]] = <span class="built_in">Function</span>.prototype</div><div class="line"> </div><div class="line"><span class="comment">// 对函数自身引用</span></div><div class="line"><span class="comment">// [[Call]] 在函数调用时F()激活</span></div><div class="line"><span class="comment">// 同时创建一个新的执行上下文</span></div><div class="line">F.[[Call]] = <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></div><div class="line"><span class="xml"> </span></div><div class="line"><span class="xml">// 内置的构造器</span></div><div class="line"><span class="xml">// [[Construct]] 会在使用“new”关键字的时候激活</span></div><div class="line"><span class="xml">// 事实上，它会为新对象申请内存</span></div><div class="line"><span class="xml">// 然后调用 F.[[Call]]来初始化创建的对象，将this值设置为新创建的对象</span></div><div class="line"><span class="xml">F.[[Construct]] = internalConstructor</span></div><div class="line"><span class="xml"> </span></div><div class="line"><span class="xml">// 当前上下文（创建函数F的上下文）的作用域名链</span></div><div class="line"><span class="xml">F.[[Scope]] = activeContext.Scope</span></div><div class="line"><span class="xml">// 如果是通过new Function(...)来创建的，则</span></div><div class="line"><span class="xml">F.[[Scope]] = globalContext.Scope</span></div><div class="line"><span class="xml"> </span></div><div class="line"><span class="xml">// 形参的个数</span></div><div class="line"><span class="xml">F.length = countParameters</span></div><div class="line"><span class="xml"> </span></div><div class="line"><span class="xml">// 通过F创建出来的对象的原型</span></div><div class="line"><span class="xml">__objectPrototype = new Object();</span></div><div class="line"><span class="xml">__objectPrototype.constructor = F // &#123;DontEnum&#125;, 在遍历中不能枚举</span></div><div class="line"><span class="xml">F.prototype = __objectPrototype</span></div><div class="line"><span class="xml"> </span></div><div class="line"><span class="xml">return F</span></div></pre></td></tr></table></figure><p>要注意的是，<code>F.[[Prototype]]</code> 是函数（构造器）的原型，而 <code>F.prototype</code> 是通过该函数创建出来的对象的原型（因为通常对这两个概念都会混淆，在有些文章中会将 <code>F.prototype</code> 叫做“构造器的原型”，这是错误的）。</p><h2><span id="总结">总结</span></h2><p>本文介绍了很多关于函数的内容；不过在后面的关于对象和原型的文章中，还会提到函数作为构造器是如何工作的。</p><h2><span id="扩展阅读">扩展阅读</span></h2><ul><li><ol><li>— <a href="http://bclary.com/2004/11/07/#a-13" target="_blank" rel="external">Function Definition</a></li></ol></li><li>15.3 — <a href="http://bclary.com/2004/11/07/#a-15.3" target="_blank" rel="external">Function Objects</a></li></ul><p class="j-dot"><strong>Translated by:</strong> Dmitry A. Soshnikov.<br><strong>Published on:</strong> 2010-04-05<br><br><strong>Originally written by:</strong> Dmitry A. Soshnikov [ru, <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-5-functions/" target="_blank" rel="external">read »</a>]<br><strong>Originally published on:</strong> 2009-07-08</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;http://dmitrysoshnikov.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dmitry A. Soshnikov&lt;/a&gt; 的文章 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMA-262-3 in detail. Chapter 5. Functions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;其中大部分参考了 &lt;a href=&quot;http://zh.blog.goddyzhao.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;goddyzhao&lt;/a&gt; 的&lt;a href=&quot;http://zh.blog.goddyzhao.me/post/11273713920/functions#_=_&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;翻译&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文将介绍 ECMAScript 中一个非常常见的对象 – 函数。我们将着重介绍函数都有哪些类型，不同类型的函数是如何影响上下文的变量对象的，以及每种类型的函数的作用域链中都包含什么，并回答诸如下面这样的问题：下面声明的函数有什么区别吗？（如果有，区别是什么）。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; foo = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述方式创建的函数和如下方式创建的有什么不同？&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面代码为什么要用一个括号包起来呢？&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;本文和此前几篇文章都是有关联的，因此，要想完全搞懂这部分内容，建议先去阅读&lt;a href=&quot;http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/&quot;&gt;第二章 变量对象&lt;/a&gt;以及&lt;a href=&quot;http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/&quot;&gt;第四章 作用域链&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面，我们首先来看一下函数类型。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ECMAScript" scheme="http://bubkoo.com/tags/ecmascript/"/>
    
      <category term="ECMA-262-3" scheme="http://bubkoo.com/tags/ecma-262-3/"/>
    
      <category term="function" scheme="http://bubkoo.com/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3 详解 第四章 作用域链</title>
    <link href="http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/"/>
    <id>http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/</id>
    <published>2014-06-01T21:56:23.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">Dmitry A. Soshnikov</a> 的文章 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 4. Scope chain</a>.</p><h2><span id="概述">概述</span></h2><p>通过<a href="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/">第二章 变量对象</a>的学习我们知道，执行上下文的数据（变量、函数声明、函数形参）都是以属性的方式储存在变量对象中。</p><p>我们还知道，变量对象是在<a href="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/#i-4-1">进入执行上下文阶段</a>被创建和初始化，随后在<a href="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/#i-4-2">执行代码阶段</a>会对属性值进行更新。</p><p>本文将深入讨论与执行上下文密切相关的另外一个重要的概念 —— 作用域链（Scope Chain）。</p><a id="more"></a><h2><span id="定义">定义</span></h2><p>如果简单扼要地讲，那么作用域链就是与内部函数息息相关的一个概念。</p><p>众所周知，ECMAScript 允许创建内部函数，甚至可以将这些内部函数作为父函数的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(x + y);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo()(); <span class="comment">// 30</span></div></pre></td></tr></table></figure><p>每个上下文都有自己的变量对象：对于全局上下文而言，其变量对象就是全局对象本身，对于函数而言，其变量对象就是活动对象。</p><p>作用域链是所有内部上下文的<em>变量对象</em>的列表，用于变量查询。比如，在上述例子中，<code>bar</code> 上下文的作用域链包含了<code>AO(bar)</code>、<code>AO(foo)</code> 和 <code>VO(global)</code>。</p><p>下面就来详细介绍下作用域链。</p><p>先从定义开始，随后再结合例子详细介绍：</p><blockquote><p>作用域链是一条变量对象的链，它和执行上下文有关，用于在处理标识符时候进行变量查询。</p></blockquote><p>作用域链在函数调用时被创建，它包含了活动对象（AO）和该函数的内部属性 <code>[[Scope]]</code>。关于 <code>[[Scope]]</code> 会在后面作详细介绍。</p><p>示意如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">activeExecutionContext = &#123;</div><div class="line">    VO: &#123;...&#125;, <span class="comment">// 或者 AO</span></div><div class="line">    <span class="keyword">this</span>: thisValue,</div><div class="line">    Scope: [   <span class="comment">// 作用域链</span></div><div class="line">      <span class="comment">// 所有变量对象的列表</span></div><div class="line">      <span class="comment">// 用于标识符查找</span></div><div class="line">    ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上述代码中的 <code>Scope</code> 定义如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scope = AO + [[Scope]]</div></pre></td></tr></table></figure><p>针对我们的例子来说，可以将 <code>Scope</code> 和 <code>[[Scope]]</code> 用普通的 ECMAScript 数组来表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Scope = [VO1, VO2, ..., VOn]; <span class="comment">// 作用域链</span></div></pre></td></tr></table></figure><p>除此之外，还可以用分层对象链的数据结构来表示，链中每一个链接都有对父作用域（上层变量对象）的引用。这种表示方式和<a href="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/">第二章</a>中讨论的某些实现中 <code>__parent__</code> 的概念相对应：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> VO1 = &#123;<span class="attr">__parent__</span>: <span class="literal">null</span>, ... other data&#125;; --&gt;</div><div class="line"><span class="keyword">var</span> VO2 = &#123;<span class="attr">__parent__</span>: VO1, ... other data&#125;; --&gt;</div><div class="line"><span class="comment">// etc.</span></div></pre></td></tr></table></figure><p>然而，使用数组来表示作用域链会更方便，因此，我们这里就采用数组的表示方式。 除此之外，不论在实现层是否采用包含 <code>__parent__</code> 特性的分层对象链的数据结构，规范对其做了抽象的定义“作用域链是一个对象列表”。数组就是实现列表这一概念最好的选择。</p><p>下面将要介绍的 <code>AO+[[Scope]]</code> 以及标识符的处理方式，都和函数的生命周期有关。</p><h2><span id="函数的生命周期">函数的生命周期</span></h2><p>函数的的生命周期分为创建和激活（调用）阶段，下面分别详细介绍。</p><h3><span id="函数创建">函数创建</span></h3><p>我们知道，进入上下文阶段时函数声明被储存在变量对象/活动对象中（VO/AO）。让我们看看在全局上下文中的变量和函数声明的例子（这里变量对象是全局对象自身，还记得，是吧？）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</div><div class="line">  alert(x + y);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(); <span class="comment">// 30</span></div></pre></td></tr></table></figure><p>在函数激活（调用）后，我们得到了正确（预期）的结果 —— <code>30</code>。不过，这里有一个非常重要的特性。</p><p>此前，我们仅仅谈到当前上下文的变量对象。这里，变量 <code>y</code> 在函数 <code>foo</code> 中定义（意味着它在 <code>foo</code> 上下文的 AO 中），但是变量 <code>x</code> 并未在 <code>foo</code> 上下文中定义，自然也不会被添加到 <code>foo</code> 的 AO 中。乍一看，变量 <code>x</code> 相对于函数 <code>foo</code> 根本就不存在。但也仅仅是乍一看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fooContext.AO = &#123;</div><div class="line">  y: <span class="literal">undefined</span> <span class="comment">// undefined – 在进入上下文时, 20 – 在激活阶段</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>那么，<code>foo</code> 函数到底是如何访问到变量 <code>x</code> 的呢？一个顺其自然的想法是：函数应当有访问更高层上下文变量对象的权限。而事实也恰是如此，就是通过函数的内部属性 <code>[[Scope]]</code> 来实现这一机制的。</p><blockquote><p><code>[[Scope]]</code> 是一个包含了所有上层变量对象的分层链，它属于当前函数上下文，并在函数创建的时候，保存在函数中。</p></blockquote><p>这里要注意的很重要的一点是：<code>[[Scope]]</code> 是在函数创建的时候保存起来的 —— 静态的（不变的），永远永远 —— 直到函数销毁。也就是说，哪怕函数永远都不能被调用到，<code>[[Scope]]</code> 属性也已经保存在函数对象上了。</p><p>另外要注意的一点是：<code>[[Scope]]</code> 与 <code>Scope</code> (作用域链)是不同的，前者是函数的属性，后者是上下文的属性。 以上述例子来说，<code>foo</code> 函数的 <code>[[Scope]]</code> 如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo.[[Scope]] = [</div><div class="line">  globalContext.VO <span class="comment">// === Global</span></div><div class="line">];</div></pre></td></tr></table></figure><p>当函数被调用时，就进入函数上下文，此时活动对象被创建，<code>this</code> 和作用域（作用域链）被确定。下面我们详细讨论这个时刻。</p><h3><span id="函数激活">函数激活</span></h3><p>正如上面定义的那样，在进入上下文，AO/VO 创建之后，上下文的 <code>Scope</code> 属性（作用域链，用于变量查询）会定义为如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scope = AO|VO + [[Scope]]</div></pre></td></tr></table></figure><p>特别注意的是活跃对象是 Scope 数组的第一个元素。添加在作用域链的最前面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scope = [AO].concat([[Scope]]);</div></pre></td></tr></table></figure><p>这个特性对处理标识符非常重要。</p><blockquote><p>处理标识符其实就是一个确定变量（或者函数声明）属于作用域链中哪个变量对象的过程。</p></blockquote><p>此算法返回的总是一个引用类型的值，其 <code>base</code> 属性就是对应的变量对象（或者如果变量不存在的时候则返回 <code>null</code>），其 <code>propertyname</code> 属性的名字就是要查询的标识符。要详细了解引用类型可以参看<a href="http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-3-this/">第三章 this</a>。</p><p>标识符处理过程包括了对应的变量名的属性查询，即在作用域链中会进行一系列的变量对象的检测，从作用域链的最底层上下文一直到最上层上下文。</p><p>因此，在查询过程中上下文中的<em>局部变量</em>比上层上下文的变量会优先被查询到，换句话说，如果两个相同名字的变量存在于不同的上下文中时，处于底层上下文的变量会优先被找到。</p><p>下面是一个相对比较复杂的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> z = <span class="number">30</span>;</div><div class="line">    alert(x +  y + z);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  bar();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(); <span class="comment">// 60</span></div></pre></td></tr></table></figure><p>全局上下文的变量对象如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">globalContext.VO === Global = &#123;</div><div class="line">  x: <span class="number">10</span></div><div class="line">  foo: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></div><div class="line"><span class="xml">&#125;;</span></div></pre></td></tr></table></figure><p>在 <code>foo</code> 函数创建的时候，其 <code>[[Scope]]</code> 属性如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo.[[Scope]] = [</div><div class="line">  globalContext.VO</div><div class="line">];</div></pre></td></tr></table></figure><p>在 <code>foo</code> 函数激活的时候（进入上下文时），<code>foo</code> 函数上下文的活跃对象如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fooContext.AO = &#123;</div><div class="line">  y: <span class="number">20</span>,</div><div class="line">  bar: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></div><div class="line"><span class="xml">&#125;;</span></div></pre></td></tr></table></figure><p>同时，<code>foo</code> 函数上下文的作用域链如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fooContext.Scope = fooContext.AO + foo.[[Scope]] <span class="comment">// i.e.:</span></div><div class="line"> </div><div class="line">fooContext.Scope = [</div><div class="line">  fooContext.AO,</div><div class="line">  globalContext.VO</div><div class="line">];</div></pre></td></tr></table></figure><p>在内部 <code>bar</code> 函数创建的时候，其 <code>[[Scope]]</code> 属性如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bar.[[Scope]] = [</div><div class="line">  fooContext.AO,</div><div class="line">  globalContext.VO</div><div class="line">];</div></pre></td></tr></table></figure><p>在 <code>bar</code> 函数激活的时候，其对应的活跃对象如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">barContext.AO = &#123;</div><div class="line">  z: <span class="number">30</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>同时，<code>bar</code> 函数上下文的作用域链如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">barContext.Scope = barContext.AO + bar.[[Scope]] <span class="comment">// i.e.:</span></div><div class="line"> </div><div class="line">barContext.Scope = [</div><div class="line">  barContext.AO,</div><div class="line">  fooContext.AO,</div><div class="line">  globalContext.VO</div><div class="line">];</div></pre></td></tr></table></figure><p>如下是 <code>x</code>，<code>y</code> 和 <code>z</code> 标识符的查询过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- <span class="string">"x"</span></div><div class="line">-- barContext.AO <span class="comment">// not found</span></div><div class="line">-- fooContext.AO <span class="comment">// not found</span></div><div class="line">-- globalContext.VO <span class="comment">// found - 10</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- <span class="string">"y"</span></div><div class="line">-- barContext.AO <span class="comment">// not found</span></div><div class="line">-- fooContext.AO <span class="comment">// found - 20</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- <span class="string">"z"</span></div><div class="line">-- barContext.AO <span class="comment">// found - 30</span></div></pre></td></tr></table></figure><h2><span id="作用域的特性">作用域的特性</span></h2><p>下面让我们看看与作用域链和函数 <code>[[scope]]</code> 属性相关的一些重要特征。</p><h3><span id="闭包">闭包</span></h3><p>在 ECMAScript 中，闭包和函数的 <code>[[Scope]]</code> 属性息息相关。正如此前介绍的，<code>[[Scope]]</code> 是在函数创建的时候就保存在函数对象上了，并且直到函数销毁的时候才消失。 事实上，闭包就是函数代码和其 <code>[[Scope]]</code> 属性的组合。因此，<code>[[Scope]]</code> 包含了函数创建所在的词法环境（上层变量对象）。上层上下文中的变量，可以在函数激活的时候，通过变量对象的词法链（函数创建的时候就保存起来了）查询到。</p><p>如下例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</div><div class="line">  foo(); <span class="comment">// 10, but not 20</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>变量 <code>x</code> 是在 <code>foo</code> 函数的 <code>[[Scope]]</code> 中找到的。对于变量查询而言，词法链是在函数创建的时候就定义的，而不是在调用函数时动态确定的（这个时候，变量 <code>x</code> 才会是 <code>20</code>）。</p><p>下面是另一个典型的闭包的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert([x, y]);</div><div class="line">  &#125;;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> x = <span class="number">30</span>;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> bar = foo(); <span class="comment">// anonymous function is returned</span></div><div class="line"> </div><div class="line">bar(); <span class="comment">// [10, 20]</span></div></pre></td></tr></table></figure><p>上述例子再一次证明了处理标识符的时候，词法作用域链是在函数创建的时候定义的 —— 变量 <code>x</code> 的值是 <code>10</code>，而不是 <code>30</code>。 并且，上述例子清楚的展示了函数（上述例子中指的是函数 <code>foo</code> 返回的匿名函数）的 <code>[[Scope]]</code> 属性，即使在创建该函数的上下文结束的时候依然存在。</p><p>更多关于 ECMAScript 对闭包的实现细节会在<a href="http://bubkoo.com/2014/06/16/ecma-262-3-in-detail-chapter-6-closures/">第六章-闭包</a>中做介绍。</p><h3><span id="通过-function-构造器创建的函数的-scope-属性">通过 Function 构造器创建的函数的 [[Scope]] 属性</span></h3><p>在上面的例子中，我们看到函数在创建的时候就拥有了 <code>[[Scope]]</code> 属性，并且通过该属性可以获取所有上层上下文中的变量。然而，这里有个例外，就是当函数通过 <code>Function</code> 构造器创建的时候。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">barFD</span>(<span class="params"></span>) </span>&#123; <span class="comment">// FunctionDeclaration</span></div><div class="line">    alert(x);</div><div class="line">    alert(y);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> barFE = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// FunctionExpression</span></div><div class="line">    alert(x);</div><div class="line">    alert(y);</div><div class="line">  &#125;;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> barFn = <span class="built_in">Function</span>(<span class="string">'alert(x); alert(y);'</span>);</div><div class="line"> </div><div class="line">  barFD(); <span class="comment">// 10, 20</span></div><div class="line">  barFE(); <span class="comment">// 10, 20</span></div><div class="line">  barFn(); <span class="comment">// 10, "y" is not defined</span></div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo();</div></pre></td></tr></table></figure><p>上述例子中，函数 <code>barFn</code> 就是通过 <code>Function</code> 构造器来创建的，这个时候变量 <code>y</code> 就无法访问到了。但这并不意味着函数 <code>barFn</code> 就没有内部的 <code>[[Scope]]</code> 属性（否则它连变量 <code>x</code> 都无法访问到）。问题就在于当函数通过 <code>Function</code> 构造器来创建的时候，其 <code>[[Scope]]</code> 属性永远都只包含全局对象。哪怕在上层上下文中（非全局上下文）创建一个闭包都是无济于事的。</p><h3><span id="二维作用域链查找">二维作用域链查找</span></h3><p>在作用域链查找的时候还有很重要的一点：需要考虑变量对象的原型（如果存在的话） – 源于原型链的特性：如果一个属性在对象中没有直接找到，查询将在原型链中继续。即常说的二维链查找。（1）作用域链环节；（2）每个作用域链 – 深入到原型链环节。如果在 <code>Object.prototype</code> 中定义了属性，我们能看到这种效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line">foo(); <span class="comment">// 10</span></div></pre></td></tr></table></figure><p>活动对象是没有原型的，我们可以在下面的例子中看出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(x);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  bar();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</div><div class="line"> </div><div class="line">foo(); <span class="comment">// 20</span></div></pre></td></tr></table></figure><p>试想下，如果 <code>bar</code> 函数的活动对象有原型的话，属性 <code>x</code> 则应当在 <code>Object.prototype</code> 中找到，因为它在 AO 中根本不存在。然而，上面第一个例子中，在标识符处理阶段遍历了整个作用域链，到了全局对象（部分实现是这样的），它继承自 <code>Object.prototype</code>，因此，最终变量 <code>x</code> 的值就变成了 <code>10</code>。</p><p>同样的情况出现在某些版本的 SpiderMonkey 的命名函数表达式（简称：NFE）中，那些存储了可选的函数表达式的名字的特殊对象也继承自 <code>Object.prototype</code>。同样的，在某些版本的 Blackberry 中，也是如此，其活跃对象是继承自 <code>Object.prototype</code> 的。不过，关于这块详细的特性将会在<a href="http://" target="_blank" rel="external">第五章 函数</a>中作介绍。</p><h3><span id="全局和-eval-上下文的作用域链">全局和 eval 上下文的作用域链</span></h3><p>尽管这部分内容没多大意思，但还是值得一提的。全局上下文的作用域链中只包含全局对象。<code>eval</code> 代码类型的上下文和调用上下文（calling context）有相同的作用域链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">globalContext.Scope = [</div><div class="line">  Global</div><div class="line">];</div><div class="line"> </div><div class="line">evalContext.Scope === callingContext.Scope;</div></pre></td></tr></table></figure><h3><span id="执行代码阶段对作用域的影响">执行代码阶段对作用域的影响</span></h3><p>在代码执行阶段有两个语句能修改作用域链，那就是 <code>with</code> 声明和 <code>catch</code> 语句。在标识符查询阶段，这两者都会被添加到作用域链的最前面。也就是说，当有 <code>with</code> 或 <code>catch</code> 的时候，作用域链就会被修改如下形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scope = withObject|catchObject + AO|VO + [[Scope]]</div></pre></td></tr></table></figure><p>如下例子中，<code>with</code> 语句添加了 <code>foo</code> 对象，使得它的属性可以不需要前缀直接访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span>&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">with</span> (foo) &#123;</div><div class="line">  alert(x); <span class="comment">// 10</span></div><div class="line">  alert(y); <span class="comment">// 20</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对应的作用域链修改为如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scope = foo + AO|VO + [[Scope]]</div></pre></td></tr></table></figure><p>再看下面例子，<code>with</code> 对象被添加到作用域链的最前端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>, y = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="keyword">with</span> (&#123;<span class="attr">x</span>: <span class="number">20</span>&#125;) &#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> x = <span class="number">30</span>, y = <span class="number">30</span>;</div><div class="line"> </div><div class="line">  alert(x); <span class="comment">// 30</span></div><div class="line">  alert(y); <span class="comment">// 30</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line">alert(x); <span class="comment">// 10</span></div><div class="line">alert(y); <span class="comment">// 30</span></div></pre></td></tr></table></figure><p>这里发生了什么？在进入上下文阶段，<code>x</code> 和 <code>y</code> 被添加到变量对象中，在代码执行阶段，发生了如下修改：</p><ul><li><code>x = 10</code>, <code>y = 10</code></li><li><code>{x: 20}</code> 被添加到作用域链的最前端</li><li>在 <code>with</code> 内部，遇到了 <code>var</code> 声明，当然什么也没创建，因为在进入上下文时，所有变量已被解析添加</li><li>这里只修改了 <code>x</code> 的值，此时的 <code>x</code> 被解析后是第二步中添加到作用域链最前的的那个对象中的 <code>x</code>，<code>x</code> 的值由<code>20</code> 变为 <code>30</code></li><li>这里也修改了 <code>y</code> 的值，<code>y</code> 是上层作用域变量对象的属性，相应地，由 <code>10</code> 修改为 <code>30</code></li><li>当 <code>with</code> 语句结束后，这个特殊对象从作用域链中移除（被修改后的 <code>x</code> - <code>30</code> 也随着对象被移除了），也就是说，作用域链回到执行 <code>with</code> 语句之前的状态</li><li>正如在最后两个 <code>alert</code> 中看到的，<code>x</code> 的值恢复到了原先的 <code>10</code>，而 <code>y</code> 的值因为在 <code>with</code> 语句的时候被修改过了，因此变为了 <code>30</code> </li></ul><p>同样，<code>catch</code> 语句会创建一个只包含一个属性（异常参数名）的新对象。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  ...</div><div class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">  alert(ex);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>作用域链修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> catchObject = &#123;</div><div class="line">  ex: </div><div class="line">&#125;;</div><div class="line"> </div><div class="line">Scope = catchObject + AO|VO + [[Scope]]</div></pre></td></tr></table></figure><p>在 <code>catch</code> 从句结束后，作用域链同样也会恢复到之前的状态。</p><h2><span id="总结">总结</span></h2><p>本文介绍了几乎所有与执行上下文相关的概念以及相应的细节。后面的章节中，会给大家介绍函数对象的细节：函数的类型（FunctionDeclaration，FunctionExpression）和闭包。顺便提下，本文中介绍过，闭包与 <code>[[Scope]]</code> 有直接关系，但是关于闭包的细节会在后续章节中作介绍。</p><h2><span id="扩展阅读">扩展阅读</span></h2><ul><li>8.6.2 – <a href="http://bclary.com/2004/11/07/#a-8.6.2" target="_blank" rel="external">[[Scope]]</a></li><li>10.1.4 – <a href="http://bclary.com/2004/11/07/#a-10.1.4" target="_blank" rel="external">Scope Chain and Identifier Resolution</a></li></ul><p class="j-dot"><strong>Translated by:</strong> Dmitry Soshnikov.<br><strong>Published on:</strong> 2010-03-21<br><br><strong>Originally written by:</strong> Dmitry Soshnikov [ru, <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-4-scope-chain/" target="_blank" rel="external">read »</a>]<br><strong>Originally published on:</strong> 2009-07-01</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;http://dmitrysoshnikov.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dmitry A. Soshnikov&lt;/a&gt; 的文章 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMA-262-3 in detail. Chapter 4. Scope chain&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;通过&lt;a href=&quot;http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/&quot;&gt;第二章 变量对象&lt;/a&gt;的学习我们知道，执行上下文的数据（变量、函数声明、函数形参）都是以属性的方式储存在变量对象中。&lt;/p&gt;
&lt;p&gt;我们还知道，变量对象是在&lt;a href=&quot;http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/#i-4-1&quot;&gt;进入执行上下文阶段&lt;/a&gt;被创建和初始化，随后在&lt;a href=&quot;http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/#i-4-2&quot;&gt;执行代码阶段&lt;/a&gt;会对属性值进行更新。&lt;/p&gt;
&lt;p&gt;本文将深入讨论与执行上下文密切相关的另外一个重要的概念 —— 作用域链（Scope Chain）。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ECMAScript" scheme="http://bubkoo.com/tags/ecmascript/"/>
    
      <category term="ECMA-262-3" scheme="http://bubkoo.com/tags/ecma-262-3/"/>
    
      <category term="Scope" scheme="http://bubkoo.com/tags/scope/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3 详解 第三章 This</title>
    <link href="http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-3-this/"/>
    <id>http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-3-this/</id>
    <published>2014-06-01T09:56:23.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">Dmitry A. Soshnikov</a> 的文章 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 3. This.</a></p><p>翻译过程参考了现有的中文翻译，学习 ECMAScript 是一个非常抽象的过程，因为很多概念都是通过抽象的方式来解释的，作者尝试尽量用一些简单的方式并使用了一些具体图表，来使我们的学习曲线稍微平稳一点。</p><h2><span id="概述">概述</span></h2><p>本文将讨论和<a href="http://bubkoo.com/2014/05/28/ecma-262-3-in-detail-chapter-1-execution-contexts/">执行上下</a>文密切相关的更多细节 - <code>this</code> 关键字。</p><p>实践证明，这个主题很难，在不同的执行上下文中确定 <code>this</code> 的值经常会发生问题。</p><p>许多程序员习惯性地讲 <code>this</code> 和面向对象编程密切联系在一起，<code>this</code> 指向了构造函数中新创建的对象。在 ECMAScript 中，这样说也没问题，但就像我们即将看到的那样，<code>this</code> 不限于用来指向新创建的对象。</p><p>接下来给大家揭开在 ECMAScript 中 <code>this</code> 神秘的面纱。</p><a id="more"></a><h2><span id="定义">定义</span></h2><p><code>this</code> 是执行上下文的一个属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">activeExecutionContext = &#123;</div><div class="line">  VO: &#123;...&#125;,</div><div class="line">  <span class="keyword">this</span>: thisValue</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这里的 VO 就是上一章介绍的<a href="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/">变量对象</a>。</p><p><code>this</code> 与上下文的可执行代码类型紧密相关，其值在<em>进入上下文阶段</em>就确定了，并且在<em>执行代码阶段</em>不能被改变。</p><p>下面详细讨论这些情景。</p><h2><span id="全局代码中的-this">全局代码中的 this</span></h2><p>全局代码中的 <code>this</code> 非常简单，<code>this</code> 始终是全局对象自身，因此，可以间接获取引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 显式定义全局对象的属性</span></div><div class="line"><span class="keyword">this</span>.a = <span class="number">10</span>; <span class="comment">// global.a = 10</span></div><div class="line">alert(a);    <span class="comment">// 10</span></div><div class="line"> </div><div class="line"><span class="comment">// 通过赋值给不受限的标识符来进行隐式定义</span></div><div class="line">b = <span class="number">20</span>;</div><div class="line">alert(<span class="keyword">this</span>.b); <span class="comment">// 20</span></div><div class="line"> </div><div class="line"><span class="comment">// 通过变量声明来进行隐式定义</span></div><div class="line"><span class="comment">// 因为全局上下文中的变量对象就是全局对象本身</span></div><div class="line"><span class="keyword">var</span> c = <span class="number">30</span>;</div><div class="line">alert(<span class="keyword">this</span>.c); <span class="comment">// 30</span></div></pre></td></tr></table></figure><h2><span id="函数代码中的-this">函数代码中的 this</span></h2><p>当 <code>this</code> 在函数代码中的时候，事情就变得有趣多了。这种情况下是最复杂的，并且会引发很多的问题。</p><p>函数代码中的 <code>this</code> 的第一个（同时也是最主要）的特性就是：它并非静态绑定在函数上。</p><p>如上所述，<code>this</code> 的值是进入执行上下文阶段确定的，函数代码中的 <code>this</code> 的值可能<em>每次都不一样</em>。</p><p>而且，一旦进入代码执行阶段，其值就维持不变了。也就是说，要给 <code>this</code> 赋一个新值是不可能的，因为 <code>this</code> 根本就不是一个变量（相反，在 Python 这类语言中，显示定义的 <code>self</code> 对象在运行时是可以随意更改的）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> bar = &#123;</div><div class="line">  x: <span class="number">20</span>,</div><div class="line">  test: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">    alert(<span class="keyword">this</span> === bar); <span class="comment">// true</span></div><div class="line">    alert(<span class="keyword">this</span>.x);       <span class="comment">// 20</span></div><div class="line"> </div><div class="line">    <span class="keyword">this</span> = foo;    <span class="comment">// error, 不能更改this的值</span></div><div class="line"> </div><div class="line">    alert(<span class="keyword">this</span>.x); <span class="comment">// 如果没有错误，则其值为10而不是20</span></div><div class="line"> </div><div class="line">  &#125;</div><div class="line"> </div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// 在进入上下文的时候，this 的值就确定了是“bar”对象</span></div><div class="line"><span class="comment">// 至于为什么，会在后面作详细介绍</span></div><div class="line"> </div><div class="line">bar.test(); <span class="comment">// true, 20</span></div><div class="line"> </div><div class="line">foo.test = bar.test;</div><div class="line"> </div><div class="line"><span class="comment">// 但是，这个时候，this的值又会变成“foo”</span></div><div class="line"><span class="comment">// 虽然我们调用的是同一个函数</span></div><div class="line"> </div><div class="line">foo.test(); <span class="comment">// false, 10</span></div></pre></td></tr></table></figure><p>那么，在函数代码中有哪些因素会影响 <code>this</code> 值的变化？有如下几个因素：</p><p>首先，在通常的函数调用时，<code>this</code> 是由激活上下文代码的调用者（caller）决定的，即调用函数的父级上下文。并且 <code>this</code> 的值是由调用表达式的形式决定的（换句话说就是，由调用函数的语法决定）。</p><p>了解并记住这点非常重要，这样才能在任何上下文中都能准确判断 <code>this</code> 的值。更确切地讲，调用表达式的形式（或者说，调用函数的方式）影响了 <code>this</code> 的值，而不是其他因素。</p><p>（一些关于 JavaScript 的文章和书籍中指出：“<code>this</code> 的值取决于函数定义的方式，如果是全局函数，那么 <code>this</code> 的值就是全局对象，如果函数是某个对象的方法，那么 <code>this</code> 的值就是该对象” – 这绝对不正确）。下面我们将看到，即便是全局函数，<code>this</code> 的值也会因为调用函数的方式不同而不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(); <span class="comment">// global</span></div><div class="line"> </div><div class="line">alert(foo === foo.prototype.constructor); <span class="comment">// true</span></div><div class="line"> </div><div class="line"><span class="comment">// 然而，同样的函数，以另外一种调用方式的话，this的值就不同了</span></div><div class="line"> </div><div class="line">foo.prototype.constructor(); <span class="comment">// foo.prototype</span></div></pre></td></tr></table></figure><p>同样，调用对象中定义的方法时，<code>this</code> 的值也有可能不是该对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>);</div><div class="line">    alert(<span class="keyword">this</span> === foo);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">foo.bar(); <span class="comment">// foo, true</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> exampleFunc = foo.bar;</div><div class="line"> </div><div class="line">alert(exampleFunc === foo.bar); <span class="comment">// true</span></div><div class="line"> </div><div class="line"><span class="comment">// 同样地，相同的函数以不同的调用方式，this的值也就不同了</span></div><div class="line"> </div><div class="line">exampleFunc(); <span class="comment">// global, false</span></div></pre></td></tr></table></figure><p>那么，究竟调用函数的方式是如何影响 <code>this</code> 的值？为了完全弄懂其中的奥妙，首选需要了解一种内部类型 - 引用（<code>Reference</code>）类型</p><h3><span id="引用类型">引用类型</span></h3><p>引用类型可以用伪代码表示为拥有两个属性的对象：<code>base</code>（即拥有属性的那个对象），和 <code>base</code> 中的 <code>propertyName</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> valueOfReferenceType = &#123;</div><div class="line">  base: ,</div><div class="line">  propertyName: </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>引用类型的值只有可能是以下两种情况：</p><ol><li>当处理一个标识符的时候</li><li>或者进行属性访问的时候</li></ol><p>标示符的处理过程在<a href="http://" target="_blank" rel="external">第四章 作用域链</a>中讨论；在这里我们只需要知道，使用这种处理方式的返回值总是一个引用类型的值（这对 <code>this</code> 来说很重要）。</p><p>标识符是变量名，函数名，函数参数名和全局对象中未识别的属性名。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure><p>中间过程中，对应的引用类型的值如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fooReference = &#123;</div><div class="line">  base: global,</div><div class="line">  propertyName: <span class="string">'foo'</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> barReference = &#123;</div><div class="line">  base: global,</div><div class="line">  propertyName: <span class="string">'bar'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>要从引用类型的值中获取一个对象实际的值需要 <code>GetValue</code> 方法，该方法用伪代码可以描述成如下形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetValue</span>(<span class="params">value</span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">if</span> (Type(value) != Reference) &#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> base = GetBase(value);</div><div class="line"> </div><div class="line">  <span class="keyword">if</span> (base === <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> base.[[Get]](GetPropertyName(value));</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述代码中的 <code>[[Get]]</code> 方法返回了对象属性实际的值，包括从原型链中继承的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GetValue(fooReference); <span class="comment">// 10</span></div><div class="line">GetValue(barReference); <span class="comment">// function object "bar"</span></div></pre></td></tr></table></figure><p>对于属性访问来说，有两种方式： 点符号（这时属性名是正确的标识符并且提前已经知道了）或者中括号符号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo.bar();</div><div class="line">foo[<span class="string">'bar'</span>]();</div></pre></td></tr></table></figure><p>中间过程中，得到如下的引用类型的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fooBarReference = &#123;</div><div class="line">  base: foo,</div><div class="line">  propertyName: <span class="string">'bar'</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line">GetValue(fooBarReference); <span class="comment">// function object "bar"</span></div></pre></td></tr></table></figure><p>那么，引用类型的值与函数上下文中 <code>this</code> 的值是如何关联起来的呢？这很重要，也是本文的核心内容。总体来说，确定函数上下文中 <code>this</code> 值的一般规则如下：</p><p class="j-quote">函数上下文中 <code>this</code> 的值由调用者（caller）提供，并由调用表达式的形式确定（函数调用的语法）。<br><br>如果在调用括号 <code>()</code> 的左边是<em>引用类型</em>，那么 <code>this</code> 的值就是该引用类型值的 <code>base</code> 对象。<br><br>在其他情况下（非引用类型），<code>this</code> 的值总是 <code>null</code>。然而，<code>null</code> 对于 <code>this</code> 来说没有任何意义，因此为隐式转换为全局对象。</p><p>看下面例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(); <span class="comment">// global</span></div></pre></td></tr></table></figure><p>上面代码中，调用括号左侧是引用类型（因为 <code>foo</code> 是标识符）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fooReference = &#123;</div><div class="line">  base: global,</div><div class="line">  propertyName: <span class="string">'foo'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>相应的，<code>this</code> 的值会设置为引用类型值的 <code>base</code> 对象，这里就是全局对象。</p><p>同样，使用属性访问器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">foo.bar(); <span class="comment">// foo</span></div></pre></td></tr></table></figure><p>同样，<code>bar</code> 也是引用类型的值，它的 <code>base</code> 对象是 <code>foo</code> 对象，当激活 <code>bar</code> 函数的时，<code>this</code> 的值就设置为 <code>foo</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fooBarReference = &#123;</div><div class="line">  base: foo,</div><div class="line">  propertyName: <span class="string">'bar'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>然而，同样的函数以不同的激活方式的话，<code>this</code> 的值就完全不同了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = foo.bar;</div><div class="line">test(); <span class="comment">// global</span></div></pre></td></tr></table></figure><p>因为 <code>test</code> 也是标识符，这样就产生了其他引用类型的值，该值的 <code>base</code>（全局对象）被设置为 <code>this</code> 的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> testReference = &#123;</div><div class="line">  base: global,</div><div class="line">  propertyName: <span class="string">'test'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p class="j-quote">注意：在 ES5 的严格模式下，<code>this</code> 的值不再是全局对象，而是 <code>undefined</code></p><br>现在，我们已经清楚地知道，为什么同样的函数以不用的方式调用，<code>this</code> 的值也会不同了，答案就在于引用类型的不同：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(); <span class="comment">// global, 因为</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> fooReference = &#123;</div><div class="line">  base: global,</div><div class="line">  propertyName: <span class="string">'foo'</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line">alert(foo === foo.prototype.constructor); <span class="comment">// true</span></div><div class="line"> </div><div class="line"><span class="comment">// 另一种调用方式</span></div><div class="line"> </div><div class="line">foo.prototype.constructor(); <span class="comment">// foo.prototype, 因为</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> fooPrototypeConstructorReference = &#123;</div><div class="line">  base: foo.prototype,</div><div class="line">  propertyName: <span class="string">'constructor'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><br><br>另一个通过调用方式动态确定 <code>this</code> 的值的经典例子：<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.bar);</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">var</span> x = &#123;<span class="attr">bar</span>: <span class="number">10</span>&#125;;</div><div class="line"><span class="keyword">var</span> y = &#123;<span class="attr">bar</span>: <span class="number">20</span>&#125;;</div><div class="line">  </div><div class="line">x.test = foo;</div><div class="line">y.test = foo;</div><div class="line">  </div><div class="line">x.test(); <span class="comment">// 10</span></div><div class="line">y.test(); <span class="comment">// 20</span></div></pre></td></tr></table></figure><br><br>### 函数调用和非引用类型<br><br>正如此前提到过的，当调用括号左侧为非引用类型的时候，<code>this</code> 的值会设置为 <code>null</code>，并最终成为全局对象。<br><br>请看下面这种函数表达式：<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>  (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>); <span class="comment">// null =&gt; global</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure><br><br>在这个例子中，我们有一个函数对象但不是引用类型的对象（因为它不是标示符，也不是属性访问器），因此 <code>this</code> 的值最终被设为全局对象。<br><br>更多复杂的例子：<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line">foo.bar();   <span class="comment">// Reference, OK =&gt; foo</span></div><div class="line">(foo.bar)(); <span class="comment">// Reference, OK =&gt; foo</span></div><div class="line">  </div><div class="line">(foo.bar = foo.bar)(); <span class="comment">// global?</span></div><div class="line">(<span class="literal">false</span> || foo.bar)();  <span class="comment">// global?</span></div><div class="line">(foo.bar, foo.bar)();  <span class="comment">// global?</span></div></pre></td></tr></table></figure><br><br>那么，为什么明明是属性访问，而最终 <code>this</code> 不是引用类型的 <code>base</code> 对象（<code>foo</code>），而是全局对象呢？<br><br>问题出在后面三个调用，在执行一定的操作运算之后，在调用括号的左边的值不再是引用类型。<br><br>第一种情况，很明显是引用类型，<code>this</code> 的值为 <code>base</code> 对象，即 <code>foo</code>。<br><br>第二种情况，分组操作符没有实际意义，分组操作符返回的仍是一个引用类型，这就是 <code>this</code> 的值为什么再次被设为 <code>base</code> 对象，即  <code>foo</code>。<br><br>第三种情况，赋值操作符（assignment operator）与组操作符不同，它会触发调用 <code>GetValue</code> 方法（参见<a href="http://bclary.com/2004/11/07/#a-11.13.1" target="_blank" rel="external">11.13.1</a>中的第三步）。最后返回的时候就是一个函数对象了（而不是引用类型的值了），这就意味着 <code>this</code> 的值会设置为 <code>null</code>，最终会变成全局对象。<br><br>第四和第五种情况也类似，逗号操作符和 <code>OR</code> 逻辑表达式都会触发调用 <code>GetValue</code> 方法，于是相应地就会丢失原先的引用类型值，变成了函数类型，<code>this</code> 的值就变成了全局对象了。<br><br>### 引用类型和 this 为 null<br><br>有一种情况，当调用表达式左侧是引用类型的值，但是 <code>this</code> 的值却是 <code>null</code>，最终变为全局对象。发生这种情况的条件是当引用类型值的 <code>base</code> 对象恰好为活跃对象。<br><br>当内部子函数在父函数中被调用的时候就会发生这种情况。正如<a href="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/">第二章</a>介绍的那样，局部变量，内部函数以及函数的形参都会存储在指定函数的活跃对象中：<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>); <span class="comment">// global</span></div><div class="line">  &#125;</div><div class="line">  bar(); <span class="comment">// 和AO.bar()是一样的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>活跃对象总是会返回 <code>this</code> 值为 <code>null</code>（用伪代码来表示， <code>AO.bar()</code> 就相当于 <code>null.bar()</code>）。然后，如此前描述的，<code>this</code> 的值最终会由 <code>null</code> 变为全局对象。<br><br>当函数调用包含在 <code>with</code> 语句的代码块中，并且 <code>with</code> 对象包含一个函数属性的时候，就会出现例外的情况。<code>with</code> 语句会将该对象添加到作用域链的最前面，在活跃对象的之前。相应地，在引用类型的值（标识符或者属性访问）的情况下，<code>base</code> 对象就不再是活跃对象了，而是 <code>with</code> 语句的对象。另外，值得一提的是，它不仅仅只针对内部函数，全局函数也是如此， 原因就是 <code>with</code> 语句中的对象掩盖了作用域链中更高层的对象（全局对象或者活跃对象）：<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="keyword">with</span> (&#123;</div><div class="line"> </div><div class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.x);</div><div class="line">  &#125;,</div><div class="line">  x: <span class="number">20</span></div><div class="line"> </div><div class="line">&#125;) &#123;</div><div class="line"> </div><div class="line">  foo(); <span class="comment">// 20</span></div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// because</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span>  fooReference = &#123;</div><div class="line">  base: __withObject,</div><div class="line">  propertyName: <span class="string">'foo'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><br><br>当调用的函数恰好是 <code>catch</code> 从句的参数时，情况也是类似的：在这种情况下，<code>catch</code> 对象也会添加到作用域链的最前面，在活跃对象和全局对象之前。 然而，这个行为在 ECMA-262-3 中被指出是个 bug，并且已经在 ECMA-262-5 中修正了；因此，在这种情况下，<code>this</code> 的值应该设置为全局对象，而不是 <code>catch</code> 对象：<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>);</div><div class="line">  &#125;;</div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">  e(); <span class="comment">// __catchObject - in ES3, global - fixed in ES5</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// on idea</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> eReference = &#123;</div><div class="line">  base: __catchObject,</div><div class="line">  propertyName: <span class="string">'e'</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// 然而，既然这是个bug</span></div><div class="line"><span class="comment">// 那就应该强制设置为全局对象</span></div><div class="line"><span class="comment">// null =&gt; global</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> eReference = &#123;</div><div class="line">  base: global,</div><div class="line">  propertyName: <span class="string">'e'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><br><br>同样的情况还会在递归调用一个非匿名函数的时候发生（函数的更多细节参考第五章）。在第一次函数调用的时候，<code>base</code> 对象是外层的活跃对象（或者全局对象），在接下来的递归调用的时候，<code>base</code> 对象应当是一个存储了可选的函数表达式名字的特殊对象，然而，事实却是，在这种情况下，<code>this</code> 的值永远都是全局对象：<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar</span>) </span>&#123;</div><div class="line"> </div><div class="line">  alert(<span class="keyword">this</span>);</div><div class="line"> </div><div class="line">  !bar &amp;&amp; foo(<span class="number">1</span>); <span class="comment">// "should" be special object, but always (correct) global</span></div><div class="line"> </div><div class="line">&#125;)(); <span class="comment">// global</span></div></pre></td></tr></table></figure><br><br>### 作为构造器调用的函数中的 this<br><br>这里介绍另外一种情况，当函数作为构造器被调用的时候：<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>); <span class="comment">// newly created object, below - "a" object</span></div><div class="line">  <span class="keyword">this</span>.x = <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line">alert(a.x); <span class="comment">// 10</span></div></pre></td></tr></table></figure><br><br>在这种情况下，<a href="http://bclary.com/2004/11/07/#a-11.2.2" target="_blank" rel="external"><code>new</code></a> 操作符会调用 “A” 函数的内部 <a href="http://bclary.com/2004/11/07/#a-13.2.2" target="_blank" rel="external"><code>[[Construct]]</code></a>。在对象创建之后，会调用内部的 <a href="http://bclary.com/2004/11/07/#a-13.2.1" target="_blank" rel="external"><code>[[Call]]</code></a> 函数，然后所有 “A” 函数中 <code>this</code> 的值会设置为新创建的对象。<br><br>### 手动设置函数调用时 this 的值<br><br><code>Function.prototype</code> 上定义了两个方法（因此，它们对所有函数而言都是可访问的），允许手动指定函数调用时 <code>this</code> 的值。这两个方法是：<code>.apply</code> 和 <code>.call</code> ； 它们都接受第一个参数作为调用上下文中 <code>this</code> 的值。而它们的不同点其实无关紧要：对于 <code>.apply</code> 来说，第二个参数接受数组类型（或者是类数组的对象，比如 <code>arguments</code> ）, 而 <code>.call</code> 方法接受任意多的参数。这两个方法只有第一个参数是必要的—— <code>this</code> 的值。<br><br>如下所示：<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.b);</div><div class="line">  alert(c);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">a(<span class="number">20</span>); <span class="comment">// this === global, this.b == 10, c == 20</span></div><div class="line"> </div><div class="line">a.call(&#123;<span class="attr">b</span>: <span class="number">20</span>&#125;, <span class="number">30</span>); <span class="comment">// this === &#123;b: 20&#125;, this.b == 20, c == 30</span></div><div class="line">a.apply(&#123;<span class="attr">b</span>: <span class="number">30</span>&#125;, [<span class="number">40</span>]) <span class="comment">// this === &#123;b: 30&#125;, this.b == 30, c == 40</span></div></pre></td></tr></table></figure><br><br>## 总结<br><br>本文我们讨论了 ECMAScript 中 <code>this</code> 关键字的特性（相对 C++ 或 Java 而言，真的可以说是特性）。希望此文对大家理解 <code>this</code> 关键字在 ECMAScript 中的工作原理有所帮助。<br><br>## 扩展阅读<br><br>- 10.1.7 – <a href="http://bclary.com/2004/11/07/#a-10.1.7" target="_blank" rel="external">This</a><br>- 11.1.1 – <a href="http://bclary.com/2004/11/07/#a-11.1.1" target="_blank" rel="external">The this keyword</a><br>- 11.2.2 – <a href="http://bclary.com/2004/11/07/#a-11.2.2" target="_blank" rel="external">The new operator</a><br>- 11.2.3 – <a href="http://bclary.com/2004/11/07/#a-11.2.3" target="_blank" rel="external">Function calls</a><br><br><br><br><p class="j-dot"><strong>Translated by:</strong> Dmitry A. Soshnikov with help of Stoyan Stefanov.<br><strong>Published on:</strong> 2010-03-07<br><br><strong>Originally written by:</strong> Dmitry A. Soshnikov [ru, <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-3-this/" target="_blank" rel="external">read »</a>]<br><strong>With additions and corrections by:</strong> Zeroglif<br><br><strong>Originally published on:</strong> 2009-06-28; <strong>updated on:</strong> 2010-03-07</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;http://dmitrysoshnikov.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dmitry A. Soshnikov&lt;/a&gt; 的文章 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-3-this/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMA-262-3 in detail. Chapter 3. This.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译过程参考了现有的中文翻译，学习 ECMAScript 是一个非常抽象的过程，因为很多概念都是通过抽象的方式来解释的，作者尝试尽量用一些简单的方式并使用了一些具体图表，来使我们的学习曲线稍微平稳一点。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文将讨论和&lt;a href=&quot;http://bubkoo.com/2014/05/28/ecma-262-3-in-detail-chapter-1-execution-contexts/&quot;&gt;执行上下&lt;/a&gt;文密切相关的更多细节 - &lt;code&gt;this&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;p&gt;实践证明，这个主题很难，在不同的执行上下文中确定 &lt;code&gt;this&lt;/code&gt; 的值经常会发生问题。&lt;/p&gt;
&lt;p&gt;许多程序员习惯性地讲 &lt;code&gt;this&lt;/code&gt; 和面向对象编程密切联系在一起，&lt;code&gt;this&lt;/code&gt; 指向了构造函数中新创建的对象。在 ECMAScript 中，这样说也没问题，但就像我们即将看到的那样，&lt;code&gt;this&lt;/code&gt; 不限于用来指向新创建的对象。&lt;/p&gt;
&lt;p&gt;接下来给大家揭开在 ECMAScript 中 &lt;code&gt;this&lt;/code&gt; 神秘的面纱。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ECMAScript" scheme="http://bubkoo.com/tags/ecmascript/"/>
    
      <category term="ECMA-262-3" scheme="http://bubkoo.com/tags/ecma-262-3/"/>
    
      <category term="this" scheme="http://bubkoo.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3 详解 第二章 变量对象</title>
    <link href="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/"/>
    <id>http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/</id>
    <published>2014-05-31T20:56:23.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">Dmitry A. Soshnikov</a> 的文章 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 2. Variable object.</a></p><p>参考了一些译文，作为自己学习 ECMAScript 的一点积累。</p><h2><span id="概要">概要</span></h2><p>创建应用程序的时，总免不了要声明变量和函数。然而，解析器（interpreter）是如何以及从哪里找到这些数据（变量，函数）的，当我们引用一个变量时，在解析器内部又发生了什么？</p><p>许多 ECMAScript 程序员都知道变量与<a href="http://bubkoo.com/2014/05/28/ecma-262-3-in-detail-chapter-1-execution-contexts/">执行上下</a>文密切相关：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// 全局上下文中的变量</span></div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">// 函数上下文中的局部变量</span></div><div class="line">&#125;)();</div><div class="line"> </div><div class="line">alert(a); <span class="comment">// 10</span></div><div class="line">alert(b); <span class="comment">// "b" is not defined</span></div></pre></td></tr></table></figure><p>同样，许多 ECMAScript 程序员也知道，基于当前版本的规范，独立作用域只能通过“函数代码”才能创建。也就是说，与 C/C++ 不同，在 ECMAScript 中 <code>for</code> 循环不会创建一个局部上下文（即局部作用域）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) &#123;</div><div class="line">  alert(k);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">alert(k); <span class="comment">// 尽管循环已经结束，但是变量 “k” 仍然在作用域中</span></div></pre></td></tr></table></figure><p>下面具体来看一下，当我们声明变量和函数时，究竟发生了什么。</p><a id="more"></a><h2><span id="数据声明">数据声明</span></h2><p>如果变量与执行上下文相关，那么它就应该知道数据储存在哪里以及如何访问这些数据，这种机制被称为变量对象（variable object）。</p><p>变量对象（简称为 VO）是与某个执行上下文相关的一个特殊对象，并储存了一下数据：</p><ul><li>变量（var, VariableDeclaration）</li><li>函数声明（FunctionDeclaration, 缩写为FD）</li><li>函数形参</li></ul><p class="j-quote">注意，在 ES5 中，变量对象和活动对象并入了词法环境模型（lexical environments model），详细的描述请<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" target="_blank" rel="external">看这里</a>。</p><p>简单举例，可以用 ECMAScript 的对象来表示变量对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VO = &#123;&#125;;</div></pre></td></tr></table></figure><p>正如我们之前所说，VO 是执行上下文的一个属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">activeExecutionContext = &#123;</div><div class="line">  VO: &#123;</div><div class="line">    <span class="comment">// 上下文中的数据 (变量声明（var）, 函数声明（FD), 函数形参（function arguments）)</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>只有全局上下文中的变量对象可以通过 VO 的属性名间接访问（因为在全局上下文中，全局对象自身就是变量对象，稍候会详细介绍）。在其他上下文中是不能直接访问 VO 对象的，因为它只是内部机制的一个实现（抽象的）。</p><p>当我们声明一个变量或函数时，就等于是在 VO 对象上添加了一个相应键/值的属性。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">test(<span class="number">30</span>);</div></pre></td></tr></table></figure><p>对应的变量对象是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局上下文中的变量对象</span></div><div class="line">VO(globalContext) = &#123;</div><div class="line">  a: <span class="number">10</span>,</div><div class="line">  test: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></div><div class="line"><span class="xml">&#125;;</span></div><div class="line"><span class="xml"> </span></div><div class="line"><span class="xml">// “test” 函数上下文中的变量对象</span></div><div class="line"><span class="xml">VO(test functionContext) = &#123;</span></div><div class="line"><span class="xml">  x: 30,</span></div><div class="line"><span class="xml">  b: 20</span></div><div class="line"><span class="xml">&#125;;</span></div></pre></td></tr></table></figure><p>但是，在实现层面上（和规范中）变量对象只是一个抽象概念。从本质上说，在实际执行上下文中，VO 可能完全不叫 VO，而且其初始结构也可能完全不同。</p><h2><span id="不同执行上下文中的变量对象">不同执行上下文中的变量对象</span></h2><p>对于所有类型的执行上下文，变量对象的一些操作（如变量初始化）和行为都是相同的。从这个角度来看，把变量对象表示为抽象概念更加合适。而在函数上下文中同样可以通过变量对象定义一些相关的额外细节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AbstractVO (变量实例化过程中的通用行为)</div><div class="line"> </div><div class="line">  ║</div><div class="line">  ╠══&gt; GlobalContextVO</div><div class="line">  ║        (VO === this === global)</div><div class="line">  ║</div><div class="line">  ╚══&gt; FunctionContextVO</div><div class="line">           (VVO === AO, &lt;arguments&gt; object and &lt;formal parameters&gt; are added)</div></pre></td></tr></table></figure><p>下面具体分析。</p><h3><span id="全局上下文中的变量对象">全局上下文中的变量对象</span></h3><p>首先，有必要给出全局对象（Global Object）的定义：</p><blockquote><p>全局对象是一个在进入任何执行上下文之前就创建的对象，此对象以单例的形式存在，它的属性在程序任何地方都可以访问，其生命周期随着程序的结束而终止。</p></blockquote><p>全局对象创建时，<code>Math</code>、<code>String</code>、<code>Date</code>、<code>parseInt</code> 等属性也会同时被初始化，同样也可以附加其它对象作为属性，其中包括可以引用全局对象自身的属性。比如，BOM 中，全局对象上的 <code>window</code> 属性就指向了全局对象自身（但是，并非所有的实现都是如此）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">global = &#123;</div><div class="line">  <span class="built_in">Math</span>: <span class="xml"><span class="tag">&lt;<span class="name">...</span>&gt;</span>,</span></div><div class="line"><span class="xml">  String: <span class="tag">&lt;<span class="name">...</span>&gt;</span></span></div><div class="line"><span class="xml">  ...</span></div><div class="line"><span class="xml">  ...</span></div><div class="line"><span class="xml">  window: global</span></div><div class="line"><span class="xml">&#125;;</span></div></pre></td></tr></table></figure><p>在引用全局对象的属性时，前缀通常可以省略，因为全局对象是不能通过名字直接访问的。尽管如此，通过全局上下文中的 this 是可以直接访问到全局对象的，也可以通过全局对象中的属性来访问到全局对象，例如，DOM 中的 <code>window</code> 属性。看下面写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>(<span class="number">10</span>); <span class="comment">// 等同于 global.String(10);</span></div><div class="line"> </div><div class="line"><span class="comment">// 带前缀</span></div><div class="line"><span class="built_in">window</span>.a = <span class="number">10</span>; <span class="comment">// === global.window.a = 10 === global.a = 10;</span></div><div class="line"><span class="keyword">this</span>.b = <span class="number">20</span>;   <span class="comment">// global.b = 20;</span></div></pre></td></tr></table></figure><p>因此，全局上下文中的变量对象就是全局对象自身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VO(globalContext) === global;</div></pre></td></tr></table></figure><p>准确理解“全局上下文中的变量对象就是全局对象自身”是非常必要的，正是由于如此，在全局上下文中声明一个变量时，我们可以通过全局对象的属性间接访问到这个变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>);</div><div class="line"> </div><div class="line">alert(a); <span class="comment">// 直接访问，is found in VO(globalContext): "test"</span></div><div class="line"> </div><div class="line">alert(<span class="built_in">window</span>[<span class="string">'a'</span>]);  <span class="comment">// 间接访问，通过 global === VO(globalContext): "test"</span></div><div class="line">alert(a === <span class="keyword">this</span>.a); <span class="comment">// true</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> aKey = <span class="string">'a'</span>;</div><div class="line">alert(<span class="built_in">window</span>[aKey]); <span class="comment">// 间接访问，通过动态属性名的方式："test"</span></div></pre></td></tr></table></figure><h3><span id="函数上下文中的变量对象">函数上下文中的变量对象</span></h3><p>在函数上下文中，变量对象（VO）不能直接被访问到，此时活动对象（Activation Object，简称 AO）扮演着 VO 的角色。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VO(functionContext) === AO;</div></pre></td></tr></table></figure><blockquote><p>活动对象在进入函数上下文的时候被创建，同时伴随着 <code>arguments</code> 属性的初始化，该属性是 <code>Arguments</code> 对象的值：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AO = &#123;</div><div class="line">  <span class="built_in">arguments</span>: </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><code>arguments</code> 对象是活动对象（AO）中的一个属性，包含以下属性：</p><ul><li>callee - 当前函数的引用</li><li>length - 实参数量</li><li>properties-indexes（字符串类型的整数），属性的值就是函数的参数值（按参数列表从左到右排列）。<code>properties-indexes</code> 的元素的个数等于 <code>arguments.length</code>，<code>properties-indexes</code> 的值和实际传递进来的参数之间是共享的。</li></ul><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="comment">// 定义的函数参数（x,y,z）的个数</span></div><div class="line">  alert(foo.length); <span class="comment">// 3</span></div><div class="line"> </div><div class="line">  <span class="comment">// 实际传递的参数个数</span></div><div class="line">  alert(<span class="built_in">arguments</span>.length); <span class="comment">// 2</span></div><div class="line"> </div><div class="line">  <span class="comment">// 引用函数自身</span></div><div class="line">  alert(<span class="built_in">arguments</span>.callee === foo); <span class="comment">// true</span></div><div class="line"> </div><div class="line">  <span class="comment">// 参数互相共享</span></div><div class="line">  alert(x === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// true</span></div><div class="line">  alert(x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">20</span>;</div><div class="line">  alert(x); <span class="comment">// 20</span></div><div class="line"> </div><div class="line">  x = <span class="number">30</span>;</div><div class="line">  alert(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 30</span></div><div class="line"> </div><div class="line">  <span class="comment">// 然而，对于没有传递的参数 z，</span></div><div class="line">  <span class="comment">// 相关的 arguments 对象的 index-property 是不共享的</span></div><div class="line">  z = <span class="number">40</span>;</div><div class="line">  alert(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// undefined</span></div><div class="line"> </div><div class="line">  <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">50</span>;</div><div class="line">  alert(z); <span class="comment">// 40</span></div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</div></pre></td></tr></table></figure><p>对于最后一种情况，在老版本的 Chrome 浏览器中有一个 Bug：形参 <code>z</code> 和 <code>arguments[2]</code> 之间仍然是共享的。</p><h2><span id="处理上下文代码的几个阶段">处理上下文代码的几个阶段</span></h2><p>至此，也就到了本文最核心的部分了。处理执行上下文代码分为两个阶段：</p><ol><li>进入执行上下文</li><li>执行代码</li></ol><p>变量对象的修改和这两个阶段密切相关。</p><p>要注意的是，这两个处理阶段是通用的行为，与上下文类型无关（不管是全局上下文还是函数上下文都是一致的）。</p><h3><span id="进入执行上下文">进入执行上下文</span></h3><p>当进入执行上下文时（在代码执行前），VO 就会被下列属性填充（在此前已经描述过了）：</p><ul><li>函数的所有形参（如果是在函数执行上下文中）<br>每个形参都对应变量对象中的一个属性，该属性由形参名和对应的实参值构成，如果没有传递实参，那么该属性值就为 <code>undefined</code></li><li>所有函数声明（FunctionDeclaration, FD）<br>每个函数声明都对应变量对象中的一个属性，这个属性由一个函数对象的名称和值构成，如果变量对象中存在相同的属性名，则完全替换该属性。</li><li>所有变量声明（var, VariableDeclaration）<br>每个变量声明都对应变量对象中的一个属性，该属性的键/值是变量名和 <code>undefined</code>，如果变量名与已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。</li></ul><p>举例说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c = <span class="number">10</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">  <span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span> <span class="title">_e</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">test(<span class="number">10</span>); <span class="comment">// call</span></div></pre></td></tr></table></figure><p>当进入 <code>test</code> 的执行上下文，并传递了实参 <code>10</code>，AO 对象如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AO(test) = &#123;</div><div class="line">  a: <span class="number">10</span>,</div><div class="line">  b: <span class="literal">undefined</span>,</div><div class="line">  c: <span class="literal">undefined</span>,</div><div class="line">  d: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">FunctionDeclaration</span> "<span class="attr">d</span>"&gt;</span></span></div><div class="line"><span class="xml">  e: undefined</span></div><div class="line"><span class="xml">&#125;;</span></div></pre></td></tr></table></figure><p>注意：AO 并不包含函数 <code>x</code>，这是因为 <code>x</code> 不是函数声明，而是一个函数表达式（FunctionExpression，简称为 FE），函数表达式不会影响 VO。</p><p>同理，函数 <code>_e</code> 也是函数表达式，就像我们即将看到的那样，因为它分配给了变量 <code>e</code>，所以可以通过名称 <code>e</code> 来访问。函数声明与函数表达式的异同，将在 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="external">Chapter 5. Functions</a> 中进行详细的探讨。</p><p>这之后，将进入处理上下文代码的第二个阶段：执行代码。</p><h3><span id="执行代码">执行代码</span></h3><p>此时，AO/VO 的属性已经填充好了。（尽管，大部分属性都还没有赋予真正的值，都只是初始化时候的 <code>undefined</code> 值）。</p><p>继续以上一例子，到了执行代码阶段，AO/VO 就会修改为如下形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AO[<span class="string">'c'</span>] = <span class="number">10</span>;</div><div class="line">AO[<span class="string">'e'</span>] = <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">FunctionExpression</span> "<span class="attr">_e</span>"&gt;</span>;</span></div></pre></td></tr></table></figure><p>再次注意，函数表达式 <code>_e</code> 仍在内存中，它被保存在声明的变量 <code>e</code> 中。但函数表达式 <code>x</code> 却不在 AO/VO 中，如果尝试在其定义前或者定义后调用 <code>x</code> 函数，这时会发生“x未定义”的错误。未保存在变量中的函数表达式只能在其内部或通过递归才能被调用。</p><p>另一个经典的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">alert(x); <span class="comment">// function</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line">alert(x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">x = <span class="number">20</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"> </div><div class="line">alert(x); <span class="comment">// 20</span></div></pre></td></tr></table></figure><p>为什么第一次弹出的是 “function”？为何在 <code>x</code> 声明前就能访问到？为什么弹出的不是 “10” 或者 “20”？原因在于，根据规范，在进入上下文时，VO 中的 <code>x</code> 被填充为函数声明。同时，还有变量声明 <code>x</code>，但是，根据前面的规则，变量声明是在函数形参和函数声明之后，并且，变量声明不会影响已经存在的同名函数或形参，因此，进入上下文时，VO 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">VO = &#123;&#125;;</div><div class="line"> </div><div class="line">VO[<span class="string">'x'</span>] = <span class="xml"><span class="tag">&lt;<span class="name">引用了函数声明“x”</span>&gt;</span></span></div><div class="line"><span class="xml"> </span></div><div class="line"><span class="xml">// 发现var x = 10;</span></div><div class="line"><span class="xml">// 如果函数“x”还未定义</span></div><div class="line"><span class="xml">// 则 "x" 为 undefined, 但是，在我们的例子中</span></div><div class="line"><span class="xml">// 变量声明并不会影响同名的函数值</span></div><div class="line"><span class="xml"> </span></div><div class="line"><span class="xml">VO['x'] = <span class="tag">&lt;<span class="name">值不受影响，仍是函数</span>&gt;</span></span></div></pre></td></tr></table></figure><p>随后，在执行代码阶段，VO 被修改为如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">VO[<span class="string">'x'</span>] = <span class="number">10</span>;</div><div class="line">VO[<span class="string">'x'</span>] = <span class="number">20</span>;</div></pre></td></tr></table></figure><p>正如在第二个和第三个alert显示的那样。</p><p>下面的例子里我们可以再次看到，变量是在进入上下文阶段放入VO中的。(因为，虽然else部分代码永远不会执行，但是不管怎样，变量 <code>b</code> 仍然存在于VO中。)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">alert(a); <span class="comment">// 1</span></div><div class="line">alert(b); <span class="comment">// undefined, but not "b is not defined"</span></div></pre></td></tr></table></figure><h2><span id="关于变量">关于变量</span></h2><p>通常，各类文章和 JavaScript 相关的书籍都声称：“不管是使用 <code>var</code> 关键字（在全局上下文）还是不使用 <code>var</code> 关键字（在任何地方），都可以声明一个全局变量”。这样描述是不恰当的，请记住：</p><p>使用 <code>var</code> 是声明变量的唯一方式。</p><p>如下赋值语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">10</span>;</div></pre></td></tr></table></figure><p>仅仅是在全局对象时创建了新的属性（而不是变量）。“不是变量”并不是意味着它无法改变，而是指它不符合 ECMAScript 规范中的变量概念，所以它“不是变量”（它之所以能成为全局对象的属性，完全是因为 <code>VO(globalContext) === global</code>，大家还记得这个吧？）。</p><p>让我们通过下面的实例看看具体的区别吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">alert(a); <span class="comment">// undefined</span></div><div class="line">alert(b); <span class="comment">// "b" is not defined</span></div><div class="line"> </div><div class="line">b = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</div></pre></td></tr></table></figure><p>所有根源仍然是 VO 和它的修改阶段（进入上下文阶段和执行代码阶段）：</p><p>进入上下文：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">VO = &#123;</div><div class="line">  a: <span class="literal">undefined</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>我们看到，这个阶段并没有任何 <code>b</code>，因为它不是变量，<code>b</code> 在执行代码阶段才出现。（但是，在我们这个例子中也不会出现，因为在 <code>b</code> 出现前就发生了错误）</p><p>将上述代码稍作改动：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">alert(a); <span class="comment">// undefined, we know why</span></div><div class="line"> </div><div class="line">b = <span class="number">10</span>;</div><div class="line">alert(b); <span class="comment">// 10, created at code execution</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</div><div class="line">alert(a); <span class="comment">// 20, modified at code execution</span></div></pre></td></tr></table></figure><p>关于变量还有非常重要的一点：与简单属性不同的是，变量是不能删除的<code>{DontDelete}</code>，这意味着要想通过 <code>delete</code> 操作符来删除一个变量是不可能的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">10</span>;</div><div class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">alert(<span class="keyword">delete</span> a); <span class="comment">// true</span></div><div class="line"> </div><div class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</div><div class="line">alert(<span class="built_in">window</span>.b); <span class="comment">// 20</span></div><div class="line"> </div><div class="line">alert(<span class="keyword">delete</span> b); <span class="comment">// false</span></div><div class="line"> </div><div class="line">alert(<span class="built_in">window</span>.b); <span class="comment">// still 20</span></div></pre></td></tr></table></figure><p class="j-quote">注意，在 ES5 中，<code>{DontDelete}</code> 被 重命名为了 <code>[[Configurable]]</code>，而且可以通过 <code>Object.defineProperty</code> 来手动控制。</p><p>但是，这里有个例外，就是 <code>eval</code> 执行上下文中，是可以删除变量的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">'var a = 10;'</span>);</div><div class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">alert(<span class="keyword">delete</span> a); <span class="comment">// true</span></div><div class="line"> </div><div class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>在一些调试工具（如 Firebug）的控制台中实验这些例子时，需要注意：Firebug 是使用 <code>eval</code> 来执行控制台里的代码，因此，变量同样没有 <code>{DontDelete}</code> 特性，可以被删除。</p><h2><span id="特殊属性-__parent__">特殊属性: __parent__</span></h2><p>根据前面的介绍，按照规范，活动对象是不能被直接访问到的。但是，一些具体的实现并没有完全遵守规范，例如在 SpiderMonkey 和 Rhino 中，函数有个特殊属性 <code>__parent__</code>，通过这个属性可以直接引用到创建该函数的上下文的活动对象或全局变量对象。</p><p>例如（在 SpiderMonkey 和 Rhino 中）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"> </div><div class="line">alert(foo.__parent__); <span class="comment">// global</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> VO = foo.__parent__;</div><div class="line"> </div><div class="line">alert(VO.a); <span class="comment">// 10</span></div><div class="line">alert(VO === global); <span class="comment">// true</span></div></pre></td></tr></table></figure><p>在上面例子中，可以看到函数 <code>foo</code> 是在全局上下文中创建的，相应的，它的 <code>__parent__</code> 属性设置为全局上下文的变量对象，也就是全局对象。</p><p>然而，在 SpiderMonkey 中以相同的方式获取活动对象（AO）是不可能的：不同的版本表现都不同，内部函数的 <code>__parent__</code> 属性会返回 <code>null</code> 或者全局对象。</p><p>在 Rhino 中，以相同的方式获取活动对象是允许的：</p><p>如下所示（Rhino）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</div><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</div><div class="line"> </div><div class="line">  <span class="comment">// 函数 foo 的活动对象</span></div><div class="line">  <span class="keyword">var</span> AO = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).__parent__;</div><div class="line"> </div><div class="line">  print(AO.y); <span class="comment">// 20</span></div><div class="line"> </div><div class="line">  <span class="comment">// 当前活动对象的 __parent__ 属性指向全局对象</span></div><div class="line">  <span class="comment">// 这样就形成了所说的作用域链</span></div><div class="line">  print(AO.__parent__ === global); <span class="comment">// true</span></div><div class="line">  print(AO.__parent__.x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">&#125;)();</div></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>本文深入讨论了跟执行上下文相关的对象，我希望这些知识对您来说能有所帮助，能解决一些您曾经遇到的问题或困惑。按照计划，在后续的章节中，我们将探讨 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="external">Scope chain</a>，<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/#function-activation" target="_blank" rel="external">Identifier resolution</a>，<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="external">Closures</a>。</p><h2><span id="扩展阅读">扩展阅读</span></h2><ul><li>10.1.3 — <a href="http://bclary.com/2004/11/07/#a-10.1.3" target="_blank" rel="external">Variable Instantiation</a></li><li>10.1.5 — <a href="http://bclary.com/2004/11/07/#a-10.1.5" target="_blank" rel="external">Global Object</a></li><li>10.1.6 — <a href="http://bclary.com/2004/11/07/#a-10.1.6" target="_blank" rel="external">Activation Object</a></li><li>10.1.8 — <a href="http://bclary.com/2004/11/07/#a-10.1.8" target="_blank" rel="external">Arguments Object</a></li></ul><p class="j-dot"><strong>Translated by:</strong> Dmitry A. Soshnikov.<br><strong>Published on:</strong> 2010-03-15<br><br><strong>Originally written by:</strong> Dmitry A. Soshnikov [ru, <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/" target="_blank" rel="external">read »</a>]<br><strong>Originally published on:</strong> 2009-06-27</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;http://dmitrysoshnikov.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dmitry A. Soshnikov&lt;/a&gt; 的文章 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMA-262-3 in detail. Chapter 2. Variable object.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考了一些译文，作为自己学习 ECMAScript 的一点积累。&lt;/p&gt;
&lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;创建应用程序的时，总免不了要声明变量和函数。然而，解析器（interpreter）是如何以及从哪里找到这些数据（变量，函数）的，当我们引用一个变量时，在解析器内部又发生了什么？&lt;/p&gt;
&lt;p&gt;许多 ECMAScript 程序员都知道变量与&lt;a href=&quot;http://bubkoo.com/2014/05/28/ecma-262-3-in-detail-chapter-1-execution-contexts/&quot;&gt;执行上下&lt;/a&gt;文密切相关：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 全局上下文中的变量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 函数上下文中的局部变量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(a); &lt;span class=&quot;comment&quot;&gt;// 10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(b); &lt;span class=&quot;comment&quot;&gt;// &quot;b&quot; is not defined&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同样，许多 ECMAScript 程序员也知道，基于当前版本的规范，独立作用域只能通过“函数代码”才能创建。也就是说，与 C/C++ 不同，在 ECMAScript 中 &lt;code&gt;for&lt;/code&gt; 循环不会创建一个局部上下文（即局部作用域）。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &amp;#123;&lt;span class=&quot;attr&quot;&gt;a&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  alert(k);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(k); &lt;span class=&quot;comment&quot;&gt;// 尽管循环已经结束，但是变量 “k” 仍然在作用域中&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面具体来看一下，当我们声明变量和函数时，究竟发生了什么。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ECMAScript" scheme="http://bubkoo.com/tags/ecmascript/"/>
    
      <category term="ECMA-262-3" scheme="http://bubkoo.com/tags/ecma-262-3/"/>
    
      <category term="Variable object" scheme="http://bubkoo.com/tags/variable-object/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3 详解 第一章 执行上下文</title>
    <link href="http://bubkoo.com/2014/05/28/ecma-262-3-in-detail-chapter-1-execution-contexts/"/>
    <id>http://bubkoo.com/2014/05/28/ecma-262-3-in-detail-chapter-1-execution-contexts/</id>
    <published>2014-05-28T16:56:23.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">Dmitry A. Soshnikov</a> 的 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 1. Execution Contexts.</a></p><p>参阅了已有的中文翻译，以此来加深对 ECMAScript 的理解。</p><h2><span id="概要">概要</span></h2><p>本文将介绍 ECMAScript 的执行上下文以及与之相关的可执行代码的类型。</p><h2><span id="定义">定义</span></h2><p>每当控制器到达 ECMAScript 的可执行代码时，控制器就进入了一个执行上下文。</p><blockquote><p>执行上下文（简称 - EC）是 ECMA-262 中的一个抽象概念，用于区别不同类型的可执行代码。</p></blockquote><p>规范中并没有从技术角度来定义执行上下文的具体结构和类型，这是实现标准 ECMAScript 引擎所需要考虑的问题。</p><p>一系列活动执行上下文在逻辑上形成一个栈。栈底永远是全局上下文，而栈顶是当前（活动）执行上下文。栈在进入或退出各种执行上下文（EC）时被修改（入栈/出栈）。</p><a id="more"></a><h2><span id="可执行代码类型">可执行代码类型</span></h2><p>可执行代码类型这个概念与执行上下文的抽象概念息息相关。在某些时刻，说道可执行代码类型时，很可能就代表了一个可执行上下文。</p><p>例如，我们将可执行上下文栈定义为一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ECStack = [];</div></pre></td></tr></table></figure><p>每当控制器进入一个函数（即便该函数是被递归调用或作为构造函数调用），都将发触发压栈操作，调用内置的 <code>Eval</code> 函数时也不例外。</p><h3><span id="全局代码">全局代码</span></h3><p>这类代码在“程序”级别上被处理：比如：加载一个外部的 JS 文件或内联的 JS 代码（包含在 <code>&lt;script&gt;&lt;/script&gt;</code> 内的代码）。全局代码不包含定义在任何函数体内的代码。</p><p>在初始化（程序开始）时，<code>ECStack</code> 是下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ECStack = [</div><div class="line">  globalContext</div><div class="line">];</div></pre></td></tr></table></figure><h3><span id="函数代码">函数代码</span></h3><p>当控制器进入函数代码（各类函数）时，就会有新的元素被压入 <code>ECStack</code> 中。值得注意的是：这里的函数代码不包含内部函数（inner functions）的代码。</p><p>我们以一个递归调用自身一次的函数为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (bar)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    foo(<span class="literal">true</span>);</div><div class="line">&#125;)(<span class="literal">false</span>);</div></pre></td></tr></table></figure><p><code>ECStack</code> 将发生两次入栈操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 首先激活 foo 函数</span></div><div class="line">ECStack = [</div><div class="line">     functionContext</div><div class="line">     globalContext</div><div class="line">];</div><div class="line"><span class="comment">// 递归激活 foo 函数</span></div><div class="line">ECStack = [</div><div class="line">     functionContext - recursively</div><div class="line">     functionContext</div><div class="line">     globalContext</div><div class="line">];</div></pre></td></tr></table></figure><p>每当函数返回，退出当前执行上下文时，<code>ECStack</code> 就会发生相应的出栈操作，先进后出，这与典型的堆栈逻辑一样。当这些代码执行完毕之后，<code>ECStack</code> 再次回到只包含 <code>globalContext</code> 的状态，直到程序结束。</p><p>一个抛出而未被捕获的异常同样也会退出一个或多个执行上下文：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="string">'Exit from bar and foo contexts'</span>;</div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><h3><span id="eval-代码">Eval 代码</span></h3><p>对于 <code>Eval</code> 代码就比较有意思了。这里有一个调用上下文的概念，即 <code>Eval</code> 函数被调用时的上下文。</p><p>在 <code>Eval</code> 中所作的操作，如变量声明或函数定义，都将影响整个调用上下文：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 影响全局上下文</span></div><div class="line"><span class="built_in">eval</span>(<span class="string">'var x = 10'</span>);</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 变量 `y` 在 `foo` 函数的本地上下文中定义</span></div><div class="line">  <span class="built_in">eval</span>(<span class="string">'var y = 20'</span>);</div><div class="line">&#125;)();</div><div class="line"> </div><div class="line">alert(x); <span class="comment">// 10</span></div><div class="line">alert(y); <span class="comment">// "y" is not defined</span></div></pre></td></tr></table></figure><p class="j-quote">注意：在 ES5 的严格模式下，<code>eval</code> 不再影响调用上下文，而是在本地沙箱中执行代码（即存在 <code>Eval</code> 作用域）。</p><p><code>ECStack</code> 将发生如下入栈/出栈变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">ECStack = [</div><div class="line">  globalContext</div><div class="line">];</div><div class="line"> </div><div class="line"><span class="comment">// eval('var x = 10');</span></div><div class="line">ECStack.push(&#123;</div><div class="line">  context: evalContext,</div><div class="line">  callingContext: globalContext</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 退出 eval</span></div><div class="line">ECStack.pop();</div><div class="line"></div><div class="line"><span class="comment">// 调用 foo 函数</span></div><div class="line">ECStack.push(<span class="xml"><span class="tag">&lt;<span class="name">foo</span>&gt;</span> functionContext);</span></div><div class="line"><span class="xml"></span></div><div class="line"><span class="xml">// eval('var y = 20');</span></div><div class="line"><span class="xml">ECStack.push(&#123;</span></div><div class="line"><span class="xml">  context: evalContext,</span></div><div class="line">  callingContext: &lt;foo&gt; functionContext</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 退出 eval </div><div class="line">ECStack.pop();</div><div class="line"></div><div class="line">// 退出 foo 函数</div><div class="line">ECStack.pop();</div></pre></td></tr></table></figure><p>也就是一个非常普通的堆栈调用逻辑。</p><p>在版本号 1.7 以下的 SpiderMonkey 实现中（Firefox），可以把调用上下文作为第二个参数传递给 <code>Eval</code>。此时，如果传入的调用上下文还存在的话，就有可能影响该上下文中的私有变量（在该上下文中声明的变量）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(x); &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = foo();</div><div class="line"></div><div class="line">bar(); <span class="comment">// 1</span></div><div class="line"><span class="built_in">eval</span>(‘x = <span class="number">2</span>’, bar); <span class="comment">// 传递上下文，影响了内部变量“var x”</span></div><div class="line">bar(); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>然而，由于安全原因，现代引擎已经修复了这个问题。</p><h2><span id="结论">结论</span></h2><p>这些基本理论对于后续章节中执行上下文相关细节（如变量、对象、作用域链等等）是非常必要的。</p><h2><span id="扩展阅读">扩展阅读</span></h2><p>ECMA-262-3 规范文档的对应的章节 - <a href="http://bclary.com/2004/11/07/#a-10" target="_blank" rel="external">10. Execution Contexts.</a></p><p class="j-dot"><strong>Translated by:</strong> Dmitry Soshnikov.<br><strong>Published on:</strong> 2010-03-11<br><br><strong>Originally written by:</strong> Dmitry Soshnikov [ru, <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-1-execution-contexts/" target="_blank" rel="external">read »</a>]<br><strong>Originally published on:</strong> 2009-06-26</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;http://dmitrysoshnikov.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dmitry A. Soshnikov&lt;/a&gt; 的 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMA-262-3 in detail. Chapter 1. Execution Contexts.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参阅了已有的中文翻译，以此来加深对 ECMAScript 的理解。&lt;/p&gt;
&lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;本文将介绍 ECMAScript 的执行上下文以及与之相关的可执行代码的类型。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;每当控制器到达 ECMAScript 的可执行代码时，控制器就进入了一个执行上下文。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;执行上下文（简称 - EC）是 ECMA-262 中的一个抽象概念，用于区别不同类型的可执行代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;规范中并没有从技术角度来定义执行上下文的具体结构和类型，这是实现标准 ECMAScript 引擎所需要考虑的问题。&lt;/p&gt;
&lt;p&gt;一系列活动执行上下文在逻辑上形成一个栈。栈底永远是全局上下文，而栈顶是当前（活动）执行上下文。栈在进入或退出各种执行上下文（EC）时被修改（入栈/出栈）。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ECMAScript" scheme="http://bubkoo.com/tags/ecmascript/"/>
    
      <category term="ECMA-262-3" scheme="http://bubkoo.com/tags/ecma-262-3/"/>
    
      <category term="execution context" scheme="http://bubkoo.com/tags/execution-context/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 核心</title>
    <link href="http://bubkoo.com/2014/05/20/javascript-the-core/"/>
    <id>http://bubkoo.com/2014/05/20/javascript-the-core/</id>
    <published>2014-05-20T16:54:01.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>此文译自 <a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">Dmitry A. Soshnikov</a> 的 <a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" target="_blank" rel="external">JavaScript. The core.</a>.</p><p>本文是<a href="http://dmitrysoshnikov.com/tag/ecma-262-3/" target="_blank" rel="external">详解 ECMA-262-3 系列</a>的概述和总结。每个部分都包含对应章节的连接，所以你可以阅读它们以获得更深入的了解。</p><p><strong>目标阅读者</strong>：有经验的程序员，专业人士。</p><p>我们从对象的概念开始，这是 ECMAScript 的根本。</p><a id="more"></a><h2><span id="对象">对象</span></h2><p>ECMAScript 做为一个高度抽象的面向对象语言，是通过对象来交互的。即使 ECMAScript 里边也有基本类型，但是，当需要的时候，它们也会被转换成对象。</p><blockquote><p>一个对象就是一个属性集合，并拥有一个独立的 <code>prototype</code>（原型）对象。这个 <code>prototype</code> 可以是一个对象或者 <code>null</code>。</p></blockquote><p>让我们看一个关于对象的基本例子。一个对象的 <code>prototype</code> 是以内部的 <code>[[Prototype]]</code> 属性来引用的。但是，在示意图里边我们将会使用 <code>__&lt;internal-property&gt;__</code> 下划线标记来替代两个括号，对于 <code>prototype</code> 对象来说是：<code>__proto__</code>。</p><p>对于以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  x: <span class="number">10</span>,</div><div class="line">  y: <span class="number">20</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>我们拥有一个这样的结构，两个显式的自身属性和一个隐含的 <code>__proto__</code> 属性，这个属性是对 <code>foo</code> 原型对象的引用：</p><p><img src="http://bubkoo.qiniudn.com/basic-object.png" alt="图 1. 一个含有原型的基本对象"></p><p>这些 <code>prototype</code> 有什么用？让我们以原型链（prototype chain）的概念来回答这个问题。</p><h2><span id="原型链">原型链</span></h2><p>原型对象也是简单的对象并且可以拥有它们自己的原型。如果一个原型对象的原型是一个非 <code>null</code> 的引用，那么以此类推，这就叫作原型链。</p><blockquote><p>原型链是一个用来实现继承和共享属性的有限对象链。</p></blockquote><p>考虑这么一个情况，我们拥有两个对象，它们之间只有一小部分不同，其他部分都相同。显然，对于一个设计良好的系统，我们将会<em>重用</em>相似的功能/代码，而不是在每个单独的对象中重复它。在基于类的系统中，这个代码重用风格叫作<em>类继承</em>－你把相似的功能放入类 <code>A</code> 中，然后类 <code>B</code> 和类 <code>C</code> 继承类 <code>A</code>，并且拥有它们自己的一些小的额外变动。</p><p>ECMAScript 中没有类的概念。但是，代码重用的风格并没有太多不同（尽管从某些方面来说比基于类的方式要更加灵活）并且通过原型链来实现。这种继承方式叫作委托继承（或者，更贴近 ECMAScript 一些，叫作原型继承）。</p><p>跟例子中的类 <code>A</code>，<code>B</code>，<code>C</code> 相似，在 ECMAScript 中你创建对象：<code>a</code>，<code>b</code>，<code>c</code>。于是，对象 <code>a</code> 中存储对象 <code>b</code> 和 <code>c</code> 中通用的部分。然后 <code>b</code> 和 <code>c</code> 只存储它们自身的额外属性或者方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  x: <span class="number">10</span>,</div><div class="line">  calculate: <span class="function"><span class="keyword">function</span> (<span class="params">z</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y + z</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = &#123;</div><div class="line">  y: <span class="number">20</span>,</div><div class="line">  __proto__: a</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = &#123;</div><div class="line">  y: <span class="number">30</span>,</div><div class="line">  __proto__: a</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// call the inherited method</span></div><div class="line">b.calculate(<span class="number">30</span>); <span class="comment">// 60</span></div><div class="line">c.calculate(<span class="number">40</span>); <span class="comment">// 80</span></div></pre></td></tr></table></figure><p>足够简单，是不是？我们看到 <code>b</code> 和 <code>c</code> 访问到了在对象 <code>a</code> 中定义的 <code>calculate</code> 方法。这是通过原型链实现的。</p><p>规则很简单：如果一个属性或者一个方法在对象自身中无法找到（也就是对象自身没有一个那样的属性），然后它会尝试在原型链中寻找这个属性/方法。如果这个属性在原型中没有查找到，那么将会查找这个原型的原型，以此类推，遍历整个原型链（当然这在类继承中也是一样的，当解析一个继承的方法的时候 – 我们遍历 <code>class</code> 链）。第一个被查找到的同名属性/方法会被使用。因此，一个被查找到的属性叫作继承属性。如果在遍历了整个原型链之后还是没有查找到这个属性的话，返回 <code>undefined</code> 值。</p><p>注意，继承方法中所使用的 <code>this</code> 的值被设置为原始对象，而并不是在其中查找到这个方法的（原型）对象。也就是，在上面的例子中 <code>this.y</code> 取的是 <code>b</code> 和 <code>c</code> 中的值，而不是 <code>a</code> 中的值。但是，<code>this.x</code> 是取的是 <code>a</code> 中的值，并且又一次通过原型链机制完成。</p><p>如果没有明确为一个对象指定原型，那么它将会使用 <code>__proto__</code> 的默认值 – <code>Object.prototype</code>。<code>Object.prototype</code> 对象自身也有一个 <code>__proto__</code> 属性，这是原型链的终点并且值为 <code>null</code>。</p><p>下一张图展示了对象 <code>a</code>，<code>b</code>，<code>c</code> 之间的继承层级：</p><p><img src="http://bubkoo.qiniudn.com/prototype-chain.png" alt="图 2. 原型链"></p><p>注意： ES5 标准化了一个实现原型继承的可选方法，即使用 <code>Object.create</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a, &#123;<span class="attr">y</span>: &#123;<span class="attr">value</span>: <span class="number">20</span>&#125;&#125;);</div><div class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>.create(a, &#123;<span class="attr">y</span>: &#123;<span class="attr">value</span>: <span class="number">30</span>&#125;&#125;);</div></pre></td></tr></table></figure><p>你可以在<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-1-properties-and-property-descriptors/#new-api-methods" target="_blank" rel="external">对应的章节</a>获取到更多关于 ES5 新 API 的信息。 ES6 标准化了 <code>__proto__</code> 属性，并且可以在对象初始化的时候使用它。</p><p>通常情况下需要对象拥有相同或者相似的状态结构（也就是相同的属性集合），赋以不同的状态值。在这个情况下我们可能需要使用构造函数，其以指定的模式来创造对象。</p><h2><span id="构造函数">构造函数</span></h2><p>除了以指定模式创建对象之外，构造函数也做了另一个有用的事情 – 它自动地为新创建的对象设置一个原型对象。这个原型对象存储在 <code>ConstructorFunction.prototype</code> 属性中。</p><p>例如，我们重写之前例子，使用构造函数创建对象 <code>b</code> 和 <code>c</code>。因此，对象 <code>a</code>（一个原型对象）的角色由 <code>Foo.prototype</code> 来扮演：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">y</span>) </span>&#123;</div><div class="line"><span class="comment">// 构造函数将会以特定模式创建对象：被创建的对象都会有"y"属性</span></div><div class="line"><span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// "Foo.prototype"存放了新建对象的原型引用</span></div><div class="line"><span class="comment">// 所以我们可以将之用于定义继承和共享属性或方法</span></div><div class="line"><span class="comment">// 所以，和上例一样，我们有了如下代码：</span></div><div class="line"></div><div class="line"><span class="comment">// 继承属性"x"</span></div><div class="line">Foo.prototype.x = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">// 继承方法"calculate"</span></div><div class="line">Foo.prototype.calculate = <span class="function"><span class="keyword">function</span> (<span class="params">z</span>) </span>&#123;</div><div class="line">returnthis.x + <span class="keyword">this</span>.y + z;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 使用foo模式创建 "b" and "c"</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo(<span class="number">20</span>);</div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Foo(<span class="number">30</span>);</div><div class="line"></div><div class="line"><span class="comment">// 调用继承的方法</span></div><div class="line">b.calculate(<span class="number">30</span>); <span class="comment">// 60</span></div><div class="line">c.calculate(<span class="number">40</span>); <span class="comment">// 80</span></div><div class="line"></div><div class="line"><span class="comment">// 让我们看看是否使用了预期的属性</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(</div><div class="line"></div><div class="line">  b.__proto__ === Foo.prototype, <span class="comment">// true</span></div><div class="line">  c.__proto__ === Foo.prototype, <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// "Foo.prototype"自动创建了一个特殊的属性"constructor"</span></div><div class="line"><span class="comment">// 指向a的构造函数本身</span></div><div class="line"><span class="comment">// 实例"b"和"c"可以通过授权找到它并用以检测自己的构造函数</span></div><div class="line"></div><div class="line">  b.constructor === Foo, <span class="comment">// true</span></div><div class="line">  c.constructor === Foo, <span class="comment">// true</span></div><div class="line">  Foo.prototype.constructor === Foo <span class="comment">// true</span></div><div class="line"></div><div class="line">  b.calculate === b.__proto__.calculate, <span class="comment">// true</span></div><div class="line">  b.__proto__.calculate === Foo.prototype.calculate <span class="comment">// true</span></div><div class="line"></div><div class="line">);</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/constructor-proto-chain.png" alt="图 3. 构造函数与对象之间的关系"></p><p>这张图又一次说明了每个对象都有一个原型。构造函数 <code>Foo</code> 也有自己的 <code>__proto__</code>，值为<code>Function.prototype</code>，<code>Function.prototype</code> 也通过其 <code>__proto__</code> 属性关联到 <code>Object.prototype</code>。重申一遍，<code>Foo.prototype</code> 只是一个显式的属性，也就是 <code>b</code> 和 <code>c</code> 的 <code>__proto__</code> 属性。</p><p>有关这个主题的完整、详细的解释可以在 ES3 系列的第七章找到。分为两个部分：<a href="http://bubkoo.com/2014/06/21/ecma-262-3-in-detail-chapter-7-1-oop-the-general-theory/">7.1 面向对象基本理论</a>，在那里你将会找到对各种面向对象范例、风格的描述以及它们和 ECMAScript 之间的对比，然后在 <a href="http://bubkoo.com/2014/06/22/ecma-262-3-in-detail-chapter-7-2-oop-ecmascript-implementation/">7.2 面向对象 ECMAScript 实现</a>，是对 ECMAScript 中面向对象的介绍。</p><p>现在，在我们知道了对象的基础之后，让我们看看运行时程序的执行在 ECMAScript 中是如何实现的。这叫作执行上下文栈，其中的每个元素也可以抽象成为一个对象。是的，ECMAScript 几乎在任何地方都和对象的概念打交道。</p><h2><span id="执行上下文栈">执行上下文栈</span></h2><p>有三种类型的 ECMAScript 代码：全局代码、函数代码和 <code>eval</code> 代码。每段代码都是在其对于的执行上下文中被执行。有且只有一个全局执行上下文，可能多个函数执行上下文和 <code>eval</code> 执行上下文。当调用一个函数时，就进入了函数执行上下文，并运行函数内部的代码；当执行 <code>eval</code> 时，就进入 <code>eval</code> 的执行上下文，并运行 <code>eval</code> 中的代码。</p><p>注意：一个函数可以创建无数个执行上下文，因为对函数的每次调用（即便是该函数递归调用自己）都将生成一个具有新状态的上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar</span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// call the same function,</span></div><div class="line"><span class="comment">// generate three different</span></div><div class="line"><span class="comment">// contexts in each call, with</span></div><div class="line"><span class="comment">// different context state (e.g. value</span></div><div class="line"><span class="comment">// of the "bar" argument)</span></div><div class="line"></div><div class="line">foo(<span class="number">10</span>);</div><div class="line">foo(<span class="number">20</span>);</div><div class="line">foo(<span class="number">30</span>);</div></pre></td></tr></table></figure><p>一个执行上下文可能会激活另一个上下文，比如，一个函数调用另一个函数（或者在全局上下文中调用一个全局函数），等等。从逻辑上来说，这是以堆栈的形式实现的，称为执行上下文栈。</p><p>激活其他上下文的上下文被称为调用者（caller），被激活的上下文称为被调用者（callee）。被调用者同时也可能是调用者（比如，一个在全局上下文中被调用的函数，之后调用了一些内部函数）。</p><p>当一个 caller 激活了一个 callee，那么这个 caller 就会暂停它自身的执行，然后将控制权交给这个 callee。这个 callee 被压入栈中，并成为一个运行中（活动的）执行上下文。在 callee 的上下文结束后，它会把控制权返回给 caller，然后 caller 的上下文继续执行（它可能触发其他上下文）直到它结束，以此类推。一个 callee 可以简单的返回或抛出一个异常来结束自身的上下文，一个抛出而未被捕获的异常可以退出（出栈）一个或多个执行上下文。</p><p>也就是说，所有的 ECMAScript 程序运行时都可以用执行上下文栈来表示，栈顶是当前活动执行上下文：</p><p><img src="http://bubkoo.qiniudn.com/an-execution-context-stack.png" alt="图4. 执行上下文栈"></p><p>程序开始运行时就进入额全局执行上下文，全局上下文位于栈底，而且是栈的第一个元素。然后，全局代码开始初始化，创建一些需要的对象或函数。当在全局上下文中运行时，其中的代码可能调用其他函数（已经创建），此时就会进入这个函数的上下文，向栈中压入新的元素，依次类推。当初始化完成后，运行时系统（runtime system）就会等待一些事件（比如鼠标点击事件），这些事件将触发一些函数，从而进入新的执行山下文。</p><p>下图中，包含某个函数的上下文 <code>EC1</code> 和全局上下文 <code>Global EC</code>，当进入和退出 <code>EC</code> 的执行上下文时，栈将发生如下变化：</p><p><img src="http://bubkoo.qiniudn.com/ec-stack-changes.png" alt="图 5. 执行上下文栈的变化"></p><p>ECMAScript 的运行时系统就是这样管理代码执行的。</p><p>更多有关 ECMAScript 中执行上下文的信息可以在对应的<a href="http://bubkoo.com/2014/05/28/ecma-262-3-in-detail-chapter-1-execution-contexts/">ECMA-262-3 详解.第一章.执行上下文</a>中获取。</p><p>每个执行上下文都可以用一个对象来表示，让我们来看看该对象的结构以及一个上下文需要什么样的状态（属性）来执行其中的代码。</p><h2><span id="执行上下文">执行上下文</span></h2><p>一个执行上下文可以抽象为一个简单的对象来表示，每个执行上下文拥有一系列属性（也可以称作上下文状态）来跟踪其代码的执行过程，下图展示了一个上下文的结构：</p><p><img src="http://bubkoo.qiniudn.com/execution-context.png" alt="图 6. 上下文结构"></p><p>除了这三个必需的属性（变量对象 (variable object)，this 指针 (this value)，作用域链 (scope chain)），执行上下文根据具体实现还可以具有任意额外属性。</p><p>让我们详细看看上下文中的这些重要属性。</p><h2><span id="变量对象">变量对象</span></h2><blockquote><p>变量对象是执行上下文的数据容器，它是一个与执行上下文相关的特殊对象，储存了在执行上下文中定义的变量和函数声明。 </p></blockquote><p>注意，函数表达式（与函数声明相对）不包含在变量对象中。</p><p>变量对象是一个抽象概念，在不同的执行上下文中，变量对象在结构上表现为不同的对象。例如，在全局上下文中，变量对象就是全局对象自身（这就是为什么我们可以通过全局对象的属性名来访问全局变量）。</p><p>请看下面在全局执行上下文的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// // 函数声明</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// 函数表达式</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(</div><div class="line">  <span class="keyword">this</span>.foo == foo, <span class="comment">// true</span></div><div class="line">  <span class="built_in">window</span>.bar == bar <span class="comment">// true</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// 引用错误，baz没有被定义</span></div></pre></td></tr></table></figure><p>全局上下文的变量对象（variable objec，简称 VO）将会拥有如下属性：</p><p><img src="http://bubkoo.qiniudn.com/variable-object.png" alt="图 7. 全局变量对象"></p><p>在看一遍上面代码，函数 <code>baz</code> 是一个函数表达式，并不包含在变量对象中。这就是为什么当我们在函数表达式之外访问它时会出现 <code>ReferenceError</code>。</p><p>注意，与其他语言（比如C/C++）相比，在 ECMAScript 中只有函数才会创建新的作用域。函数作用域中声明的变量和函数，在函数外部不能直接访问，并且不会污染全局变量对象。</p><p>使用 <code>eval</code> 时也会进入一个新的（<code>eval</code> 的）执行上下文。然而，<code>eval</code> 要么使用全局变量对象，要么使用调用者（caller）的变量对象（比如，<code>eval</code> 被调用时所在的函数）。</p><p>那么函数上下文中的变量对象是怎样的呢？在一个函数上下文中，变量对象是以活动对象（activation object）来表示。</p><h2><span id="活动对象">活动对象</span></h2><p>当一个函数被调用时，一个称为活动对象（activation object）的特殊对象将被创建。活动对象包含形参和特殊的 <code>arguments</code> 对象（具有索引属性的参数映射）。在函数上下文中，活动对象作为变量对象来使用。</p><p>也就是说，一个函数的变量对象仍然是一个简单的对象，除了储存变量和函数声明外，它还储存了函数的形参以及 <code>arguments</code> 对象，并被称为活动对象。</p><p>看下面例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> z = <span class="number">30</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 函数声明</span></div><div class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// 函数表达式</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</div></pre></td></tr></table></figure><p>函数 <code>foo</code> 上下文中的活动对象：</p><p><img src="http://bubkoo.qiniudn.com/activation-object.png" alt="图 8. 活动对象"></p><p>函数表达式 <code>baz</code> 仍然不在活动对象/变量对象中。</p><p>针对所有细节（比如变量和函数声明的提升问题（hoisting））的完整描述请参阅 <a href="http://bubkoo.com/2014/05/31/ecma-262-3-in-detail-chapter-2-variable-object/">ECMA-262-3 详解.第二章.变量对象</a>。</p><p class="j-quote">注意，在 ES5 中，变量对象和活动对象并入了词法环境模型（lexical environments model），详细的描述请<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" target="_blank" rel="external">看这里</a>。</p><p>让我们移步下一节。众所周知，在 ECMAScript 中我们可以使用内部函数，在这些内部函数中我们可以访问父函数的变量或全局作用域中的变量。我们将上下文中变量对象命名为作用域对象，与原型链相似，也有所谓的作用域链。</p><h2><span id="作用域链">作用域链</span></h2><blockquote><p>作用域链是一个对象列表，上下文代码中出现的标识符将在这个列表中查找。</p></blockquote><p>与原型链相似，查找规则也很简单：如果一个变量在函数自身作用域（在函数自身的变量/活动对象）中没有找到，那么就会查找父级函数（外层函数）的变量对象，以次类推。</p><p>就上下文而言，标识符指：变量名称、函数声明、形参，等等。当一个函数在其代码中引用的标识符不是本地变量（函数或形参），那么这个标识符就称为<em>自由变量</em>，查找这些自由变量时就需要用到作用域链。</p><p>在通常情况下，一条作用域链就是所有父级变量对象（VO）加上（作用域链头部的）函数自身的变量对象/活动对象（VO/AO）。但是，这个作用域链也可以包含任何其他对象，比如，在上下文执行过程中动态加入到作用域链中的对象－像 <code>with</code> 对象或者特殊的 <code>catch</code> 从句（catch-clauses）对象。</p><p>当解析（查找）一个标识符的时候，会从作用域链中的活动对象开始查找，然后（如果这个标识符在函数自身的活动对象中没有被查找到）向作用域链的上一层查找 － 重复这个过程，就和原型链一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</div><div class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> z = <span class="number">30</span>;</div><div class="line">    <span class="comment">// "x" 和 "y" 是自由变量，在作用域链的</span></div><div class="line">    <span class="comment">// 上层对象（bar 的活动对象之后）中查找</span></div><div class="line">    <span class="built_in">console</span>.log(x + y + z);</div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>我们可以假设作用域链是通过隐藏属性 <code>__parent__</code> 连接起来的，该属性指向作用域链上的上一层对象。这可以在 Rhino 下用真实代码进行测试，并且这项技术已经用于 <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" target="_blank" rel="external">ES5 的词法分析环境</a>（在那里被叫作outer连接）。作用域链的另一种表现形式可以是一个简单的数组。利用 <code>__parent__</code> 的概念，我们可以用下图表示上面的自理（并且父变量对象存储在函数的[[Scope]]属性中）：</p><p><img src="http://bubkoo.qiniudn.com/scope-chain.png" alt="图 9. 作用域链"> </p><p>在代码执行过程中，使用 <code>with</code> 语句和 <code>catch</code> 从句对象来扩大作用域链。并且由于这些对象是简单的对象，他们也会有原型链。这使作用域链查找变为两个维度：（1）首先是作用域链，然后（2）在每个连接点，深入到连接点的原型链中（如果此链接有原型）。</p><p>看下面例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> w = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> y = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="comment">// 在 SpiderMonkey 中，全局对象，即全局上下文中的变量对象</span></div><div class="line"><span class="comment">// 继承自 "Object.prototype"，所以我们可以访问到 “并没有</span></div><div class="line"><span class="comment">// 定义的全局变量 x”，这是在原型链中找到的。</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// "foo" local variables</span></div><div class="line">  <span class="keyword">var</span> w = <span class="number">40</span>;</div><div class="line">  <span class="keyword">var</span> x = <span class="number">100</span>;</div><div class="line"></div><div class="line">  <span class="comment">// "x" 在 "Object.prototype" 中查找到，</span></div><div class="line">  <span class="comment">// 因为 &#123;z: 50&#125; 继承自 "Object.prototype"</span></div><div class="line">  </div><div class="line">  <span class="keyword">with</span> (&#123;<span class="attr">z</span>: <span class="number">50</span>&#125;) &#123;</div><div class="line">    <span class="built_in">console</span>.log(w, x, y , z); <span class="comment">// 40, 10, 30, 50</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 当 "with" 对象从作用域链中移除后，</span></div><div class="line">  <span class="comment">// "x" 又成为 "foo" 上下文中的活动对象（AO）的属性。</span></div><div class="line">  <span class="comment">// 变量 "w" 仍然是本地的</span></div><div class="line">  <span class="built_in">console</span>.log(x, w); <span class="comment">// 100, 40</span></div><div class="line"></div><div class="line">  <span class="comment">// 在浏览器环境中，下面展示了如何引用全局变量</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.w); <span class="comment">// 20</span></div><div class="line"></div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>我们就会有如下的结构（确切的说，在我们查找<strong>parent</strong>连接之前，首先查找<strong>proto</strong>链）：</p><p><img src="http://bubkoo.qiniudn.com/scope-chain-with.png" alt="图 10. with 增大的作用域链"></p><p>注意，不是在所有的实现中全局对象都是继承自 <code>Object.prototype</code>。上图中描述的行为（从全局上下文中引用「未定义」的变量 <code>x</code>）可以在诸如 SpiderMonkey 引擎中进行测试。</p><p>只要所有父变量对象都存在，那么从内部函数引用外部数据则没有特别之处 – 我们只要遍历作用域链去解析（搜寻）需要的变量。然而，如上文所提及，当一个上下文终止之后，其状态与自身将会被销毁，同时父函数可能会返回一个内部函数。而且，这个返回的函数之后可能在另一个上下文中被调用。如果自由变量的上下文已经「消失」了，那么这样的调用将会发生什么？通常来说，有一个概念可以帮助我们解决这个问题，叫作（词法）闭包，其在 ECMAScript 中就是和作用域链的概念紧密相关的。</p><h2><span id="闭包">闭包</span></h2><p>在 ECMAScript 中，函数是一等（first-class）对象。这个术语意味着函数可以做为参数传递给其他函数（在那种情况下，这些参数叫作「<em>函数类型参数</em>」（<em>funargs</em>，是”functional arguments”的简称））。接收「函数类型参数」的函数叫作<em>高阶函数</em>或者，贴近数学一些，叫作<em>高阶操作符</em>。同样函数也可以从其他函数中返回。返回其他函数的函数叫作<em>以函数为值的函数</em>（或者叫作<em>拥有函数类值的函数</em>）。</p><p>有两个在概念上与「函数类型参数（funargs）」和「函数类型值」相关的问题。并且这两个子问题在”Funarg 问题”（或者叫作”中很普遍。为了解决整个”Funarg 问题”，闭包（closure）的概念被创造了出来。我们详细的描述一下这两个子问题（我们将会看到这两个问题在 ECMAScript 中都是使用图中所提到的函数的 <code>[[Scope]]</code> 属性来解决的）。</p><p>funarg 的第一个问题是「向上 funarg 问题」。它会在当一个函数从另一个函数向上返回（到外层）并且使用上面所提到的自由变量的时候出现。为了在即使父函数上下文结束的情况下也能访问其中的变量，内部函数在被创建的时候会在它的 <code>[[Scope]]</code> 属性中保存父函数的作用域链。所以当函数被调用的时候，它上下文的作用域链会被格式化成活动对象与 <code>[[Scope]]</code> 属性的和（实际上就是我们刚刚在上图中所看到的）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Scope chain = Activation object + [[Scope]]</div><div class="line">作用域链 = 活动对象 + [[Scope]]</div></pre></td></tr></table></figure><p>请注意，最主要的事情是——函数在被创建时保存外部作用域，是因为这个被保存的作用域链将会在未来的函数调用中用于变量查找。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// "foo"返回的也是一个函数</span></div><div class="line"><span class="comment">// 并且这个返回的函数可以随意使用内部的变量x</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> returnedFunction = foo();</div><div class="line"></div><div class="line"><span class="comment">// 全局变量 "x"</span></div><div class="line"><span class="keyword">var</span> x = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// 执行返回的函数</span></div><div class="line">returnedFunction(); <span class="comment">// 结果是10而不是20</span></div></pre></td></tr></table></figure><p>这种形式的作用域称为静态作用域（词法作用域）。上面的 <code>x</code> 变量就是在函数 <code>bar</code> 的 <code>[[Scope]]</code> 中搜寻到的。理论上来说，也会有动态作用域，也就是上述的 <code>x</code> 被解释为 <code>20</code>，而不是 <code>10</code>。但是 EMCAScript 不使用动态作用域。</p><p>funarg 的第二个问题是「向下 funarg 问题」。在这种情况下，由于存在父级上下会，在判断一个变量值的时候会有多义性。也就是，这个变量究竟应该使用哪个作用域？是在函数创建时的作用域呢，还是在执行时的作用域呢？为了避免这种多义性，可以采用闭包，也就是使用静态作用域。</p><p>请看下面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局变量 "x"</span></div><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">// 全局function</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">funArg</span>) </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">// 局部变量 "x"</span></div><div class="line"><span class="keyword">var</span> x = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// 这不会有歧义</span></div><div class="line"><span class="comment">// 因为我们使用"foo"函数的[[Scope]]里保存的全局变量"x",</span></div><div class="line"><span class="comment">// 并不是caller作用域的"x"</span></div><div class="line"></div><div class="line">  funArg(); <span class="comment">// 10, 而不是20</span></div><div class="line"></div><div class="line">&#125;)(foo); <span class="comment">// 将foo作为一个"funarg"传递下去</span></div></pre></td></tr></table></figure><p>我们可以断定静态作用域是一门语言拥有闭包的必需条件。不过，在某些语言中，会提供动态和静态作用域的结合，可以允许开发员选择哪一种作用域。但是在 ECMAScript 中，只采用了静态作用域。所以结论是：ECMAScript 完全支持闭包，技术上是通过函数的 <code>[[Scope]]</code> 属性实现的。现在我们可以给闭包下一个准确的定义：</p><blockquote><p>闭包是一个代码块（在 ECMAScript 是一个函数）和以静态方式/词法方式进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到自由变量。</p></blockquote><p>注意，由于每个（标准的）函数都在创建的时候保存了 <code>[[Scope]]</code>，所以理论上来讲，ECMAScript 中的所有函数都是闭包。</p><p>另一个需要注意的重要事情是，多个函数可能拥有相同的父作用域（这是很常见的情况，比如当我们拥有两个内部/全局函数的时候）。在这种情况下，<code>[[Scope]]</code> 属性中存储的变量是在拥有相同父作用域链的所有函数之间共享的。一个闭包对变量进行的修改会体现在另一个闭包对这些变量的读取上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    foo: <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> ++x; &#125;,</div><div class="line">    bar: <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> --x; &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> closures = baz();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(</div><div class="line">  closures.foo(), <span class="comment">// 2</span></div><div class="line">  closures.bar()  <span class="comment">// 1</span></div><div class="line">);</div></pre></td></tr></table></figure><p>以上代码可以通过下图进行说明：</p><p><img src="http://bubkoo.qiniudn.com/shared-scope.png" alt="图 11. 共享的[[Scope]]"></p><p>这个特性在循环中创建多个函数的时候会使人非常困惑。在创建的函数中使用循环计数器的时候，一些程序员经常会得到非预期的结果，所有函数中的计数器都是同样的值。现在是到了该揭开谜底的时候了 －- 因为所有这些函数拥有同一个 <code>[[Scope]]</code>，这个属性中的循环计数器的值是最后一次所赋的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</div><div class="line">  data[k] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(k);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">data[<span class="number">0</span>](); <span class="comment">// 3, but not 0</span></div><div class="line">data[<span class="number">1</span>](); <span class="comment">// 3, but not 1</span></div><div class="line">data[<span class="number">2</span>](); <span class="comment">// 3, but not 2</span></div></pre></td></tr></table></figure><p>有几种技术可以解决这个问题。其中一种是在作用域链中提供一个额外的对象。比如，使用额外函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</div><div class="line">  data[k] = (<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      alert(x);</div><div class="line">    &#125;;</div><div class="line">  &#125;)(k); <span class="comment">// pass "k" value</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// now it is correct</span></div><div class="line">data[<span class="number">0</span>](); <span class="comment">// 0</span></div><div class="line">data[<span class="number">1</span>](); <span class="comment">// 1</span></div><div class="line">data[<span class="number">2</span>](); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>对闭包理论和它们的实际应用感兴趣的同学可以在<a href="http://bubkoo.com/2014/06/15/ecma-262-3-in-detail-chapter-6-closures/">第六章 闭包</a>中了解更多细节。如果想获取更多关于作用域链的信息，可以看一下<a href="http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-4-scope-chain/">第四章 作用域链</a>。</p><p>继续下个部分，讨论一下执行上下文的最后一个属性。这就是关于 <code>this</code> 值的概念。</p><h2><span id="this">This</span></h2><blockquote><p><code>this</code> 是一个与执行上下文密切相关的特殊对象，因此，它可以称为上下文对象（context object），也就是用来指明执行上下文是在哪个上下文中被触发的对象。</p></blockquote><p>任何对象都可以做为上下文中的 <code>this</code> 的值。我想再一次澄清，一些对 ECMAScript 执行上下文特别是 <code>this</code> 的值的误解。<code>this</code> 经常被错误地描述为变量对象的一个属性，这类错误存在于比如像这<a href="http://yuiblog.com/assets/High_Perf_JavaScr_Ch2.pdf" target="_blank" rel="external">本书中</a>（即便如此，这本书的相关章节还是十分不错的）。在重复一次：</p><blockquote><p><code>this</code> 是执行上下文的一个属性，而不是变量对象的属性。</p></blockquote><p>这个特性非常重要，因为与变量相反，<code>this</code> 从不会参与到标识符解析过程。换句话说，在代码中当访问 <code>this</code> 的时候，它的值是直接从执行上下文中获取的，并不需要任何作用域链查找。<code>this</code> 的值只在进入上下文的时候进行一次确定。</p><p>顺便说一下，与 ECMAScript 相反，比如，Python 的方法都会拥有一个被当作简单变量的 <code>self</code> 参数，这个变量的值在各个方法中是相同的，并且在执行过程中可以被更改成其他值。在 ECMAScript 中，给 <code>this</code> 赋一个新值是不可能的，因为，再重复一遍，它不是一个变量并且不存在于变量对象中。</p><p>在全局上下文中，<code>this</code> 就等于全局对象本身（这意味着，这里的 <code>this</code> 等于变量对象）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(</div><div class="line">  x,        <span class="comment">// 10</span></div><div class="line">  <span class="keyword">this</span>.x,   <span class="comment">// 10</span></div><div class="line">  <span class="built_in">window</span>.x  <span class="comment">// 10</span></div><div class="line">);</div></pre></td></tr></table></figure><p>在函数上下文的情况下，对函数的每次调用，其中的 <code>this</code> 值可能是不同的。这个 <code>this</code> 值是通过函数调用表达式（也就是函数被调用的方式）的形式由 caller 所提供的。举个例子，下面的函数 <code>foo</code> 是一个 callee，在全局上下文中被调用，此上下文为 caller。让我们通过例子看一下，对于一个代码相同的函数，<code>this</code> 值是如何在不同的调用中（函数触发的不同方式），由 caller 给出不同的结果的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数 foo 的代码从未改变，但是 this 的值在每次调用时都不一样</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// caller 激活 "foo" (callee) 并为 callee 提供 this 的值</span></div><div class="line"></div><div class="line">foo(); <span class="comment">// 全局对象</span></div><div class="line">foo.prototype.constructor(); <span class="comment">// foo.prototype</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = &#123;</div><div class="line">  baz: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line">bar.baz(); <span class="comment">// bar</span></div><div class="line"></div><div class="line">(bar.baz)(); <span class="comment">// also bar</span></div><div class="line">(bar.baz = bar.baz)(); <span class="comment">// but here is global object</span></div><div class="line">(bar.baz, bar.baz)();  <span class="comment">// also global object</span></div><div class="line">(<span class="literal">false</span> || bar.baz)();  <span class="comment">// also global object</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> otherFoo = bar.baz;</div><div class="line">otherFoo(); <span class="comment">// again global object</span></div></pre></td></tr></table></figure><p>为了深入理解 <code>this</code> 为什么（或者更本资一点来说，是如何）在每个函数调用中可能会发生变化，你可以阅读<a href="http://bubkoo.com/2014/06/01/ecma-262-3-in-detail-chapter-3-this/">第三章 This</a>。在那里，对上面所提到的情况都会有详细的讨论。</p><h2><span id="总结">总结</span></h2><p>在此我们完成了一个简短的概述。尽管看来不是那么简短，但是这些话题若要完整表述完毕，则需要一整本书。我们没有提及两个重要话题：函数（以及不同类型的函数之间的不同，比如函数声明与函数表达式）与 ECMAScript 的求值策略（evaluation strategy） 。这两个话题可以分别查阅本系列教程<a href="http://" target="_blank" rel="external">第五章 函数</a>与<a href="http://" target="_blank" rel="external">第八章 求值策略（evaluation strategy）</a>。</p><p>如果你有留言，问题或者补充，我将会很乐意地在评论中讨论它们。</p><p>祝学习ECMAScript好运！</p><p class="j-dot"><strong>Written by:</strong> Dmitry A. Soshnikov<br><strong>Published on:</strong> 2010-09-02</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文译自 &lt;a href=&quot;http://dmitrysoshnikov.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dmitry A. Soshnikov&lt;/a&gt; 的 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/javascript-the-core/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript. The core.&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;本文是&lt;a href=&quot;http://dmitrysoshnikov.com/tag/ecma-262-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;详解 ECMA-262-3 系列&lt;/a&gt;的概述和总结。每个部分都包含对应章节的连接，所以你可以阅读它们以获得更深入的了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标阅读者&lt;/strong&gt;：有经验的程序员，专业人士。&lt;/p&gt;
&lt;p&gt;我们从对象的概念开始，这是 ECMAScript 的根本。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="ECMAScript" scheme="http://bubkoo.com/tags/ecmascript/"/>
    
      <category term="ECMA-262-3" scheme="http://bubkoo.com/tags/ecma-262-3/"/>
    
  </entry>
  
  <entry>
    <title>面向切面编程（AOP）简介</title>
    <link href="http://bubkoo.com/2014/05/08/intro-to-aspect-oriented-programming/"/>
    <id>http://bubkoo.com/2014/05/08/intro-to-aspect-oriented-programming/</id>
    <published>2014-05-08T16:30:37.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文连接：<a href="http://know.cujojs.com/tutorials/aop/intro-to-aspect-oriented-programming" target="_blank" rel="external">Intro to Aspect Oriented Programming</a></p><p>本文简单地介绍了 AOP 的原理，以及 AOP 与其他方式的异同，并没有涉及太多的复杂逻辑，另外推荐下面两篇文章，这些文章中都间接或直接提及了 AOP：</p><ul><li><a href="http://www.alloyteam.com/2013/08/yong-aop-gai-shan-javascript-dai-ma/" target="_blank" rel="external">用 AOP 改善 JavaScript 代码</a></li><li><a href="http://www.ibm.com/developerworks/cn/web/wa-lo-jshttp/index.html" target="_blank" rel="external">使用 JavaScript 拦截和跟踪浏览器中的 HTTP 请求</a></li></ul><p>面向切面编程（AOP）是一种非侵入式扩充对象、方法和函数行为的技术。通过 AOP 可以从“外部”去增加一些行为，进而合并既有行为或修改既有行为。</p><p>虽然有很多技术可以用来增加和合并行为，例如继承、组合、委托，然而，在很多情况下，AOP 被证明是更灵活和更少侵入的方式，非常值得将其纳入我们的工具箱中。<br><a id="more"></a><br>我们先通过一个简单的例子，来了解它是如何工作的。</p><p>假设，在我们的代码中包含如下一个简单类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">Thing.prototype.doSomething = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result;</div><div class="line"></div><div class="line">    <span class="comment">// compute some result using x and y</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>然后，在我们的程序中的许多部位使用了上面的类的实例，代码看起来像下面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line"></div><div class="line"><span class="comment">// some time later, and possibly even in</span></div><div class="line"><span class="comment">// another part of the application</span></div><div class="line"><span class="keyword">var</span> result = thing.doSomething(x, y);</div></pre></td></tr></table></figure><h2><span id="增加行为">增加行为</span></h2><p>现在，假设我们怀疑 <code>Thing.prototype.doSomething</code> 是导致性能问题的根源，我们想要跟踪记录该方法的输入参数 <code>x</code> 和 <code>y</code>、计算 <code>result</code> 所花费的时间，以及 <code>result</code> 的值。</p><h3><span id="修改所有调用点">修改所有调用点</span></h3><p>有一条捷径就是在 <code>Thing.prototype.doSomething</code> 被调用的每个位置进行日志记录，像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = thing.doSomething(x, y);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log((<span class="built_in">Date</span>.now() - start) + <span class="string">'ms'</span>, x, y, result);</div></pre></td></tr></table></figure><p>很明显，如果 <code>Thing.prototype.doSomething</code> 在很多位置被调用，这意味着将进行很多次的复制、粘贴。你可能会遗漏某些位置，更糟糕的是，在收集到数据后，可能忘记将某些位置的代码移除。</p><h3><span id="修改源代码">修改源代码</span></h3><p>另一条途径就是修改 <code>Thing</code> 的源代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Thing.prototype.doSomething = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</div><div class="line"></div><div class="line">    <span class="comment">// compute some result using x and y</span></div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log((<span class="built_in">Date</span>.now() - start) + <span class="string">'ms'</span>, x, y, result);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>尽管这样做只需要修改一个位置，但具有相当的入侵性：需要修改 <code>Thing</code> 的源代码。想象一下，如果 <code>Thing.prototype.doSomething</code> 的源码更加复杂，包含多处 <code>return</code> 和一些 <code>try/catch/finally</code> 块。在不改变方法的行为的同时，收集到所需要的数据，代码修改起来并不是那么容易。</p><p>如果你也想使用类似的方式来分析其他方法，你也将不得不修改他们的源代码。</p><h2><span id="使用继承">使用继承</span></h2><p>使用继承可以避免修改 <code>Thing</code> 的源代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfiledThing</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    Thing.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ProfiledThing.prototype = <span class="built_in">Object</span>.create(Thing.prototype);</div><div class="line"></div><div class="line">ProfiledThing.prototype.doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result = Thing.prototype.doSomething.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log((<span class="built_in">Date</span>.now() - start) + <span class="string">'ms'</span>, x, y, result);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种方式避免了修改 <code>Thing</code> 的源代码，但有一个显著的问题：需要将使用 <code>new Thing()</code> 的每一个位置修改为 <code>new ProfiledThing()</code></p><p>有一些方法可以缓解这个问题，但是现在可以清晰地知道我们需要一个更好的方式。</p><h2><span id="关注分离">关注分离</span></h2><p>这个分析行为的一个有趣特点是，它与 <code>Thing</code> 的原本目的无关，它是一个额外的功能。<code>Thing</code> 很可能是为了解决特定领域的特定问题而创建，上面的那些解决方案都将一些无关行为引入到 <code>Thing</code> 中。</p><p><code>Thing</code> 只需要完成自身的工作而不需要关心任何与分析相关的工作，但以上的解决方案都迫使分析工作与 <code>Thing</code> 的本质工作直接关联在一起。</p><p>我们需要一种技术，以一种可控的、非侵入式的方式来引入这类行为。也就是说，这种方式能够有力保障 <code>Thing</code> 的行为，并且不需要我们修改 <code>Thing</code> 的源代码，或者使用 <code>Thing</code> 的位置的源代码。</p><h2><span id="引入-aop">引入 AOP</span></h2><p>正如之前描述的那样，AOP 是一种非侵入的增加对象行为的方式。在 JavaScript，这非常简单，甚至不需要使用任何工具或库就能实现 AOP，但它非常实用，就像其他工具或库帮助你构建可复用的模式一样。</p><p>如果你曾经写过下面这样的代码，那么你已经在 JavaScript 中实现了 AOP：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> origDoSomething = thing.doSomething;</div><div class="line"></div><div class="line"><span class="comment">// Method replacement is a simple form of AOP</span></div><div class="line">thing.doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    doSomethingElseFirst();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> origDoSomething.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这有效地为 <code>thing.doSomething</code> 增加了行为。现在，调用 <code>thing.doSomething</code> 时，将首先调用 <code>doSomethingElseFirst</code>，然后再执行原来的行为。</p><p>从 AOP 的角度，我们可以说 <code>doSomethingElseFirst</code> 是应用于 <code>thing.doSomething</code> 的一个行为切面。确切地讲，<code>doSomethingElseFirst</code> 被称作“before advice”，也就是说，我们使 <code>thing.doSomething</code> 在执行原来的行为之前执行 <code>doSomethingElseFirst</code>。AOP 通常可以实现多种类型，比如 <code>before</code>、<code>after</code>、<code>afterReturning</code>、<code>afterThrowing</code> 和 <code>around</code>。</p><p>对于上面简单的例子，有几个重点需要注意：</p><ul><li><code>Thing</code> 的源代码没有被修改</li><li><code>Thing</code> 的使用方无需修改调用代码</li><li><code>doSomething</code> 的原本行为得以保留</li><li><code>Thing</code> 并不知道 <code>doSomethingElseFirst</code> 的存在，并且不依赖它。因此，<code>Thing</code> 的单元测试也不需要更新。当然，我们需要为 <code>doSomethingElseFirst</code> 编写单元测试，除此之外，没有其他的代码需要测试用例。</li></ul><h2><span id="aop-应用示例">AOP 应用示例</span></h2><p>我们用 AOP 的方式来给 <code>Thing</code> 增加分析行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> origDoSomething = Thing.prototype.doSomething;</div><div class="line"></div><div class="line">Thing.prototype.doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result = origDoSomething.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log((<span class="built_in">Date</span>.now() - start) + <span class="string">'ms'</span>, x, y, result);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们再次使用了方法替换的技术，只是这次替换的是 <code>Thing</code> 原型上的方法罢了。所有 <code>Thing</code> 的实例都拥有了这个新的，包含分析行为的 <code>doSomething</code> 方法了。这种类型的 AOP 称作“around”，因为在原来行为之前和之后都做了某些事情。</p><p>尽管这与上面的继承方式看起来非常像，但有一个非常重要的不同点：我们没有引入新的构造函数，因此 <code>Thing</code> 的调用方无需修改代码。</p><h2><span id="aop-实践">AOP 实践</span></h2><p>上面通过非侵入式地为原型上的单个方法添加分析行为，简单地演示了 AOP 在 JavaScript 中可以方便地应用，不仅如此，该技术还可以应用于更复杂更有趣的事情，例如：</p><ul><li>收集整个应用的分析数据</li><li>跟踪程序的执行过程来可视化调用栈</li><li>自动重新执行失败的异步 I/O，如 XHR 或数据库查询</li><li>在应用程序中以松散耦合的方式连接合作组件，而不是使用事件机制或 Pub/Sub</li></ul><p>在后面的教程中，我们将看到更多的关于如何应用 AOP 的例子，以及它的适用场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文连接：&lt;a href=&quot;http://know.cujojs.com/tutorials/aop/intro-to-aspect-oriented-programming&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intro to Aspect Oriented Programming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文简单地介绍了 AOP 的原理，以及 AOP 与其他方式的异同，并没有涉及太多的复杂逻辑，另外推荐下面两篇文章，这些文章中都间接或直接提及了 AOP：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.alloyteam.com/2013/08/yong-aop-gai-shan-javascript-dai-ma/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用 AOP 改善 JavaScript 代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/web/wa-lo-jshttp/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用 JavaScript 拦截和跟踪浏览器中的 HTTP 请求&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面向切面编程（AOP）是一种非侵入式扩充对象、方法和函数行为的技术。通过 AOP 可以从“外部”去增加一些行为，进而合并既有行为或修改既有行为。&lt;/p&gt;
&lt;p&gt;虽然有很多技术可以用来增加和合并行为，例如继承、组合、委托，然而，在很多情况下，AOP 被证明是更灵活和更少侵入的方式，非常值得将其纳入我们的工具箱中。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="AOP" scheme="http://bubkoo.com/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>前端跨域通信解决方案</title>
    <link href="http://bubkoo.com/2014/04/22/improve-cross-domain-communication-with-client-side-solutions/"/>
    <id>http://bubkoo.com/2014/04/22/improve-cross-domain-communication-with-client-side-solutions/</id>
    <published>2014-04-22T17:45:48.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>此类文章在社区中一抓一大把，但为什么还要来翻译这篇文章呢？最主要的原因是本章的配图太好了，一看就懂，扯远了。。</p><p>原文：<a href="http://www.ibm.com/developerworks/library/wa-crossdomaincomm/" target="_blank" rel="external">Improve cross-domain communication with client-side solutions</a></p><h2><span id="介绍">介绍</span></h2><p>越来越多的网站需要相互协作。例如，一个在线房屋租赁网站需要谷歌地图的支持，以显示某个出租屋的位置。为了满足这种需求，出现了各种各样的聚合应用（mashup）。聚合应用是一种将来自不同供应商的数据或组件整合在一起，使其更有价值或更加可定制化的 Web 应用。聚合应用或协作能力，被认为是 Web 2.0 的一个重要组成部分</p><p>但是，要将异步 AJAX 和聚合应用结合在一起并不是那么容易，由于浏览器的安全限制，页面上不同组件之间的通信也难以做到。传统的解决方案是，在服务器上设置一个代理，但这种方式的伸缩性不大。在本文中，你可以了解到一些客户端的跨域通信和数据传输的解决方案。</p><h2><span id="安全限制">安全限制</span></h2><p>同源策略（SOP）将阻止从一个源加载的脚本去操作另一个源的数据或方法，<em>同源</em>要求脚本的域名、协议和端口都相同，你可能会误解同源策略，它不仅仅意味着站点 A 不允许从站点 B 获取信息，你需要知道在同源策略下能做什么和不能做什么。</p><h2><span id="同源策略的限制">同源策略的限制</span></h2><p>例如，A 源中的页面可以：</p><ul><li>从 B 源获取脚本、样式和图片文件</li><li>使用 <code>iframe/frame</code> 嵌入指向 B 源的页面</li><li>通过 HTML 元素（如 <code>iframe</code> 或 <code>img</code>）的 <code>src</code> 属性，向 B 源发送信息</li></ul><p>A 源中的页面不能：</p><ul><li>向 B 源发送 AJAX 请求</li><li>读取或操作通过 <code>iframe/frame</code> 嵌入的 B 源页面的内容</li></ul><p>为什么会这样？主要是为了保护用户的重要信息。假设，一个用户正在访问某个网站，他不希望提交到该网站的任何信息被泄露给其他网站。这种限制限制了网站之间的合作，但可以保护用户免受潜在的恶意攻击。</p><p>接下来的章节将讨论跨域通信和数据传输的客户端解决方案。每一种解决方案都有优缺点，应用场景在很大程度上影响你的选择。<br><a id="more"></a></p><h2><span id="子域名跨域解决方案-cross-subdomain-solution">子域名跨域解决方案 Cross-subdomain solution</span></h2><p>如果 A 源和 B 源具有相同的父域名，通过设置 <code>document.domain</code> 属性，就很容易使其相互通信。在 HTML 规范中 <code>document.domain</code> 是一个只读属性，现代浏览器允许将其设置为父域名（不是顶级域名）。例如，一个 URL 是 <code>www.myapp.com/index.html</code> 的页面，可以设置为 <code>myapp.com</code>，而另一个来自 <code>sample.myapp.com/index2.html</code> 的页面也可以设置为 <code>myapp.com</code>，图 1 展示了 <code>document.domain</code> 的工作原理：</p><p><img src="http://bubkoo.qiniudn.com/cross-subdomain-solution.gif" alt="图 1. document.domain"></p><p>通过将不同子域名的 <code>document.domain</code> 属性设置为相同的父域名，来实现不同子域名之间的跨域通信，这并不属于同源策略限制的范畴。但是，严格来说，子域名跨域的解决方案最适用于内部应用之间的跨域通信。</p><h2><span id="urlhash-解决方案">URL.hash 解决方案</span></h2><p>一个 URL 由几部分组成，如图 2 所示：</p><p><img src="http://bubkoo.qiniudn.com/components-of-a-URL.gif" alt="图 2. Components of a URL"></p><p>一般来说，URL 的任何改变都重新会加载一个新的网页，除了 <code>hash</code> 的变化，<code>hash</code> 的任何改变都不会导致页面刷新。<code>hash</code> 已经被广泛使用在支持局部刷新的 Web 2.0 单页应用中，用来记录用户的访问路径。在跨域解决方案中，<code>hash</code> 也非常有用，来自不同源的页面可以相互设置对方的 URL，包括 <code>hash</code> 值，但仍被限制获取对方的 <code>hash</code> 值。文档之间可以通过 <code>hash</code> 来相互通信。如图 3 中的例子：</p><p><img src="http://bubkoo.qiniudn.com/communication-using-URL.hash.gif" alt="图 3. Communication using URL.hash(fragment id)"></p><p>在图 3 中，如果 A 想给 B 发送消息，可以通过修改 B 的 <code>hash</code> 值，代码如下：</p><figure class="highlight javascript"><figcaption><span>通过 url.hash 发送消息</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params">originURL, msg</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> data = &#123;<span class="attr">from</span>:originURL, <span class="attr">msg</span>:msg&#125;;</div><div class="line">var src = originURL + “#” + dojo.toJson(data);</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'domainB'</span>).src=src;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>B 页面将轮询自身的 <code>hash</code> 值，获取到 A 页面发出的消息。B 也可以用同样的方式回复 A，如果 A 也希望能接受到 B 的消息，也需要轮询自身的 <code>hash</code> 值。</p><figure class="highlight javascript"><figcaption><span>轮询 url.hash 并从其中获取信息</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.oldHash=<span class="string">""</span>;</div><div class="line">checkMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> newHash = <span class="built_in">window</span>.location.hash;</div><div class="line"><span class="keyword">if</span>(newHash.length &gt; <span class="number">1</span>)&#123;</div><div class="line">newHash = newHash.substring(<span class="number">1</span>,newHash.length);</div><div class="line"><span class="keyword">if</span>(newHash != oldHash)&#123;</div><div class="line"> oldHash = newHash;</div><div class="line"> <span class="keyword">var</span> msgs = dojo.fromJson(newHash);</div><div class="line"> <span class="keyword">var</span> origin = msgs.from;</div><div class="line"> <span class="keyword">var</span> msg = msgs.msg;</div><div class="line">  sendMessage(origin, <span class="string">"Hello document A"</span>);</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.setInterval(checkMessage, <span class="number">1000</span>);</div><div class="line">sendMessage = <span class="function"><span class="keyword">function</span>(<span class="params">target, msg</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> hash = <span class="string">"msg="</span>+ msg;</div><div class="line">parent.location.href= target + “#” + hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>和 JSONP 一样，这种方式发送的消息有长度限制，但它可以更好地处理错误。一些特殊的字符，如问号(?)，是 URL 的保留字符，应该先进行编码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params">originURL, msg</span>)</span>&#123;</div><div class="line">…</div><div class="line">var src = originURL + “#” + encodeURI (dojo.toJson(data));</div><div class="line">…</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同时，接受到消息时，需要进行解密操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMsg</span>(<span class="params"></span>)</span>&#123;</div><div class="line">…</div><div class="line"><span class="keyword">var</span> msgs = <span class="built_in">decodeURI</span>(dojo.fromJson(newHash)); </div><div class="line">…</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="cross-fragment-技术">Cross-fragment 技术</span></h3><p>由于许多网站的 <code>hash</code> 已经被用于其他用途，对于这样的网站用 <code>hash</code> 跨域将非常复杂（需要从 <code>hash</code> 中合并和分离出消息）。图 4 是 cross-fragment 的原理：</p><p><img src="http://bubkoo.qiniudn.com/cross-fragment-technique.gif" alt="图 4. Cross-fragment technique"></p><p>当 A 想与 <code>iframe</code> 中的 B 通信，它首先将在 A 页面中新创建一个 <code>iframe</code>，这个 <code>iframe</code> 指向一个与 B 同域名的“代理”页面 C，C 页面的 URL 将包含将要发送的数据和 B 所在 <code>iframe</code> 的 ID。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params">msg</span>)</span>&#123;</div><div class="line">   <span class="keyword">var</span> frame = <span class="built_in">document</span>.createElement(“iframe”);</div><div class="line">   <span class="keyword">var</span> baseProxy = “http:<span class="comment">//www.otherapp.com/proxy.html”;</span></div><div class="line">   <span class="keyword">var</span> request = &#123;<span class="attr">frameName</span>:’otherApp’,<span class="attr">data</span>:msg&#125;;</div><div class="line">   frame.src = baseProxy+”#”+encodeURI (dojo.toJson(request));</div><div class="line">   frame.style.display=”none”;</div><div class="line">   <span class="built_in">document</span>.body.appendChild(frame);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当 C 加载完成后，它将获取到 A 发送的消息，然后调用 B 页面中对应的方法，由于 B 和 C 是相同域名，通过获取到对方的 window对象，他们可以直接调用对方的方法。这样，A 就成功将消息发送至 B，B 也可以以同样的方式回复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onLoad = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">var</span> hash = <span class="built_in">window</span>.location.hash;</div><div class="line">     <span class="keyword">if</span>(hash &amp;&amp; hash.length&gt;<span class="number">1</span>)&#123;</div><div class="line">          <span class="keyword">var</span> request = hash.substring(<span class="number">1</span>,hash.length);</div><div class="line">          <span class="keyword">var</span> obj = dojo.fromJson(<span class="built_in">decodeURI</span> (request));</div><div class="line">          <span class="keyword">var</span> data = obj.data;</div><div class="line">          <span class="comment">//process data</span></div><div class="line">          parent.frames[obj.frameName].getData(…);<span class="comment">// getData in a function defined in B</span></div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="实施-openajax">实施 OpenAjax</span></h3><p>OpenAjax 提供管理中心模块，以支持基于文档 ID 的跨域通信解决方案，管理中心模块包括管理端和客户端，管理中心包含一个消息中心来储存消息。如果一个组件想要与其他组件通信，首先需要创建一个通信客户端，并相应创建一个与之相连的 <code>iframe</code> 容器。容器将代表客户端与管理中心通信。客户端用发布/订阅的机制来发送和接受消息。OpenAjax 的工作流程如图 5 所示。</p><p><img src="http://bubkoo.qiniudn.com/main-workflow-for-OpenAjax.gif" alt="图 5. Main workflow for OpenAjax"></p><h2><span id="windowname-解决方案">Window.name 解决方案</span></h2><p><code>Window.name</code> 跨域是一个巧妙的解决方案，一般情况下，我们使用 <code>Window.name</code> 的情况如下：</p><ul><li>使用window.frames[windowName]得到一个子窗口</li><li>将其设置为链接元素的target属性</li></ul><p>加载任何页面 <code>Window.name</code> 的值始终保持不变。由于 <code>Window.name</code> 这个显著的特点，使其适用于在不同源之间进行跨域通信，但这是个不常用的属性。那么怎么在同源策略下使用呢？图 6 显示了如何使用 <code>window.name</code> 来跨域通信。</p><p><img src="http://bubkoo.qiniudn.com/window.name-and-cross-domain-communication.gif" alt="图 6. window.name and cross-domain communication"></p><p>当页面 A 想要从另一个源获取资源或 Web 服务，首先在自己的页面上创建一个隐藏的 <code>iframe</code> B，将 B 指向外部资源或服务，B 加载完成之后，将把响应的数据附加到 <code>window.name</code> 上。由于现在 A 和 B 还不同源，A 依旧不能获取到 B 的 <code>name</code> 属性。当B 获取到数据之后，再将页面导航到任何一个与 A 同源的页面，这时 A 就可以直接获取到 B 的 <code>name</code> 属性值。当 A 获取到数据之后，就可以随时删掉 B。</p><h3><span id="使用-dojoxiowindowname-跨域">使用 dojox.io.windowName 跨域</span></h3><p>Dojo 提供了基于 <code>window.name</code> 的跨域支持，唯一的 API 是 <code>dojox.io.windowName.send(method, args)</code>，这和 <code>dojo.xhrGet/dojo.xhrPost</code> 很相似。<code>method</code> 参数可以是 GET 或 POST，<code>args</code> 参数则与 <code>dojo.xhr</code> 中的类似。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> args = &#123;</div><div class="line"> url: <span class="string">"http://www.sample.com/testServlet?windowName=true"</span>,</div><div class="line"> load: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line"> alert(<span class="string">"You've got the data from server "</span> + data);</div><div class="line">    &#125;,</div><div class="line">error: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line"> alert(<span class="string">"Error occurred: "</span> + error);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">dojox.io.windowName.send(<span class="string">"GET"</span>,args);</div></pre></td></tr></table></figure><p>你可以和使用 <code>dojo.xhr</code> 相同的方式来使用 <code>dojox.io.windowName</code>。对于服务器端，如果想让资源或服务支持 <code>windowname</code> 的方式，建议你检查请求中的 <code>windowname</code> 参数，如果含有 <code>windowname</code> 参数，服务端应该返回一个 HTML 文档，该文档将把发送到客户端的数据设置到所在的 <code>window.name</code> 属性上。例如：</p><figure class="highlight java"><figcaption><span>testServlet.java:</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</div><div class="line"> <span class="comment">//process request</span></div><div class="line"> String returnData = ...;</div><div class="line"> String isWindowNameReq = request.getParameter(“windowName”);</div><div class="line"> <span class="keyword">if</span>(<span class="keyword">null</span> !=isWindowNameReq &amp;&amp; Boolean.parseBoolean(isWindowNameReq))&#123;</div><div class="line"> returnData = getCrossDomainStr(returnData);</div><div class="line">&#125;</div><div class="line"> response.getOutputStream().print(returnData);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getCrossDomainStr</span><span class="params">(String data)</span></span>&#123;</div><div class="line"> StringBuffer returnStr = <span class="keyword">new</span> StringBuffer();</div><div class="line"> returnStr.append(<span class="string">"&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;window.name='"</span>);</div><div class="line"> returnStr.append(data);</div><div class="line"> returnStr.append(<span class="string">"'&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"</span>);</div><div class="line"> <span class="keyword">return</span> returnStr.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当导航回同域的任何页面时，需要确保页面是存在的，在 IE 下，如果页面不存在将导致异常，在 Firefox 中，你可以简单使用 <code>blank.html</code>。在 Dojo 中，你需要通过 <code>dojo.dojoBlankHtmlUrl</code> 属性来指定回滚的页面，默认情况下，是 Dojo 库下面的 <code>dojo/resources/blank.html</code> 文件。</p><p>使用 <code>window.name</code> 传输的数据量要比 <code>url.hash</code> 大得多，大多数现代浏览器可以达到 16M+。</p><h2><span id="html5-新特性">HTML5 新特性</span></h2><p>在 HTML5 规范中，新方法 <code>window.postMessage(message, targetOrigin)</code> 可以用于安全跨域通信。当该方法被调用时，将分发一个消息事件，如果窗口监听了相应的消息，窗口就可以获取到消息和消息来源。如图 7 所示：</p><p><img src="http://bubkoo.qiniudn.com/cross-domain-communication-with-HTML5.gif" alt="图 7. Cross-domain communication with HTML5"></p><p>在 图 7 中，如果 <code>iframe</code> 想要通知不同源的父窗口它已经加载完成，可以使用 <code>window.postMessage</code> 来发送消息。同时，它也将监听回馈消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//www.otherapp.com/index.html</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">postMessage</span>(<span class="params">msg</span>)</span>&#123;</div><div class="line">     <span class="keyword">var</span> targetWindow = parent.window;</div><div class="line">      targetWindow.postMessage(msg,<span class="string">"*"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleReceive</span>(<span class="params">msg</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> object = dojo.fromJson(msg);</div><div class="line"> <span class="keyword">if</span>(object.status == “ok”)&#123;</div><div class="line"><span class="comment">//continue to do other things</span></div><div class="line">……</div><div class="line"> &#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="comment">//retry sending msg</span></div><div class="line">……</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, handleReceive, <span class="literal">false</span>);</div><div class="line"><span class="built_in">window</span>.onLoad = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    postMessage(<span class="string">"already loaded"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>父窗口监听了消息事件，当消息到达时，它首先检查消息是否是来 <code>www.otherapp.com</code>，如果是就发送一个反馈消息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//www.myapp.com/index.html</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleReceive</span>(<span class="params">event</span>)</span>&#123; </div><div class="line">    <span class="keyword">if</span>(event.origin != <span class="string">"http://www.otherapp.com"</span>)</div><div class="line">        <span class="keyword">return</span>; </div><div class="line">     <span class="comment">//process data</span></div><div class="line">     ……</div><div class="line">     <span class="keyword">var</span> otherAppFrame = <span class="built_in">document</span>.getElementById(“otherApp”) </div><div class="line">     otherAppFrame.postMessage(“&#123;<span class="attr">status</span>:’ok’&#125;”,”http:<span class="comment">//www.otherapp.com”);</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, handleReceive, <span class="literal">false</span>);</div></pre></td></tr></table></figure><p>上面的代码可以运行在 Firefox 3+、IE8 以上、Google Chrome 2、Opera 9+ 和 Safari 4 上。如果你的页面不想收到任何消息，就不要添加消息监听，进而忽略所有消息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此类文章在社区中一抓一大把，但为什么还要来翻译这篇文章呢？最主要的原因是本章的配图太好了，一看就懂，扯远了。。&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://www.ibm.com/developerworks/library/wa-crossdomaincomm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Improve cross-domain communication with client-side solutions&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;越来越多的网站需要相互协作。例如，一个在线房屋租赁网站需要谷歌地图的支持，以显示某个出租屋的位置。为了满足这种需求，出现了各种各样的聚合应用（mashup）。聚合应用是一种将来自不同供应商的数据或组件整合在一起，使其更有价值或更加可定制化的 Web 应用。聚合应用或协作能力，被认为是 Web 2.0 的一个重要组成部分&lt;/p&gt;
&lt;p&gt;但是，要将异步 AJAX 和聚合应用结合在一起并不是那么容易，由于浏览器的安全限制，页面上不同组件之间的通信也难以做到。传统的解决方案是，在服务器上设置一个代理，但这种方式的伸缩性不大。在本文中，你可以了解到一些客户端的跨域通信和数据传输的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;安全限制&quot;&gt;&lt;a href=&quot;#安全限制&quot; class=&quot;headerlink&quot; title=&quot;安全限制&quot;&gt;&lt;/a&gt;安全限制&lt;/h2&gt;&lt;p&gt;同源策略（SOP）将阻止从一个源加载的脚本去操作另一个源的数据或方法，&lt;em&gt;同源&lt;/em&gt;要求脚本的域名、协议和端口都相同，你可能会误解同源策略，它不仅仅意味着站点 A 不允许从站点 B 获取信息，你需要知道在同源策略下能做什么和不能做什么。&lt;/p&gt;
&lt;h2 id=&quot;同源策略的限制&quot;&gt;&lt;a href=&quot;#同源策略的限制&quot; class=&quot;headerlink&quot; title=&quot;同源策略的限制&quot;&gt;&lt;/a&gt;同源策略的限制&lt;/h2&gt;&lt;p&gt;例如，A 源中的页面可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 B 源获取脚本、样式和图片文件&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;iframe/frame&lt;/code&gt; 嵌入指向 B 源的页面&lt;/li&gt;
&lt;li&gt;通过 HTML 元素（如 &lt;code&gt;iframe&lt;/code&gt; 或 &lt;code&gt;img&lt;/code&gt;）的 &lt;code&gt;src&lt;/code&gt; 属性，向 B 源发送信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A 源中的页面不能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向 B 源发送 AJAX 请求&lt;/li&gt;
&lt;li&gt;读取或操作通过 &lt;code&gt;iframe/frame&lt;/code&gt; 嵌入的 B 源页面的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么会这样？主要是为了保护用户的重要信息。假设，一个用户正在访问某个网站，他不希望提交到该网站的任何信息被泄露给其他网站。这种限制限制了网站之间的合作，但可以保护用户免受潜在的恶意攻击。&lt;/p&gt;
&lt;p&gt;接下来的章节将讨论跨域通信和数据传输的客户端解决方案。每一种解决方案都有优缺点，应用场景在很大程度上影响你的选择。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Cross Domain" scheme="http://bubkoo.com/tags/cross-domain/"/>
    
  </entry>
  
  <entry>
    <title>大型 JavaScript 架构中的设计模式</title>
    <link href="http://bubkoo.com/2014/04/21/patterns-for-large-scale-javascript-application-architecture/"/>
    <id>http://bubkoo.com/2014/04/21/patterns-for-large-scale-javascript-application-architecture/</id>
    <published>2014-04-21T22:57:24.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们今天要讨论的主题是，大型 JavaScript 应用中一些有效的设计模式。本文基于我最近发布在 LondonJS 上同名演讲，灵感则来自于 Nicholas Zakas <a href="http://yuilibrary.com/theater/nicholas-zakas/zakas-architecture/" target="_blank" rel="external">之前的研究成果</a>。</p><h2><span id="我是谁以及我为什么要撰写这个主题">我是谁以及我为什么要撰写这个主题？</span></h2><p>我目前是 AOL 的一名 JavaScript 和 UI 开发人员，负责规划和编写下一代面向用户的应用的前端架构。这些应用不仅复杂，而且需要一种可扩展和高复用的架构，我的职责之一就是确保这类应用中的设计模式尽可能是可持续的。</p><p>尽管在这个领域有许多比我知识渊博的专家，我也认为自己是设计模式的狂热者。先前，我基于 <a href="http://wiki.creativecommons.org/Books" target="_blank" rel="external">Creative Commons</a> 许可写了 <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/" target="_blank" rel="external">《Essential JavaScript Design Patterns》</a> 一书，现在我正在为此书撰写更详尽的后续版本。</p><h2><span id="140-个字的全文概述">140 个字的全文概述</span></h2><p>如果你时间不够，下面是本文的概述，只有一条 tweet 的长度。</p><p class="j-warning">应用解耦。架构/模块，外观模式和中介模式。模块发布消息，中介管理发布/订阅，外观处理安全问题。</p><h2><span id="什么是大型-javascript-应用">什么是“大型” JavaScript 应用</span></h2><p>正式开始之前，我们先尝试为“大型” JavaScript 应用下个定义。我发现，即便是在这个领域有多年开发经验的开发者，对于这个问题他们的答案都可能很主观。</p><p>作为实验，我询问了一些中级开发者，让他们试着作一个非正式的定义。一个开发者认为是代码超过 100,000 行的 JavaScript 应用，而另一个则认为是源代码超过 1M 的 JavaScript 应用。他们的答案很大胆，但都<strong>准确</strong>，因为代码量的大小不总是和应用的复杂度相关，100,000 行代码也可能是相当琐碎的代码。</p><p>虽然我的定义并不一定是普遍观点，但我认为这更接近大型 JavaScript 应用的本质：</p><p class="j-warning">在我看来，大型 JavaScript 应用是那种<strong>非琐碎</strong>，并且需要<strong>大量</strong>开发人员努力维护的应用，在浏览器端有繁重的数据操作和显示处理。</p><p>也许，该定义的最后一句话才是最重要的。</p><a id="more"></a><h2><span id="回顾一下你目前的架构">回顾一下你目前的架构</span></h2><p class="j-warning">如果准备开发一个大型 JavaScript 应用，请记得投入<strong>充足的时间</strong>来做基础架构，这才是最有意义的，而且通常比你最初的想象要复杂。</p><p>这里我不再啰嗦强调基础架构的重要性了，一些开发者在开发大型应用时，都认为：“我在之前中型项目中的开发中积累了一套完善的解决和设计模式，这也应该适用于稍大的项目。”在某种程度上这是可行的，但请不要想当然，<strong>更大的应用通常需要考虑更多的问题</strong>。我即将讨论为什么花费更多的时间来规划应用架构从长远来看是值得的。</p><p>对大多数 JavaScript 开发人员来说，在他们目前的架构中都或多或少使用了如下这些模块：</p><ul><li>自定义组件 (custom widgets)</li><li>模型 (models)</li><li>视图 (views)</li><li>控制器 (controllers)</li><li>模板 (templates)</li><li>库/工具集 (libraries/toolkits)</li><li>应用程序核心 (application core)</li></ul><p class="j-info"><strong>相关阅读</strong><br>- <a href="http://blog.rebeccamurphey.com/code-org-take-2-structuring-javascript-applic" target="_blank" rel="external">Rebecca Murphey - Structuring JavaScript Applications</a><br>- <a href="http://michaux.ca/articles/mvc-architecture-for-javascript-applications" target="_blank" rel="external">Peter Michaux - MVC Architecture For JavaScript Applications</a><br>- <a href="http://stackoverflow.com/questions/5112899/knockout-js-vs-backbone-js-vs" target="_blank" rel="external">StackOverflow - A discussion on modern MVC frameworks</a><br>- <a href="http://msdn.microsoft.com/en-us/scriptjunkie/ff706600" target="_blank" rel="external">Doug Neiner - Stateful Plugins and the Widget Factory</a><br></p><p>或许你还将你的应用划分为不同的功能模块，并应用了其他一些设计模式，这非常好，但可能还不够，获取还会遇到一系列潜在的问题。</p><p><strong>1. 哪些模块可以独立复用？</strong></p><p>单个模块可以独立存在吗？他们是自包含的吗？如果让我看看你或者你的团队正在编写的大型应用的代码，我会随机选择一个模块，并将其丢在一个新页面中，可以就这样简单地独立使用这个模块吗？为什么要这样做？从长远来看，如果你的公司开始开发越来越多的应用，应用之间又有某些交叉的功能，如果有人说：“我们的用户喜欢邮件客户端的聊天模块，让我们将其添加到我们新的协作编辑套件中吧”，可以通过复用模块来实现吗？</p><p><strong>2. 系统中有多少模块依赖于其他模块？</strong></p><p>模块间是紧耦合的吗？在深入讨论前，值得一提的是：在一个系统中一个模块完全不依赖其他模块，并不总是可行，在某个粒度级别，一些模块可以从其它一些基础模块扩展而来。而我们讨论的问题是不同功能模块之间的关联度，应该使这些不同的模块不依赖或加载过多的其它模块。</p><p><strong>3. 如果某模块崩溃了，应用仍然可用吗？</strong></p><p>如果你正在构建一个类似 GMail 的应用，当邮件模块崩溃时，不应该影响其它部位的使用，如聊天应用。同时，按照之前所说，一个模块应该能够脱离当前的应用而独立存在。在我的演讲中，我提到了基于用户意图的动态模块加载，例如，在上例中，用户可能默认关闭了聊天应用，页面初始化时就不需要加载相关的模块，当用户通过某些操作想要使用聊天应用时，才动态加载对应的模块，并且加载过来的模块不会对之前模块造成影响。</p><p><strong>4. 对独立模块的测试容易吗？</strong></p><p>对于一个大规模的系统，每天都有数以百万计的用户（或恶意用户）在使用系统的不同部位。有必要对那些可复用的模块进行充分的测试，保证模块在当前的架构和脱离当前架构时，测试都是可行的，这样才能为模块复用提供最大的保证。</p><h2><span id="从长远考虑">从长远考虑</span></h2><p>做基础架构时，从长远考虑很重要，尽可能预测系统将来会有什么样的改变，虽然不可能准确预估系统将如何增长，但肯定有可考虑的空间。到此，你会想到你的系统中的某些模块吗？</p><p>开发人员经常将 DOM 操作代码和其他代码紧紧地耦合在一起，他们即将面临将核心逻辑代码独立成模块的问题。如果稍微长远考虑一下，他们就不会这样做。</p><p>我的一个听众认为，这样严格的架构可能并不适用于未来。非常正确，然而，如果现在不考虑进来，将来可能会耗费更多的成本。</p><p class="j-warning">将来，可能由于性能、安全或设计问题，你决定把正在使用的 Dojo、jQuery、Zepto 或 YUI 换成一个完全不同的库。这很可能会演变成一个问题，因为不同库之间不容易互换，并且，如果当前库与你的应用紧密耦合的话，将导致高额的转换成本。</p><p>假如你是一个 Dojo 的使用者，或许现在没有更好的库可以切换过去，但谁能保证未来几年不会出现更好的库呢，而且那时你又想切换过去呢？</p><p>如果你的架构足够灵活，并不关心模块使用的是神马底层库，将大大节约时间和经济成本。</p><p>总而言之，如果你的应用还做不到不重写整个应用而完成底层库的切换，请继续阅读。</p><p>下面引用了一些有影响力的 JavaScript 开发者的观点：</p><p class="j-warning">“构建大型应用的秘诀在于永远不要构建大型应用，将你的应用分解成小块，然后将这些可测试的、颗粒化的小块组装成你的大型应用” - <strong>Justin Meyer, author JavaScriptMVC</strong></p><p class="j-warning">“关键是一开始就必须承认你不可能完全预测到你的应用将如何增长，然后你就会保守地设计你的系统。举个例子，应用中与其他系统进行通信的模块将来可能会改变，因此你需要将它抽象出来。” - <strong>Nicholas Zakas, author ‘High-performance JavaScript websites’</strong></p><p class="j-warning">“组件之间关系越紧密，它们就越难以复用，对组件的修改就越困难，因为难免会影响到其他组件。” - <strong>Rebecca Murphey, author of jQuery Fundamentals</strong></p><p>这些原则对于构建经久考验的架构至关重要，应该始终牢记于心。</p><h2><span id="头脑风暴">头脑风暴</span></h2><p>先想想我们试图实现什么。</p><p class="j-warning">我们想要一个松散耦合的架构，功能被分解为<strong>独立的模块</strong>，模块之间没有依赖。当触发某个事件时，模块将<strong>通知</strong>应用程序的其他部分，并由一个<strong>中间层</strong>来解析和响应这些消息。</p><p>例如，我们有一个在线面包店的 JavaScript 应用，那么模块中这个“事件”的就可能是“第 42 批面包卷已经准备好派送”。</p><p>我们使用一个独立的模块解析其他模块中的消息，这样，模块不会直接调用核心模块，同时，模块不需要直接调用其它模块或与其它模块进行交互。这可以防止由某个模块出错而导致应用程序崩溃，并给我们提供了一种重启崩溃模块的方式。</p><p>另一个是安全问题。事实上，大多数人不会认为应用程序的内部安全是个问题,因为他们认为自己足够聪明，构建应用时，清楚地知道哪些是公共的哪些是私有的。</p><p>模块不应该是万能的，需要确定某个模块允许做什么不能做什么。例如，在我的系统中，如果我知道公共聊天组件不允许与管理模块或拥有 DB 写权限的模块发生交互，就可以防止别人利用组件中已知的漏洞来发起 XSS 攻击。</p><p>用一个中间层来处理权限，确定哪些模块可以访问应用的哪些部分，这样可以增加应用的安全性。这意味着，一个模块只能做那些被允许的事情。</p><h2><span id="推荐架构">推荐架构</span></h2><p>我所寻求的解决方案由三个著名的设计模式组成：<strong>模块模式</strong>、<strong>外观模式</strong>和<strong>中介模式</strong>。</p><p>在传统模式中，模块间直接相互通信，在我们的架构中，模块只会发布感兴趣的事件，理想情况下，一个模块不会感知到其他模块的存在。中介模式用来订阅模块中的消息，并作出适当的响应。外观模式用于执行模块对应的功能。</p><p>我将详细讨论下面这些内容：</p><ul><li>设计模式<ul><li>模块化理论<ul><li><a href="#modtheory">概要</a></li><li><a href="#modpattern">模块模式</a></li><li><a href="#objliteral">对象字面量</a></li><li><a href="#commonjsmods">CommonJS 模块</a></li></ul></li><li><a href="#facadepattern">外观模式</a></li><li><a href="#mediatorpattern">中介模式</a> </li></ul></li><li>在架构中的应用<ul><li><a href="#applyingfacade">应用外观模式 - 抽象的核心</a></li><li><a href="#applyingmediator">应用中介模式 - 应用程序核心</a></li><li><a href="#tyingittogether">集成应用</a>   </li></ul></li></ul><h3><span id="模块化理论">模块化理论</span></h3><p><a name="modtheory"></a></p><p>也许你已经使用过模块化开发，如果还没有，本节将是一个入门的简单例子。</p><p class="j-warning">模块是任何健壮架构中<strong>不可或缺</strong>的一部分，在大型系统中，模块是通常具有单一目，并具有通用性的部分。</p><p>可以为模块定义好依赖关系，并立即自动加载这些依赖项，这种方式更具可伸缩性，不必跟踪模块依赖和手动加载模块或注入 <code>&lt;script&gt;</code> 标签。</p><p>任何成体系的应用都应该基于模块化组件来构建。回到刚刚的 GMail 应用，可以认为模块是独立存在的功能单元，如聊天功能模块。但是，还取决于功能单元的复杂度，它很可能还依赖于更细粒度的子模块。例如，有一个处理表情符号的模块，可以被使用在聊天应用和邮件应用中。</p><p class="j-warning">在我们的架构中，模块<strong>很少感知</strong>系统中的其余模块发生的事情。我们可以通过外观模式将这个任务委托给中介。</p><p>这是刻意这样设计的，一个模块只让系统知道它正在发生的事情，而不需要关心其他模块的运行情况，系统就能够支持添加、删除或替换模块，不会因为紧耦合而导致系统中其他模块崩溃。</p><p>要想实现这个想法，松散耦合是必要的。在可能的地方移除代码依赖有助于提高模块的可维护性。在我们的例子中，模块不应该依赖其他模块就能正常运行。当松散耦合得到有效实施时，看看系统中一个部位的更改将如何影响其它部位。</p><p>在 JavaScript 中，有几种方式来实现模块化，包括著名的模块模式和对象字面量，有经验的开发人员已经熟悉这些，如果你也已经熟悉，请跳到 <a href="#commonjsmods">CommonJS 模块</a>部分。</p><h3><span id="模块模式-the-module-pattern">模块模式 The Module Pattern</span></h3><p><a name="modpattern"></a></p><p>模块模式是一个流行的设计模式，通过闭包来封装“私有”、状态和结构。它提供一种包装公共和私有方法和变量的方式，避免污染全局变量或与其他开发人员的接口发生冲突。这种模式，只返回一些公共的 API，剩下的一切则是私有的。</p><p>这提供了一个纯净的解决方案，将逻辑繁重的部分保护在其中，值暴露出接口给应用的其他部位调用。这种模式非常类似于一个立即执行的函数（<a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" target="_blank" rel="external">IIFE</a>），除了返回的是一个对象，而不是函数。</p><p>需要指出的是，在 JavaScript 中并不存在真正意义上的“私有”，因为 JavaScript 不同于一些传统的语言，变量不能被声明为公共或私有的，所以我们使用函数作用域来模拟这一概念。在模块模式中，利用闭包，声明的变量和方法只在模块内部可用，在返回的对象中定义的变量和方法才是随处可用的。</p><p>下面你将看到一个用模块模式实现的购物车应用，模块被包含在 <code>basketModule</code> 这个全局对象中。模块中的 <code>basket</code> 数组是私有的，因此应用的其它部分不能直接读取它，它只存在于模块的闭包中，所以只有那些与它同作用域的方法（例如，<code>addItem()</code>, <code>getItem()</code> 等等）才能访问到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> basketModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> basket = []; <span class="comment">//private</span></div><div class="line">    <span class="keyword">return</span> &#123; <span class="comment">//exposed to public</span></div><div class="line">        addItem: <span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123;</div><div class="line">            basket.push(values);</div><div class="line">        &#125;,</div><div class="line">        getItemCount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> basket.length;</div><div class="line">        &#125;,</div><div class="line">        getTotal: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">           <span class="keyword">var</span> q = <span class="keyword">this</span>.getItemCount(),p=<span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(q--)&#123;</div><div class="line">                p+= basket[q].price; </div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;());</div></pre></td></tr></table></figure><p>在模块中，我们返回了一个对象，并自动赋给了 <code>basketModule</code>，因此，你可以这样来使用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//basketModule is an object with properties which can also be methods</span></div><div class="line">basketModule.addItem(&#123;<span class="attr">item</span>:<span class="string">'bread'</span>,<span class="attr">price</span>:<span class="number">0.5</span>&#125;);</div><div class="line">basketModule.addItem(&#123;<span class="attr">item</span>:<span class="string">'butter'</span>,<span class="attr">price</span>:<span class="number">0.3</span>&#125;);</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(basketModule.getItemCount());</div><div class="line"><span class="built_in">console</span>.log(basketModule.getTotal());</div><div class="line"> </div><div class="line"><span class="comment">//however, the following will not work:</span></div><div class="line"><span class="built_in">console</span>.log(basketModule.basket);<span class="comment">// (undefined as not inside the returned object)</span></div><div class="line"><span class="built_in">console</span>.log(basket); <span class="comment">//(only exists within the scope of the closure)</span></div></pre></td></tr></table></figure><p>上面的方法被有效地限制在 <code>basketModule</code> 命名空间中。</p><p>从历史角度来看，模块模式最早在 2003 年由许多人创建，包括 <a href="http://groups.google.com/group/comp.lang.javascript/msg/9f58bd11bd67d937" target="_blank" rel="external">Richard Cornford</a>，后来在道格拉斯(Douglas Crockford)的演讲中被推广，并被 Eric Miraglia 在 YUI 的博客中再次介绍。</p><p>在具体的工具库或框架中，模块模式是什么样的情况呢？</p><h4><span id="dojo">Dojo</span></h4><p>Dojo 试图通过 <code>dojo.declare</code> 来实现类似于“类”的功能，这个也可用于实现模块模式。例如，如果我们想把 <code>basket</code> 定义在 <code>store</code> 命名空间下，可以这样来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//traditional way</span></div><div class="line"><span class="keyword">var</span> store = <span class="built_in">window</span>.store || &#123;&#125;;</div><div class="line">store.basket = store.basket || &#123;&#125;;</div><div class="line"> </div><div class="line"><span class="comment">//using dojo.setObject</span></div><div class="line">dojo.setObject(<span class="string">"store.basket.object"</span>, (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> basket = [];</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(basket);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        publicMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                privateMethod();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;()));</div></pre></td></tr></table></figure><p>如果混合使用 <code>dojo.provide</code> 将变得非常强大。</p><h4><span id="yui">YUI</span></h4><p>下面的例子在很大程度上基于由 Eric Miraglia 实现的原始的 YUI 模块模式，代码相对来说比较不言自明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">YAHOO.store.basket = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> </div><div class="line">    <span class="comment">//"private" variables:</span></div><div class="line">    <span class="keyword">var</span> myPrivateVar = <span class="string">"I can be accessed only within YAHOO.store.basket ."</span>;</div><div class="line"> </div><div class="line">    <span class="comment">//"private" method:</span></div><div class="line">    <span class="keyword">var</span> myPrivateMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            YAHOO.log(<span class="string">"I can be accessed only from within YAHOO.store.basket"</span>);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        myPublicProperty: <span class="string">"I'm a public property."</span>,</div><div class="line">        myPublicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            YAHOO.log(<span class="string">"I'm a public method."</span>);</div><div class="line"> </div><div class="line">            <span class="comment">//Within basket, I can access "private" vars and methods:</span></div><div class="line">            YAHOO.log(myPrivateVar);</div><div class="line">            YAHOO.log(myPrivateMethod());</div><div class="line"> </div><div class="line">            <span class="comment">//The native scope of myPublicMethod is store so we can</span></div><div class="line">            <span class="comment">//access public members using "this":</span></div><div class="line">            YAHOO.log(<span class="keyword">this</span>.myPublicProperty);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">&#125;();</div></pre></td></tr></table></figure><h4><span id="jquery">jQuery</span></h4><p>有许多方式可以将 jQuery 代码包装在模块模式中。Ben Cherry 之前提出了一个实现方式，用一个函数将模块定义包装起来，模块定义时处理一些共性事件。</p><p>在下面例子中，定义了一个 <code>library</code> 函数来创建一个模块，当一个新模块被创建时，自动将 <code>init</code> 函数绑定到 <code>document.ready</code> 上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">library</span>(<span class="params">module</span>) </span>&#123;</div><div class="line">  $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">module</span>.init) &#123;</div><div class="line">      <span class="built_in">module</span>.init();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">module</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> myLibrary = library(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> &#123;</div><div class="line">     init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="comment">/*implementation*/</span></div><div class="line">     &#125;</div><div class="line">   &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure><p class="j-info"><strong>相关阅读</strong><br>- <a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth" target="_blank" rel="external">Ben Cherry - The Module Pattern In-Depth</a><br>- <a href="http://lanyrd.com/2011/jsconf/sfgdk/" target="_blank" rel="external">John Hann - The Future Is Modules, Not Frameworks</a><br>- <a href="https://gist.github.com/274388" target="_blank" rel="external">Nathan Smith - A Module pattern aliased window and document gist</a><br>- <a href="http://blog.davidlitmark.com/post/6009004931/an-introduction-to-the-revealing-module-pattern" target="_blank" rel="external">David Litmark - An Introduction To The Revealing Module Pattern</a><br></p><h3><span id="对象字面量-object-literal-notation">对象字面量 Object Literal Notation</span></h3><p><a name="objliteral"></a></p><p>在对象字面量中，一个对象被描述为一组用逗号分隔的键/值对，并用一对 <code>{}</code> 包裹起来。对象中的名词可以是字符串或标识符，其后紧跟一个冒号 <code>:</code>。在对象的最后一个键/值对后面不能有逗号，因为这可能导致错误。</p><p>对象字面量不需要用 <code>new</code> 操作符来实例化，但是不能在语句的开始使用，因为 <code>{</code> 可能会被解析为语句块的开始。在下面你可以看到，使用对象字面量来定义一个模块，可以使用 <code>myModule.property = &#39;someValue&#39;</code> 的方式来给对象添加新成员。</p><p class="j-warning">模块模式在很多情况下很有用，但是，如果你不需要特定的私有属性或方法，那么对象字面量无疑是更合适的代替品。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myModule = &#123;</div><div class="line">    myProperty : <span class="string">'someValue'</span>,</div><div class="line">    <span class="comment">//object literals can contain properties and methods.</span></div><div class="line">    <span class="comment">//here, another object is defined for configuration</span></div><div class="line">    <span class="comment">//purposes:</span></div><div class="line">    myConfig:&#123;</div><div class="line">        useCaching:<span class="literal">true</span>,</div><div class="line">        language: <span class="string">'en'</span>   </div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//a very basic method</span></div><div class="line">    myMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'I can haz functionality?'</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//output a value based on current configuration</span></div><div class="line">    myMethod2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Caching is:'</span> + (<span class="keyword">this</span>.myConfig.useCaching)?<span class="string">'enabled'</span>:<span class="string">'disabled'</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//override the current configuration</span></div><div class="line">    myMethod3: <span class="function"><span class="keyword">function</span>(<span class="params">newConfig</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> newConfig == <span class="string">'object'</span>)&#123;</div><div class="line">           <span class="keyword">this</span>.myConfig = newConfig;</div><div class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>.myConfig.language); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">myModule.myMethod(); <span class="comment">//I can haz functionality</span></div><div class="line">myModule.myMethod2(); <span class="comment">//outputs enabled</span></div><div class="line">myModule.myMethod3(&#123;<span class="attr">language</span>:<span class="string">'fr'</span>,<span class="attr">useCaching</span>:<span class="literal">false</span>&#125;); <span class="comment">//fr</span></div></pre></td></tr></table></figure><p class="j-info"><strong>相关阅读</strong><br>- <a href="http://blog.rebeccamurphey.com/2009/10/15/using-objects-to-organize-your-code" target="_blank" rel="external">Rebecca Murphey - Using Objects To Organize Your Code</a><br>- <a href="http://www.phpied.com/3-ways-to-define-a-javascript-class/" target="_blank" rel="external">Stoyan Stefanov - 3 Ways To Define A JavaScript Class </a><br>- <a href="http://benalman.com/news/2010/03/theres-no-such-thing-as-a-json/" target="_blank" rel="external">Ben Alman - Clarifications On Object Literals (There’s no such thing as a JSON Object)</a><br>- <a href="http://ejohn.org/blog/simple-javascript-inheritance/" target="_blank" rel="external">John Resig - Simple JavaScript Inheritance</a><br></p><h3><span id="commonjs-模块-commonjs-modules">CommonJS 模块 CommonJS Modules</span></h3><p><a name="commonjsmods"></a></p><p>在过去的一两年，你可能已经听说过 <a href="http://commonjs.org/" target="_blank" rel="external">CommonJS</a> - 一个致力于设计、原型化和标准化 JavaScript API 的志愿者工作组。目前，他们已经批准了模块和包的标准，CommonJS AMD 规范定义了一个简单的 API 来声明模块，模块可同时用于浏览器的同步和异步的 <code>&lt;script&gt;</code> 标签中。他们的模块模式相对比较清爽，并且我认为它是 ES Harmony（JavaScript 语言的下一个版本）所建议的模块系统的可靠基石。</p><p>从结构的角度来看，一个 CommonJS 模块是一段可重用的 JavaScript，它输出特定的对象，以供任何依赖它的代码调用。这种模块格式变得相当普遍，成为 JS 模块格式事实上的标准。有很多关于实现 CommonJS 模块模式的教程，单高度概括起来，都包含两个基本部分：一个 <code>exports</code> 对象，包含了对其他模块可用的对象；一个 <code>require</code> 函数，用来导入其他模块暴露的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Example of achieving compatibility with AMD and standard CommonJS by putting boilerplate around the standard CommonJS module format:</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">define</span>)</span>&#123;</div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require,exports</span>)</span>&#123;</div><div class="line"><span class="comment">// module contents</span></div><div class="line"> <span class="keyword">var</span> dep1 = <span class="built_in">require</span>(<span class="string">"dep1"</span>);</div><div class="line"> exports.someExportedFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;;</div><div class="line"> <span class="comment">//...</span></div><div class="line">&#125;);</div><div class="line">&#125;)(<span class="keyword">typeof</span> define==<span class="string">"function"</span>?define:<span class="function"><span class="keyword">function</span>(<span class="params">factory</span>)</span>&#123;factory(<span class="built_in">require</span>,exports)&#125;);</div></pre></td></tr></table></figure><p>有许多强大的库可以处理 CommonJS 模块的加载，但我虽喜欢的是 RequireJS。一个完整的 RequireJS 教程超出了本文的范围，不过我推荐你读一读 James Burke 的博文 <a href="http://msdn.microsoft.com/en-us/scriptjunkie/ff943568" target="_blank" rel="external">ScriptJunkie</a>。我知道很多人也喜欢 Yabble。</p><p>扯些题外话，RequireJS 提供了一些包装方法，来简化静态模块的创建过程和异步加载。它可以很容易的加载模块以及模块的依赖，然后在模块就绪时执行模块的内容。</p><p>有些开发人员声称 CommonJS 模块不太适用于浏览器环境。原因是 CommonJS 模块无法通过 <code>&lt;script&gt;</code> 标签加载，除非有服务端协助。我们假设有一个把图片编码为 ASCII 的库，它暴露出一个 <code>encodeToASCII</code> 函数。它的模块类似于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> encodeToASCII = <span class="built_in">require</span>(<span class="string">"encoder"</span>).encodeToASCII;</div><div class="line">exports.encodeSomeSource = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//process then call encodeToASCII</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这类情况下，<code>&lt;script&gt;</code> 标签将无法正常工作，因为作用域没有被包裹起来，这就意味着 <code>encodeToASCII</code> 方法将被绑定到 <code>window</code> 对象上，<code>require</code> 也不是之前的定义，并且需要为每个模块单独创建 exports。客户端在服务器端的协助下，或通过发送 XHR 请求加载脚本，并使用 <code>eval()</code> 函数，可以很容易处理这种情况。</p><p>使用 RequireJS，该模块的早期版本可以重写为下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> encodeToASCII = <span class="built_in">require</span>(<span class="string">"encoder"</span>).encodeToASCII;</div><div class="line">    exports.encodeSomeSource = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="comment">//process then call encodeToASCII</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>对于不只依赖于静态 JavaScript 的项目来说，CommonJS 是很好的选择，不过先要花一些时间来阅读相关资料。我仅仅涉及到了冰山一角，如果你想深入阅读，CommonJS 的 wikie 和 Sitepen 有着大量资源。</p><p class="j-info"><strong>相关阅读</strong><br>- <a href="http://wiki.commonjs.org/wiki/Modules" target="_blank" rel="external">The CommonJS Module Specifications</a><br>- <a href="http://dailyjs.com/2010/10/18/modules/" target="_blank" rel="external">Alex Young - Demystifying CommonJS Modules</a><br>- <a href="http://requirejs.org/docs/commonjs.html#packages" target="_blank" rel="external">Notes on CommonJS modules with RequireJS</a><br></p><h3><span id="外观模式-the-facade-pattern">外观模式 The Facade Pattern</span></h3><p><a name="facadepattern"></a></p><p>接下来，我们来看看外观模式，在今天定义的架构中扮演着关键角色的设计模式。</p><p>当创建一个外观模式时，通常是创建了一个隐藏了不同实现的外在表现。外观模式为大批量代码提供了一个方便的高级接口，隐藏了底层的复杂性，呈现给其他开发人员的是简化的 API。</p><p>外观模式是一种结构模式，经常可以在 JavaScript 框架和库中看到，尽管它的实现可能提供能大量行为，但只有一个“外观”或一些有限的抽象方法供客户使用。</p><p>这样，我们直接与“外观”交互，而不是隐藏在其后的子系统。</p><p>外观模式有趣之处在于，它可以隐藏各个功能模块的内部实现细节，甚至可以在客户不知情的情况下修改其内部实现。</p><p>通过维护一个一致性的外观（简化的 API），就不必担心一个模块是否使用了 dojo、jQuery、YUI、zepto 或其他库。只要交互层没有改变，你就可以更换我们的库（如，jQuery 或 Dojo）而不会影响系统的其他部分。</p><p>下面是一个非常简单的外观模式的示例，正如你所看到的，在我们的模块内部定义了许多私有方法，然后使用外观模式来为这些方法提供了一个更简单的 API。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _private = &#123;</div><div class="line">        i:<span class="number">5</span>,</div><div class="line">        get : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'current value:'</span> + <span class="keyword">this</span>.i);</div><div class="line">        &#125;,</div><div class="line">        set : <span class="function"><span class="keyword">function</span>(<span class="params"> val </span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.i = val;</div><div class="line">        &#125;,</div><div class="line">        run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'running'</span>);</div><div class="line">        &#125;,</div><div class="line">        jump: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'jumping'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        facade : <span class="function"><span class="keyword">function</span>(<span class="params"> args </span>) </span>&#123;</div><div class="line">            _private.set(args.val);</div><div class="line">            _private.get();</div><div class="line">            <span class="keyword">if</span> ( args.run ) &#123;</div><div class="line">                _private.run();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;());</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="built_in">module</span>.facade(&#123;<span class="attr">run</span>: <span class="literal">true</span>, <span class="attr">val</span>:<span class="number">10</span>&#125;);</div><div class="line"><span class="comment">//outputs current value: 10, running</span></div></pre></td></tr></table></figure><p>在将其应用到我们的架构之前，先介绍到这里。接下来，我们将进入激动人心的中介模式，外观模式和中介模式的核心区别在于，外观模式（一种结构模式）只暴露了现有功能，而中介模式（一种行为模式）可以添加功能。</p><p class="j-info"><strong>相关阅读</strong><br>- <a href="http://books.google.co.uk/books?id=za3vlnlWxb0C&amp;lpg=PA141&amp;ots=MD5BLTsSzH&amp;dq=javascript%20facade%20pattern&amp;pg=PA141#v=onepage&amp;q=javascript facade pattern&amp;f=false" target="_blank" rel="external">Dustin Diaz, Ross Harmes - Pro JavaScript Design Patterns (Chapter 10, available to read on Google Books)</a><br></p><h3><span id="中介模式-the-mediator-pattern">中介模式 The Mediator Pattern</span></h3><p><a name="mediatorpattern"></a></p><p>机场交通控制 - 这个简单的比喻最好地诠释了中介模式。航站楼控制着哪个飞机可以起飞或降落，因为所有的沟通都是通过航站楼和飞机之间进行，而不是飞机与飞机之间直接沟通。这个系统成功的关键在于中央控制器，即所谓的中介。</p><p class="j-warning">当模块之间通信比较复杂时可以使用中介，单决定权还是在我们自己。如果在你的代码中，模块之间有千丝万缕的关系，就是时候实施一个中央控制器，这就是中介模式的用武之地。</p><p>回到我们的讨论，中介模式在不同模块之间的<strong>交互</strong>过程中充当了中介角色，将交互细节都<strong>封装</strong>在了内部。通过阻止对象之间相互引用，这种模式还促进了松散耦合，解决了模块内部依赖问题。</p><p>中介模式还有什么其他优势呢？嗯，中介模式允许各个模块的行为独立变化，因此相当灵活。如果你之前使用过观察者模式（发布/订阅模式）来实现模块之间的事件广播，你会发现中介模式相当好理解。</p><p>让我们看看模块是如何与中介交互的：</p><p><img src="http://bubkoo.qiniudn.com/modules-interact-with-a-mediator.jpg" alt=""></p><p>模块是发布者，中介既是发布者又是订阅者。模块 1 广播一个事件来通知中介需呀做点什么，中介捕获到该事件后，通知模块 2 去完成模块 1 需要的任务，并向中介者广播一个完成事件。同时，模块 3 也被中介启动，记录从中介传来的通知。</p><p>注意，任何模块之间都没有<strong>直接通信</strong>，如果作用链中的模块 3 运行失败或意外停止，中介可以假装“暂停”其他模块的任务，停止并重启模块 3，然后继续工作，这对系统而言几乎没有影响。这种层级解耦是中介模式提供的最主要优势之一。</p><p>回顾一些，中介者模式的优势如下：</p><p>引入中介作为中央控制点来使模块解耦。允许模块监听或广播消息，而不用关心系统的其余部分。消息可以同时被任意数量的模块来处理。</p><p>缺点是：</p><p>在模块之间添加中介，模块始终必须间接沟通。由于松散耦合的本资，这可能会导致轻微的性能下降，而且很难通过广播消息得知系统将如何响应。如果有一天，紧耦合让你头痛，这也许是一个解决方案。</p><p><strong>示例</strong>：这是中介者模式的一个实现，基于 <a href="https://github.com/rpflorence" target="_blank" rel="external">@rpflorence</a> 之前的工作成果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mediator = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">channel, fn</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (!mediator.channels[channel]) mediator.channels[channel] = [];</div><div class="line">        mediator.channels[channel].push(&#123; <span class="attr">context</span>: <span class="keyword">this</span>, <span class="attr">callback</span>: fn &#125;);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;,</div><div class="line"> </div><div class="line">    publish = <span class="function"><span class="keyword">function</span>(<span class="params">channel</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (!mediator.channels[channel]) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = mediator.channels[channel].length; i &lt; l; i++) &#123;</div><div class="line">            <span class="keyword">var</span> subscription = mediator.channels[channel][i];</div><div class="line">            subscription.callback.apply(subscription.context, args);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        channels: &#123;&#125;,</div><div class="line">        publish: publish,</div><div class="line">        subscribe: subscribe,</div><div class="line">        installTo: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">            obj.subscribe = subscribe;</div><div class="line">            obj.publish = publish;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">&#125;());</div></pre></td></tr></table></figure><p><strong>示例</strong>：下面是前面实现的两个使用示例，有效管理了发布/订阅。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Pub/sub on a centralized mediator</span></div><div class="line"></div><div class="line">mediator.name = <span class="string">"tim"</span>;</div><div class="line">mediator.subscribe(<span class="string">'nameChange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">this</span>.name = arg;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">mediator.publish(<span class="string">'nameChange'</span>, <span class="string">'david'</span>); <span class="comment">//tim, david</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//Pub/sub via third party mediator</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'sam'</span> &#125;;</div><div class="line">mediator.installTo(obj);</div><div class="line">obj.subscribe(<span class="string">'nameChange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">this</span>.name = arg;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">obj.publish(<span class="string">'nameChange'</span>, <span class="string">'john'</span>); <span class="comment">//sam, john</span></div></pre></td></tr></table></figure><p class="j-info"><strong>相关阅读</strong><br>- Stoyan Stefanov - Page 168, JavaScript Patterns<br>- <a href="http://arguments.callee.info/2009/05/18/javascript-design-patterns--mediator/" target="_blank" rel="external">HB Stone - JavaScript Design Patterns: Mediator</a><br>- <a href="http://www.vincehuston.org/dp/mediator.html" target="_blank" rel="external">Vince Huston - The Mediator Pattern (not specific to JavaScript, but a concise)</a><br></p><h3><span id="应用外观模式-抽象的核心">应用外观模式 - 抽象的核心</span></h3><p><a name="applyingfacade"></a></p><p>架构建议：</p><p class="j-warning">外观模式作为应用程序核心的<strong>抽象</strong>，位于中介和模块之间。理想情况下，它应该是系统中其他部分唯一可以感知到的部分。</p><p>抽象的责任包括为模块提供<strong>统一的接口</strong>，并确保任何时候都是可用的。这非常类似于 Nicholas Zakas 首次提出的优秀架构中的沙箱控制器角色。</p><p>组件将通过外观与中介通信，所以外观必须是可靠的。需要澄清的是，我所说的“通信”实际上是指与外观进行通信，外观是中介者的抽象，将监听模块的广播消息，然后把广播消息传给中介。</p><p>除了为模块提供接口，外观还扮演着保安的角色，确定了一个模块可以访问应用中的哪些部分。组件只能调用自己的方法，对于没有权限的部分，则不能与之交互。例如，一个模块可能广播 <code>dataValidationCompletedWriteToDB</code> 消息，这里的安全检查是确保有权限的模块才能请求数据库写操作。我们最好避免让模块视图做一下不被允许的事情。</p><p>总之，中介管理发布/订阅，只有通过外观检查的消息才会被传给中介。</p><h3><span id="应用中介者模式-应用程序核心">应用中介者模式 - 应用程序核心</span></h3><p><a name="applyingmediator"></a></p><p>中介扮演的角色是应用程序的核心。我们已经简单介绍了它的一些职责，我们还需要完整的来看看它的左右职责。</p><p>中介的主要任务是管理模块的<strong>生命周期</strong>。当中介检查到一个<strong>消息</strong>时，它需要决定应用程序该如何响应 – 这实际上意味着是否需要<strong>停止</strong>或<strong>启动</strong>一个或一组模块。</p><p class="j-warning">理想情况下，模块一旦启动，就应该<strong>自动</strong>执行。模块是否应该在 DOM 就绪时才执行，决定这个的不是中介的职责，架构中应该有足够的空间来让模块自己来决定。</p><p>你可能想知道在什么情况下一个模块需要被“停止” – 如果应用程序侦测到某个模块出现故障或处于严重的错误中，可以决定让阻止模块中的方法继续执行，这时就可以重新启动模块。这样做的目的减少中断，提高用户体验。</p><p>此外，中介（应用核心）应该可以<strong>添加或移除</strong>模块，而不破坏任何东西。一个典型的应用场景是，某些功能不是在页面初始化的时候加载，而是基于用户意图动态加载，回到 GMail 的例子，谷歌可以聊天部件默认收起，只有当用户开始使用时才动态加载。从性能优化的角度来看，这是非常有意义的。</p><p>错误管理也是由应用程序核心负责。模块除了广播感兴趣的事件之外，还会广播发生的任何错误，然后核心可以做出相应的反馈（例如停止或重启模块）。确保应用有足够的灵活空间，来引入新的或更好的方式来处理错误或向终端用户显示错误，这是解耦架构中的重要环节。通过中介者使用发布/订阅机制，就可以做到这一点。</p><h3><span id="集成应用-tying-it-all-together">集成应用 Tying It All Together</span></h3><p><a name="tyingittogether"></a></p><ul><li><p><strong>模块</strong>为应用程序提供特定的功能。每当发生了某些事件，它们发布消息来告知应用程序 – 这是它们的主要关注点。正如我将在 FAQ 中介绍的，模块可以依赖 DOM 工具方法，但是理想情况下不应该依赖系统中的任何其他模块。它们不应该关注：</p><ul><li>什么对象或模块将订阅它们发布的消息</li><li>这些对象在哪里（是否在客户端或服务器端）</li><li>有多少对象订阅了它的消息</li></ul><p><img src="http://bubkoo.qiniudn.com/tying-it-all-together-chart1a.gif" alt=""></p></li><li><p><strong>外观</strong> 抽象的核心，避免模块之间直接接触。它从模块订阅感兴趣的事件，并说：“太棒了！发生了什么事情？给我细节！”它还通过检查发布消息的模块是否具有相应的权限，来检查模块的安全性。</p><p><img src="http://bubkoo.qiniudn.com/tying-it-all-together-chart2a.gif" alt=""></p></li><li><p>中介者（应用程序的核心） 扮演“发布/订阅”管理者的角色。负责管理模块，在需要时启动或停止模块。特别适用于动态依赖加载，并确保失败的模块可以在需要时集中重启。</p><p><img src="http://bubkoo.qiniudn.com/tying-it-all-together-chart3a.gif" alt=""></p></li></ul><p>这种架构的结果是，在大多数情况下，模块之间不会相互依赖，这是因为这种解耦架构，模块很容易独立进行测试和维护，可以将模块用于另一个项目，而不需要太多额外的工作。模块可以被动态添加或移除，而不会导致应用程序崩溃。</p><h2><span id="超越beyond发布订阅自动事件注册">超越(Beyond)发布/订阅：自动事件注册</span></h2><p>正如 Michael Mahemoff 之前提到，当考虑大型 JavaScript 应用时，适当利用这门语言的动态特性是有益的。关于详细内容请阅读 Michael <a href="https://plus.google.com/106413090159067280619/posts/hDZkVrDXZR6" target="_blank" rel="external">G+</a> 上列举的概念，我最关注一个特别的概念 – 自动事件注册（AER）。</p><p>AER 通过基于命名约定的自动连接模式，解决了从订阅者到发布者的连接问题。例如，如果某个模块发布了 <code>messageUpdate</code> 消息，所有与 <code>messageUpdate</code> 相关的方法将被自动调用。</p><p>这种模式涉及到：注册所有可能订阅事件的模块，注册所有可能被订阅的事件，最后为组件库中的每个订阅者注册方法。对于这篇文章所讨论的架构来说，这是一个非常有趣的方法，但也确实带来一些有趣的挑战。</p><p>例如，当动态执行时，对象可以在创建时注册自身。请阅读 Michael 关于 AER 的<a href="http://softwareas.com/automagic-event-registration" target="_blank" rel="external">文章</a>，他更深入地讨论了如何处理这类问题。</p><h2><span id="常问问题">常问问题</span></h2><p><strong>Q: 是否可以完全避免实现一个沙箱或外观？</strong><br>A: 虽然前面的介绍中使用了外观来实现安全功能，如果不用外观，完全可以通过中介和发布/订阅机制来做系统中的通信。这种轻量级版本可以提供一定程度的解耦，但是如果这么做，模块就可以直接与应用程序核心（中介者）直接接触。</p><p><strong>Q: 您提到了模块没有任何依赖，这是否包含对第三方库的依赖（如jQuery）?</strong><br>A: 这里是指对其他模块的依赖。一些开发人员在架构中选择了一些 DOM 工具库，实际上是对这些 DOM 库的公共抽象。例如，你可以创建一个 DOM 工具类，使用 jQuery 来查询选择器表达式，并返回查找到的 DOM 结果（或者使用 Dojo）。通过这种方式，尽管模块依然会查询 DOM，但不会强依赖于特定的库。有许多方式可以实现这一点，但是理想情况下，核心模块不应该依赖其他模块。</p><p>这样做你会发现，有时候很容易就可以让一个完整的模块运行在另一个项目中。需要说清楚的是，我完全同意对模块进行扩展或使用模块的部分功能，但是记住，在某些情况下，想要把这样的模块应用到其他项目会增加工作量。</p><p><strong>Q: 我现在就想开始使用这种架构。是否有可供参考的样板代码？</strong><br>A: 如果时间允许的话，我打算为这篇文章发布一个样例程序，但目前你最好的选择是 Andrew Burgees 的超值教程 <a href="http://bit.ly/orGVOL" target="_blank" rel="external">Writing Modular JavaScript</a>（在推荐之前需要完全披露的是，这仅仅是一个推荐链接，收到的任何反馈都将有助于完善内容）。Andrew 的样例库包含一张屏幕截屏以及代码，覆盖了这篇文章的的大部分主要观点，但选择把外观称作“沙箱”，就像 Zakas。还有一些讨论是关于如何理想地在这样一个架构中实现 DOM 抽象库———类似于我对第二个问题的回答，Andrew 在实现选择器表达式查询时采用了一些有趣的模式，使得在大多数情况下，用短短几行代码就可以做到切换库。我并不是说它是正确的或最好的实现方式，但是它是一种可能，而且我个人也在使用它。</p><p><strong>Q: 如果模块需要直接与核心通信，这么做可能吗？</strong><br>A: 正如 Zakas 之前暗示的，为什么模块不应该访问核心，这在技术上并没有问题，但这是最佳实践，比其他任何事情都重要。如果你想严格地坚持这种架构，你需要遵循定义的这些规则，或者选择一个更松散的结构，就像第一个问题的答案。</p><p class="j-quote">参考原文：<a href="http://addyosmani.com/largescalejavascript/" target="_blank" rel="external">Patterns For Large-Scale JavaScript Application Architecture</a><br>原文作者：<a href="http://twitter.com/addyosmani" target="_blank" rel="external">Addy Osmani</a>.<br>技术评审：<a href="http://twitter.com/peolanha" target="_blank" rel="external">Andrée Hansson</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们今天要讨论的主题是，大型 JavaScript 应用中一些有效的设计模式。本文基于我最近发布在 LondonJS 上同名演讲，灵感则来自于 Nicholas Zakas &lt;a href=&quot;http://yuilibrary.com/theater/nicholas-zakas/zakas-architecture/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;之前的研究成果&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;我是谁以及我为什么要撰写这个主题？&quot;&gt;&lt;a href=&quot;#我是谁以及我为什么要撰写这个主题？&quot; class=&quot;headerlink&quot; title=&quot;我是谁以及我为什么要撰写这个主题？&quot;&gt;&lt;/a&gt;我是谁以及我为什么要撰写这个主题？&lt;/h2&gt;&lt;p&gt;我目前是 AOL 的一名 JavaScript 和 UI 开发人员，负责规划和编写下一代面向用户的应用的前端架构。这些应用不仅复杂，而且需要一种可扩展和高复用的架构，我的职责之一就是确保这类应用中的设计模式尽可能是可持续的。&lt;/p&gt;
&lt;p&gt;尽管在这个领域有许多比我知识渊博的专家，我也认为自己是设计模式的狂热者。先前，我基于 &lt;a href=&quot;http://wiki.creativecommons.org/Books&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Creative Commons&lt;/a&gt; 许可写了 &lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Essential JavaScript Design Patterns》&lt;/a&gt; 一书，现在我正在为此书撰写更详尽的后续版本。&lt;/p&gt;
&lt;h2 id=&quot;140-个字的全文概述&quot;&gt;&lt;a href=&quot;#140-个字的全文概述&quot; class=&quot;headerlink&quot; title=&quot;140 个字的全文概述&quot;&gt;&lt;/a&gt;140 个字的全文概述&lt;/h2&gt;&lt;p&gt;如果你时间不够，下面是本文的概述，只有一条 tweet 的长度。&lt;/p&gt;
&lt;p class=&quot;j-warning&quot;&gt;应用解耦。架构/模块，外观模式和中介模式。模块发布消息，中介管理发布/订阅，外观处理安全问题。&lt;/p&gt;

&lt;h2 id=&quot;什么是“大型”-JavaScript-应用&quot;&gt;&lt;a href=&quot;#什么是“大型”-JavaScript-应用&quot; class=&quot;headerlink&quot; title=&quot;什么是“大型” JavaScript 应用&quot;&gt;&lt;/a&gt;什么是“大型” JavaScript 应用&lt;/h2&gt;&lt;p&gt;正式开始之前，我们先尝试为“大型” JavaScript 应用下个定义。我发现，即便是在这个领域有多年开发经验的开发者，对于这个问题他们的答案都可能很主观。&lt;/p&gt;
&lt;p&gt;作为实验，我询问了一些中级开发者，让他们试着作一个非正式的定义。一个开发者认为是代码超过 100,000 行的 JavaScript 应用，而另一个则认为是源代码超过 1M 的 JavaScript 应用。他们的答案很大胆，但都&lt;strong&gt;准确&lt;/strong&gt;，因为代码量的大小不总是和应用的复杂度相关，100,000 行代码也可能是相当琐碎的代码。&lt;/p&gt;
&lt;p&gt;虽然我的定义并不一定是普遍观点，但我认为这更接近大型 JavaScript 应用的本质：&lt;/p&gt;
&lt;p class=&quot;j-warning&quot;&gt;在我看来，大型 JavaScript 应用是那种&lt;strong&gt;非琐碎&lt;/strong&gt;，并且需要&lt;strong&gt;大量&lt;/strong&gt;开发人员努力维护的应用，在浏览器端有繁重的数据操作和显示处理。&lt;/p&gt;

&lt;p&gt;也许，该定义的最后一句话才是最重要的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Architecture" scheme="http://bubkoo.com/tags/architecture/"/>
    
      <category term="Patterns" scheme="http://bubkoo.com/tags/patterns/"/>
    
  </entry>
  
  <entry>
    <title>HTTP cookies 详解</title>
    <link href="http://bubkoo.com/2014/04/21/http-cookies-explained/"/>
    <id>http://bubkoo.com/2014/04/21/http-cookies-explained/</id>
    <published>2014-04-21T15:08:49.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP cookies，通常称之为“cookie”，已经存在很长时间了，但是仍然没有被充分理解。首要问题是存在许多误解，认为 cookie 是后门程序或病毒，却忽视了其工作原理。第二个问题是，对于 cookie 的操作缺少统一的接口。尽管存在这些问题，cookie 仍旧在 Web 开发中扮演者重要的角色，以至于如果没有出现相应的代替品就消失的话，我们许多喜欢的 Web 应用将变的不可用。</p><h2><span id="cookie-的起源">cookie 的起源</span></h2><p>早期的 Web 应用面临的最大问题之一就是如何维持状态。简言之，服务器无法知道两个请求是否来自于同一个浏览器。当时，最简单的办法就是在请求的页面中插入一个 token，然后在下次请求时将这个 token 返回至服务器。这需要在页面的 form 表单中插入一个包含 token 的隐藏域，或者将 token 放在 URL 的 query 字符串中来传递。这两种方法都需要手动操作，而且极易出错。</p><p>当时网景通讯的一名员工 <a href="http://en.wikipedia.org/wiki/Lou_Montulli" target="_blank" rel="external">Lou Montulli</a>，在 1994 年将 “<a href="http://en.wikipedia.org/wiki/Magic_cookie" target="_blank" rel="external">magic cookies</a>” 的概念应用到 Web 通讯中。他试图解决 Web 的第一个购物车应用，现在购物车成了购物网站的支柱。他的<a href="http://curl.haxx.se/rfc/cookie_spec.html" target="_blank" rel="external">原始说明文档</a>提供了 cookie 工作原理的基本信息，该文档后来被作为规范纳入到 <a href="http://tools.ietf.org/html/rfc2109" target="_blank" rel="external">RFC 2109</a>（大多数浏览器的实现参考文档）中，最终被纳入到 <a href="http://tools.ietf.org/html/rfc2965" target="_blank" rel="external">RFC 2965</a> 中。Montulli 也被授予 cookie 的美国<a href="http://v3.espacenet.com/publicationDetails/biblio?CC=US&amp;NR=5774670&amp;KC=&amp;FT=E" target="_blank" rel="external">专利</a>。网景浏览器在它的第一个版本中就开始支持 cookie，现在所有 Web 浏览器都支持 cookie。</p><a id="more"></a><h2><span id="cookie-是什么">cookie 是什么</span></h2><p>简单地说，cookie 就是浏览器储存在用户电脑上的一小段文本文件。cookie 是纯文本格式，不包含任何可执行的代码。一个 Web 页面或服务器告知浏览器按照一定规范来储存这些信息，并在随后的请求中将这些信息发送至服务器，Web 服务器就可以使用这些信息来识别不同的用户。大多数需要登录的网站在用户验证成功之后都会设置一个 cookie，只要这个 cookie 存在并可以，用户就可以自由浏览这个网站的任意页面。再次说明，cookie 只包含数据，就其本身而言并不有害。</p><h2><span id="创建-cookie">创建 cookie</span></h2><p>Web 服务器通过发送一个称为 <code>Set-Cookie</code> 的 HTTP 消息头来创建一个 cookie，<code>Set-Cookie</code> 消息头是一个字符串，其格式如下（中括号中的部分是可选的）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</div></pre></td></tr></table></figure><p>消息头的第一部分，value 部分，通常是一个 <code>name=value</code> 格式的字符串。事实上，这种格式是原始规范中指定的格式，但是浏览器并不会对 cookie 值按照此格式来验证。实际上，你可以指定一个不含等号的字符串，它同样会被存储。然而，最常用的使用方式是按照 <code>name=value</code> 格式来指定 cookie 的值（大多数接口只支持该格式）。</p><p>当存在一个 cookie，并允许设置可选项，该 cookie 的值会在随后的每次请求中被发送至服务器，cookie 的值被存储在名为 Cookie 的 HTTP 消息头中，并且只包含了 cookie 的值，忽略全部设置选项。例如：        </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie: value</div></pre></td></tr></table></figure><p>通过 <code>Set-Cookie</code> 指定的可选项只会在浏览器端使用，而不会被发送至服务器端。发送至服务器的 cookie 的值与通过 <code>Set-Cookie</code> 指定的值完全一样，不会有进一步的解析或转码操作。如果请求中包含多个 cookie，它们将会被分号和空格分开，例如： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie: value1; value2; name1=value1</div></pre></td></tr></table></figure><p>服务器端框架通常包含解析 cookie 的方法，可以通过编程的方式获取 cookie 的值。</p><h2><span id="cookie-编码">cookie 编码</span></h2><p>对于 cookie 的值进行编码一直都存在一些困惑。普遍认为 cookie 的值必须经过 URL 编码，但其实这是一个谬论，尽管通常都这么做。原始规范中明确指出只有三个字符必须进行编码：分号、逗号和空格，规范中还提到可以进行 URL 编码，但并不是必须，在 RFC 中没有提及任何编码。然而，几乎所有的实现都对 cookie 的值进行了一系列的 URL 编码。对于 <code>name=value</code> 格式，通常会对 <code>name</code> 和 <code>value</code> 分别进行编码，而不对等号 <code>=</code> 进行编码操作。</p><h2><span id="过期时间选项">过期时间选项</span></h2><p>紧跟 cookie 值后面的每个选项都以分号和空格分开，每个选择都指定了 cookie 在什么情况下应该被发送至服务器。第一个选项是过期时间（expires），指定了 cookie 何时不会再被发送至服务器，随后浏览器将删除该 cookie。该选项的值是一个 <code>Wdy, DD-Mon-YYYY HH:MM:SS GMT</code> 日期格式的值，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie: name=Nicholas; expires=Sat, <span class="number">02</span> May <span class="number">2009</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">25</span> GMT</div></pre></td></tr></table></figure><p>没有设置 <code>expires</code> 选项时，cookie 的生命周期仅限于当前会话中，关闭浏览器意味着这次会话的结束，所以会话 cookie 仅存在于浏览器打开状态之下。这就是为什么为什么当你登录一个 Web 应用时经常会看到一个复选框，询问你是否记住登录信息：如果你勾选了复选框，那么一个 <code>expires</code> 选项会被附加到登录 cookie 中。如果 <code>expires</code> 设置了一个过去的时间点，那么这个 cookie 会被立即删掉。</p><h2><span id="domain-选项">domain 选项</span></h2><p>下一个选项是 <code>domain</code>，指定了 cookie 将要被发送至哪个或哪些域中。默认情况下，<code>domain</code> 会被设置为创建该 cookie 的页面所在的域名，所以当给相同域名发送请求时该 cookie 会被发送至服务器。例如，本博中 cookie 的默认值将是 <code>bubkoo.com</code>。<code>domain</code> 选项可用来扩充 cookie 可发送域的数量，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie: name=Nicholas; domain=nczonline.net</div></pre></td></tr></table></figure><p>像 Yahoo! 这种大型网站，都会有许多 name.yahoo.com 形式的站点（例如：my.yahoo.com, finance.yahoo.com 等等）。将一个 cookie 的 <code>domain</code> 选项设置为 <code>yahoo.com</code>，就可以将该 cookie 的值发送至所有这些站点。浏览器会把 <code>domain</code> 的值与请求的域名做一个尾部比较（即从字符串的尾部开始比较），并将匹配的 cookie 发送至服务器。</p><p><code>domain</code> 选项的值必须是发送 <code>Set-Cookie</code> 消息头的主机名的一部分，例如我不能在 google.com 上设置一个 cookie，因为这会产生安全问题。不合法的 <code>domain</code> 选择将直接被忽略。</p><h2><span id="path-选项">path 选项</span></h2><p>另一个控制 <code>Cookie</code> 消息头发送时机的选项是 <code>path</code> 选项，和 <code>domain</code> 选项类似，<code>path</code> 选项指定了请求的资源 URL 中必须存在指定的路径时，才会发送<code>Cookie</code> 消息头。这个比较通常是将 <code>path</code> 选项的值与请求的 URL 从头开始逐字符比较完成的。如果字符匹配，则发送 <code>Cookie</code> 消息头，例如： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie:name=Nicholas;path=<span class="regexp">/blog</span></div></pre></td></tr></table></figure><p>在这个例子中，<code>path</code> 选项值会与 <code>/blog</code>，<code>/blogrool</code> 等等相匹配；任何以 <code>/blog</code> 开头的选项都是合法的。需要注意的是，只有在 <code>domain</code> 选项核实完毕之后才会对 <code>path</code> 属性进行比较。<code>path</code> 属性的默认值是发送 <code>Set-Cookie</code> 消息头所对应的 URL 中的 <code>path</code> 部分。</p><h2><span id="secure-选项">secure 选项</span></h2><p>最后一个选项是 <code>secure</code>。不像其它选项，该选项只是一个标记而没有值。只有当一个请求通过 SSL 或 HTTPS 创建时，包含 <code>secure</code> 选项的 cookie 才能被发送至服务器。这种 cookie 的内容具有很高的价值，如果以纯文本形式传递很有可能被篡改，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie: name=Nicholas; secure</div></pre></td></tr></table></figure><p>事实上，机密且敏感的信息绝不应该在 cookie 中存储或传输，因为 cookie 的整个机制原本都是不安全的。默认情况下，在 HTTPS 链接上传输的 cookie 都会被自动添加上 <code>secure</code> 选项。</p><h2><span id="cookie-的维护和生命周期">Cookie 的维护和生命周期</span></h2><p>在一个 cookie 中可以指定任意数量的选项，并且这些选项可以是任意顺序，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie:name=Nicholas; domain=nczonline.net; path=<span class="regexp">/blog</span></div></pre></td></tr></table></figure><p>这个 cookie 有四个标识符：cookie 的 <code>name</code>，<code>domain</code>，<code>path</code>，<code>secure</code> 标记。要想改变这个 cookie 的值，需要发送另一个具有相同 cookie <code>name</code>，<code>domain</code>，<code>path</code> 的 <code>Set-Cookie</code> 消息头。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie: name=Greg; domain=nczonline.net; path=<span class="regexp">/blog</span></div></pre></td></tr></table></figure><p>这将覆盖原来 cookie 的值。但是，修改 cookie 选项的任意一项都将创建一个完全不同的新 cookie，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie: name=Nicholas; domain=nczonline.net; path=<span class="regexp">/</span></div></pre></td></tr></table></figure><p>这个消息头返回之后，会同时存在两个名为 “name” 的不同的 cookie。如果你访问 <code>www.nczonline.net/blog</code> 下的一个页面，以下的消息头将被包含进来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie: name=Greg; name=Nicholas</div></pre></td></tr></table></figure><p>在这个消息头中存在了两个名为 “name” 的 cookie，<code>path</code> 值越详细则 cookie 越靠前。 按照 <code>domain-path-secure</code> 的顺序，设置越详细的 cookie 在字符串中越靠前。假设我在 <code>ww.nczonline.net/blog</code> 下用默认选项创建了另一个 cookie：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie: name=Mike</div></pre></td></tr></table></figure><p>那么返回的消息头现在则变为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie: name=Mike; name=Greg; name=Nicholas</div></pre></td></tr></table></figure><p>以 “Mike” 作为值的 cookie 使用了域名（<code>www.nczonline.net</code>）作为其 <code>domain</code> 值并且以全路径（<code>/blog</code>）作为其 <code>path</code> 值，则它较其它两个 cookie 更加详细。</p><h2><span id="使用失效日期">使用失效日期</span></h2><p>当 cookie 创建时指定了失效日期，这个失效日期则关联了以 <code>name-domain-path-secure</code> 为标识的 cookie。要改变一个 cookie 的失效日期，你必须指定同样的组合。当改变一个 cookie 的值时，你不必每次都设置失效日期，因为它不是 cookie 标识信息的组成部分。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie:name=Mike;expires=Sat,<span class="number">03</span> May <span class="number">2025</span> <span class="number">17</span>:<span class="number">44</span>:<span class="number">22</span> GMT</div></pre></td></tr></table></figure><p>现在已经设置了 cookie 的失效日期，所以下次我想要改变 cookie 的值时，我只需要使用它的名字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie:name=Matt</div></pre></td></tr></table></figure><p>cookie 的失效日期并没有改变，因为 cookie 的标识符是相同的。实际上，只有你手工的改变 cookie 的失效日期，否则其失效日期不会改变。这意味着在同一个会话中，一个会话 cookie 可以变成一个持久化 cookie（一个可以在多个会话中存在的），反之则不可。为了要将一个持久化 cookie 变为一个会话 cookie，你必须删除这个持久化 cookie，这只要设置它的失效日期为过去某个时间之后再创建一个同名的会话 cookie 就可以实现。</p><p>需要记得的是失效日期是以浏览器运行的电脑上的系统时间为基准进行核实的。没有任何办法来来验证这个系统时间是否和服务器的时间同步，所以当服务器时间和浏览器所处系统时间存在差异时这样的设置会出现错误。</p><h2><span id="cookie-自动删除">cookie 自动删除</span></h2><p>cookie 会被浏览器自动删除，通常存在以下几种原因：</p><ul><li>会话 cooke (Session cookie) 在会话结束时（浏览器关闭）会被删除</li><li>持久化 cookie（Persistent cookie）在到达失效日期时会被删除</li><li>如果浏览器中的 cookie 数量达到限制，那么 cookie 会被删除以为新建的 cookie 创建空间。详见我的另外一篇关于 <a href="http://www.nczonline.net/blog/2008/05/17/browser-cookie-restrictions/" target="_blank" rel="external">cookies restrictions</a> 的博客</li></ul><p>对于自动删除来说，Cookie 管理显得十分重要，因为这些删除都是无意识的。</p><h2><span id="cookie-限制条件">Cookie 限制条件</span></h2><p>cookie 存在许多限制条件，来阻止 cookie 滥用并保护浏览器和服务器免受一些负面影响。有两种 cookie 限制条件：cookie 的属性和 cookie 的总大小。原始规范中限定每个域名下不超过 20 个 cookie，早期的浏览器都遵循该规范，并且在 IE7 中有更近一步的提升。在微软的一次更新中，他们在 IE7 中增加 cookie 的限制数量到 50 个，与此同时 Opera 限定 cookie 数量为 30 个，Safari 和 Chrome 对与每个域名下的 cookie 个数没有限制。</p><p>发向服务器的所有 cookie 的最大数量（空间）仍旧维持原始规范中所指出的：4KB。所有超出该限制的 cookie 都会被截掉并且不会发送至服务器。</p><h2><span id="subcookies">Subcookies</span></h2><p>鉴于 cookie 的数量存在限制，开发者提出 subcookies 的观点来增加 cookie 的存储量。Subcookies 是存储在一个 cookie 值中的一些 <code>name-value</code> 对，通常与以下格式类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name=a=b&amp;c=d&amp;e=f&amp;g=h</div></pre></td></tr></table></figure><p>这种方式允许在单个 cookie 中保存多个 <code>name-value</code> 对，而不会超出浏览器 cookie 数量的限制。通过这种方式创建 cookie 的负面影响是，需要自定义解析方式来提取这些值，相比较而言 cookie 的格式会更为简单。服务器端框架已开始支持 subcookies 的存储。我编写的 <a href="http://developer.yahoo.com/yui/cookie/" target="_blank" rel="external">YUI Cookie utility</a>，支持在 javascript 中读/写 subcookies</p><h2><span id="javascript-中的-cookie">JavaScript 中的 cookie</span></h2><p>在 JavaScript 中通过 <code>document.cookie</code> 属性，你可以创建、维护和删除 cookie。创建 cookie 时该属性等同于 <code>Set-Cookie</code> 消息头，而在读取 cookie 时则等同于 <code>Cookie</code> 消息头。在创建一个 cookie 时，你需要使用和 <code>Set-Cookie</code> 期望格式相同的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.cookie=<span class="string">"name=Nicholas;domain=nczonline.net;path=/"</span>;</div></pre></td></tr></table></figure><p>设置 <code>document.cookie</code> 属性的值并不会删除存储在页面中的所有 cookie。它只简单的创建或修改字符串中指定的 cookie。下次发送一个请求到服务器时，通过 <code>document.cookie</code> 设置的 cookie 会和其它通过 <code>Set-Cookie</code> 消息头设置的 cookie 一并发送至服务器。这些 cookie 并没有什么明确的不同之处。</p><p>要使用 JavaScript 提取 cookie 的值，只需要从 <code>document.cookie</code> 中读取即可。返回的字符串与 <code>Cookie</code> 消息头中的字符串格式相同，所以多个 cookie 会被分号和字符串分割。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name1=Greg; name2=Nicholas</div></pre></td></tr></table></figure><p>鉴于此，你需要手工解析这个 cookie 字符串来提取真实的 cookie 数据。当前已有许多描述如何利用 JavaScript 来解析 cookie 的资料，包括我的书，<a href="http://www.amazon.com/gp/product/047022780X?ie=UTF8&amp;tag=nczonline-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=047022780X" target="_blank" rel="external">Professional JavaScript</a>，所以在这我就不再说明。通常利用已存在的 JavaScript 库操作 cookie 会更简单，如使用 <a href="http://developer.yahoo.com/yui/cookie/" target="_blank" rel="external">YUI Cookie utility</a> 来处理 cookie，而不要手工重新创建这些算法。</p><p>通过访问 <code>document.cookie</code> 返回的 cookie 遵循发向服务器的 cookie 一样的访问规则。要通过 JavaScript 访问 cookie，该页面和 cookie 必须在相同的域中，有相同的 <code>path</code>，有相同的安全级别。</p><p>注意：一旦 cookie 通过 JavaScript 设置后便不能提取它的选项，所以你将不能知道 <code>domain</code>，<code>path</code>，<code>expires</code> 日期或 <code>secure</code> 标记。</p><h2><span id="http-only-cookies">HTTP-Only cookies</span></h2><p>微软的 IE6 SP1 在 cookie 中引入了一个新的选项：<code>HTTP-only</code>，<code>HTTP-Only</code> 背后的意思是告之浏览器该 cookie 绝不能通过 JavaScript 的 <code>document.cookie</code> 属性访问。设计该特征意在提供一个安全措施来帮助阻止通过 JavaScript 发起的跨站脚本攻击 (XSS) 窃取 cookie 的行为（我会在另一篇博客中讨论安全问题，本篇如此已足够）。今天 Firefox2.0.0.5+、Opera9.5+、Chrome 都支持 HTTP-Only cookie。3.2 版本的 Safari 仍不支持。</p><p>要创建一个 HTTP-Only cookie，只要向你的 cookie 中添加一个 <code>HTTP-Only</code> 标记即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie: name=Nicholas; HttpOnly</div></pre></td></tr></table></figure><p>一旦设定这个标记，通过 <code>documen.coookie</code> 则不能再访问该 cookie。IE 同时更近一步并且不允许通过 <code>XMLHttpRequest</code> 的 <code>getAllResponseHeaders()</code> 或 <code>getResponseHeader()</code> 方法访问 cookie，然而其它浏览器则允许此行为。Firefox 在 3.0.6 中<a href="http://www.mozilla.org/security/announce/2009/mfsa2009-05.html" target="_blank" rel="external">修复了该漏洞</a>，然而仍旧有许多<a href="http://manicode.blogspot.com/2009/01/browser-httponly-support-update.html" target="_blank" rel="external">浏览器漏洞</a>存在，<a href="https://www.owasp.org/index.php/HTTPOnly#Browsers_Supporting_HTTPOnly" target="_blank" rel="external">complete browser support list</a> 列出了这些。</p><p>你不能通过 JavaScript 设置 <code>HTTP-only</code>，因为你不能再通过 JavaScript 读取这些 cookie，这是情理之中的事情。</p><h2><span id="总结">总结</span></h2><p>为了高效的利用 cookie，仍旧有许多要了解和弄明白的东西。对于一项创建于十多年前但仍旧如最初实现的那样被使用至今的技术来说，这是件多不可思议的事。本篇只是提供了一些每个人都应该知道的关于浏览器 cookie 的基本指导，但无论如何，也不是一个完整的参考。对于今天的 Web 来说 cookie 仍旧起着非常重要的作用，并且不恰当的管理 cookie 会导致各种各样的问题，从最糟糕的用户体验到安全漏洞。我希望这篇手册能够激起一些关于 cookie 的不可思议的亮点。</p><p class="j-quote">原文：<a href="http://www.nczonline.net/blog/2009/05/05/http-cookies-explained/" target="_blank" rel="external">HTTP cookies explained</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP cookies，通常称之为“cookie”，已经存在很长时间了，但是仍然没有被充分理解。首要问题是存在许多误解，认为 cookie 是后门程序或病毒，却忽视了其工作原理。第二个问题是，对于 cookie 的操作缺少统一的接口。尽管存在这些问题，cookie 仍旧在 Web 开发中扮演者重要的角色，以至于如果没有出现相应的代替品就消失的话，我们许多喜欢的 Web 应用将变的不可用。&lt;/p&gt;
&lt;h2 id=&quot;cookie-的起源&quot;&gt;&lt;a href=&quot;#cookie-的起源&quot; class=&quot;headerlink&quot; title=&quot;cookie 的起源&quot;&gt;&lt;/a&gt;cookie 的起源&lt;/h2&gt;&lt;p&gt;早期的 Web 应用面临的最大问题之一就是如何维持状态。简言之，服务器无法知道两个请求是否来自于同一个浏览器。当时，最简单的办法就是在请求的页面中插入一个 token，然后在下次请求时将这个 token 返回至服务器。这需要在页面的 form 表单中插入一个包含 token 的隐藏域，或者将 token 放在 URL 的 query 字符串中来传递。这两种方法都需要手动操作，而且极易出错。&lt;/p&gt;
&lt;p&gt;当时网景通讯的一名员工 &lt;a href=&quot;http://en.wikipedia.org/wiki/Lou_Montulli&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lou Montulli&lt;/a&gt;，在 1994 年将 “&lt;a href=&quot;http://en.wikipedia.org/wiki/Magic_cookie&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;magic cookies&lt;/a&gt;” 的概念应用到 Web 通讯中。他试图解决 Web 的第一个购物车应用，现在购物车成了购物网站的支柱。他的&lt;a href=&quot;http://curl.haxx.se/rfc/cookie_spec.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始说明文档&lt;/a&gt;提供了 cookie 工作原理的基本信息，该文档后来被作为规范纳入到 &lt;a href=&quot;http://tools.ietf.org/html/rfc2109&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC 2109&lt;/a&gt;（大多数浏览器的实现参考文档）中，最终被纳入到 &lt;a href=&quot;http://tools.ietf.org/html/rfc2965&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC 2965&lt;/a&gt; 中。Montulli 也被授予 cookie 的美国&lt;a href=&quot;http://v3.espacenet.com/publicationDetails/biblio?CC=US&amp;amp;NR=5774670&amp;amp;KC=&amp;amp;FT=E&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;专利&lt;/a&gt;。网景浏览器在它的第一个版本中就开始支持 cookie，现在所有 Web 浏览器都支持 cookie。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Cookies" scheme="http://bubkoo.com/tags/cookies/"/>
    
      <category term="HTTP" scheme="http://bubkoo.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>神鹰 - 自动化</title>
    <link href="http://bubkoo.com/2014/04/20/angry-birds-of-javascript-mighty-eagle-automation/"/>
    <id>http://bubkoo.com/2014/04/20/angry-birds-of-javascript-mighty-eagle-automation/</id>
    <published>2014-04-20T21:40:10.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-mighty-eagle-automation.png" alt=""></p><p>一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）</p><p>小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p><blockquote><p>阅读本系列的<a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/">介绍文章</a>，查看所有小鸟以及它们的进攻力量。</p></blockquote><h2><span id="战况">战况</span></h2><ul><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/">红色大鸟 - 立即调用的函数表达式</a></li><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/">蓝色小鸟 - 事件</a></li><li><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/">黄色小鸟 - 模块化、依赖管理、性能优化</a></li><li><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/">黑色小鸟 - 前端分层架构</a></li><li><a href="http://bubkoo.com/2014/04/14/angry-birds-of-javascript-white-bird-linting/">白色小鸟 - 代码质量和代码分析</a></li><li><a href="http://bubkoo.com/2014/04/17/angry-birds-of-javascript-green-bird-mocking/">绿色小鸟 - 模拟请求和模拟数据</a></li><li><a href="http://bubkoo.com/2014/04/18/angry-birds-of-javascript-orange-bird-templating/">橙色小鸟 - 模板引擎</a></li><li><a href="http://bubkoo.com/2014/04/19/angry-birds-of-javascript-big-brother-bird-patterns/">大兄弟 - 设计模式</a></li></ul><h2><span id="神鹰的攻击力">神鹰的攻击力</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-angrybirds-eagle.png" alt=""></p><p>本文我们将看看使用超级武器的神鹰，它使用一套工具来组织和部署鸟儿们到战斗中去。渐渐的，它们一个接一个地夺回了本属于他们的东西。</p><a id="more"></a><h2><span id="猪猪偷走了什么">猪猪偷走了什么</span></h2><p>经过一段时间后，小鸟们开始使用 RequireJS (黄色小鸟)，JSHint (白色小鸟)，Plato，Mustache (橙色小鸟) 和其他一系列强大的工具，但所有这些工具都需要依靠命令行。记住这些工具对应的命令很烦人，并且在更新网站时，很容易忘记运行某个命令。幸好，神鹰带来了一些工具，使得这些工作变得简单，神鹰用 Grunt 和 Bowser 自动执行常见任务，并让项目可以很容易的引入必需的常用库。</p><p>但是，在最近的一次进攻中，小猪偷走了鸟儿们的自动化工具。其中一只神鹰被指派去夺回来，它将使用神鹰神奇的力量去夺回本系列中介绍过的技术。</p><h2><span id="grunt">Grunt</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-mighty-eagle-automation-grunt.png" alt=""></p><p>Grunt 是一个基于任务的命令行工具，用于前端应用的自动构建。社区被这个工具深深吸引，并产出了大量插件可供选择，例如 CoffeeScript 编译、Handlebars 预编译、Less 支持、JSHint 检查等等…</p><p>事实上已经有几个大型项目正在使用 Grunt 辅助自动构建过程以及其他任务，例如 Twitter、jQuery、Modernizr、Sauce Labs 等。</p><h3><span id="开始使用">开始使用</span></h3><p>开始使用之前，你需要在 node 中用下面的命令安装 Grunt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g grunt-cli grunt-init</div></pre></td></tr></table></figure><p>安装 Grun 之后，每个项目需要两个主要的文件：</p><ul><li>Gruntfile.js</li><li>package.json</li></ul><h4><span id="gruntfilejs">Gruntfile.js</span></h4><p>你可以从头创建自己的 <code>Gruntfile.js</code>，也可以从文档中拷贝一份初学者的 <code>Gruntfile.js</code>，或者使用项目脚手架 <code>grunt-init gruntfile</code>。如何安装脚手架请参阅 Grunt 的项目<a href="http://gruntjs.com/project-scaffolding" target="_blank" rel="external">脚手架页面</a>的介绍。下面的 <code>Gruntfile.js</code> 示例来自 Grunt 的<a href="http://gruntjs.com/getting-started" target="_blank" rel="external">入门指南</a>页面…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="comment">// Project configuration.</span></div><div class="line">    grunt.initConfig(&#123;</div><div class="line">        pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),</div><div class="line">        uglify: &#123;</div><div class="line">            options: &#123;</div><div class="line">                banner: <span class="string">'/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'</span></div><div class="line">            &#125;,</div><div class="line">            build: &#123;</div><div class="line">                src: <span class="string">'src/&lt;%= pkg.name %&gt;.js'</span>,</div><div class="line">                dest: <span class="string">'build/&lt;%= pkg.name %&gt;.min.js'</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">// Load the plugin that provides the "uglify" task.</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// Default task(s).</span></div><div class="line">    grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'uglify'</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4><span id="packagejson">package.json</span></h4><p><code>package.json</code> 描述了项目名称、版本，以及可能有的依赖，例如 Grunt 和 Grunt 插件。你可以从 Grunt 的<a href="http://gruntjs.com/getting-started" target="_blank" rel="external">入门指南</a>页面拷贝一份 package.json 示例…（如下所示）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"my-project-name"</span>,</div><div class="line">    <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</div><div class="line">    <span class="string">"devDependencies"</span>: &#123;</div><div class="line">        <span class="string">"grunt"</span>: <span class="string">"~0.4.1"</span>,</div><div class="line">        <span class="string">"grunt-contrib-jshint"</span>: <span class="string">"~0.1.1"</span>,</div><div class="line">        <span class="string">"grunt-contrib-nodeunit"</span>: <span class="string">"~0.1.2"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="grunt-插件">Grunt 插件</span></h3><p>现在一切就绪，你可以使用一整套插件开始自动执行任务。这里有几个有趣的插件，你可能会感兴趣…</p><ul><li>grunt-contrib-coffee - 把 CoffeeScript 编译为 JavaScript</li><li>grunt-contrib-compass - 把 Compass 编译为 CSS</li><li>grunt-contrib-concat - 合并文件</li><li>grunt-contrib-connect - 启动一个 Web 服务</li><li>grunt-contrib-csslint - 检测 CSS 文件</li><li>grunt-contrib-handlebars - 预编译 Handlebar 模板</li><li>grunt-contrib-htmlmin - 压缩 HTML 文件</li><li>grunt-contrib-imagemin - 压缩 PNG 和 JPEG 图片</li><li>grunt-contrib-jshint - 用 JSHint 检查 JS 文件</li><li>grunt-contrib-less - 将 LESS 编译为 CSS</li><li>grunt-contrib-nodeunit - 运行 Nodeunit 单元测试</li><li>grunt-contrib-watch - 当文件发生变化时运行与定义任务</li><li>grunt-contrib-requirejs - 使用 r.js 优化 RequireJS 项目</li><li>grunt-contrib-uglify - 用 UglifyJS 压缩文件</li><li>grunt-contrib-yuidoc - 编译 YUIDocs</li><li>… more …</li></ul><h3><span id="jquery-的-gruntfile">jQuery 的 Gruntfile</span></h3><p>我从 GitHub 上 clone 了一份 jQuery，用来查看 jQuery 是如何使用 Grunt 的，下面是执行 Grunt 时得到的输出。</p><p><img src="http://bubkoo.qiniudn.com/grunt-jquery.png" alt=""></p><p>如果你仔细查看上图，你会发现执行了一下任务：更新 Git 子模块（Sizzle，Qunit），从各个模块中构建出 jQuery，执行 JSHint 检查，创建 SourceMaps，并运行一个比较指定文件大小的任务。如果你深入研究它的 Gruntfile 的话，你还会发现它自定义一种不同于 Browserstack 的方式来运行单元测试。</p><h3><span id="modernizr-的-gruntfile">Modernizr 的 Gruntfile</span></h3><p>我同样也 clone 了一份 Modernizr 库，然后输入 <code>grunt qunit</code> 观察它的 746 项单元测试的测试过程，并在 369ms 内测试通过，测试使用了无界面的浏览器引擎 PhantomJS。</p><p><img src="http://bubkoo.qiniudn.com/grunt-modernizr.png" alt=""></p><h3><span id="grunt-资源">Grunt 资源</span></h3><p>本文的意图不是教会你如何使用 Grunt，只是让你意识到有这个东西的存在，它是实现前端自动化构建的一个非常好的工具，如果你还不了解 Grunt，你可以参阅下面的资源，这些资源将引导你逐步深入…</p><ul><li><a href="http://www.youtube.com/watch?v=q3Sqljpr-Vc" target="_blank" rel="external">The Grunt Basics</a> by Cary Landholt (<a href="http://twitter.com/carylandholt" target="_blank" rel="external">@carylandholt</a>)</li><li><a href="http://merrickchristensen.com/articles/gruntjs-workflow.html" target="_blank" rel="external">Grunt.js Workflow</a> by Merrick Christensen (<a href="http://twitter.com/iammerrick" target="_blank" rel="external">@iammerrick</a>)</li><li><a href="http://net.tutsplus.com/tutorials/javascript-ajax/meeting-grunt-the-build-tool-for-javascript/" target="_blank" rel="external">Meet Grunt: The Build Tool for JavavScript</a> by Andrew Burgess (<a href="http://twitter.com/andrew8088" target="_blank" rel="external">@andrew8088</a>)</li></ul><h2><span id="twitter-bower">Twitter Bower</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-mighty-eagle-automation-bower.png" alt=""></p><p>使用 Node 或 Ruby 的开发人员可能已经熟悉了 npm 或 gems，但是对于浏览器脚本和样式没有类似的工具…至少到目前为止还没有！</p><p>Twitter Bower 项目旨在为 HTML、CSS 和 JavaScript 提供一套包管理器来解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g bower</div></pre></td></tr></table></figure><p>安装 Bower 之后你就可以开始下载库！例如，我想下载最新版本的 jQuery，只需要运行 <code>bower install jquery</code>，然后你会看到下面的输出…</p><p><img src="http://bubkoo.qiniudn.com/bower-install-jquery.png" alt=""></p><h4><span id="bower-资源">Bower 资源</span></h4><p>如果想更多的了解 Bower，建议去看看下面的这些好资源。</p><ul><li><a href="http://net.tutsplus.com/tutorials/tools-and-tips/meet-bower-a-package-manager-for-the-web/" target="_blank" rel="external">Meet Bower: A Package Manager For The Web</a> by Andrew Burgess (<a href="http://twitter.com/andrew8088" target="_blank" rel="external">@andrew8088</a>)</li><li><a href="http://net.tutsplus.com/tutorials/javascript-ajax/a-requirejs-backbone-and-bower-starter-template/" target="_blank" rel="external">A RequireJS, Backbone, and Bower Starter Template</a> by Jeffrey Way (<a href="http://twitter.com/jeffrey_way" target="_blank" rel="external">@jeffrey_way</a>)</li></ul><h2><span id="yeoman">Yeoman</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-mighty-eagle-automation-yo.png" alt=""></p><p>Yeoman 项目是一款与 Grunt 和 Bower 协同工作的脚手架引擎。可以让你的应用快速运行起来。要使用 Yeoman，你需要先用下面的语法安装它…</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g yo grunt-cli bower</div></pre></td></tr></table></figure><p>Yeoman 安装之后，你可以生成各种不同类型的项目。在下面的的截图中，我用 Yeoman 创建了一个 Web 应用。在按我的需求订制应用的过程中，它会问几个问题。</p><p><img src="http://bubkoo.qiniudn.com/yo-webapp.png" alt=""></p><p>还有其他的脚手架，例如 <a href="https://github.com/yeoman/generator-backbone" target="_blank" rel="external">Backbone</a>、<a href="https://github.com/yeoman/generator-angular" target="_blank" rel="external">AngularJS</a> 等，你可以安装它们，然后开始你的项目。可以在 Yeoman 的 GitHub 页面看到更多的<a href="https://github.com/yeoman" target="_blank" rel="external">生成器列表</a>。</p><p>例如在下面的截图中，我先创建了一个新的 Backbone 应用，然后立即创建了一个新的 <code>bird</code> 模型。</p><p><img src="http://bubkoo.qiniudn.com/yo-backbone-app.png" alt=""></p><p><img src="http://bubkoo.qiniudn.com/yo-backbone-model.png" alt=""></p><blockquote><p>Yeoman 目前是 1.0 测试版，网站上说在 Windows 下有一些问题。虽然我已经能用它做一些扩展，但是我敢肯定有一些计划完全支持的功能尚不支持。</p></blockquote><h2><span id="进攻">进攻</span></h2><p>下面是一个用 <a href="http://incompl.github.com/boxbox/" target="_blank" rel="external">boxbox</a> 构建的简易版 Angry Birds，boxbox 是一个用于 <a href="https://code.google.com/p/box2dweb/" target="_blank" rel="external">box2dweb</a> 的物理学框架，由 <a href="http://bocoup.com/" target="_blank" rel="external">Bocoup</a> 的 <a href="http://twitter.com/_gsmith" target="_blank" rel="external">Greg Smith</a> 编写。</p><blockquote><p>按下空格键来发射神鹰，你也可以使用方向键。</p></blockquote><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-mighty-eagle-automation-attack.png" alt=""></p><h2><span id="结论">结论</span></h2><p>拥抱 Grunt、Bower 和 Yeoman 可以帮助自动化开发、测试、部署过程中的各个环节。这些工具的社区非常活跃，你可以在上面找到满足你应用需求的插件。</p><p>还有很多其他的前端架构技术也被猪偷走了。接下来，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p><p class="j-quote">原文：<a href="http://www.elijahmanor.com/angry-birds-of-javascript-mighty-eagle-automation/" target="_blank" rel="external">Angry Birds of JavaScript- Mighty Eagle: Automation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-of-javascript-mighty-eagle-automation.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）&lt;/p&gt;
&lt;p&gt;小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读本系列的&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/&quot;&gt;介绍文章&lt;/a&gt;，查看所有小鸟以及它们的进攻力量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;战况&quot;&gt;&lt;a href=&quot;#战况&quot; class=&quot;headerlink&quot; title=&quot;战况&quot;&gt;&lt;/a&gt;战况&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/&quot;&gt;红色大鸟 - 立即调用的函数表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/&quot;&gt;蓝色小鸟 - 事件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/&quot;&gt;黄色小鸟 - 模块化、依赖管理、性能优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/&quot;&gt;黑色小鸟 - 前端分层架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/04/14/angry-birds-of-javascript-white-bird-linting/&quot;&gt;白色小鸟 - 代码质量和代码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/04/17/angry-birds-of-javascript-green-bird-mocking/&quot;&gt;绿色小鸟 - 模拟请求和模拟数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/04/18/angry-birds-of-javascript-orange-bird-templating/&quot;&gt;橙色小鸟 - 模板引擎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/04/19/angry-birds-of-javascript-big-brother-bird-patterns/&quot;&gt;大兄弟 - 设计模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;神鹰的攻击力&quot;&gt;&lt;a href=&quot;#神鹰的攻击力&quot; class=&quot;headerlink&quot; title=&quot;神鹰的攻击力&quot;&gt;&lt;/a&gt;神鹰的攻击力&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-angrybirds-eagle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文我们将看看使用超级武器的神鹰，它使用一套工具来组织和部署鸟儿们到战斗中去。渐渐的，它们一个接一个地夺回了本属于他们的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Architecture" scheme="http://bubkoo.com/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>大兄弟 - 设计模式</title>
    <link href="http://bubkoo.com/2014/04/19/angry-birds-of-javascript-big-brother-bird-patterns/"/>
    <id>http://bubkoo.com/2014/04/19/angry-birds-of-javascript-big-brother-bird-patterns/</id>
    <published>2014-04-19T00:39:52.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-big-brother-bird-patterns.jpg" alt=""></p><p>一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）</p><p>小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p><blockquote><p>阅读本系列的<a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/">介绍文章</a>，查看所有小鸟以及它们的进攻力量。</p></blockquote><h2><span id="战况">战况</span></h2><ul><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/">红色大鸟 - 立即调用的函数表达式</a></li><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/">蓝色小鸟 - 事件</a></li><li><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/">黄色小鸟 - 模块化、依赖管理、性能优化</a></li><li><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/">黑色小鸟 - 前端分层架构</a></li><li><a href="http://bubkoo.com/2014/04/14/angry-birds-of-javascript-white-bird-linting/">白色小鸟 - 代码质量和代码分析</a></li><li><a href="http://bubkoo.com/2014/04/17/angry-birds-of-javascript-green-bird-mocking/">绿色小鸟 - 模拟请求和模拟数据</a></li><li><a href="http://bubkoo.com/2014/04/18/angry-birds-of-javascript-orange-bird-templating/">橙色小鸟 - 模板引擎</a></li></ul><h2><span id="大兄弟的攻击力">大兄弟的攻击力</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-big-brother-bird.png" alt=""></p><p>本文我们将看看大兄弟，它拿出了重武器：有限状态机和成熟的设计模式，渐渐的，它们逐一夺回了本属于它们的东西</p><a id="more"></a><h2><span id="猪猪偷走了什么">猪猪偷走了什么</span></h2><p>鸟儿们了解编程的大部分知识，但对于一些大家都能理解的通用场景，他们还没有形成共同的术语。一天大兄弟到来了，并为常见设计模式做了命名和描述的文档，这样，当鸟儿们在讨论架构时都能使用相同的术语。后来大兄弟的术语广受欢迎，最终成文著名的<strong>四人帮</strong>一书。但是，在最近的一次进攻过程中，小猪偷走了四人帮一书，大兄弟就被指派去夺回该书。它将使用势不可挡的力量摧毁猪群，夺回本属于它们的东西。</p><h2><span id="四人帮的设计模式">四人帮的设计模式</span></h2><h3><span id="创建模式">创建模式</span></h3><ul><li>抽象工厂模式</li><li>构造器模式</li><li>工厂模式</li><li>原型模式</li><li>单例模式</li></ul><h3><span id="行为模式">行为模式</span></h3><ul><li>责任链模式</li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>模板方法模式</li><li>访问者模式</li></ul><h3><span id="结构模式">结构模式</span></h3><ul><li>适配器模式</li><li>桥接模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul><h2><span id="javascript-中的一些设计模式">JavaScript 中的一些设计模式</span></h2><h3><span id="单例模式">单例模式</span></h3><p>单例模式最简单的形式就是对象字面量，像下面代码这样，我们只是简单地创建了一个对象。从技术上讲，有人或许会建议使用 <code>Object.create</code>，但大多数情况下，对象字面量的方式就已经满足单例模式的定义了。你可以在本文末尾的附加资源中找到更高级的解决方案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bird = &#123;</div><div class="line">    type: <span class="string">"Red"</span>,</div><div class="line">    fly: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Weeeee!"</span> );</div><div class="line">    &#125;,</div><div class="line">    destroy: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Hasta la vista, baby!"</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3><span id="工厂模式">工厂模式</span></h3><p>工厂模式就是在不使用 <code>new</code> 关键字的情况下创建一个对象的方式，核心在于在工厂方法内部用抽象的方式来创建对象。在下面的示例中，我们不需要太多的花招，就可以按照这种方式来添加一些自定的代码，而不会额外修改 API，这就是工厂模式的关键点所在。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Bird = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Bird.factory = <span class="function"><span class="keyword">function</span>(<span class="params"> type </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> bird;</div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> Bird[ type ] === <span class="string">"function"</span> ) &#123;</div><div class="line">        bird = <span class="keyword">new</span> Bird[ type ]();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bird;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">Bird.Red = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Bird.Blue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> redBird = Bird.factory( <span class="string">"Red"</span> );</div><div class="line"><span class="keyword">var</span> blueBird = Bird.factory( <span class="string">"Blue"</span> );</div></pre></td></tr></table></figure><h3><span id="桥接模式">桥接模式</span></h3><p>在下面代码中，我们在时间处理程序和将要执行的代码之间建立了一个简单的桥接，从而使被执行的代码更易于测试，因为它不在依赖于 jQuery 返回的上下文元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 普通方式</span></div><div class="line"><span class="keyword">var</span> getUrl = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> url = $( <span class="keyword">this</span> ).attr( <span class="string">"href"</span> );</div><div class="line">    </div><div class="line">    $.ajax(&#123;</div><div class="line">        url: url,</div><div class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log( data );</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line">$( <span class="string">"a.ajax"</span> ).on( <span class="string">"click"</span>, getUrl );</div><div class="line"> </div><div class="line"><span class="comment">// 桥接模式</span></div><div class="line"><span class="keyword">var</span> getUrl = <span class="function"><span class="keyword">function</span>(<span class="params"> url, callback </span>) </span>&#123;</div><div class="line">    $.ajax(&#123;</div><div class="line">        url: url,</div><div class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> ( callback ) &#123; callback( data ); &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> getUrlBridge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> url = $( <span class="keyword">this</span> ).attr( <span class="string">"href"</span> );</div><div class="line">    </div><div class="line">    getUrl( url, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( data );</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">$( <span class="string">"a.ajax"</span> ).on( <span class="string">"click"</span>, getUrlBridge );</div></pre></td></tr></table></figure><h3><span id="外观模式">外观模式</span></h3><p>外观模式在前端开发中很普遍，因为有太多的跨浏览器问题。外观模式为这种不统一提供了一个统一的 API。在下面代码中，我们为各个浏览器抽象出了一个统一的添加事件监听的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/ Facade</div><div class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params"> element, type, eventHandler </span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> ( element.addEventListener ) &#123;</div><div class="line">element.addEventListener( type, eventHandler, <span class="literal">false</span> );</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( elemement.attachEvent ) &#123;</div><div class="line">element.attachEvent( <span class="string">"on"</span> + type, eventHandler );    </div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3><span id="适配器模式">适配器模式</span></h3><p>适配器模式是实现代码之间合作的方式。当你需要切换到使用其它库，而又不能忍受重写大量代码时，适配器模式将非常凑效。在下面代码中，我修改了 jQuery 的 <code>$.when</code> 方法，使其与 <code>WinJS.Promise</code> 方法兼容。这是我在 appendTo 工作时写的代码，当时我们希望在 Windows 8 APP 中可以使用 jQuery。你可以在 <a href="https://github.com/appendto/jquery-win8" target="_blank" rel="external">jquery-win8</a> 中找到这段代码。</p><blockquote><p>jquery-win8 库的大部分功能已经不再需要了，因为 Jonathan Sampson 已经与 jQuery 开发团队一起协作，以确保他对这一垫片的更新被添加到 jQuery 2.0 版本中，<a href="http://appendto.com/blog/2013/03/windows-store-applications-with-jquery-2-0/" target="_blank" rel="external">这篇文章</a>记录了这一点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * jquery-win8-deferred - jQuery $.when that understands WinJS.promise</span></div><div class="line"><span class="comment"> * version: 0.1</span></div><div class="line"><span class="comment"> * author: appendTo, LLC</span></div><div class="line"><span class="comment"> * copyright: 2012</span></div><div class="line"><span class="comment"> * license: MIT (http://www.opensource.org/licenses/mit-license)</span></div><div class="line"><span class="comment"> * date: Thu, 01 Nov 2012 07:38:13 GMT</span></div><div class="line"><span class="comment"> */</span></div><div class="line"> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> $when = $.when;</div><div class="line">    $.when = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line"> </div><div class="line">        args = $.map(args, <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> WinJS.Promise) &#123;</div><div class="line">                arg = $.Deferred(<span class="function"><span class="keyword">function</span> (<span class="params">dfd</span>) </span>&#123;</div><div class="line">                    arg.then(</div><div class="line">                        <span class="function"><span class="keyword">function</span> <span class="title">complete</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                            dfd.resolveWith(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">                        &#125;, <span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                            dfd.rejectWith(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">                        &#125;, <span class="function"><span class="keyword">function</span> <span class="title">progress</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                            dfd.notifyWith(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">                        &#125;</div><div class="line">                    );</div><div class="line">                &#125;).promise();</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="keyword">return</span> arg;</div><div class="line">        &#125;);</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> $when.apply(<span class="keyword">this</span>, args);</div><div class="line">    &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure><h3><span id="观察者模式">观察者模式</span></h3><p>我已经在本系列的 <a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/">Blue Bird</a> 一文中阐述了观察者模式，这是一个强大的模式，可以实现各种组件的解耦。个人推荐使用 <a href="https://github.com/postaljs/postal.js" target="_blank" rel="external">postal.js</a> 库。</p><h2><span id="更多模式">更多模式</span></h2><h3><span id="继承">继承</span></h3><p>在 JavaScript 中实现继承有多种方式，当你在应用中创建对象时，最好了解一下下面的这些方式。</p><h4><span id="原型继承">原型继承</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bird = &#123;</div><div class="line">    name: <span class="string">"Red Bird"</span>,</div><div class="line">    power: <span class="string">""</span>,</div><div class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;,</div><div class="line">    catapult: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">" is catapulting with "</span> + <span class="keyword">this</span>.power;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> yellowBird = <span class="built_in">Object</span>.create( bird );</div><div class="line">yellowBird.name = <span class="string">"Yellow Bird"</span>;</div><div class="line">yellowBird.power = <span class="string">"Speed"</span>;</div><div class="line"><span class="built_in">console</span>.log( yellowBird.catapult() );</div></pre></td></tr></table></figure><h4><span id="模拟继承">模拟继承</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Bird = <span class="function"><span class="keyword">function</span>(<span class="params"> name, power </span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name + <span class="string">" Bird"</span>;</div><div class="line">    <span class="keyword">this</span>.power = power || <span class="string">""</span>;</div><div class="line">&#125;;</div><div class="line">Bird.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line">Bird.prototype.catapult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getName() + <span class="string">" is catapulting with "</span> + <span class="keyword">this</span>.power;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> YellowBird = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.constructor.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">&#125;;</div><div class="line">YellowBird.prototype = <span class="keyword">new</span> Bird();</div><div class="line"> </div><div class="line"><span class="keyword">var</span> yellowBird = <span class="keyword">new</span> YellowBird( <span class="string">"Yellow"</span>, <span class="string">"Speed"</span> );</div><div class="line">yellowBird.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"Super Awesome "</span> + <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log( yellowBird.catapult() );</div></pre></td></tr></table></figure><h3><span id="链式调用">链式调用</span></h3><p>由于 jQuery 库，链式调用在前端开发中变得流行起来。其实实现起来非常简单，你只需要在每一个方法结束时返回 <code>this</code>，这样就可以立即调用对象中的其它方法，请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bird = &#123;</div><div class="line">    catapult: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Yippeeeeee!"</span> );</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;,</div><div class="line">    destroy: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"That'll teach you... you dirty pig!"</span> );</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">bird.catapult().destroy();</div></pre></td></tr></table></figure><h3><span id="封装模式">封装模式</span></h3><p>我在 <a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/">Red Bird</a> 一文中已经阐述了封装模式，只不过当时说的是 IIFE。封装模式允许你拥有公共和私有的属性和方法，以此来封装你的代码。下面是一个非常简单的示例。更多细节请参阅文章 <a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/">Red Bird</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IIFE</span></div><div class="line"><span class="keyword">var</span> yellowBird = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> superSecret  = &#123;</div><div class="line">        power: <span class="string">"Speed"</span> </div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        type: <span class="string">"Red"</span>,</div><div class="line">        mood: <span class="string">"Angry"</span>,</div><div class="line">        goal: <span class="string">"Vengence"</span></div><div class="line">    &#125;</div><div class="line">&#125;());</div></pre></td></tr></table></figure><h3><span id="有限状态机">有限状态机</span></h3><p>有限状态机是我最喜欢的模式之一，我的朋友 Jim Cowart (<a href="http://twitter.com/ifandelse" target="_blank" rel="external">@ifandelse</a>) 创建了 <a href="https://github.com/ifandelse/machina.js" target="_blank" rel="external">Machina.js</a> 库来在 JavaScript 中实现这一模式，更多信息请参考他的<a href="http://freshbrewedcode.com/jimcowart/2012/03/12/machina-js-finite-state-machines-in-javascript/" target="_blank" rel="external">博客文章</a>和 <a href="https://github.com/ifandelse/machina.js" target="_blank" rel="external">GitHub 库</a>。下面示例是使用状态机来描述愤怒的小鸟。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> attackFsm = <span class="keyword">new</span> machina.Fsm(&#123;</div><div class="line">    initialState: <span class="string">"idle"</span>,</div><div class="line">    states : &#123;</div><div class="line">        <span class="string">"idle"</span> : &#123;</div><div class="line">            _onEnter: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.handle( <span class="string">"Zzzzzz"</span> );</div><div class="line">            &#125;,</div><div class="line">            <span class="string">"bird.launch"</span> : <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log( <span class="string">"Weeeeee at "</span> + data.angle + <span class="string">" degrees!"</span> );</div><div class="line">                <span class="keyword">this</span>.transition( <span class="string">"attacking"</span> );</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="string">"attacking"</span> : &#123;</div><div class="line">            _onEnter: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log( <span class="string">"Yay, hear me tweet!"</span> );</div><div class="line">            &#125;,</div><div class="line">            <span class="string">"pig.destroyed"</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.transition( <span class="string">"victorious"</span> );</div><div class="line">            &#125;,</div><div class="line">            <span class="string">"pig.alive"</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.transition( <span class="string">"defeated"</span> );</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="string">"victorious"</span>: &#123;</div><div class="line">            _onEnter: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log( <span class="string">"Yay, we are victorious!"</span> );</div><div class="line">            &#125;,</div><div class="line">            <span class="string">"game.restart"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.transition( <span class="string">"idle"</span> );</div><div class="line">            &#125;,</div><div class="line">            <span class="string">"game.next"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="comment">// Goto next level</span></div><div class="line">                <span class="keyword">this</span>.transition( <span class="string">"idle"</span> );</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="string">"defeated"</span>: &#123;</div><div class="line">            _onEnter: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log( <span class="string">"You may have won this time, but I'll be back!"</span> );</div><div class="line">            &#125;,</div><div class="line">            <span class="string">"gmae.restart"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.transition( <span class="string">"idle"</span> );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">attackFsm.handle( <span class="string">"bird.launch"</span>, &#123; <span class="attr">angle</span>: <span class="number">45</span> &#125; );</div><div class="line">attackFsm.handle( <span class="string">"pig.destroyed"</span> );</div></pre></td></tr></table></figure><h2><span id="建议">建议</span></h2><p>除了学习这些设计模式之外，我建议你选择一个你最喜欢的库，然后深入研究它的源代码，你可以从中学到有价值的东西。起初时某些代码可能很难理解，但坚持一段时间后，你可以从那些真正理解这些设计模式的库开发者身上学到很多干货。你也可以选择其中某个特别的方法并深入研究它，如果你不知道到哪里去寻找这样的特别方法，为什么不选择 jQuery？并使用 James Padolsey (<a href="http://twitter.com/padosley" target="_blank" rel="external">@padosley</a>) 的 <a href="http://james.padolsey.com/jquery/" target="_blank" rel="external">jQuery Source Viewer</a> 来帮你寻找。</p><h2><span id="附加资源">附加资源</span></h2><p>有太多的设计模式，以至于我无法一一在此列出，在我之前已经有太多关于设计模式的博客，而已还会有更多。如果我错过了任何好的设计模式，请告知我。</p><ul><li><a href="http://www.joezimjs.com/javascript/javascript-design-patterns-singleton/" target="_blank" rel="external">JavaScript Design Patterns</a> by Joe Zim (<a href="http://twitter.com/JoeZimJS" target="_blank" rel="external">@JoeZimJS</a>)</li><li><a href="http://net.tutsplus.com/tutorials/javascript-ajax/digging-into-design-patterns-in-javascript/" target="_blank" rel="external">Understanding Design Patterns in JavaScript</a> by Tilo Mitra (<a href="http://twitter.com/tilomitra" target="_blank" rel="external">@tilomitra</a>)</li><li><a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/" target="_blank" rel="external">Learning JavaScript Design Patterns</a> by Addy Osmani (<a href="http://twitter.com/addyosmani" target="_blank" rel="external">@addyosmani</a>)</li><li><a href="http://shichuan.github.io/javascript-patterns/" target="_blank" rel="external">JS Patterns</a> by Shi Chuan (<a href="http://twitter.com/shichuan" target="_blank" rel="external">@shichuan</a>)</li><li><a href="http://shop.oreilly.com/product/9780596806767.do" target="_blank" rel="external">JavaScript Patterns</a> by Stoyan Stefanov (<a href="http://twitter.com/xyz" target="_blank" rel="external">@xyz</a>)</li><li><a href="http://shop.oreilly.com/product/9780596517748.do" target="_blank" rel="external">JavaScript: The Good Parts</a> by Douglas Crockford</li></ul><h2><span id="进攻">进攻</span></h2><p>下面是一个用 <a href="http://incompl.github.com/boxbox/" target="_blank" rel="external">boxbox</a> 构建的简易版 Angry Birds，boxbox 是一个用于 <a href="https://code.google.com/p/box2dweb/" target="_blank" rel="external">box2dweb</a> 的物理学框架，由 <a href="http://bocoup.com/" target="_blank" rel="external">Bocoup</a> 的 <a href="http://twitter.com/_gsmith" target="_blank" rel="external">Greg Smith</a> 编写。</p><blockquote><p>按下空格键来发射大兄弟，你也可以使用方向键。</p></blockquote><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-big-brother-bird-patterns-attack.png" alt=""></p><h2><span id="结论">结论</span></h2><p>你不知道所有的这些设计模式也能完成前端开发，但是了解一些经常重复使用的设计模式确实大有益处。一旦习惯使用这些设计模式，架构设计时变得更加容易，也可以更快找到解决方案。你可以花一些时间去学习附加资源中的东西，然后着手选择适合目前的你的设计模式。</p><p>还有很多其他的前端架构技术也被猪偷走了。接下来，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p><p class="j-quote">原文：<a href="http://www.elijahmanor.com/angry-birds-of-javascript-big-brother-bird-patterns/" target="_blank" rel="external">Angry Birds of JavaScript- Big Brother Bird: Patterns</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-of-javascript-big-brother-bird-patterns.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）&lt;/p&gt;
&lt;p&gt;小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读本系列的&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/&quot;&gt;介绍文章&lt;/a&gt;，查看所有小鸟以及它们的进攻力量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;战况&quot;&gt;&lt;a href=&quot;#战况&quot; class=&quot;headerlink&quot; title=&quot;战况&quot;&gt;&lt;/a&gt;战况&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/&quot;&gt;红色大鸟 - 立即调用的函数表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/&quot;&gt;蓝色小鸟 - 事件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/&quot;&gt;黄色小鸟 - 模块化、依赖管理、性能优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/&quot;&gt;黑色小鸟 - 前端分层架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/04/14/angry-birds-of-javascript-white-bird-linting/&quot;&gt;白色小鸟 - 代码质量和代码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/04/17/angry-birds-of-javascript-green-bird-mocking/&quot;&gt;绿色小鸟 - 模拟请求和模拟数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/04/18/angry-birds-of-javascript-orange-bird-templating/&quot;&gt;橙色小鸟 - 模板引擎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;大兄弟的攻击力&quot;&gt;&lt;a href=&quot;#大兄弟的攻击力&quot; class=&quot;headerlink&quot; title=&quot;大兄弟的攻击力&quot;&gt;&lt;/a&gt;大兄弟的攻击力&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-big-brother-bird.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文我们将看看大兄弟，它拿出了重武器：有限状态机和成熟的设计模式，渐渐的，它们逐一夺回了本属于它们的东西&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Architecture" scheme="http://bubkoo.com/tags/architecture/"/>
    
      <category term="Pattern" scheme="http://bubkoo.com/tags/pattern/"/>
    
  </entry>
  
  <entry>
    <title>橙色小鸟 - 模板系统</title>
    <link href="http://bubkoo.com/2014/04/18/angry-birds-of-javascript-orange-bird-templating/"/>
    <id>http://bubkoo.com/2014/04/18/angry-birds-of-javascript-orange-bird-templating/</id>
    <published>2014-04-18T21:39:35.000Z</published>
    <updated>2014-04-18T21:39:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-orange-bird-templating.jpg" alt=""></p><p>一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）</p><p>小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p><blockquote><p>阅读本系列的<a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/">介绍文章</a>，查看所有小鸟以及它们的进攻力量。</p></blockquote><h2><span id="战况">战况</span></h2><ul><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/">红色大鸟 - 立即调用的函数表达式</a></li><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/">蓝色小鸟 - 事件</a></li><li><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/">黄色小鸟 - 模块化、依赖管理、性能优化</a></li><li><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/">黑色小鸟 - 前端分层架构</a></li><li><a href="http://bubkoo.com/2014/04/14/angry-birds-of-javascript-white-bird-linting/">白色小鸟 - 代码质量和代码分析</a></li><li><a href="http://bubkoo.com/2014/04/17/angry-birds-of-javascript-green-bird-mocking/">绿色小鸟 - 模拟请求和模拟数据</a></li></ul><h2><span id="橙色小鸟的攻击力">橙色小鸟的攻击力</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-Orange-bird.png" alt=""></p><p>本文我们将一起来看看橙色小鸟。开始时，它是一个简单的模板，然后被解析成为 DOM 对象，这明确传达了一个消息就是小鸟们是认真的。渐渐的，小鸟们一个接一个地夺回了本属于他们的东西。</p><a id="more"></a><h2><span id="猪偷走了什么">猪偷走了什么</span></h2><p>近几年来，有一个趋势就是，Web 开发中越来越多的工作都由前端来完成。我们通过 AJAX 或者 Web Socket 与后端通信，然后将数据以某种方式渲染在 UI 上。大多数前端都是使用字符串拼接的方式来构建丰富的用户界面，这就出现了很多烦人的代码，并可能导致一些错误。这时，橙色小鸟走过来说：“嘿，我们有更好的方式吗？我们可以以某种方式将数据和视图分开吗？”，这就是模板引擎进入小鸟们世界的开端。橙色小鸟从人类那里借来了一些模板库，比如 Underscore.js 和 <a href="http://handlebarsjs.com/" target="_blank" rel="external">Handlebar.js</a>，来满足这种需求。</p><p>然而，在小猪进攻过程中，小鸟们的模板库被盗走了。现在，一只橙色小鸟被派去夺回失窃的模板库。它将使用爆炸性的力量去摧毁猪群，夺回本属于它们的东西。</p><h2><span id="为什么要使用模板引擎">为什么要使用模板引擎</span></h2><p>开始深入之前，我们先看看为什么需要模板引擎。我开发的越多，就越想找到将应用各个部分分开的方式，将太多东西放在同一处让我觉得恶心。看看下面一段代码，然后告诉我你的感受…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> twitter, $, undefined </span>) </span>&#123; </div><div class="line">    <span class="keyword">var</span> _selection;</div><div class="line">        </div><div class="line">    twitter.init = <span class="function"><span class="keyword">function</span>(<span class="params"> $selection </span>) </span>&#123;</div><div class="line">        _selection = $selection;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    twitter.displayTweets = <span class="function"><span class="keyword">function</span>(<span class="params"> tweets </span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> $list = $( <span class="string">"&lt;ul/ &gt;"</span> );</div><div class="line">        </div><div class="line">        $.each( tweets || &#123;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"> index, tweet </span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> html = <span class="string">"&lt;i&gt;"</span> + moment( tweet.created_at ).fromNow() + <span class="string">"&lt;/i&gt;: "</span>;</div><div class="line">            html += <span class="string">"&lt;b&gt;"</span> + tweet.user.name + <span class="string">"&lt;/b&gt; - "</span>;</div><div class="line">            html += <span class="string">"&lt;span&gt;"</span> + tweet.text + <span class="string">"&lt;/span&gt;"</span>;</div><div class="line">            html += tweet.retweeted ? <span class="string">" &lt;i class='icon-repeat'&gt;&lt;/i&gt;"</span> : <span class="string">""</span>;</div><div class="line">            html += tweet.favorited ? <span class="string">" &lt;i class='icon-star'&gt;&lt;/i&gt;"</span> : <span class="string">""</span>;</div><div class="line">            </div><div class="line">            $( <span class="string">"&lt;li /&gt;"</span>, &#123; <span class="attr">html</span>: html &#125;).appendTo( $list );         </div><div class="line">        &#125;);</div><div class="line">            </div><div class="line">       _selection.empty().append( $list.children() );         </div><div class="line">    &#125;;</div><div class="line">&#125;( <span class="built_in">window</span>.twitter = <span class="built_in">window</span>.twitter || &#123;&#125;, jQuery ));</div></pre></td></tr></table></figure><p>是吧，你也不喜欢字符串拼接的方式。我不希望在我的代码里面出现展现相关的代码。不过这样做它确实可以工作，你可以看到内嵌的 jsFiddle 的输出结果。</p><iframe allowfullscreen="allowfullscreen" frameborder="0" height="200" src="http://jsfiddle.net/B4fJB/embedded/result,js,html" width="100%"></iframe><p>那么我们将如何做呢？模板引擎就可以帮助我们简化我们的代码，并将 HTML 标签从代码中独立出来。</p><h2><span id="underscorejs">Underscore.js</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-orange-bird-templating-underscore.png" alt="Underscore"></p><p>我们来看看 Underscore.js 库中提供的模板方法。在我最近的一些项目中我都趋向于使用 Underscore，因此我切实感受到了它的强大。如果我正在做的工作非常简单，那么我通常会默认使用 Underscore 模板引擎。然而，你会看到它有一些局限性，因此我们将看看下一个更吸引人的库。</p><h3><span id="示例1">示例1</span></h3><p>下面就是使用 Underscore 模板引擎重新的上面示例的代码，你会发现代码大大地精简了！哈哈！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">twitter.displayTweets = <span class="function"><span class="keyword">function</span>(<span class="params"> tweets </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> templateString = $( <span class="string">"#tweets-underscore"</span> ).html(),</div><div class="line">        template = _.template( templateString );</div><div class="line">    </div><div class="line">   _selection.empty().append( template( &#123; <span class="attr">tweets</span>: tweets &#125; ) );                   </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-orange-bird-templating-Inflated-orange-bird-sprite.png" alt=""></p><p>大部分工作都由模板来完成了，模板中包含大量标记。现在我们的橙色小鸟看起来就完全不同了;) 将模板放入一个 <code>script</code> 标签中，并给标签指定一个 ID，模板中的特殊标记 <code>&lt;%= expression %&gt;</code> 表示将要插入的变量的值，你也可以在 <code>&lt;% statements %&gt;</code> 中插入任意的 JavaScript 语法（如循环、流程控制等）！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"tweets-underscore"</span> <span class="attr">type</span>=<span class="string">"text/template"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></div><div class="line"><span class="javascript">        &lt;% _.each( tweets, <span class="function"><span class="keyword">function</span>(<span class="params"> tweet </span>) </span>&#123; %&gt;</span></div><div class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></div><div class="line"><span class="javascript">            &lt;i&gt;<span class="xml"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">moment</span>( <span class="attr">tweet.created_at</span> )<span class="attr">.fromNow</span>() %&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span>:</span></div><div class="line"><span class="javascript">            &lt;b&gt;<span class="xml"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">tweet.user.name</span> %&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span> - </span></div><div class="line"><span class="javascript">            &lt;span&gt;<span class="xml"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">tweet.text</span> %&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> </span></div><div class="line"><span class="javascript">            &lt;% <span class="keyword">if</span> ( tweet.retweeted ) &#123; %&gt;<span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon-repeat"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span> </span></span></div><div class="line"><span class="javascript">            &lt;% <span class="keyword">if</span> ( tweet.favorited ) &#123; %&gt;<span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon-star"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span></span></div><div class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></div><div class="line"><span class="xml">        <span class="tag">&lt;<span class="name">%</span> &#125;); %&gt;</span></span></div><div class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>你可以在 <a href="http://jsfiddle.net/wkH3k/" target="_blank" rel="external">jsFiddle</a> 中试验上面的代码。</p><p>正如 Uncle Ben 所说：“能力越大，责任就越大。”</p><p><img src="http://bubkoo.qiniudn.com/with_great_power_comes_great_responsibility_by_itomibhaa-d4lajvl.jpg" alt=""></p><p>在现实环境中，允许在模板中插入任意的代码并不好，在模板中放入数据操作逻辑将使单元测试难以开展。试想一下，如果在模板中混入大量逻辑代码，情况会是怎样？如果你这样做，并没有解决我们刚刚提到的问题，即展现和逻辑混在一起。</p><h3><span id="示例2">示例2</span></h3><p>下面是使用 Underscore 的另一个例子，这次我们预先处理了数据。我使用了 <code>_.map()</code> 方法来将每个属性转换为预期的样式，这样做的缺点就是，在将数据传递给模板之前需要先遍历一边，这会导致一些性能开销。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">twitter.displayTweets = <span class="function"><span class="keyword">function</span>(<span class="params"> tweets </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> templateString = $( <span class="string">"#tweets-underscore"</span> ).html(),</div><div class="line">        template = _.template( templateString );</div><div class="line"> </div><div class="line">    tweets = _.map( tweets, <span class="function"><span class="keyword">function</span>(<span class="params"> tweet </span>) </span>&#123;</div><div class="line">        tweet.created_at = moment( tweet.created_at ).fromNow();</div><div class="line">        <span class="keyword">return</span> tweet;</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    _selection.empty().append( template( &#123; <span class="attr">tweets</span>: tweets &#125; ) );                   </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>我们可以将之前模板中的数据逻辑移除了，因为我们在上面的 JavaScript 中完成了这项工作。这个版本比上面的好，但是还可以更好。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"tweets-underscore"</span> <span class="attr">type</span>=<span class="string">"text/template"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></div><div class="line"><span class="javascript">        &lt;% _.each( tweets, <span class="function"><span class="keyword">function</span>(<span class="params"> tweet </span>) </span>&#123; %&gt;</span></div><div class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></div><div class="line"><span class="javascript">            &lt;i&gt;<span class="xml"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">tweet.created_at</span> %&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span>: </span></div><div class="line"><span class="javascript">            &lt;b&gt;<span class="xml"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">tweet.user.name</span> %&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span> - </span></div><div class="line"><span class="javascript">            &lt;span&gt;<span class="xml"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">tweet.text</span> %&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> </span></div><div class="line"><span class="javascript">            &lt;% <span class="keyword">if</span> ( tweet.retweeted ) &#123; %&gt;<span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon-repeat"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span> </span></span></div><div class="line"><span class="javascript">            &lt;% <span class="keyword">if</span> ( tweet.favorited ) &#123; %&gt;<span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon-star"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span></span></div><div class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></div><div class="line"><span class="xml">        <span class="tag">&lt;<span class="name">%</span> &#125;); %&gt;</span></span></div><div class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>你可以在 <a href="http://jsfiddle.net/auBUX/" target="_blank" rel="external">jsFiddle</a> 中试验上面的代码。</p><h3><span id="为什么使用-underscorejs">为什么使用 Underscore.js</span></h3><h4><span id="赞成">赞成</span></h4><ul><li>可以在模板中嵌入任意的 JavaScript 代码</li><li>非常轻量级</li><li>如果你正在使用 Backbone.js，那么你可以直接使用它</li><li>如果你正在使用 Underscore.js，那么你可以直接使用它</li><li>可以预编译模板</li><li>可以运行在客户端和服务端</li><li>你还能想到其他的吗？</li></ul><h4><span id="反对">反对</span></h4><ul><li>可以在模板中嵌入任意的 JavaScript 代码</li><li>模板中没有 <code>this</code> 概念</li><li>你还能想到其他的吗？</li></ul><h2><span id="handlebarsjs">Handlebars.js</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-orange-bird-templating-handlebars-logo.png" alt="Handlebars"></p><p>总体来看，我更倾向于选择 Handlebars 模板引擎。Handlebars 鼓励你将展现和逻辑分开，速度也更快，并提供了一套预编译机制，我们将对此稍作深入的讨论。首先，我们换个角度看看本文之前提出的问题。下面代码是使用 Handlebars 的解决方案，这段代码和之前版本一样干净。同时你会发现，我在模板中使用了 <code>fromNow</code> 这个 helper 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">twitter.init = <span class="function"><span class="keyword">function</span>(<span class="params"> $selection </span>) </span>&#123;</div><div class="line">    _selection = $selection;</div><div class="line">    </div><div class="line">    Handlebars.registerHelper( <span class="string">"fromNow"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> time </span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> moment( time ).fromNow();</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">twitter.displayTweets = <span class="function"><span class="keyword">function</span>(<span class="params"> tweets </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> templateString = $( <span class="string">"#tweets-handlebars"</span> ).html(),</div><div class="line">        template = Handlebars.compile( templateString );</div><div class="line">                        </div><div class="line">    _selection.empty().append( template( tweets ) );         </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>下面是模板的语法，这种语法与 Underscore 相比更加简洁，这正是我喜欢的。在模板内部我使用了模板的帮助方法 <code>fromNow</code> 来转换时间。这非常好，因为我们不需要像在 Underscore 中那样预先转换数据，或在模板内部嵌入数据操作的逻辑代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"tweets-handlebars"</span> <span class="attr">type</span>=<span class="string">"text/x-handlebars-template"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></div><div class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><div class="hexo-insert-code"><script id="tweets-handlebars" type="text/x-handlebars-template">    <ul>    </ul></script></div><p>你可以在 <a href="http://jsfiddle.net/UeWHb/" target="_blank" rel="external">jsFiddle</a> 中试验上面的代码。</p><h2><span id="模板预编译">模板预编译</span></h2><p><img src="http://bubkoo.qiniudn.com/batman-unicorn-dolphins.jpg" alt=""></p><p>我在前面简单提到过，我喜欢 Handlebars 的原因之一是，它可以对模板进行预编译。这是什么意思呢！？！对于 Underscore 和 Handlebars，在使用模板之前都需要先编译模板（使用 Underscore 时你可以一步完成，但是在内部仍然需要先编译模板）。如果你打算多次重用同一个模板，或者你仅仅希望在使用模板时它就已经就绪，那么预编译就是很好的做法。然而，使用 Handlebars 可以帮你做更多，你可以在服务器端先编译好模板，然后直接在前端引用编译后的模板。这意味着这样可以大大减少前端的工作量，并且 Handlebars 有一个运行时的精简版本，其中只包含了必要的执行模板的方法（不是编译模板）。这太酷了，不是吗？如果你的答案是“这就像蝙蝠侠骑着彩虹独角兽和海豚在一起一样！”，那么你是对的，恭喜…</p><p>那么，它到底是如何工作的？好吧，首先你在服务器上用 Node 安装 Handlebars…</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g handlebars</div></pre></td></tr></table></figure><p>然后将模板内容（<code>script</code> 标签之间）提取到一个文件中，这里我们将其保存为 <code>tweets.tmpl</code>。现在运行 handlebars 预编译模板文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">handlebars tweets.tmpl -f tweets.tmpl.js</div></pre></td></tr></table></figure><p>完成之后，你就得到了模板的一个预编译版本，现在你可以在前端应用中引用它，就像下面这样…</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"tweets.tmpl.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>现在，预编译的模板在页面上是可用的，你可以通过 Handlebars 来访问到预编译的模板，这样你就可以开始使用它了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = Handlebars.templates[ <span class="string">"tweets.tmpl"</span> ],</div><div class="line">    markup = template( tweets );</div></pre></td></tr></table></figure><h2><span id="为什么使用-handlebarsjs">为什么使用 Handlebars.js</span></h2><h3><span id="赞成">赞成</span></h3><ul><li>它是一个弱逻辑模板引擎</li><li>支持服务端预编译模板</li><li>支持 Helper 方法</li><li>可以运行在客户端和服务端</li><li>在模板中支持 <code>this</code> 的概念</li><li>它是 Mustache.js 的超集</li><li>你能想到其他的吗？</li></ul><h3><span id="反对">反对</span></h3><ul><li>你能想到任何理由吗？</li></ul><h2><span id="其他模板引擎怎么样">其他模板引擎怎么样</span></h2><p>这个问题问的非常好，也许你的需求和我不一样，或者你只是单纯不喜欢某个我提到的模板引擎。如果是这样的话，那么你应该看看由 Garann Means (<a href="http://twitter.com/garannm" target="_blank" rel="external">@garannm</a>) 创建的<a href="http://garann.github.io/template-chooser/" target="_blank" rel="external">模板选择工具</a>，这是一个很强大的工具，它将询问你一组问题，来辅助判断哪个模板引擎适合你的需求，界面看起就像下面的例子…</p><p><img src="http://bubkoo.qiniudn.com/template-chooser.png" alt=""></p><h2><span id="其他资源">其他资源</span></h2><ul><li><a href="http://net.tutsplus.com/tutorials/javascript-ajax/introduction-to-handlebars/" target="_blank" rel="external">An Introduction to Handlebars</a> by Gabriel Manricks (<a href="http://twitter.com/GabrielManricks" target="_blank" rel="external">@GabrielManricks</a>)</li><li><a href="http://net.tutsplus.com/tutorials/javascript-ajax/best-practices-when-working-with-javascript-templates/" target="_blank" rel="external">Best Practices When Working With JavaScript Templates</a> by Andrew Burgess (<a href="http://twitter.com/andrew8088" target="_blank" rel="external">@andrew8088</a>)</li><li><a href="http://css.dzone.com/articles/demo-handlebars-and-why-you" target="_blank" rel="external">Demo of Handlebars, and Why You Should Consider a Templating Engine</a> Raymond Camden(<a href="http://twitter.com/cfjedimaster" target="_blank" rel="external">@cfjedimaster</a>)</li><li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/template/" target="_blank" rel="external">HTML’s New Template Tag: Standardizing Client-Side Templating</a> by Eric Bidelman (<a href="http://twitter.com/ebidel" target="_blank" rel="external">@ebidel</a>)</li></ul><h2><span id="进攻">进攻</span></h2><p>下面是一个用 <a href="http://incompl.github.com/boxbox/" target="_blank" rel="external">boxbox</a> 构建的简易版 Angry Birds，boxbox 是一个用于 <a href="https://code.google.com/p/box2dweb/" target="_blank" rel="external">box2dweb</a> 的物理学框架，由 <a href="http://bocoup.com/" target="_blank" rel="external">Bocoup</a> 的 <a href="http://twitter.com/_gsmith" target="_blank" rel="external">Greg Smith</a> 编写。</p><blockquote><p>按下空格键来发射橙色小鸟，你也可以使用方向键。</p></blockquote><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-orange-bird-templating-attact.png" alt=""></p><h2><span id="结论">结论</span></h2><p>在代码中混入 HTML 标记非常让人讨厌，代码繁琐、枯燥，并且难以维护。将各个部分按职能分开，不仅简化了代码，而且保证了各部分各司其职，带来了极大的好处。值得庆幸的是，像 Underscore 和 Handlebars 这样的库提供了一种清晰的方式，将展现描述从逻辑中分离出来。你可以自由选择使用什么库，但是我鼓励你多进行一些比较，找到最适合你的库。因此这个问题的答案可能是不仅仅使用一个库，这才是一个不错的选择。</p><p>还有很多其他的前端架构技术也被猪偷走了。接下来，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p><p class="j-quote">原文：<a href="http://www.elijahmanor.com/angry-birds-of-javascript-orange-bird-templating/" target="_blank" rel="external">Angry Birds of JavaScript- Orange Bird: Templating</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-of-javascript-orange-bird-templating.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）&lt;/p&gt;
&lt;p&gt;小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读本系列的&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/&quot;&gt;介绍文章&lt;/a&gt;，查看所有小鸟以及它们的进攻力量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;战况&quot;&gt;&lt;a href=&quot;#战况&quot; class=&quot;headerlink&quot; title=&quot;战况&quot;&gt;&lt;/a&gt;战况&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/&quot;&gt;红色大鸟 - 立即调用的函数表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/&quot;&gt;蓝色小鸟 - 事件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/&quot;&gt;黄色小鸟 - 模块化、依赖管理、性能优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/&quot;&gt;黑色小鸟 - 前端分层架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/04/14/angry-birds-of-javascript-white-bird-linting/&quot;&gt;白色小鸟 - 代码质量和代码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/04/17/angry-birds-of-javascript-green-bird-mocking/&quot;&gt;绿色小鸟 - 模拟请求和模拟数据&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;橙色小鸟的攻击力&quot;&gt;&lt;a href=&quot;#橙色小鸟的攻击力&quot; class=&quot;headerlink&quot; title=&quot;橙色小鸟的攻击力&quot;&gt;&lt;/a&gt;橙色小鸟的攻击力&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-Orange-bird.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文我们将一起来看看橙色小鸟。开始时，它是一个简单的模板，然后被解析成为 DOM 对象，这明确传达了一个消息就是小鸟们是认真的。渐渐的，小鸟们一个接一个地夺回了本属于他们的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Architecture" scheme="http://bubkoo.com/tags/architecture/"/>
    
      <category term="Template" scheme="http://bubkoo.com/tags/template/"/>
    
  </entry>
  
  <entry>
    <title>绿色小鸟 - 模拟请求和模拟数据</title>
    <link href="http://bubkoo.com/2014/04/17/angry-birds-of-javascript-green-bird-mocking/"/>
    <id>http://bubkoo.com/2014/04/17/angry-birds-of-javascript-green-bird-mocking/</id>
    <published>2014-04-17T21:39:20.000Z</published>
    <updated>2014-04-17T21:39:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-green-bird-mocking.png" alt=""></p><p>一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）</p><p>小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p><blockquote><p>阅读本系列的<a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/">介绍文章</a>，查看所有小鸟以及它们的进攻力量。</p></blockquote><h2><span id="战况">战况</span></h2><ul><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/">红色大鸟 - 立即调用的函数表达式</a></li><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/">蓝色小鸟 - 事件</a></li><li><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/">黄色小鸟 - 模块化、依赖管理、性能优化</a></li><li><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/">黑色小鸟 - 前端分层架构</a></li><li><a href="http://bubkoo.com/2014/04/14/angry-birds-of-javascript-white-bird-linting/">白色小鸟 - 代码质量和代码分析</a></li></ul><h2><span id="绿色小鸟的攻击力">绿色小鸟的攻击力</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-green-bird.png" alt=""></p><p>本文将介绍绿色小鸟，它可以穿透那些难以抵达的地方，并且伪装和监视那些偷东西的小猪，这正是他们的攻击力。渐渐地，他们夺回了属于他们的东西。</p><a id="more"></a><h2><span id="猪猪偷走了什么">猪猪偷走了什么</span></h2><p>大多数鸟都是前端开发人员，不怎么关注后端。结果小鸟和水牛就形成了共生关系，水牛编写后端代码，小鸟做前端开发。这种安排有个问题就是，当水牛们正在做后端开发时，小鸟们只能在旁边玩弄自己的羽毛，直到后端开发完成。然而，一旦完成后端开发，项目的交付压力就落在了小鸟们身上，而水牛们却在树荫下的水坑中悠哉。幸运的是，不久前一只绿色小鸟提出了模拟后端服务的想法，这样在它们在等待水牛完成后端开发的同时，也能同步进行前端开发。同时，它还引入了一些很方便的库，使模拟过程变得更加容易。</p><p>但是，在小猪的进攻过程中，小鸟们的模拟库被偷走了。然后，一只绿色小鸟被派去夺回被偷走的东西。它将使用具有颠覆力量的诡计去夺回本属于它们的东西。</p><h2><span id="twitter-应用">Twitter 应用</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-green-bird-mocking-twitter.jpg" alt=""></p><p>我们一起来一个简单的 Twitter 应用，根据用户名获取 Twitter 消息。为什么是 Twitter？因为愤怒的小鸟们与 Twitter 有特殊的关系，尤其是蓝色小鸟 ;)</p><p>下面的应用使用 JSONP 从 Twitter 获取数据，我曾经想使用 Backbone 来编写这个应用，但是考虑到这样做可能会使模拟（mocking）的概念不是那么清晰，并且我也没有使用模板引擎，我是故意这样做的，另一只愤怒的小鸟将介绍模板引擎的概念 ;)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> twitter, $, undefined </span>) </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">var</span> channel = twitter.channel = postal.channel(),</div><div class="line">        URL_TEMPLATE = <span class="string">"https://api.twitter.com/1/statuses/user_timeline/"</span> + </div><div class="line">            <span class="string">"%(userName)s.json?count=%(count)s&amp;include_rts=1"</span>,</div><div class="line">        $selection = <span class="literal">null</span>;</div><div class="line">        </div><div class="line">    twitter.selector = <span class="literal">null</span>;</div><div class="line"> </div><div class="line">    twitter.init = <span class="function"><span class="keyword">function</span>(<span class="params"> selector </span>) </span>&#123;</div><div class="line">        twitter.selector = selector;</div><div class="line">        </div><div class="line">        channel.subscribe( <span class="string">"tweets.available"</span>, twitter.displayTweets );    </div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    twitter.displayTweets = <span class="function"><span class="keyword">function</span>(<span class="params"> tweets </span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> $list = $( <span class="string">"&lt;ul/ &gt;"</span> ),</div><div class="line">            $location = $selection || $( twitter.selector );</div><div class="line">        </div><div class="line">        <span class="comment">// This would be better suited for a templating engine,</span></div><div class="line">        <span class="comment">// but that's for another Angry Bird ;)</span></div><div class="line">        $.each( tweets || &#123;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"> index, tweet </span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> html = <span class="string">"&lt;i&gt;"</span> + moment( tweet.created_at ).fromNow() + <span class="string">"&lt;/i&gt;: "</span>;</div><div class="line">            html += <span class="string">"&lt;b&gt;"</span> + tweet.user.name + <span class="string">"&lt;/b&gt; - "</span>;</div><div class="line">            html += tweet.text;</div><div class="line">            html += tweet.retweeted ? <span class="string">" &lt;i class='icon-repeat'&gt;&lt;/i&gt;"</span> : <span class="string">""</span>;</div><div class="line">            html += tweet.favorited ? <span class="string">" &lt;i class='icon-star'&gt;&lt;/i&gt;"</span> : <span class="string">""</span>;</div><div class="line">            </div><div class="line">            $( <span class="string">"&lt;li /&gt;"</span>, &#123; <span class="attr">html</span>: html &#125;).appendTo( $list );         </div><div class="line">        &#125;);</div><div class="line">            </div><div class="line">       $location.append( $list.children() );         </div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    twitter.getTweets = <span class="function"><span class="keyword">function</span>(<span class="params"> userName, count </span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> url = _.string.sprintf( URL_TEMPLATE, &#123; </div><div class="line">                userName: userName, </div><div class="line">                count: count || <span class="number">5</span> </div><div class="line">            &#125;);</div><div class="line"> </div><div class="line">        $.ajax(&#123;</div><div class="line">            url: url,</div><div class="line">            dataType: <span class="string">"jsonp"</span>,</div><div class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params"> tweets </span>) </span>&#123;</div><div class="line">                channel.publish( <span class="string">"tweets.available"</span>, tweets );</div><div class="line">            &#125;</div><div class="line">        &#125;);                </div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">&#125;( <span class="built_in">window</span>.twitter = <span class="built_in">window</span>.twitter || &#123;&#125;, jQuery ));</div><div class="line"> </div><div class="line">twitter.init( <span class="string">".tweets"</span> );</div><div class="line"> </div><div class="line">$( <span class="built_in">document</span> ).on( <span class="string">"click"</span>, <span class="string">"button"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> $input = $( <span class="keyword">this</span> ).closest( <span class="string">"form"</span> ).find( <span class="string">"input"</span> );</div><div class="line">    </div><div class="line">    e.preventDefault();                                                 </div><div class="line">    twitter.getTweets( $input.val() || <span class="string">"elijahmanor"</span> );    </div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>上面的代码片段用 jsFiddle 嵌入在了下面</p><h2><span id="使用-apitwittercom-的-twitter-应用">使用 api.twitter.com 的 Twitter 应用</span></h2><iframe allowfullscreen="allowfullscreen" frameborder="0" height="300" src="http://jsfiddle.net/KXr8U/1/embedded/result,html" width="100%"></iframe><p>从 Twitter 返回的数据看起来像下面的截图：</p><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-green-bird-mocking-twitter-raw.png" alt=""></p><h2><span id="模拟静态数据">模拟静态数据</span></h2><p>如果 Twitter 服务器挂掉了，或者不稳定，或者你只是想在没有联网的情况下测试你的应用，会怎么样呢？这个时候模拟后端服务的优势就凸显出来了。我们可以使用 Mockjax 这个 jQuery 库，你只需要调用 <code>$.mockjax</code> 方法，并提供你想监听的 <code>url</code> 和你想要返回的数据。下面是一个模拟 api.twitter.com 并返回一些静态数据的示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$.mockjax(&#123;</div><div class="line">    url: <span class="string">"https://api.twitter.com/1/statuses/user_timeline/*"</span>,</div><div class="line">    responseTime: <span class="number">750</span>,</div><div class="line">    responseText: [</div><div class="line">        &#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">created_at</span>: <span class="string">"Mon Apr 11 8:00:00 +0000 2012"</span>,  <span class="attr">text</span>: <span class="string">"Test Tweet 1"</span>,</div><div class="line">            favorited: <span class="literal">false</span>, <span class="attr">retweeted</span>: <span class="literal">false</span>, <span class="attr">user</span>: &#123; <span class="attr">name</span>: <span class="string">"User 1"</span> &#125; &#125;,</div><div class="line">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">created_at</span>: <span class="string">"Mon Apr 11 9:00:00 +0000 2012"</span>,  <span class="attr">text</span>: <span class="string">"Test Tweet 2"</span>,</div><div class="line">            favorited: <span class="literal">true</span>,  <span class="attr">retweeted</span>: <span class="literal">true</span>,  <span class="attr">user</span>: &#123; <span class="attr">name</span>: <span class="string">"User 2"</span> &#125; &#125;,</div><div class="line">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">created_at</span>: <span class="string">"Mon Apr 11 10:00:00 +0000 2012"</span>, <span class="attr">text</span>: <span class="string">"Test Tweet 3"</span>,</div><div class="line">            favorited: <span class="literal">false</span>, <span class="attr">retweeted</span>: <span class="literal">true</span>,  <span class="attr">user</span>: &#123; <span class="attr">name</span>: <span class="string">"User 3"</span> &#125; &#125;,</div><div class="line">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">created_at</span>: <span class="string">"Mon Apr 11 11:00:00 +0000 2012"</span>, <span class="attr">text</span>: <span class="string">"Test Tweet 4"</span>,</div><div class="line">            favorited: <span class="literal">true</span>,  <span class="attr">retweeted</span>: <span class="literal">false</span>, <span class="attr">user</span>: &#123; <span class="attr">name</span>: <span class="string">"User 4"</span> &#125; &#125;,</div><div class="line">        &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">created_at</span>: <span class="string">"Mon Apr 11 12:00:00 +0000 2012"</span>, <span class="attr">text</span>: <span class="string">"Test Tweet 5"</span>,</div><div class="line">            favorited: <span class="literal">true</span>,  <span class="attr">retweeted</span>: <span class="literal">true</span>,  <span class="attr">user</span>: &#123; <span class="attr">name</span>: <span class="string">"User 5"</span> &#125; &#125;</div><div class="line">    ]</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这样前端开发就于后端独立开来，不仅这个很酷，在编写 AJAX 的单元测试时也非常方便。</p><p>上面的代码片段用 jsFiddle 嵌入在了下面。</p><h2><span id="使用-mockjax-的-twitter-应用">使用 Mockjax 的 Twitter 应用</span></h2><iframe allowfullscreen="allowfullscreen" frameborder="0" height="300" src="http://jsfiddle.net/ufqPC/1/embedded/result,html" width="100%"></iframe><p>从 Mockjax 返回的数据看起来像下面这样：</p><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-green-bird-mocking-twitter-mock-static.png" alt=""></p><h2><span id="模拟动态随机数据">模拟动态随机数据</span></h2><p>这种方式的一个缺点就是，静态的数据让开发者逐渐变得缺乏想象和懒惰。我通常的做法是，仍然使用相同的对象，只是在某些值上面加 1 或者其他一些东西。这样做很不错，但也很麻烦，而且还耗时，还不能让你了解真正的 UI 可能的样子。辛运的是，有一个非常好的库 - mockJSON，你需要为你的真实数据提供一个模板，指定字段的类型、长度等信息。下面是我重写后的代码，这将随机生成 5 到 10 个要显示的消息对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$.mockjax(&#123;</div><div class="line">    url: <span class="string">"https://api.twitter.com/1/statuses/user_timeline/*"</span>,</div><div class="line">    responseTime: <span class="number">750</span>,</div><div class="line">    response: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> data = $.mockJSON.generateFromTemplate(&#123;</div><div class="line">            <span class="string">"tweets|5-10"</span>: [&#123;</div><div class="line">                <span class="string">"id|+1"</span>: <span class="number">0</span>, </div><div class="line">                <span class="string">"created_at"</span>: <span class="string">"Mon Apr 11 @TIME_HH:@TIME_MM:@TIME_SS +0000 2012"</span>,</div><div class="line">                <span class="string">"text"</span>: <span class="string">"@LOREM_IPSUM"</span>,</div><div class="line">                <span class="string">"favorited|0-1"</span>: <span class="literal">false</span>,</div><div class="line">                <span class="string">"retweeted|0-1"</span>: <span class="literal">false</span>,</div><div class="line">                <span class="string">"user"</span>: &#123; <span class="string">"name"</span>: <span class="string">"@MALE_FIRST_NAME @LAST_NAME"</span> &#125;</div><div class="line">            &#125;]</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        <span class="keyword">this</span>.responseText = data.tweets;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>上面的代码用 jsFiddle 嵌入在了下面的页面中。</p><h2><span id="使用-mockjax-和-mockjson-的-twitter-应用">使用 Mockjax 和 mockJSON 的 Twitter 应用</span></h2><iframe allowfullscreen="allowfullscreen" frameborder="0" height="300" src="http://jsfiddle.net/cHS9q/1/embedded/result,html" width="100%"></iframe><p>使用 Mockjax 和 mockJSON 返回的数据看起来像下面这样：</p><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-green-bird-mocking-twitter-mock-dynamic.png" alt=""></p><h2><span id="进攻">进攻</span></h2><p>下面是一个用 <a href="http://incompl.github.com/boxbox/" target="_blank" rel="external">boxbox</a> 构建的简易版 Angry Birds，boxbox 是一个用于 <a href="https://code.google.com/p/box2dweb/" target="_blank" rel="external">box2dweb</a> 的物理学框架，由 <a href="http://bocoup.com/" target="_blank" rel="external">Bocoup</a> 的 <a href="http://twitter.com/_gsmith" target="_blank" rel="external">Greg Smith</a> 编写。</p><blockquote><p>按下空格键来发射绿色小鸟，你也可以使用方向键。</p></blockquote><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-green-bird-mocking-attack.png" alt=""></p><h2><span id="结论">结论</span></h2><p>前后端分离开发或许有些困难，还好有一些技术和库可以使前端开发和原型构建与后端开发独立开。模拟静态数据还可以帮助开发人员进行单元测试。</p><p>还有很多其他的前端架构技术也被猪偷走了。接下来，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p><p class="j-quote">原文：<a href="http://www.elijahmanor.com/angry-birds-of-javascript-green-bird-mocking/" target="_blank" rel="external">Angry Birds of JavaScript- Green Bird: Mocking</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-of-javascript-green-bird-mocking.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）&lt;/p&gt;
&lt;p&gt;小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读本系列的&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/&quot;&gt;介绍文章&lt;/a&gt;，查看所有小鸟以及它们的进攻力量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;战况&quot;&gt;&lt;a href=&quot;#战况&quot; class=&quot;headerlink&quot; title=&quot;战况&quot;&gt;&lt;/a&gt;战况&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/&quot;&gt;红色大鸟 - 立即调用的函数表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/&quot;&gt;蓝色小鸟 - 事件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/&quot;&gt;黄色小鸟 - 模块化、依赖管理、性能优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/&quot;&gt;黑色小鸟 - 前端分层架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/04/14/angry-birds-of-javascript-white-bird-linting/&quot;&gt;白色小鸟 - 代码质量和代码分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;绿色小鸟的攻击力&quot;&gt;&lt;a href=&quot;#绿色小鸟的攻击力&quot; class=&quot;headerlink&quot; title=&quot;绿色小鸟的攻击力&quot;&gt;&lt;/a&gt;绿色小鸟的攻击力&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-green-bird.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍绿色小鸟，它可以穿透那些难以抵达的地方，并且伪装和监视那些偷东西的小猪，这正是他们的攻击力。渐渐地，他们夺回了属于他们的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Architecture" scheme="http://bubkoo.com/tags/architecture/"/>
    
      <category term="Mock" scheme="http://bubkoo.com/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>白色小鸟 - 代码质量和代码分析</title>
    <link href="http://bubkoo.com/2014/04/14/angry-birds-of-javascript-white-bird-linting/"/>
    <id>http://bubkoo.com/2014/04/14/angry-birds-of-javascript-white-bird-linting/</id>
    <published>2014-04-14T17:11:47.000Z</published>
    <updated>2014-04-14T17:11:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-white-bird-linting.jpg" alt=""></p><h2><span id="介绍">介绍</span></h2><p>一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）</p><p>小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p><blockquote><p>阅读本系列的<a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/">介绍文章</a>，查看所有小鸟以及它们的进攻力量。</p></blockquote><h2><span id="战况">战况</span></h2><ul><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/">红色大鸟 - 立即调用的函数表达式</a></li><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/">蓝色小鸟 - 事件</a></li><li><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/">黄色小鸟 - 模块化、依赖管理、性能优化</a></li><li><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/">黑色小鸟 - 前端分层架构</a></li></ul><h2><span id="白色小鸟的攻击力">白色小鸟的攻击力</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-white-bird.png" alt="white bird"></p><p>本篇文章我将介绍白色小鸟，它看似没有什么攻击力，但当它们拿出严格的代码风格和质量检查时，小猪们都惊呆了。渐渐的，小鸟们将一个接一个地夺回属于他们的东西。</p><a id="more"></a><h2><span id="小猪偷走了什么">小猪偷走了什么</span></h2><p>小鸟们尝试学习用一种不同的方式编写代码，有的是自学，有的则是去计算机科学相关的大学学习。即使这群小鸟中有大量经验丰富和才华横溢之辈，当它们聚在一起来开发一个大型应用时就会酿成一场灾难，它们都认为自己的编码标准才是正确的方式，这就会导致了一些问题。一天，一只白色小鸟走过来，并建议他们遵循一个通用的编码风格，此外，还带来了一些工具，来帮助他们形成统一的标准和解决冲突，并提前关注一些潜在的问题。</p><p>不幸的是，在小猪的进攻过程中，它们的代码规范文档和代码质量工具被偷走了。现在，一只白色小鸟接到任务去夺回来，它将使用不可抗拒的代码质量的威力，来夺回属于它们的东西。</p><h2><span id="javascript-编码规范">JavaScript 编码规范</span></h2><p>目前有许多编码规范可供选择，最重要的是选择其中一个并坚持遵循这个规范。如果你在一个团队中，他们也应该同意一些规范，如果你们不能达成一致，那么选择一个最接近的规范，并允许一些例外。</p><p>这样做你将发现…</p><ul><li>开发人员将更快理解团队中其他人写的代码</li><li>代码库合并不会那么可怕</li><li>拥有确实能够减少缺陷的标准</li><li>代码看上去更加统一</li><li>关于谁才是正确的分歧将减少</li><li>…还有哪些呢？等着你来发现…</li></ul><p>这里列举了一些我知道的代码规范：</p><ul><li>Douglas Crockford’s <a href="http://javascript.crockford.com/code.html" target="_blank" rel="external">Code Conventions for the JavaScript Programming Language</a></li><li>Rich Waldron’s (<a href="http://twitter.com/rwaldron" target="_blank" rel="external">@rwaldron</a>) <a href="https://github.com/rwldrn/idiomatic.js" target="_blank" rel="external">Idiomatic.js - Principles of Writing Consistent, Idiomatic JavaScript</a> ← Recommended</li><li>jQuery’s <a href="http://contribute.jquery.org/style-guide/js/?rdfrom=http%3A%2F%2Fdocs.jquery.com%2Fmw%2Findex.php%3Ftitle%3DJQuery_Core_Style_Guidelines%26redirect%3Dno" target="_blank" rel="external">JavaScript Style Guide</a> ← Recommended</li><li>Google’s <a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml" target="_blank" rel="external">JavaScript Style Guide</a></li></ul><p>Addy Osmani (<a href="http://twitter.com/addyosmani" target="_blank" rel="external">@addyosmani</a>) 有一篇写的很好的文章 <a href="http://addyosmani.com/blog/javascript-style-guides-and-beautifiers/" target="_blank" rel="external">JavaScript Style Guides And Beautifiers</a>，深入解释了各种代码风格，并用实例演示了如果遵循上面提到的这些代码风格标准。</p><h2><span id="javascript-代码检查">JavaScript 代码检查</span></h2><p>代码检查工具可以帮助你找到代码错误和潜在的问题，通常还能帮助你实施代码规范，无论你选择以上代码规范的哪一种。</p><p>有几种代码检查工具可供选择，但是我最喜欢 Anton Kovalyov (<a href="http://twitter.com/valueof" target="_blank" rel="external">@valueof</a>) 创建的 <a href="http://jshint.com/" target="_blank" rel="external">JSHint</a>。JSHint 是社区共同努力的结果，前身是广受欢迎的 JSLint 库。我见证了这个项目成长过程，JSHint 包含很多选项，你可以选择开启或禁用，最后找到最适合你的团队的配置。</p><p>JSHint 可以执行的标准检查包括…</p><ul><li>使用 <code>===</code> 代替 <code>==</code> </li><li>使用没有被预先定义的变量</li><li>声明从未被使用的变量</li><li>在循环内部声明函数</li><li>还有更多选项…</li></ul><p>完整的选项列表请参阅 <a href="http://jshint.com/docs/" target="_blank" rel="external">JSHint 文档</a>。</p><p>我很喜欢最近增加的一些选项：</p><ul><li><code>maxcomplexity</code> - 最大循环复杂度（参见后面引用的维基百科）</li><li><code>maxstatements</code> - 函数允许的语句条数最大值</li><li><code>maxparams</code> - 函数中允许的变量数最大值</li><li><code>maxdepth</code> - 函数允许的最大深度</li><li><code>maxlen</code> - 单行代码的最大长度</li></ul><blockquote><p>“最大循环复杂度是一段代码中线性独立路径数” – <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity" target="_blank" rel="external">http://en.wikipedia.org/wiki/Cyclomatic_complexity</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*jshint maxparams:3, maxdepth:2, maxstatements:5, maxcomplexity:3, maxlen:80 */</span></div><div class="line"><span class="comment">/*global console:false */</span></div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> undefined </span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"> arg1, arg2, arg3, arg4 </span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"too many parameters!"</span> );</div><div class="line">        <span class="keyword">if</span> ( arg1 === <span class="number">1</span> ) &#123;</div><div class="line">            <span class="built_in">console</span>.log( arg1 );</div><div class="line">            <span class="keyword">if</span> ( arg2 === <span class="number">2</span> ) &#123;</div><div class="line">                <span class="built_in">console</span>.log( arg2 );</div><div class="line">                <span class="keyword">if</span>( arg3 === <span class="number">3</span> ) &#123;</div><div class="line">                    <span class="built_in">console</span>.log( <span class="string">"too much nesting!"</span> ); <span class="built_in">console</span>.log( arg3 ); <span class="built_in">console</span>.log( arg4 );</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"too many statements!"</span> );</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    test1( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> );</div><div class="line">&#125;());</div></pre></td></tr></table></figure><p>用 JSHint 对上述代码片段进行检查之后，生成如下错误：</p><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-white-bird-linting-error.png" alt=""></p><p>辛运的是，你不需要每次都在 JSHint 的网站来检查你的代码，可以将 JSHint 集成到代码编辑器中：</p><ul><li>VIM Plugin (<a href="https://github.com/walm/jshint.vim" target="_blank" rel="external">jshint.vim</a>)</li><li>Sublime Text 2 Extension (<a href="https://github.com/Kronuz/SublimeLinter" target="_blank" rel="external">Sublime Linter</a>)</li><li>TextMate Bundle (<a href="http://fgnass.posterous.com/jslint-in-textmate" target="_blank" rel="external">JSHint TextMate Bundle</a>)</li><li>Visual Studio <a href="http://vswebessentials.com/" target="_blank" rel="external">Web Essentials</a></li><li>Eclipse IDE (<a href="http://github.eclipsesource.com/jshint-eclipse/" target="_blank" rel="external">JSHint Integration</a>)</li></ul><blockquote><p>在神鹰一文中，我们将讨论如何在命令行中使用 JSHint，已经如何实现自动化。</p></blockquote><h2><span id="javascript-代码分析">JavaScript 代码分析</span></h2><p>代码检查很不错，但是有时我们希望得到我们代码的全局概览，然后再深入分析代码的某些部分。</p><p>辛运的是，<a href="https://github.com/jsoverson/plato" target="_blank" rel="external">Plato</a> 这个工具可以分析你的代码，并提供一个可视化的报表，通过报表你可以知道应用的复杂度。这个工具需要在 Node 环境下执行，可以通过 <code>npm install plato -g</code> 命令来安装。</p><p>安装 Plato 之后，可以在命令行中运行 <code>plato -r -d report myDirectory</code>，这将递归分析 <code>myDirectory</code> 文件夹中的代码，并将分析结果导出到 <code>report</code> 文件夹中。</p><p>如果你使用 Plato 对 jQuery 源码进行分析，将得到类似下面的报告。正如你所见，代码行数随着时间减少，这个非常好，并且可维护性还不错，然后用柱状图详细列出了每个JavaScript 文件的可维护性。再往下的柱状图列出了每个文件的代码行数、每个文件的预计错误数，以及每个文件的 JSLint 错误数。</p><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-white-bird-javaScript-analysis.png" alt="JavaScript Analysis"></p><p>如果深入分析某个文件，你将看到下面的报告。这份报告最棒的地方是用一种容易理解的方式展示了每个函数的复杂度和代码行数。通过该工具标识出的关注点，你可以快速定位到文件的不同部分进行审查。</p><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-white-bird-javaScript-analysis-details.png" alt="JavaScript Analysis"></p><p>你可以到 Plato 的 GitHub 上查看上面的 <a href="http://jsoverson.github.com/plato/examples/jquery/" target="_blank" rel="external">jQuery 报告</a>。</p><h2><span id="进攻">进攻</span></h2><p>下面是一个用 <a href="http://incompl.github.com/boxbox/" target="_blank" rel="external">boxbox</a> 构建的简易版 Angry Birds，boxbox 是一个用于 <a href="https://code.google.com/p/box2dweb/" target="_blank" rel="external">box2dweb</a> 的物理学框架，由 <a href="http://bocoup.com/" target="_blank" rel="external">Bocoup</a> 的 <a href="http://twitter.com/_gsmith" target="_blank" rel="external">Greg Smith</a> 编写。</p><blockquote><p>按下空格键来发射白色小鸟，你也可以使用方向键。</p></blockquote><p><img src="http://bubkoo.qiniudn.com/angry-birds-white-bird-attack.png" alt=""></p><h2><span id="结论">结论</span></h2><p>前端 web 应用很容易就变得复杂，如果开发人员不能达成共识，项目就很可能会分崩离析，尤其是在大型项目中。有一个统一的代码标准，并借助一些工具来帮助我们找到潜在的问题，将大大有助于项目的成功。</p><p>还有很多其他的前端架构技术也被猪偷走了。接下来，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p><p class="j-quote">原文：<a href="http://www.elijahmanor.com/angry-birds-of-javascript-white-bird-linting/" target="_blank" rel="external">Angry Birds of JavaScript- White Bird: Linting</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-of-javascript-white-bird-linting.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）&lt;/p&gt;
&lt;p&gt;小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读本系列的&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/&quot;&gt;介绍文章&lt;/a&gt;，查看所有小鸟以及它们的进攻力量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;战况&quot;&gt;&lt;a href=&quot;#战况&quot; class=&quot;headerlink&quot; title=&quot;战况&quot;&gt;&lt;/a&gt;战况&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/&quot;&gt;红色大鸟 - 立即调用的函数表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/&quot;&gt;蓝色小鸟 - 事件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/&quot;&gt;黄色小鸟 - 模块化、依赖管理、性能优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/&quot;&gt;黑色小鸟 - 前端分层架构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;白色小鸟的攻击力&quot;&gt;&lt;a href=&quot;#白色小鸟的攻击力&quot; class=&quot;headerlink&quot; title=&quot;白色小鸟的攻击力&quot;&gt;&lt;/a&gt;白色小鸟的攻击力&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-white-bird.png&quot; alt=&quot;white bird&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇文章我将介绍白色小鸟，它看似没有什么攻击力，但当它们拿出严格的代码风格和质量检查时，小猪们都惊呆了。渐渐的，小鸟们将一个接一个地夺回属于他们的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Architecture" scheme="http://bubkoo.com/tags/architecture/"/>
    
      <category term="Linting" scheme="http://bubkoo.com/tags/linting/"/>
    
      <category term="Analysis" scheme="http://bubkoo.com/tags/analysis/"/>
    
  </entry>
  
  <entry>
    <title>黑色小鸟 - 前端分层架构</title>
    <link href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/"/>
    <id>http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/</id>
    <published>2014-03-29T15:28:40.000Z</published>
    <updated>2014-03-29T15:28:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-black-bird-backbone.jpg" alt=""></p><h2><span id="介绍">介绍</span></h2><p>一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）</p><p>小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p><blockquote><p>阅读本系列的<a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/">介绍文章</a>，查看所有小鸟以及它们的进攻力量。</p></blockquote><h2><span id="战况">战况</span></h2><ul><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/">红色大鸟 - 立即调用的函数表达式</a></li><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/">蓝色小鸟 - 事件</a></li><li><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/">黄色小鸟 - 模块化、依赖管理、性能优化</a></li></ul><h2><span id="黑色小鸟的攻击力">黑色小鸟的攻击力</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-black-bird.png" alt="black bird"></p><p>在这篇文章中，我们将看看黑色小鸟，它们使用 Backbone.js 的组织方式，用炸弹进攻肥小猪们。慢慢的，小鸟们将一个接一个地夺回本属于他们的东西。</p><a id="more"></a><h2><span id="猪猪偷走了什么">猪猪偷走了什么</span></h2><p>小鸟们从曾经写出来的 jQuery 代码就像蠕虫大杂烩那样乱成一团，它们将视图、模型和展现逻辑的代码混淆在一起。后来，它们的其中一个祖先，一只黑色小鸟，引入了 Backbone.js，并向它们演示了一种不同的方式来开发前端应用。但是，在小猪最近的一次进攻中，小猪们从小鸟那里偷走了 Backbone.js，并带回了它们肮脏的猪圈。</p><p>其中一只黑色小鸟被指派去夺回被偷去的东西，为了夺回属于它们的东西，它将使用具有爆炸性力量的组织结构来帮助它摧毁猪群。</p><h2><span id="乱成一团的蠕虫大杂烩">乱成一团的蠕虫大杂烩</span></h2><p>我们再来看看下面的应用，在上次<a href="http://draft.blogger.com/blogger.g?blogID=30404818" target="_blank" rel="external">蓝色小鸟</a>进攻中已经处理过，之前通过增加消息来理清混乱，这里我们将使用 Backbone.js 来达到同样的目的，下面是程序运行结果…</p><blockquote><p>现在貌似 <a href="http://plnkr.co/" target="_blank" rel="external">Plunker</a> 不能正确地嵌入在页面上，该应用是一个简单的 Netflix 搜索入口，返回 Netflix 的搜索结果。如果 Plunker 失效，我将把这个 demo  移到别处，抱歉带来不便。</p></blockquote><iframe allowfullscreen="allowfullscreen" frameborder="0" src="http://embed.plnkr.co/td1ZTtptDT0RIxc7VIgM" style="height: 300px; width: 100%"></iframe><p>为了再次唤起你的记忆，下面再次贴出了该应用的实现代码。你会发现代码将许多关注点都混在一起了（DOM事件，视图更新，AJAX交互，等等）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">$( <span class="built_in">document</span> ).on( <span class="string">"click"</span>, <span class="string">".term"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</div><div class="line">    e.preventDefault();</div><div class="line">    $( <span class="string">"input"</span> ).val( $( <span class="keyword">this</span> ).text() );</div><div class="line">    $( <span class="string">"button"</span> ).trigger( <span class="string">"click"</span> );</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">$( <span class="built_in">document</span> ).ready( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">    $( <span class="string">"button"</span> ).on( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> searchTerm = $( <span class="string">"input"</span> ).val();</div><div class="line">        <span class="keyword">var</span> url = <span class="string">"http://odata.netflix.com/Catalog/Titles?$filter=substringof('"</span> +</div><div class="line">                <span class="built_in">escape</span>( searchTerm ) + <span class="string">"',Name)&amp;$callback=callback&amp;$format=json"</span>;</div><div class="line">        </div><div class="line">        $( <span class="string">".help-block"</span> ).html( <span class="function"><span class="keyword">function</span>(<span class="params"> index, html </span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> e.originalEvent ? html + <span class="string">", "</span> + <span class="string">"&lt;a href='#' class='term'&gt;"</span> +</div><div class="line">                searchTerm + <span class="string">"&lt;/a&gt;"</span> : html;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        $.ajax(&#123;</div><div class="line">            dataType: <span class="string">"jsonp"</span>,</div><div class="line">            url: url,</div><div class="line">            jsonpCallback: <span class="string">"callback"</span>,</div><div class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> rows = [];</div><div class="line">                $.each( data.d.results, <span class="function"><span class="keyword">function</span>(<span class="params"> index, result </span>) </span>&#123;</div><div class="line">                    <span class="keyword">var</span> row = <span class="string">""</span>;</div><div class="line">                    <span class="keyword">if</span> ( result.Rating &amp;&amp; result.ReleaseYear ) &#123;</div><div class="line">                        row += <span class="string">"&lt;td&gt;"</span> + result.Name + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">                        row += <span class="string">"&lt;td&gt;"</span> + result.Rating + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">                        row += <span class="string">"&lt;td&gt;"</span> + result.ReleaseYear + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">                        row = <span class="string">"&lt;tr&gt;"</span> + row + <span class="string">"&lt;/tr&gt;"</span>;</div><div class="line">                        rows.push( row );</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">                $( <span class="string">"table"</span> ).show().find( <span class="string">"tbody"</span> ).html( rows.join( <span class="string">""</span> ) );</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        e.preventDefault();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>你发现问题了吗？很容易写出像上面那样的代码，但我希望你能发现，这样的代码使用和维护起来都将令人难以忍受。别担心，我们都曾写过那样的代码。好消息是，我们不必接着那样写代码。让我们来看看 Backbone.js 到底是什么，以及它是如何帮助我们解决上述问题的。</p><blockquote><p>还有很多其他前端 MV* 框架（Knockout、AngularJS、EmberJS以及其他）可以结构化上面的代码。我鼓励你选择一个工具，并熟练使用它。</p></blockquote><h2><span id="backbonejs-基础">Backbone.js 基础</span></h2><p>Backbone.js 有一些组件，他们可以协同来创建一个 web 应用，你不必都用上这些组件，但你想用时它们都是可用的。</p><ul><li>Model - 代表数据以及相关逻辑</li><li>Collection - 模型的有序集合</li><li>View - 依赖模型，并含有渲染方法的模块</li><li>Router - 提供可链接和可分享 URL 的机制</li><li>Event - 观察者事件模块</li><li>History - 提供操作历史的功能（支持后退按钮）</li><li>Sync - 可扩展组件，提供与服务器端 RESTful 风格的通信</li></ul><h2><span id="重构紧耦合的代码">重构紧耦合的代码</span></h2><p>让我们尝试重构上面混乱的 jQuery 代码，使用 Backbone.js 将我们的关注点分离开。</p><p>本文不会深入介绍上面的所有组件，重点会放在 3 个主要的组件（Models，Collections 和 Views），同时涉及到一些 Sync 组件，但是是作为其他主题的一部分。如果你想深入研究这些主题，可以参考文章末尾我列举的一些资源。</p><h3><span id="requirejs">RequireJS</span></h3><p>在进入讨论 Models，Collections 和 Views 之前，我想演示如何使用 RequireJS  来帮助我们将 index.html 页面中脚本文件都移除。</p><blockquote><p>如果你从未接触过 RequireJS，你可以参考 <a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/">黄色小鸟 - RequireJS</a> 这篇关于 RequireJS 的文章。</p></blockquote><h4><span id="mainjs">main.js</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    paths: &#123;</div><div class="line">        jquery: <span class="string">"https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min"</span>,</div><div class="line">        underscore: <span class="string">"http://underscorejs.org/underscore"</span>,</div><div class="line">        backbone: <span class="string">"http://backbonejs.org/backbone"</span>,</div><div class="line">        postal: <span class="string">"http://cdnjs.cloudflare.com/ajax/libs/postal.js/0.8.2/postal.min"</span>,</div><div class="line">        bootstrap: <span class="string">"http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.0/js/bootstrap.min"</span></div><div class="line">    &#125;,</div><div class="line">    shim: &#123;</div><div class="line">        underscore: &#123;</div><div class="line">            exports: <span class="string">"_"</span></div><div class="line">        &#125;,</div><div class="line">        backbone: &#123;</div><div class="line">            deps: [ <span class="string">"jquery"</span>, <span class="string">"underscore"</span> ],</div><div class="line">            exports: <span class="string">"Backbone"</span></div><div class="line">        &#125;,</div><div class="line">        bootstrap: &#123;</div><div class="line">            <span class="string">"deps"</span> : [ <span class="string">"jquery"</span> ]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="built_in">require</span>( [ <span class="string">"jquery"</span>, <span class="string">"search-view"</span>, <span class="string">"search"</span>, <span class="string">"movie-view"</span>, <span class="string">"movies"</span> ], </div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"> $, SearchView, Search, MovieView, Movies </span>) </span>&#123;</div><div class="line">        $( <span class="built_in">document</span> ).ready( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> searchView = <span class="keyword">new</span> SearchView(&#123;</div><div class="line">                el: $( <span class="string">"#search"</span> ),</div><div class="line">                model: <span class="keyword">new</span> Search()</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">            <span class="keyword">var</span> movieView = <span class="keyword">new</span> MovieView(&#123;</div><div class="line">                el: $( <span class="string">"#output"</span> ),</div><div class="line">                collection: <span class="keyword">new</span> Movies()</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure><p>上面代码定义了  jQuery、Underscore、Backbone、Postal 和     Bootstrap 的路径，需要给 Underscore、Backbone 和 Bootstrap 设置垫片（shim），因为它们不是 AMD 模块。</p><p>调用 <code>require</code> 方法来加载依赖项，回调执行时，jQuery 和 其他依赖的模型和视图都已经加载好。</p><h3><span id="模型">模型</span></h3><p>我们将创建 2 个模型（Seach 和 Movie）来表示上面的应用。</p><p>下面的 Search 模型相当简单，它的主要任务是响应 <code>term</code> 属性的变化。我们使用 Backbone 的事件（观察者事件）来监听模型的变化，然后传播消息到 Postal.js（媒介事件）。关于这些术语的更多信息以及它们的不同之处，可以参考关于事件的<a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/">愤怒的蓝色小鸟</a>一文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">define( [ <span class="string">"backbone"</span>, <span class="string">"channels"</span> ], <span class="function"><span class="keyword">function</span>(<span class="params"> Backbone, channels </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> Model = Backbone.Model.extend(&#123;</div><div class="line">        initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.on( <span class="string">"change:term"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> model, value </span>) </span>&#123;</div><div class="line">                channels.bus.publish( <span class="string">"search.term.changed"</span>, &#123; <span class="attr">term</span>: value &#125; );</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> Model;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>下面的 Movie 模型也没有处理很多事情，它的主要目的是解析服务器返回的数据，并把结果映射为更易于管理的结构。这样我们只需要关心 releaseYear、rating 和 name 属性。</p><h4><span id="moviejs">movie.js</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">efine( [ <span class="string">"backbone"</span> ], <span class="function"><span class="keyword">function</span>(<span class="params"> Backbone </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> Model = Backbone.Model.extend(&#123;</div><div class="line">        defaults: &#123; <span class="attr">term</span>: <span class="string">""</span> &#125;,</div><div class="line">        parse: <span class="function"><span class="keyword">function</span>(<span class="params"> data, xhr </span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                releaseYear: data.ReleaseYear,</div><div class="line">                rating: data.Rating,</div><div class="line">                name: data.Name</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> Model;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3><span id="集合">集合</span></h3><p>正如上面描述的那样，集合是一组模型，下面代码就是一组 Movie 模型。集合定义了从服务器获取模型的服务器地址，该应用的后端是 Netflix，它的入口稍微有点复杂，所以我们定义了一函数来动态创建服务器的 URL。同时，我们还定义了一个 <code>parse</code> 方法，它将直接返回映射到 <code>Movie</code> 模型的数组。由于这个 AJAX 用到了 JSONP，我们还需要重写 <code>sync</code> 方法提供一些额外的选项。  </p><h4><span id="moviesjs">movies.js</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">define( [ <span class="string">"backbone"</span>, <span class="string">"movie"</span> ], <span class="function"><span class="keyword">function</span>(<span class="params"> Backbone, Movie </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> Collection = Backbone.Collection.extend(&#123;</div><div class="line">        model: Movie,</div><div class="line">        url: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"http://odata.netflix.com/Catalog/Titles?$filter=substringof('"</span> +</div><div class="line">                <span class="built_in">escape</span>( <span class="keyword">this</span>.term ) + <span class="string">"',Name)&amp;$callback=callback&amp;$format=json"</span>;</div><div class="line">        &#125;,</div><div class="line">        parse : <span class="function"><span class="keyword">function</span>(<span class="params"> data, xhr </span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> data.d.results;</div><div class="line">        &#125;,</div><div class="line">        sync: <span class="function"><span class="keyword">function</span>(<span class="params"> method, model, options </span>) </span>&#123;  </div><div class="line">            options.dataType = <span class="string">"jsonp"</span>;  </div><div class="line">            options.jsonpCallback = <span class="string">"callback"</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> Backbone.sync( method, model, options );  </div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> Collection;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3><span id="视图">视图</span></h3><p>与传统的 MVC 中的视图相比，我认为这里的视图更加。不管怎么样，这个应用有 2 个视图，我们简要地看看。</p><p><code>SearchView</code> 视图处理 DOM 和模型之间的交互。<code>events</code> 属性主要用来绑定 DOM 事件，在这个应用中监听了按钮的点击事件和之前搜索链接的点击事件，搜索链接的改变将被记录在模型的 <code>term</code> 属性中。<code>initialize</code> 方法为 <code>term</code> 属性改变设置了事件监听，如果 <code>term</code> 发生改变，对应的 UI 将发生改变。  </p><h4><span id="search-viewjs">search-view.js</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">define( [ <span class="string">"jquery"</span>, <span class="string">"backbone"</span>, <span class="string">"underscore"</span>, <span class="string">"channels"</span> ], </div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"> $, Backbone </span>) </span>&#123;</div><div class="line"> </div><div class="line">        <span class="keyword">var</span> View = Backbone.View.extend(&#123;</div><div class="line">            events: &#123;</div><div class="line">                <span class="string">"click button"</span>: <span class="string">"searchByInput"</span>,</div><div class="line">                <span class="string">"click .term"</span>: <span class="string">"searchByHistory"</span></div><div class="line">            &#125;,</div><div class="line">            initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.model.on( <span class="string">"change"</span>, <span class="keyword">this</span>.updateHistory, <span class="keyword">this</span> );</div><div class="line">                <span class="keyword">this</span>.model.on( <span class="string">"change"</span>, <span class="keyword">this</span>.updateInput, <span class="keyword">this</span> );</div><div class="line">            &#125;,</div><div class="line">            searchByInput: <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</div><div class="line">                e.preventDefault();</div><div class="line">                </div><div class="line">                <span class="keyword">this</span>.model.set( <span class="string">"term"</span>, <span class="keyword">this</span>.$( <span class="string">"input"</span> ).val() );</div><div class="line">            &#125;,</div><div class="line">            searchByHistory: <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> text = $( e.target ).text();</div><div class="line">                </div><div class="line">                <span class="keyword">this</span>.model.set( <span class="string">"term"</span>, text );</div><div class="line">            &#125;,</div><div class="line">            updateHistory: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">                </div><div class="line">                <span class="keyword">this</span>.$el.find( <span class="string">".help-block"</span> ).html( <span class="function"><span class="keyword">function</span>(<span class="params">index, html</span>) </span>&#123;</div><div class="line">                    <span class="keyword">var</span> term = that.model.get( <span class="string">"term"</span> );</div><div class="line">                    </div><div class="line">                    <span class="keyword">return</span> ~html.indexOf( term ) ? html : </div><div class="line">                        html + <span class="string">", "</span> + <span class="string">"&lt;a href='#' class='term'&gt;"</span> + term + <span class="string">"&lt;/a&gt;"</span>;</div><div class="line">                &#125;);</div><div class="line">            &#125;,</div><div class="line">            updateInput: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.$el.find( <span class="string">"input"</span> ).val( <span class="keyword">this</span>.model.get(<span class="string">"term"</span>) );    </div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> View;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure><p><code>MovieView</code> 视图与上面的视图有些许不一样。第一点要指出的就是奇怪的 <code>text!movie-template.html</code> 依赖，我使用了  RequireJS 的 <code>text.js</code> 插件，该插件允许将将文本资源作为依赖项的一部分加载。这对于使用文本文件的场景非常有用，比如模板引擎中的模板文件，或与某个组件对应的 CSS 文件。在 <code>initialize</code> 方法中，我们订阅了 <code>term</code> 的改变事件，当发生改变时通知集合从服务器 <code>fetch</code> 新数据，当数据从服务器返回时，<code>render</code> 方法将被调用，在 <code>render</code> 方法中我们使用 <code>Underscore</code> 的模板引擎来将结果渲染到页面中。   </p><h4><span id="movie-viewjs">movie-view.js</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">define( [ <span class="string">"jquery"</span>, <span class="string">"backbone"</span>, <span class="string">"underscore"</span>, <span class="string">"channels"</span>, <span class="string">"text!movie-template.html"</span> ], </div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"> $, Backbone, _, channels, template </span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> View = Backbone.View.extend(&#123;</div><div class="line">            template: _.template( template ),</div><div class="line">            initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">                </div><div class="line">                _.bindAll( <span class="keyword">this</span>, <span class="string">"render"</span> );                </div><div class="line">                channels.bus.subscribe( <span class="string">"search.term.changed"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">                    that.collection.term = data.term;</div><div class="line">                    that.collection.fetch(&#123;</div><div class="line">                        success: that.render</div><div class="line">                    &#125;);</div><div class="line">                &#125;);</div><div class="line">            &#125;,</div><div class="line">            render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> html = <span class="keyword">this</span>.template(&#123; <span class="attr">movies</span>: <span class="keyword">this</span>.collection.toJSON() &#125;);</div><div class="line">                <span class="keyword">this</span>.$el.show().find( <span class="string">"tbody"</span> ).html( html );</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> View;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure><p>下面就是你想知道的模板文件，我使用的是 Underscore 的模板引擎，该引擎与 John 多年之前写的 micro-templating 非常相似。还有一些其他的模板库，我使用这个引擎，是因为它是 Underscore 内置的模板引擎，并且 Underscore 是 Backbone 的依赖项，如果想有更多的特性，我会使用 Handlebars 来代替，单这是关于愤怒的小鸟的另一个故事了。</p><h4><span id="movie-templatehtml">movie-template.html</span></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">_.each</span>( <span class="attr">movies</span>, <span class="attr">function</span>( <span class="attr">movie</span> ) &#123; %&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">movie.name</span> %&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">movie.rating</span> %&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">movie.releaseYear</span> %&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">%</span> &#125;); %&gt;</span></div></pre></td></tr></table></figure><h2><span id="附加资源">附加资源</span></h2><p>本文只涉及到了 Backbone.js 的皮毛，如果你想了解更多关于 Backbone.js，下面这些资源你也许用的上。</p><blockquote><p>下面这些资源来源于 <a href="http://www.elijahmanor.com/2013/01/beginner-html5-javascript-jquery.html" target="_blank" rel="external">Beginner HTML5, JavaScript, jQuery, Backbone, and CSS3 Resources</a> 这篇博文。</p></blockquote><ul><li><a href="http://backbonejs.org/" target="_blank" rel="external">Backbone.js API</a></li><li><a href="http://backbonejs.org/docs/backbone.html" target="_blank" rel="external">Annotated Backbone.js Code</a></li><li><a href="https://github.com/documentcloud/backbone/wiki/Extensions,-Plugins,-Resources" target="_blank" rel="external">Backbone Extensions, Plugins, &amp; Resources</a></li><li><a href="https://github.com/tbranyen/backbone-boilerplate" target="_blank" rel="external">Backbone Boilerplate</a></li><li><a href="https://github.com/addyosmani/backbone-fundamentals" target="_blank" rel="external">Backbone Fundamentals eBook</a> by Addy Osmani (<a href="http://twitter.com/addyosmani" target="_blank" rel="external">@addyosmani</a>)</li><li><a href="https://peepcode.com/products/backbone-js" target="_blank" rel="external">Peep Code: Backbone.js Video Series</a> by Geoffery Grosenbach (<a href="http://twitter.com/topfunky" target="_blank" rel="external">@topfunky</a>) and David Goodlad (<a href="http://twitter.com/dgoodlad" target="_blank" rel="external">@dgoodlad</a>)</li><li><a href="http://pragprog.com/screencasts/v-dback/hands-on-backbone-js" target="_blank" rel="external">The Pragmatic Bookshelf: Hands-on Backbone.js</a> by Derick Bailey (<a href="http://twitter.com/derickbailey" target="_blank" rel="external">@derickbailey</a>)</li><li><a href="http://backbonescreencasts.com/" target="_blank" rel="external">Backbone.js Screencasts</a> by Joey Beninghove</li><li><a href="http://www.pluralsight.com/training/Courses/TableOfContents/backbone-fundamentals" target="_blank" rel="external">Pluralsight: Backbone.js Fundamentals</a> by Liam McLennan (<a href="http://twitter.com/liammclennan" target="_blank" rel="external">@liammclennan</a>)</li><li><a href="http://codular.com/starting-with-backbone" target="_blank" rel="external">The Skinny on BackboneJS</a> by Ben Howdle (<a href="http://twitter.com/benhowdle" target="_blank" rel="external">@benhowdle</a>)</li><li><a href="http://backbonetutorials.com/" target="_blank" rel="external">Backbone Tutorials</a></li><li><a href="http://net.tutsplus.com/tag/backbone/" target="_blank" rel="external">Backbone.js Tutorials</a> via Nettuts</li><li><a href="http://javascriptplayground.com/blog/category/backbonejs" target="_blank" rel="external">Exploring Backbone.js Series</a> by Jack Franklin (<a href="http://twitter.com/jack_franklin" target="_blank" rel="external">@jack_franklin</a>)</li></ul><h2><span id="进攻">进攻</span></h2><p>下面是一个用 <a href="http://incompl.github.com/boxbox/" target="_blank" rel="external">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href="https://code.google.com/p/box2dweb/" target="_blank" rel="external">box2dweb</a> 的物理学框架，由 <a href="http://bocoup.com/" target="_blank" rel="external">Bocoup</a> 的 <a href="http://twitter.com/_gsmith" target="_blank" rel="external">Greg Smith</a> 编写。</p><blockquote><p>按下空格键来发射黄色小鸟，你也可以使用方向键。</p></blockquote><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-black-bird-backbone-attack.png" alt=""></p><h2><span id="结论">结论</span></h2><p>前端 web 应用很容易就变得复杂，如果你不小心，那么你的代码就可能在不知不觉间变得混乱起来。幸好有了 Backbone.js 提供的各种组件，来帮助我们将应用分为可用的、包含各自目的的模块。感谢黑色小鸟为小鸟们夺回了 Backbone，这样它们就可以更早休息，因为它们知道在应用的适当地方，被有条理的组织了起来。</p><p>还有很多其他的前端架构技术也被猪偷走了。接下来，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p><p class="j-quote">原文：<a href="http://www.elijahmanor.com/angry-birds-of-javascript-black-bird-backbone/" target="_blank" rel="external">Angry Birds of JavaScript- Black Bird: Backbone</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-of-javascript-black-bird-backbone.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）&lt;/p&gt;
&lt;p&gt;小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读本系列的&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/&quot;&gt;介绍文章&lt;/a&gt;，查看所有小鸟以及它们的进攻力量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;战况&quot;&gt;&lt;a href=&quot;#战况&quot; class=&quot;headerlink&quot; title=&quot;战况&quot;&gt;&lt;/a&gt;战况&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/&quot;&gt;红色大鸟 - 立即调用的函数表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/&quot;&gt;蓝色小鸟 - 事件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/&quot;&gt;黄色小鸟 - 模块化、依赖管理、性能优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;黑色小鸟的攻击力&quot;&gt;&lt;a href=&quot;#黑色小鸟的攻击力&quot; class=&quot;headerlink&quot; title=&quot;黑色小鸟的攻击力&quot;&gt;&lt;/a&gt;黑色小鸟的攻击力&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-black-bird.png&quot; alt=&quot;black bird&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将看看黑色小鸟，它们使用 Backbone.js 的组织方式，用炸弹进攻肥小猪们。慢慢的，小鸟们将一个接一个地夺回本属于他们的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Architecture" scheme="http://bubkoo.com/tags/architecture/"/>
    
      <category term="Backbone" scheme="http://bubkoo.com/tags/backbone/"/>
    
  </entry>
  
  <entry>
    <title>黄色小鸟 - 模块化、依赖管理、性能优化</title>
    <link href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/"/>
    <id>http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/</id>
    <published>2014-03-29T00:01:16.000Z</published>
    <updated>2014-03-29T00:01:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-yellow-bird-requirejs.png" alt=""></p><h2><span id="介绍">介绍</span></h2><p>一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）</p><p>小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p><blockquote><p>阅读本系列的<a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/">介绍文章</a>，查看所有小鸟以及它们的进攻力量。</p></blockquote><h2><span id="战况">战况</span></h2><ul><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/">红色大鸟 - 立即调用的函数表达式</a></li><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/">蓝色小鸟 - 事件</a></li></ul><h2><span id="黄色小鸟的攻击力">黄色小鸟的攻击力</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-yellow-bird.png" alt=""></p><p>在这片文章中，我们将看看黄色小鸟，它使用 <a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a> 作为助推器，利用动态脚本加载来攻击那些讨厌的猪。慢慢的，小鸟们将一个接一个地夺回本属于他们的东西。</p><a id="more"></a><h2><span id="猪猪偷走了什么">猪猪偷走了什么</span></h2><p>小鸟们曾经手动添加到本文件到 HTML 页面中，首先这并不会导致什么问题，但是一旦当它们的应用变得更加庞大和复杂，就会面临组织代码、解决依赖关系和确定优化策略等一系列困难。庆幸的是，它们引入了 <a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a> 实现代码模块化、脚本异步加载、依赖管理，并提供了一种简单的方式来优化代码。后来发生了一件不幸的事情，在猪猪进攻过程中，RequireJS 库被他们偷走了。</p><h2><span id="一个崩溃的应用">一个崩溃的应用</span></h2><p>让我们以一个简单的页面开始，只引入了少数几个脚本文件。你会注意到在页面最后我只加载了 3 个流行的库（jQuery，Underscore 和 Postal）和一些自定义代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;  </div><div class="line">    &lt;head lang=<span class="string">"en"</span>&gt;</div><div class="line">        &lt;meta charset=<span class="string">"utf-8"</span>&gt;</div><div class="line">        &lt;title&gt;Angry Birds&lt;<span class="regexp">/title&gt;</span></div><div class="line"><span class="regexp">        &lt;link rel="stylesheet" href="./</span>css/style.css<span class="string">"&gt;</span></div><div class="line"><span class="string">    &lt;/head&gt;</span></div><div class="line"><span class="string">    &lt;body&gt;</span></div><div class="line"><span class="string">        &lt;script src="</span>./libs/jquery.min.js<span class="string">"&gt;&lt;/script&gt;</span></div><div class="line"><span class="string">        &lt;script src="</span>./libs/postal.min.js<span class="string">"&gt;&lt;/script&gt;</span></div><div class="line"><span class="string">        &lt;script src="</span>./libs/underscore.min.js<span class="string">"&gt;&lt;/script&gt;</span></div><div class="line"><span class="string">        &lt;script&gt;</span></div><div class="line"><span class="string">            var channel = postal.channel();</span></div><div class="line"><span class="string">        </span></div><div class="line"><span class="string">            channel.subscribe( "</span>pig.collide<span class="string">", function() &#123;</span></div><div class="line"><span class="string">                console.log( "</span>Pig Down!<span class="string">" );</span></div><div class="line"><span class="string">            &#125;);</span></div><div class="line"><span class="string">        </span></div><div class="line"><span class="string">            channel.publish( "</span>pig.collide<span class="string">" );</span></div><div class="line"><span class="string">        &lt;/script&gt;</span></div><div class="line"><span class="string">    &lt;/body&gt;</span></div><div class="line"><span class="string">&lt;/html&gt;</span></div></pre></td></tr></table></figure><p>上面代码看上去非常简单，但是当我运行页面时，在开发者工具的控制台中却得到如下错误…</p><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-yellow-bird-requirejs-error.png" alt=""></p><p>你在自问自答：什么！？！我没有在任何位置看到 <code>each</code> 方法啊，到底是怎么回事？噢，好像是在 postal.min.js 内部某处发生了异常，找到了一个 BUG…再运行一遍看是不是这样，但是，等等！？！这里也许还有别的东西。</p><p>其实，真正的问题不是 postal.js 存在 BUG，而是 postal.js 依赖 underscore.js，问题在于 underscore.js 需要在 postal.js 之前加载，修改一下脚本的加载顺序就可以轻松地解决这个问题。在上面示例中，修复过程并不值得一提，但是请想想一下，一旦项目变得庞大，需要大量的脚本文件，这是一件繁重的工作。</p><h2><span id="requirejs-基础">RequireJS 基础</span></h2><p>在我们开始使用 RequireJS 来解决上述问题前，先高度概括一下这个库能为我们做什么。RequireJS 是一个异步模块加载器，它提供的 API 允许我们定义和加载模块，这两个方法（define 和 require）非常容易理解，我们一起来看看。</p><h3><span id="define-方法">define 方法</span></h3><p>创建一个模块，你需要提供一个模块名称，依赖列表和一个回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 文件名: my-first-module.js</span></div><div class="line"> </div><div class="line"><span class="comment">// 按照约定，模块的默认名称是文件名</span></div><div class="line">define( </div><div class="line">    [ <span class="string">"underscore"</span>, <span class="string">"jquery"</span> ], <span class="comment">// 依赖项数组</span></div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"> _, $ </span>) </span>&#123; <span class="comment">// 回调函数，其参数和请求的依赖项对应</span></div><div class="line">        <span class="comment">// Underscore 和 jQuery 已经加载完成</span></div><div class="line">        <span class="comment">// 可以通过 `_` &amp; `$` 变量来使用</span></div><div class="line"> </div><div class="line">        <span class="keyword">return</span> &#123; <span class="comment">// 不管是谁加载该模块，回调函都将是可用的</span></div><div class="line">            message: <span class="string">"Hello World!"</span></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure><h3><span id="require-方法">require 方法</span></h3><p>在应用的某个地方，你需要使用 <code>require</code> 函数来开始执行代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>( </div><div class="line">    [ <span class="string">"my-first-module"</span> ],    <span class="comment">// 依赖项数组</span></div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"> firstModule </span>) </span>&#123; <span class="comment">// 回调函数的参数与依赖项项对应</span></div><div class="line">        <span class="built_in">console</span>.log( firstModule.message );</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure><h2><span id="修复应用">修复应用</span></h2><p>我用 RequireJS 修复了上面的小应用，你可以看到下面的代码中我移除了其他所有的 <code>&lt;script&gt;</code> 标签，只剩一个指向 require.js 库，RequireJS 知道从哪里开始执行应用，因为我们在 <code>&lt;script&gt;</code> 标签的属性上添加了一个 HTML5 的 <code>data-main</code> 属性，该属性指定了开始执行的脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;  </div><div class="line">    &lt;head lang=<span class="string">"en"</span>&gt;</div><div class="line">        &lt;meta charset=<span class="string">"utf-8"</span>&gt;</div><div class="line">        &lt;title&gt;Angry Birds&lt;<span class="regexp">/title&gt;</span></div><div class="line"><span class="regexp">        &lt;link rel="stylesheet" href="./</span>css/style.css<span class="string">"&gt;</span></div><div class="line"><span class="string">    &lt;/head&gt;</span></div><div class="line"><span class="string">    &lt;body&gt;</span></div><div class="line"><span class="string">        &lt;!-- </span></div><div class="line"><span class="string">            You'll notice that the markup is cleaned up dramatically</span></div><div class="line"><span class="string">            The data-main HTML5 attribute defines where to kick things off</span></div><div class="line"><span class="string">        --&gt;</span></div><div class="line"><span class="string">        &lt;script src="</span>./libs/<span class="built_in">require</span>.min.js<span class="string">" data-main="</span>./js/main<span class="string">"&gt;&lt;/script&gt;</span></div><div class="line"><span class="string">    &lt;/body&gt;</span></div><div class="line"><span class="string">&lt;/html&gt;</span></div></pre></td></tr></table></figure><p>主脚本文件中有一段配置，在这里你可以为现有的 AMD 模块指定别名，也可以通过 shim 来配置不符合 AMD 规范的模块。虽然 jQuery 和 Postal 已经是符合 AMD 规范的模块，我们需要在配置中包含它们，因为它们的文件位置和 <code>main.js</code> 不在同一个文件夹下面。</p><p>你不必在配置中包含应用程序中的所有自定义模块。你可以通过文件路径和名称引用它们。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* main.js */</span></div><div class="line"> </div><div class="line"><span class="comment">// Let RequireJS know where all the scripts are</span></div><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    paths: &#123;</div><div class="line">        <span class="string">"jquery"</span>: <span class="string">"../libs/jquery.min"</span>,</div><div class="line">        <span class="string">"underscore"</span>: <span class="string">"../libs/underscore.min"</span>,</div><div class="line">        <span class="string">"postal"</span>: <span class="string">"../libs/postal.min"</span></div><div class="line">    &#125;,</div><div class="line">    shim: &#123;</div><div class="line">        <span class="comment">// Underscore.js 不是一个 AMD 模块，所以需要为其配置在 shim 中</span></div><div class="line">        underscore: &#123;</div><div class="line">            exports: <span class="string">"_"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 在 postal.js 内部定义了依赖 underscore</span></div><div class="line"><span class="comment">// 所以在加载 postal 之前，RequireJS 会先加载 underscore</span></div><div class="line"><span class="built_in">require</span>([ <span class="string">"postal"</span> ], <span class="function"><span class="keyword">function</span>(<span class="params"> postal </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> channel = postal.channel();</div><div class="line"> </div><div class="line">    channel.subscribe( <span class="string">"pig.collide"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Pig Down!"</span> );</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    channel.publish( <span class="string">"pig.collide"</span> );</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2><span id="优化">优化</span></h2><p>目前，我们的应用只包含 5 个脚本文件，但是你知道我们的应用只会继续添加额外的脚本，因此，需要一种简单的方式来合并和压缩我们的脚本文件，使其在线上环境有更好的性能，通过使用 RequireJS 已经为我们的应用定义好了所有依赖。</p><p>值得庆幸的是，有一个称为 <a href="http://requirejs.org/docs/1.0/docs/optimization.html" target="_blank" rel="external">r.js</a> 的工具可以收集依赖信息，并用这些信息生成一个合并和压缩过的脚本文件。你可以通过 Node 包管理器 <code>npm install requirejs</code> 安装这个工具。</p><p>在运行这个工具时，你需要在控制台中输入运行所需要的命令行参数，但我更喜欢为其指定一个构建配置文件，就像下面这样，你可以在官方 GitHub 上找到<a href="https://github.com/jrburke/r.js/blob/master/build/example.build.js" target="_blank" rel="external">完整的选项列表</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(&#123;</div><div class="line">appDir: <span class="string">"."</span>,               <span class="comment">// The main root URL</span></div><div class="line">dir: <span class="string">"../dist"</span>,            <span class="comment">// Directory that we build to</span></div><div class="line">mainConfigFile: <span class="string">"main.js"</span>, <span class="comment">// Location of main.js</span></div><div class="line">name: <span class="string">"main"</span>,              <span class="comment">// Name of the module that we are loading</span></div><div class="line">optimizeCss: <span class="string">"standard"</span>,   <span class="comment">// Standard optimization for CSS</span></div><div class="line">removeCombined: <span class="literal">true</span>,      <span class="comment">// Temporary combined files will be removed</span></div><div class="line">paths : &#123;</div><div class="line"><span class="string">"jquery"</span>: <span class="string">"libs/jquery.min"</span>,</div><div class="line"><span class="string">"underscore"</span>: <span class="string">"libs/underscore.min"</span>,</div><div class="line"><span class="string">"postal"</span>: <span class="string">"libs/postal.min"</span></div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>一旦定义好 <code>build.js</code> 文件之后，你需要让 <code>r.js</code> 知道你将使用这个配置文件，通过运行这条命令 <code>r.js -o build.js</code> 来开始执行，你可以在控制台中看到输出结果，就像下面这样。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ r.js -o build.js</div><div class="line">Optimizing (standard) CSS file: C:/Users/Elijah/Desktop/demo/dist/css/style.css</div><div class="line"> </div><div class="line">Tracing dependencies <span class="keyword">for</span>: main</div><div class="line">Uglifying file: C:/Users/Elijah/Desktop/demo/dist/build.js</div><div class="line">Uglifying file: C:/Users/Elijah/Desktop/demo/dist/libs/jquery.min.js</div><div class="line">Uglifying file: C:/Users/Elijah/Desktop/demo/dist/libs/postal.min.js</div><div class="line">Uglifying file: C:/Users/Elijah/Desktop/demo/dist/libs/require.min.js</div><div class="line">Uglifying file: C:/Users/Elijah/Desktop/demo/dist/libs/underscore.min.js</div><div class="line">Uglifying file: C:/Users/Elijah/Desktop/demo/dist/main.js</div><div class="line">Uglifying file: C:/Users/Elijah/Desktop/demo/dist/r.js</div><div class="line"> </div><div class="line">css/style.css</div><div class="line">----------------</div><div class="line">css/style.css</div><div class="line"> </div><div class="line"><span class="function">C:/<span class="title">Users</span>/<span class="title">Elijah</span>/<span class="title">Desktop</span>/<span class="title">demo</span>/<span class="title">src</span>/<span class="title">main.js</span></span></div><div class="line"><span class="function">----------------</span></div><div class="line"><span class="function"><span class="title">C</span>:/<span class="title">Users</span>/<span class="title">Elijah</span>/<span class="title">Desktop</span>/<span class="title">demo</span>/<span class="title">src</span>/<span class="title">main.js</span></span></div></pre></td></tr></table></figure><h2><span id="其他资源">其他资源</span></h2><p>在本文中，对于 RequireJS 和 r.js 优化工具，只涉及到很浅的部分，如果你想更加深入了解这些工具，你可以参考下面这些资源。</p><ul><li>Jack Franklin’s (<a href="http://twitter.com/jack_franklin" target="_blank" rel="external">@jack_franklin</a>) <a href="http://javascriptplayground.com/blog/2012/07/requirejs-amd-tutorial-introduction" target="_blank" rel="external">Introduction to RequireJS</a> article</li><li>Jeffrey Way’s (<a href="http://twitter.com/jeffrey_way" target="_blank" rel="external">@jeffrey_way</a>) <a href="http://net.tutsplus.com/tutorials/javascript-ajax/a-requirejs-backbone-and-bower-starter-template/" target="_blank" rel="external">A RequireJS, Backbone, and Bower Starter Template</a> screencast</li><li>Cary Landholt’s (<a href="http://twitter.com/carylandholt" target="_blank" rel="external">@carylandholt</a>) <a href="http://www.youtube.com/watch?v=VGlDR1QiV3A" target="_blank" rel="external">RequireJS Basics</a> video</li><li>Jonathan Creamer’s (<a href="http://twitter.com/jcreamer898" target="_blank" rel="external">@jcreamer898</a>) <a href="http://tech.pro/tutorial/1156/using-requirejs-in-an-aspnet-mvc-application" target="_blank" rel="external">Using Require.js in an ASP.NET MVC application</a> article</li></ul><h2><span id="进攻">进攻</span></h2><p>下面是一个用 <a href="http://incompl.github.com/boxbox/" target="_blank" rel="external">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href="https://code.google.com/p/box2dweb/" target="_blank" rel="external">box2dweb</a> 的物理学框架，由 <a href="http://bocoup.com/" target="_blank" rel="external">Bocoup</a> 的 <a href="http://twitter.com/_gsmith" target="_blank" rel="external">Greg Smith</a> 编写。</p><blockquote><p>按下空格键来发射黄色小鸟，你也可以使用方向键。</p></blockquote><p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-yellow-bird-requirejs-attack.png" alt=""></p><h2><span id="结论">结论</span></h2><p>前端应用很容易就变得复杂，理想的做法是提供某种结构和依赖管理的方式，以及对最终结果进行优化的方式。经过黄色小鸟的不懈努力，它们最终夺回了 RequireJS，并将在下一个应用中使用起来。</p><p>还有很多其他的前端架构技术也被猪偷走了。接下来，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p><p class="j-quote">原文：<a href="http://www.elijahmanor.com/angry-birds-of-javascript-yellow-bird-requirejs/" target="_blank" rel="external">Angry Birds of JavaScript: Yellow Bird RequireJS</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-of-javascript-yellow-bird-requirejs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）&lt;/p&gt;
&lt;p&gt;小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读本系列的&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/&quot;&gt;介绍文章&lt;/a&gt;，查看所有小鸟以及它们的进攻力量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;战况&quot;&gt;&lt;a href=&quot;#战况&quot; class=&quot;headerlink&quot; title=&quot;战况&quot;&gt;&lt;/a&gt;战况&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/&quot;&gt;红色大鸟 - 立即调用的函数表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/&quot;&gt;蓝色小鸟 - 事件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;黄色小鸟的攻击力&quot;&gt;&lt;a href=&quot;#黄色小鸟的攻击力&quot; class=&quot;headerlink&quot; title=&quot;黄色小鸟的攻击力&quot;&gt;&lt;/a&gt;黄色小鸟的攻击力&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-yellow-bird.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这片文章中，我们将看看黄色小鸟，它使用 &lt;a href=&quot;http://requirejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RequireJS&lt;/a&gt; 作为助推器，利用动态脚本加载来攻击那些讨厌的猪。慢慢的，小鸟们将一个接一个地夺回本属于他们的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Architecture" scheme="http://bubkoo.com/tags/architecture/"/>
    
      <category term="RequireJS" scheme="http://bubkoo.com/tags/requirejs/"/>
    
      <category term="Modular" scheme="http://bubkoo.com/tags/modular/"/>
    
      <category term="Dependency" scheme="http://bubkoo.com/tags/dependency/"/>
    
      <category term="Performance" scheme="http://bubkoo.com/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>蓝色小鸟 - 事件</title>
    <link href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/"/>
    <id>http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/</id>
    <published>2014-03-28T21:35:58.000Z</published>
    <updated>2014-03-28T21:35:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-blue-bird-events.png" alt=""></p><h2><span id="介绍">介绍</span></h2><p>一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）</p><p>小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p><blockquote><p>阅读本系列的<a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/">介绍文章</a>，查看所有小鸟以及它们的进攻力量。</p></blockquote><h2><span id="战况">战况</span></h2><ul><li><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/">红色大鸟 - 立即调用的函数表达式</a></li></ul><h2><span id="蓝色小鸟的攻击力">蓝色小鸟的攻击力</span></h2><p><img src="http://bubkoo.qiniudn.com/angry-birds-blue-bird-1.png" alt=""></p><p>在这篇文章中，我们将看看蓝色小鸟，它通过触发事件和消息来渗透进猪猪的城堡中，慢慢的，小鸟们将一个接一个地夺回本属于他们的东西。</p><a id="more"></a><h2><span id="猪猪偷走了什么">猪猪偷走了什么</span></h2><p>小鸟们曾经使用组件化的方式来构建 web 应用，但是组件之间有强依赖关系，它们最终开始学习，并引入了消息和事件机制来降低组件之间的耦合度。不幸的是，在进攻过程中，猪猪偷走了它们的观察者模式。</p><p>其中一只蓝色小鸟被指派去夺回被盗走的东西，并恢复松散耦合的组件。</p><h2><span id="示例程序">示例程序</span></h2><p>我们将以下面的 web 应用为例，来解释消息的必要性。这个应用的功能是从 Netflix 上搜索电影，我将展示这个应用的原始代码，然后重构它。</p><iframe allowfullscreen="allowfullscreen" frameborder="0" height="350" src="http://jsfiddle.net/LrFVp/14/embedded/result" width="100%"></iframe><h2><span id="紧耦合的代码">紧耦合的代码</span></h2><p>上面应用的第一个版本是用如下方式编写，看看这段代码，试着理解它。这可能很痛苦，但还请稍微忍耐一下 ;)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">$( <span class="built_in">document</span> ).on( <span class="string">"click"</span>, <span class="string">".term"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</div><div class="line">    $( <span class="string">"input"</span> ).val( $( <span class="keyword">this</span> ).text() );</div><div class="line">    $( <span class="string">"button"</span> ).trigger( <span class="string">"click"</span> );</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">$( <span class="string">"button"</span> ).on( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> searchTerm = $( <span class="string">"input"</span> ).val(),</div><div class="line">        url = <span class="string">"http://odata.netflix.com/Catalog/Titles?$filter=substringof('"</span> + </div><div class="line">            <span class="built_in">escape</span>( searchTerm ) + <span class="string">"',Name)&amp;$callback=callback&amp;$format=json"</span>;</div><div class="line"> </div><div class="line">    $( <span class="string">".help-block"</span> ).html( <span class="function"><span class="keyword">function</span>(<span class="params"> index, html </span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> e.originalEvent ? </div><div class="line">            html + <span class="string">", "</span> + <span class="string">"&lt;a href='#' class='term'&gt;"</span> + searchTerm + <span class="string">"&lt;/a&gt;"</span> : html;</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    $.ajax(&#123;</div><div class="line">        dataType: <span class="string">"jsonp"</span>,</div><div class="line">        url: url,</div><div class="line">        jsonpCallback: <span class="string">"callback"</span>,</div><div class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> rows = [];</div><div class="line">            $.each( data.d.results, <span class="function"><span class="keyword">function</span>(<span class="params"> index, result </span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> row = <span class="string">""</span>;</div><div class="line">                <span class="keyword">if</span> ( result.Rating &amp;&amp; result.ReleaseYear ) &#123;</div><div class="line">                    row += <span class="string">"&lt;td&gt;"</span> + result.Name + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">                    row += <span class="string">"&lt;td&gt;"</span> + result.Rating + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">                    row += <span class="string">"&lt;td&gt;"</span> + result.ReleaseYear + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">                    row = <span class="string">"&lt;tr&gt;"</span> + row + <span class="string">"&lt;/tr&gt;"</span>;</div><div class="line">                    rows.push( row );</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            $( <span class="string">"table"</span> ).show().find( <span class="string">"tbody"</span> ).html( rows.join( <span class="string">""</span> ) );</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>上面的代码示例是一个典型的 jQuery 例子，在网上随处可见。这段代码可以工作，但是在同个位置处理了许多不同的事务，你可以发现，事件处理、获取数据和处理数据都混杂在了同一个地方。可以想象，随着时间推移，这段代码可能变得越来越庞大，也变得越来越容易发生错误。</p><p>在继续深入之前，我们先看看事件具体是什么，它有些什么类型。</p><h2><span id="事件类型">事件类型</span></h2><h3><span id="观察者事件">观察者事件</span></h3><p>如果你熟悉前端开发，观察者事件很可能是你最常用的一种事件。对于 DOM 来说，你可以将这种事件看着是给 DOM 元素添加事件处理函数，DOM 元素直接引用了事件的回调函数，当指定的事件发送时，回调函数将被执行。</p><h4><span id="例子">例子</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.getElementById( <span class="string">"bird"</span> )</div><div class="line">    <span class="comment">// 用原生的 addEventListener 方法给 DOM 元素添加事件</span></div><div class="line">    .addEventListener( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">"Catapult!"</span> ); &#125;, <span class="literal">false</span> );</div><div class="line"> </div><div class="line">$( <span class="string">"#bird"</span> )</div><div class="line">    <span class="comment">// Old school event helpers attaches observer to the DOM element</span></div><div class="line">    .click( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">"Flying through the air..."</span> ); &#125; )</div><div class="line">    <span class="comment">// Old school bind method attaches observer to the DOM element</span></div><div class="line">    .bind( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">"COWABUNGA!"</span> ); &#125; )</div><div class="line">    <span class="comment">// New school 2 parameter on method attaches observer to the DOM element</span></div><div class="line">    .on( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">"Destroy those pesky pigs!"</span> ); &#125; );</div><div class="line"> </div><div class="line"><span class="comment">// Event is triggered and the list of observers are notified</span></div><div class="line">$( <span class="string">"#bird"</span> ).trigger( <span class="string">"click"</span> );</div></pre></td></tr></table></figure><h2><span id="媒介事件">媒介事件</span></h2><p>在最近几年中媒介事件变得越来越普遍，其核心思想是，用一个实体来管理订阅和发布消息，与观察者事件最大的不同在于，媒介事件不会直接绑定在触发事件的对象上。</p><blockquote><p>这就是设计模式中的发布订阅模式，或者叫观察者模式</p></blockquote><h4><span id="例子">例子</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> channel = postal.channel(),</div><div class="line">    $lastUpdated = $( <span class="string">"#lastUpdated"</span> );</div><div class="line"> </div><div class="line"><span class="comment">// 订阅 bird.launch 消息</span></div><div class="line">channel.subscribe( <span class="string">"bird.launch"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Launch the blue birds at a "</span> + data.angle + <span class="string">" angle!"</span> );</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 订阅 bird.reset 消息</span></div><div class="line">channel.subscribe( <span class="string">"bird.reset"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Resetting blue birds to the catapult."</span> );</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 订阅满足 bird.* 通配符格式的消息</span></div><div class="line">channel.subscribe( <span class="string">"bird.*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">    $lastUpdated.text( moment().format( <span class="string">"MMMM Do YYYY, h:mm:ss a"</span> ) ); </div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 发布消息，并附带可选的参数</span></div><div class="line">channel.publish( <span class="string">"bird.launch"</span>, &#123; <span class="attr">angle</span>: <span class="number">45</span> &#125; );</div><div class="line">channel.publish( <span class="string">"bird.reset"</span> );</div></pre></td></tr></table></figure><h4><span id="实现">实现</span></h4><p>有一些库可以让你方便地使用媒介事件，下面列举出了一些可择库，个人推荐使用 Jim <a href="https://github.com/postaljs/postal.js" target="_blank" rel="external">postal.js</a> 库。</p><ul><li>Ben Alman’s (<a href="http://twitter.com/cowboy" target="_blank" rel="external">@cowboy</a>) <a href="https://github.com/cowboy/jquery-tiny-pubsub" target="_blank" rel="external">Tiny jQuery Pub/Sub</a> library</li><li>Peter Higgin’s (<a href="http://twitter.com/phiggins" target="_blank" rel="external">@phiggins</a>) <a href="https://github.com/phiggins42/bloody-jquery-plugins/blob/master/pubsub.js" target="_blank" rel="external">pubsub.js</a> library</li><li><strong>Jim Cowart’s (<a href="http://twitter.com/ifandelse" target="_blank" rel="external">@ifandelse</a>) <a href="https://github.com/postaljs/postal.js" target="_blank" rel="external">postal.js</a> library ← 推荐</strong></li><li>Dustin Diaz’s (<a href="http://twitter.com/ded" target="_blank" rel="external">@ded</a>) <a href="https://github.com/ded/reqwest" target="_blank" rel="external">reqwest</a> library</li><li>appendTo’s (<a href="http://twitter.com/appendTo" target="_blank" rel="external">@appendTo</a>) <a href="http://amplify.js/" target="_blank" rel="external">AmplifyJS Pub/Sub</a> component</li></ul><h2><span id="混合事件">混合事件</span></h2><p>另外一种事件则混合了观察者事件和媒介事件。这种事件看起来像是媒介事件，但是如果仔细看，你可以追述到事件的订阅者。jQuery 的代理模式就是一个很好的例子，代理模式很有用，但是它是基于 DOM 的事件冒泡机制，所以我们可以追踪到事件的来源。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Observer is attached to the #pigs element where impact events are delegated</span></div><div class="line">$( <span class="string">"#pigs"</span> ).on( <span class="string">"impact"</span>, <span class="string">".pig"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"I know which pig was impacted: "</span> + e.target.innerHTML );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"I know where the subscribers are listed: "</span> + e.delegateTarget.id );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"I can invoke another subscriber if I want!"</span> );</div><div class="line">    $._data( e.delegateTarget, <span class="string">"events"</span> ).secret[ <span class="number">0</span> ].handler( e );</div><div class="line">    $( <span class="keyword">this</span> ).text( <span class="string">"Bacon"</span> );</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">$( <span class="string">"#pigs"</span> ).on( <span class="string">"secret"</span>, <span class="string">".pig"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Shh, I'm hiding. Don't tell anyone..."</span> );</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 事件在 .pig 元素上触发并冒泡到 #pigs 元素上</span></div><div class="line">$( <span class="string">".pig:first"</span> ).trigger( <span class="string">"impact"</span> );</div></pre></td></tr></table></figure><p>顺便说一下，我不推荐使用 <code>$._data()</code> 方法，因为它并没有出现在官方 API 文档中，因此不能保证在 jQuery 的以后的版本中可用，这是 jQuery 内部的一个帮助方法。但是，我这里想告诉你的是，在混合事件中，订阅者可以获取到一些在媒介事件中不能获取到的一些消息。别误会我的意思，我很喜欢 jQuery 的代理事件，这里只是为了演示混合事件是上面两种事件的组合。</p><h2><span id="该使用哪一个">该使用哪一个</span></h2><p>概念都梳理清楚了，那么我该使用哪种类型的事件呢，以及在什么时候使用？这是一个很好的问题，我的一个朋友 Jim 在他最近的一篇文章中也有提及该问题，下面是他文章中的一段引用…</p><blockquote><p>在组件内部使用观察者事件，在组件之间使用媒介事件，不管怎么样，他们可以同时使用。 -<a href="http://freshbrewedcode.com/jimcowart/2013/02/07/client-side-messaging-essentials/" target="_blank" rel="external">Jim Cowart</a></p></blockquote><p>Jim 推荐在模块内部的通信时使用观察者事件（jQuery 的 <code>.on()</code> 方法），组件之间的通信则使用中介事件（postal.js）。</p><p>Jim 在他的文章中提出的另一项技术，就是将观察者事件和媒介事件合成在一起，这样可以两全其美，他展示了一些很棒的例子，我推荐你去看看他的文章，文章链接在下面的参考资源中用粗体标示出来了。</p><h2><span id="附加资源">附加资源</span></h2><p>如果你对上述概念有兴趣并想获取更多信息，你可以考虑通过下面这些资源来了解更多关于事件的信息。</p><ul><li><strong>Jim Cowart’s (<a href="http://twitter.com/ifandelse" target="_blank" rel="external">@ifandelse</a>) <a href="http://freshbrewedcode.com/jimcowart/2013/02/07/client-side-messaging-essentials/" target="_blank" rel="external">Client-side Messaging Essentials</a> article</strong></li><li>Addy Osmani’s (<a href="http://twitter.com/addyosmani" target="_blank" rel="external">@addyosmani</a>) <a href="http://msdn.microsoft.com/en-us/magazine/hh201955.aspx" target="_blank" rel="external">Understanding the Publish/Subscribe Pattern for Greater JavaScript Scalability</a> article</li><li>Rebecca Murphey’s (<a href="http://twitter.com/rmurphey" target="_blank" rel="external">@rmurphey</a>) <a href="http://net.tutsplus.com/tutorials/javascript-ajax/loose-coupling-with-the-pubsub-plugin/" target="_blank" rel="external">Loose Coupling with the pubsub Plugin</a> screencast</li></ul><h2><span id="松散耦合的代码">松散耦合的代码</span></h2><p>我原打算用 Backbone.js 或构造函数来编写下面的代码，但是为了保持简单和表达消息的理念，我把它们都移除了。因此，虽然这可能不是实际代码库的代码，但希望你一看就明白是什么意思。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> channel = postal.channel();</div><div class="line"> </div><div class="line">$( <span class="built_in">document</span> ).on( <span class="string">"click"</span>, <span class="string">".term"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> term = $( <span class="keyword">this</span> ).text();</div><div class="line">    </div><div class="line">    e.preventDefault();</div><div class="line">    $( <span class="string">"input"</span> ).val( term );</div><div class="line">    channel.publish( <span class="string">"searchTerm.changed"</span>, &#123; <span class="attr">term</span>: term &#125; );</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">$( <span class="string">"button"</span> ).on( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    channel.publish( <span class="string">"searchTerm.changed"</span>, &#123; <span class="attr">term</span>: $( <span class="string">"input"</span> ).val() &#125; );</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">channel.subscribe( <span class="string">"searchTerm.changed"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">    netflix.getTitles( data.term, <span class="function"><span class="keyword">function</span>(<span class="params"> titles </span>) </span>&#123;</div><div class="line">        channel.publish( <span class="string">"netflix.titles.updated"</span>, titles );</div><div class="line">    &#125;);    </div><div class="line">&#125;);</div><div class="line"> </div><div class="line">channel.subscribe( <span class="string">"searchTerm.changed"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">    $( <span class="string">".help-block"</span> ).html( <span class="function"><span class="keyword">function</span>(<span class="params"> index, html </span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> ~html.indexOf( data.term ) ? html :</div><div class="line">            html + <span class="string">", "</span> + <span class="string">"&lt;a href='#' class='term'&gt;"</span> + data.term + <span class="string">"&lt;/a&gt;"</span>;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">channel.subscribe( <span class="string">"netflix.titles.updated"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> titles </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> rows = [];</div><div class="line">    $.each( titles, <span class="function"><span class="keyword">function</span>(<span class="params"> index, result </span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> row = <span class="string">""</span>;</div><div class="line">        <span class="keyword">if</span> ( result.Rating &amp;&amp; result.ReleaseYear ) &#123;</div><div class="line">            row += <span class="string">"&lt;td&gt;"</span> + result.Name + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">            row += <span class="string">"&lt;td&gt;"</span> + result.Rating + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">            row += <span class="string">"&lt;td&gt;"</span> + result.ReleaseYear + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">            row = <span class="string">"&lt;tr&gt;"</span> + row + <span class="string">"&lt;/tr&gt;"</span>;</div><div class="line">            rows.push( row );</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    $( <span class="string">"table"</span> ).show().find( <span class="string">"tbody"</span> ).html( rows.join( <span class="string">""</span> ) );</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="built_in">window</span>.netflix = &#123;</div><div class="line">    getTitles: <span class="function"><span class="keyword">function</span>(<span class="params"> term, callback </span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> url = <span class="string">"http://odata.netflix.com/Catalog/Titles?$filter=substringof('"</span> +</div><div class="line">                <span class="built_in">escape</span>( term ) + <span class="string">"',Name)&amp;$callback=callback&amp;$format=json"</span>;</div><div class="line">      </div><div class="line">        $.ajax(&#123;</div><div class="line">            dataType: <span class="string">"jsonp"</span>,</div><div class="line">            url: url,</div><div class="line">            jsonpCallback: <span class="string">"callback"</span>,</div><div class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123; callback( data.d.results ); &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2><span id="进攻">进攻</span></h2><p>下面是一个用 <a href="http://incompl.github.com/boxbox/" target="_blank" rel="external">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href="https://code.google.com/p/box2dweb/" target="_blank" rel="external">box2dweb</a> 的物理学框架，由 <a href="http://bocoup.com/" target="_blank" rel="external">Bocoup</a> 的 <a href="http://twitter.com/_gsmith" target="_blank" rel="external">Greg Smith</a> 编写。</p><blockquote><p>按下空格键来发射蓝色小鸟，你也可以使用方向键。如果花了很长时间也不能摧毁猪群，那么你可能要考虑多按几次空格键了 ;)</p></blockquote><p><img src="http://bubkoo.qiniudn.com/angry-birds-blue-bird-attack.png" alt=""></p><h2><span id="结论">结论</span></h2><p>在你的 web 应用中使用事件和消息可以帮助通信，事件可以实现组件的内部通信，消息则可以使实现组件之间的监听，而不需要强依赖关系。</p><p>还有很多其他的前端架构技术也被猪偷走了。接下来，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p><p class="j-quote">原文：<a href="http://www.elijahmanor.com/angry-birds-of-javascript-blue-bird-events/" target="_blank" rel="external">Angry Birds of JavaScript- Blue Bird: Events</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-of-javascript-blue-bird-events.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来。一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）&lt;/p&gt;
&lt;p&gt;小鸟们最终能取得胜利吗？它们会战胜那些满身培根味的敌人吗？让我们一起来揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读本系列的&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/&quot;&gt;介绍文章&lt;/a&gt;，查看所有小鸟以及它们的进攻力量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;战况&quot;&gt;&lt;a href=&quot;#战况&quot; class=&quot;headerlink&quot; title=&quot;战况&quot;&gt;&lt;/a&gt;战况&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/&quot;&gt;红色大鸟 - 立即调用的函数表达式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;蓝色小鸟的攻击力&quot;&gt;&lt;a href=&quot;#蓝色小鸟的攻击力&quot; class=&quot;headerlink&quot; title=&quot;蓝色小鸟的攻击力&quot;&gt;&lt;/a&gt;蓝色小鸟的攻击力&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-blue-bird-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将看看蓝色小鸟，它通过触发事件和消息来渗透进猪猪的城堡中，慢慢的，小鸟们将一个接一个地夺回本属于他们的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Architecture" scheme="http://bubkoo.com/tags/architecture/"/>
    
      <category term="Event" scheme="http://bubkoo.com/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>红色大鸟 - 立即调用的函数表达式</title>
    <link href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/"/>
    <id>http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/</id>
    <published>2014-03-28T12:23:29.000Z</published>
    <updated>2014-03-28T12:23:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-red-bird-iife.png" alt=""></p><h2><span id="介绍">介绍</span></h2><p>一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来，一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）</p><p>本文将介绍红色大鸟，它们以 IIFE 作为中坚力量进行进攻，IIFE 是一切私有化的基础。</p><blockquote><p>译注：IIFE (Immediately-invoked Function Expression) 立即调用的函数表达式</p></blockquote><p><img src="http://bubkoo.qiniudn.com/angry-birds-red-bird.png" alt=""></p><h2><span id="猪猪偷走了什么">猪猪偷走了什么</span></h2><p>多年来小鸟们们习惯于将它们自定的变量和函数乱扔在全局命名空间下（<code>window</code> 对象），随着时间的推移，它们慢慢学会了如何使用一些技巧来保护他们的对象，但是，最近这些非全局命名空间中的秘密都被猪猪给偷走了，幸好小鸟们很辛运，这项技术存在一些缺陷，它们计划攻击猪群，然后释放本属于它们的东西。</p><a id="more"></a><h2><span id="对象是如何成为全局的">对象是如何成为全局的</span></h2><p>有几种方式来使一个对象成为全局对象，战争的一部分就是来了解这些方式。</p><ul><li><strong>在 window 作用域中声明对象</strong></li></ul><p>下面例子中声明了 <code>type</code> 和 <code>attack</code> 两个变量，它们被声明在顶级作用域中，因此它们可以通过 <code>window</code> 对象来访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> type = <span class="string">"Red"</span>,</div><div class="line">    attack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( type + <span class="string">" Bird Attacks!"</span> );</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.type );   <span class="comment">// 这是全局变量</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.attack ); <span class="comment">// 这是全局函数</span></div></pre></td></tr></table></figure><ul><li><strong>对象未在任何作用域中声明</strong></li></ul><p>在 JavaScript 中意外声明一个全局变量是最危险和最易发生的事情，当然你不是故意要这样做。如果你忘记声明一个变量，那么 JavaScript 将为你声明并使其成为一个全局变量，这通常不是你期望的，并可能暴露你程序的某些部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> type = <span class="string">"Red"</span>,</div><div class="line">    attack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        typeOfBird = type + <span class="string">" Bird"</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> typeOfBird + <span class="string">" Bird Attacks!"</span>;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.type );       <span class="comment">// 这是全局变量</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.attack() );   <span class="comment">// 这是全局函数</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.typeOfBird ); <span class="comment">// 这也是一个全局变量 :(</span></div></pre></td></tr></table></figure><ul><li><strong>明确地向 Window 添加对象</strong></li></ul><p>你也可以有意将变量暴露给全局命名空间。你可以简单地访问 <code>window</code> 对象来手动添加属性或方法，在代码中使用这项技术，这并不是一个好主意，也没有任何价值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> type = <span class="string">"Red"</span>,</div><div class="line">    attack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        typeOfBird = type + <span class="string">" Bird"</span>;</div><div class="line"> </div><div class="line">        <span class="built_in">window</span>.message = typeOfBird + <span class="string">" Attacks!"</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> typeOfBird + <span class="string">" Bird Attacks!"</span>;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.type );       <span class="comment">// 这是全局变量</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.attack() );   <span class="comment">// 这是全局函数</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.typeOfBird ); <span class="comment">// 这也是一个全局变量 :(</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.message );    <span class="comment">// 这也是一个全局变量 :|</span></div></pre></td></tr></table></figure><h2><span id="为什么全局对象会导致一些问题">为什么全局对象会导致一些问题</span></h2><ul><li><p><strong>代码冲突</strong><br>与你同一个公司的开发人员，可能会声明一些在你的程序中已经存在的函数、方法或属性，这是有风险的。如果你没有减少全局命名空间中条目的机制，随着你的程序变得越来越庞大和复杂，变量被意外覆盖的风险就会随之增加。你可能会规避这个风险，因为你有严格的代码审查，并且所有的开发人员都知道你代码的方方面面。如果这正是描述的你，那么请看看下面的原因 ;)</p></li><li><p><strong>与第三方库冲突</strong><br>使用全局变量的另一个风险就是，你的代码可能和你正在使用的第三方库冲突。目前有很多库、插件和框架，并不是所有这些三方库都了解和有意识地将全局变量控制到最少，你的代码和这些库可能会发生冲突，并覆盖彼此的行为，这可能导致意想不到的结果。你可能会规避这个风险，因为你深入了解了你正在使用的三方库，并完全知道这些三方库暴露了那些全局变量。如果这正是描述的你，那么请接着看下面的原因 ;)</p></li><li><p><strong>与浏览器的附加元件/扩展/插件冲突</strong><br>使用全局变量的最后一个风险就是，你的代码可能和浏览器自身冲突。什么！？！我们以 Chrome 为例，Chrome 的插件是基于 JavaScript 的，并且当页面加载完成之后，所有已经安装的插件将运行在你的页面上。你永远不知道你的用户会安装什么样的插件，那么这些插件暴露的全局变量就可能与你的代码冲突。这也许有些牵强？好吧，这只是一种可能，但是我的确遇到一个高调的网站（我不会说是哪一个）面临了这种问题，当我使用这个网站时，却发现它被损坏了。我认识这个网站的开发人员，因此我联系了他们，经过反复排查，结果发现是一个安装的插件导致了网站的崩溃。我联系了插件的开发者，然后他们更新了他们的代码，现在一切才恢复正常。</p></li></ul><h2><span id="保护自己的各种方式">保护自己的各种方式</span></h2><p>虽然上面的代码片段都很短并且很简单，他们都暴露的太多的变量到全局命名空间中。所以，我们如何保护我们的代码呢？</p><ul><li><strong>对象字面量</strong><br>防止全局扩散最简单的方式是，将一些全局变量放在一个中心的对象字面量上。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将 type &amp; attack 属性放在 bird 这个对象字面量上</span></div><div class="line"><span class="keyword">var</span> bird = &#123;</div><div class="line">    type: <span class="string">"Red"</span>,</div><div class="line">    attack: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="keyword">this</span>.type + <span class="string">" Bird Attacks!"</span> );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.bird );          <span class="comment">// 只有一个全局对象</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.bird.type );     <span class="comment">// Red</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.bird.attack() ); <span class="comment">// Red Bird Attacks!</span></div></pre></td></tr></table></figure><ul><li><strong>立即执行的函数表达式</strong><br>立即执行的函数表达式（IIFE）是解决全局变量问题的另一种方式，这种方式比对象字面量更复杂，但也提供能更强大的功能。这种方式允许开发人员暴露公共和私有的属性、方法给使用者。在进去正题之前，我们先看看这种方式的一些奇怪的语法，JavaScript 变量的作用域是通过函数作用域来决定的，而没有块级作用域的概念。因此，如果你在 <code>if</code> 语句内声明一个变量，这个变量将在包含这个 <code>if</code> 语句的函数的任何位置都将可用，这也许对于那些惯于使用 C、C++、C#、Java 和 类似语言的开发者有些震惊。下面，我们将利用函数作用域这一特性来创建一个匿名函数（没有名字的函数），并立即调用它。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Error: JavaScript 不能正确解析这段代码</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 所有变量或函数都包含在这个范围</span></div><div class="line">&#125;(); <span class="comment">// &lt;-- 立即调用</span></div></pre></td></tr></table></figure><p>不幸的是，上面这段代码并不能被正确执行，因为 JavaScript 不能正确解析这段代码。思路是对的，但是实现有一点点偏差。值得庆幸的，有一种简单的方式让 JavaScript 知道我们在做什么，就是用一组额外的括号包裹这个表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JavaScript 能够正确解析</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 所有变量或函数都包含在这个范围</span></div><div class="line">&#125;()); <span class="comment">// &lt;-- 立即调用</span></div></pre></td></tr></table></figure><p>译者注：立即执行的函数还有另外一种书写方式，后面会有介绍：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JavaScript 能够正确解析</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 所有变量或函数都包含在这个范围</span></div><div class="line">&#125;)(); <span class="comment">// &lt;-- 立即调用</span></div></pre></td></tr></table></figure><p>下面的模式是大家所熟知的暴露模块模式（Revealing Module Pattern）。你应该注意到，使用立即执行的函数创建了一个特殊的函数作用域，并且，需要特别注意的是，在结尾处返回了作用域中那些你想作为公共的属性，剩下的那些没有被返回的将会成为私有属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Revealing Module Pattern</span></div><div class="line"><span class="keyword">var</span> bird = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> type = <span class="string">"Red"</span>,</div><div class="line">        power = <span class="string">"IIFE"</span>, <span class="comment">// 这将是私有的</span></div><div class="line">        attack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log( type + <span class="string">" Bird Attacks with an "</span> + power +  <span class="string">"!"</span> );</div><div class="line">        &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 只有被返回的那些才是公共的</span></div><div class="line">        type: type,</div><div class="line">        attack: attack</div><div class="line">    &#125;;</div><div class="line">&#125;());</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.bird );          <span class="comment">// 只有一个全局变量</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.bird.type );     <span class="comment">// 公共属性</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.bird.attack() ); <span class="comment">// 公共方法，并能访问私有变量</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.bird.power );    <span class="comment">// 私有变量，将不能被访问（执行到这里将会报错）</span></div></pre></td></tr></table></figure><p>你可能也遇到过下面这种替代语法，它在很多库和框架中很流行。这种模式仍然使用了 IIFE，但是传入了一个全局变量作为命名空间。<code>window.bird = window.bird || {}</code> 这段代码，是一种奇特的方式来检查 <code>bird</code> 对象是否已经存在，如果不存在就创建一个新对象。在立即执行的函数内部，任何附加到 <code>bird</code> 对象的变量或方法都将是公共的，而其他的都将是私有的。这种模式的好处是，它可以重复使用，用各种组件来构建一个库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> bird </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> power = <span class="string">"IIFE"</span>; <span class="comment">// 这将是私有的</span></div><div class="line">    </div><div class="line">    bird.type = <span class="string">"Red"</span>;</div><div class="line">    bird.attack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( bird.type + <span class="string">" Bird Attacks with an "</span> + power + <span class="string">"!"</span> );</div><div class="line">    &#125;;</div><div class="line">&#125;( <span class="built_in">window</span>.bird = <span class="built_in">window</span>.bird || &#123;&#125; ));</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.bird );          <span class="comment">// 只有一个全局对象</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.bird.type );     <span class="comment">// 公共属性</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.bird.attack() ); <span class="comment">// 公共方法，并能访问私有变量</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.bird.power );    <span class="comment">// 私有变量，将不能被访问（执行到这里将会报错）</span></div></pre></td></tr></table></figure><h2><span id="进攻">进攻！</span></h2><p>下面是一个用 <a href="http://incompl.github.com/boxbox/" target="_blank" rel="external">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href="https://code.google.com/p/box2dweb/" target="_blank" rel="external">box2dweb</a> 的物理学框架，由 <a href="http://bocoup.com/" target="_blank" rel="external">Bocoup</a> 的 <a href="http://twitter.com/_gsmith" target="_blank" rel="external">Greg Smith</a> 编写。</p><blockquote><p>按下空格键来发射红色小鸟，你也可以使用方向键。</p></blockquote><p><img src="http://bubkoo.qiniudn.com/angry-birds-jsfiddle-shadow.png" alt=""></p><h2><span id="结论">结论</span></h2><p>这些技术对一个前端应用程序是至关重要的，因为它可以保护自己免受其他代码的干扰，并且提供了一种方式来封装组织你的代码。</p><p>还有很多其他的前端架构技术也被猪偷走了。接下来，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p><p class="j-quote">原文： <a href="http://www.elijahmanor.com/angry-birds-of-javascript-red-bird-iife/" target="_blank" rel="external">Angry Birds of JavaScript- Red Bird: IIFE</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-of-javascript-red-bird-iife.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来，一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）&lt;/p&gt;
&lt;p&gt;本文将介绍红色大鸟，它们以 IIFE 作为中坚力量进行进攻，IIFE 是一切私有化的基础。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译注：IIFE (Immediately-invoked Function Expression) 立即调用的函数表达式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-red-bird.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;猪猪偷走了什么&quot;&gt;&lt;a href=&quot;#猪猪偷走了什么&quot; class=&quot;headerlink&quot; title=&quot;猪猪偷走了什么&quot;&gt;&lt;/a&gt;猪猪偷走了什么&lt;/h2&gt;&lt;p&gt;多年来小鸟们们习惯于将它们自定的变量和函数乱扔在全局命名空间下（&lt;code&gt;window&lt;/code&gt; 对象），随着时间的推移，它们慢慢学会了如何使用一些技巧来保护他们的对象，但是，最近这些非全局命名空间中的秘密都被猪猪给偷走了，幸好小鸟们很辛运，这项技术存在一些缺陷，它们计划攻击猪群，然后释放本属于它们的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Architecture" scheme="http://bubkoo.com/tags/architecture/"/>
    
      <category term="IIFE" scheme="http://bubkoo.com/tags/iife/"/>
    
  </entry>
  
  <entry>
    <title>愤怒的小鸟与 JavaScript 系列</title>
    <link href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/"/>
    <id>http://bubkoo.com/2014/03/28/angry-birds-of-javascript-series/</id>
    <published>2014-03-28T10:52:45.000Z</published>
    <updated>2014-03-28T10:52:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bubkoo.qiniudn.com/angry-birds-of-javascript-series.jpg" alt="OlechkaDesign.com"></p><h2><span id="介绍">介绍</span></h2><p>一群恶魔的猪从无辜的小鸟那里偷走了所有的前端架构，现在它们要夺回来，一对特工英雄（愤怒的小鸟）将攻击那些卑鄙的猪，直到夺回属于他们的前端架构。（译者注：本系列是关乎前端架构的讨论，作者借用当前最风靡的游戏 - 愤怒的小鸟，为我们揭开了前端架构的真实面目。）</p><h2><span id="来认识一下我们的特工英雄">来认识一下我们的特工英雄</span></h2><p>在接下来的几周里会逐渐向你介绍我们的超级英雄…</p><ul><li><p><strong><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-red-bird-iife/">红色大鸟（大兄弟）</a></strong></p><p><img src="http://bubkoo.qiniudn.com/angry-birds-red-bird.png" alt=""></p><p>红色大鸟兄弟依靠 IIFE 的力量进行攻击，IIFE 是一切私有化的基础。封装你的代码，保护代码免受其他代码的干扰。</p><blockquote><p>译注：IIFE (Immediately-invoked Function Expression) 立即调用的函数表达式</p></blockquote></li><li><p><strong><a href="http://bubkoo.com/2014/03/28/angry-birds-of-javascript-blue-bird-events/">蓝色小鸟（分身鸟）</a></strong></p><p><img src="http://bubkoo.qiniudn.com/angry-birds-blue-bird.png" alt=""></p><p>蓝色小鸟触发事件和消息来渗透进猪猪的城堡中。</p></li><li><p><strong><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-yellow-bird-requirejs/">黄色小鸟（神风敢死鸟）</a></strong></p><p><img src="http://bubkoo.qiniudn.com/angry-birds-yellow-bird.png" alt=""></p><p>黄色小鸟使用 <a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a> 作为助推器，利用动态脚本加载来攻击那些讨厌的猪。</p></li><li><p><strong><a href="http://bubkoo.com/2014/03/29/angry-birds-of-javascript-black-bird-backbone/">黑色小鸟（炸弹鸟）</a></strong></p><p><img src="http://bubkoo.qiniudn.com/angry-birds-black-bird.png" alt=""></p><p>黑色小鸟被证明是最有组织的方法来打击小猪们，它们引入了 Backbone.js 的先进理念，采用炸弹进攻。</p></li><li><p><strong><a href="http://bubkoo.com/2014/04/14/angry-birds-of-javascript-white-bird-linting/">白色小鸟（巾帼英雄）</a></strong></p><p><img src="http://bubkoo.qiniudn.com/angry-birds-white-bird.png" alt=""></p><p>白色小鸟看似没有攻击力，但是，当它们拿出严格的代码风格和质量检查时，小猪们都惊呆了。</p></li><li><p><strong><a href="http://bubkoo.com/2014/04/17/angry-birds-of-javascript-green-bird-mocking/">绿色小鸟（回旋鸟）</a></strong></p><p><img src="http://bubkoo.qiniudn.com/angry-birds-green-bird.png" alt=""></p><p>绿色小鸟可以抵达那些难以到达的地方，利用模拟和间谍方式来打击那些偷东西的猪。</p></li><li><p><strong><a href="http://bubkoo.com/2014/04/18/angry-birds-of-javascript-orange-bird-templating/">橙色小鸟（气球鸟）</a></strong></p><p><img src="http://bubkoo.qiniudn.com/angry-birds-Orange-bird.png" alt=""></p><p>开始时，它是一个简单的模板，然后被解析成 DOM 对象，这明确传达了一个消息就是小鸟们是认真的。</p></li></ul><ul><li><p><strong><a href="http://bubkoo.com/2014/04/19/angry-birds-of-javascript-big-brother-bird-patterns/">大兄弟</a></strong></p><p><img src="http://bubkoo.qiniudn.com/angry-birds-big-brother-bird.png" alt=""></p><p>大兄弟拿出了设计模式和有限状态机这杆大枪。</p></li><li><p><strong><a href="http://bubkoo.com/2014/04/20/angry-birds-of-javascript-mighty-eagle-automation/">神鹰</a></strong></p><p><img src="http://bubkoo.qiniudn.com/angry-birds-angrybirds-eagle.png" alt=""></p><p>神鹰使用超级武器，一套工具，可以组织和部署其它鸟儿们，来对抗他们即将征服的敌人。</p></li></ul><p>图片来源于 <a href="http://angrybirds.wikia.com/wiki/Mighty_Eagle" target="_blank" rel="external">Angry Birds Wiki</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/angry-birds-of-javascript-series.jpg&quot; alt=&quot;OlechkaDesign.com&quot;&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;介绍&quot;&gt;介绍&lt;/span&gt;&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Architecture" scheme="http://bubkoo.com/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>Promises 和异步编程</title>
    <link href="http://bubkoo.com/2014/03/25/promises-and-async-programming/"/>
    <id>http://bubkoo.com/2014/03/25/promises-and-async-programming/</id>
    <published>2014-03-25T08:36:57.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中处理异步和回调就是家常便饭，我们通常会面对这样一些问题：</p><ol><li>如何优雅滴组织我们的回调代码</li><li>对异步函数错误处理的最佳实践是什么</li><li>异步嵌套问题</li><li>怎样使我们的代码可读性和可维护性更高</li></ol><blockquote><p>Programs are meant to be read by humans and only incidentally for computers to execute. 程序是给人读的，只是顺带让计算机执行一下。 ——《编写可维护的JavaScript》@Donald Knuth</p></blockquote><p>当然，最常见也是最简单的处理方式就是，直接将回调函数或错误处理函数作为异步函数的参数，在异步函数返回时进行相应的调用，这种方式的缺陷估计大家心里或多或少都有点见解。难道就没有爽的编程模式？</p><p>这里分享了几篇文章，主要讲解了 JavaScript 中的 Promise 机制，以及如何使用它来改善我们的异步编程和回调问题。其中三篇参阅了 <a href="http://nuysoft.com/2013/08/29/async-programming/" target="_blank" rel="external">http://nuysoft.com/2013/08/29/async-programming/</a> ，另外一篇来自 <a href="http://www.html5rocks.com/zh/tutorials/es6/promises/" target="_blank" rel="external">html5rocks 的 Promise 教程</a>。</p><ul><li><a href="http://bubkoo.com/2014/03/25/async-programming-is-messy/">凌乱的异步编程</a></li><li><a href="http://bubkoo.com/2014/03/25/simplifying-async-with-promises/">用 Promises 简化异步编程</a> </li><li><a href="http://bubkoo.com/2014/03/25/mastering-async-error-handling-with-promises/">用 Promises 控制异步错误处理</a> </li><li><a href="http://bubkoo.com/2014/03/22/javascript-promises/">JavaScript Promises 教程</a></li></ul><p>下图是 jQuery 中动画回调链，图片来自 @司徒正美 的 MVC 分享 PPT。</p><p><img src="http://bubkoo.qiniudn.com/nightmare-of-callback.jpg" alt="回调的噩梦"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 中处理异步和回调就是家常便饭，我们通常会面对这样一些问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何优雅滴组织我们的回调代码&lt;/li&gt;
&lt;li&gt;对异步函数错误处理的最佳实践是什么&lt;/li&gt;
&lt;li&gt;异步嵌套问题&lt;/li&gt;
&lt;li&gt;怎样使我们的代码可读性和可维护性更高&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Programs are meant to be read by humans and only incidentally for computers to execute. 程序是给人读的，只是顺带让计算机执行一下。 ——《编写可维护的JavaScript》@Donald Knuth&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，最常见也是最简单的处理方式就是，直接将回调函数或错误处理函数作为异步函数的参数，在异步函数返回时进行相应的调用，这种方式的缺陷估计大家心里或多或少都有点见解。难道就没有爽的编程模式？&lt;/p&gt;
&lt;p&gt;这里分享了几篇文章，主要讲解了 JavaScript 中的 Promise 机制，以及如何使用它来改善我们的异步编程和回调问题。其中三篇参阅了 &lt;a href=&quot;http://nuysoft.com/2013/08/29/async-programming/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nuysoft.com/2013/08/29/async-programming/&lt;/a&gt; ，另外一篇来自 &lt;a href=&quot;http://www.html5rocks.com/zh/tutorials/es6/promises/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;html5rocks 的 Promise 教程&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/25/async-programming-is-messy/&quot;&gt;凌乱的异步编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/25/simplifying-async-with-promises/&quot;&gt;用 Promises 简化异步编程&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/25/mastering-async-error-handling-with-promises/&quot;&gt;用 Promises 控制异步错误处理&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/03/22/javascript-promises/&quot;&gt;JavaScript Promises 教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图是 jQuery 中动画回调链，图片来自 @司徒正美 的 MVC 分享 PPT。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/nightmare-of-callback.jpg&quot; alt=&quot;回调的噩梦&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Async" scheme="http://bubkoo.com/tags/async/"/>
    
      <category term="Promise" scheme="http://bubkoo.com/tags/promise/"/>
    
      <category term="When" scheme="http://bubkoo.com/tags/when/"/>
    
  </entry>
  
  <entry>
    <title>凌乱的异步编程</title>
    <link href="http://bubkoo.com/2014/03/25/async-programming-is-messy/"/>
    <id>http://bubkoo.com/2014/03/25/async-programming-is-messy/</id>
    <published>2014-03-25T07:14:35.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="1-异常和-trycatch">1. 异常和 try/catch</span></h2><p>当执行可能失败的操作时，采用异常机制和 try/catch 是一种直观的方式，这样我们就可以从异常中恢复，或将异常抛出，异常沿着调用堆栈到达调用者，调用者可以处理该异常或将其继续抛出。</p><p>看一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisMightFail</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">if</span>(badThingsHappened) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(...);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> theGoodResult;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">recoverFromFailure</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">return</span> recoveryValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        result = thisMightFail();</div><div class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">        result = recoverFromFailure(e);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这个例子中，调用 <code>thisMightFail</code> 时一定会失败并抛出一个 <code>Error</code> 异常，   <code>getTheResult</code> 捕获了该异常，然后调用 <code>recoverFromFailure</code>（例如，返回某个默认值）来从异常中恢复。这个例子之所以能够工作，是因为 <code>thisMightFail</code> 是<strong>同步</strong>的。<br><a id="more"></a></p><h2><span id="2-面向异步">2. 面向异步</span></h2><p>如果 <code>thisMightFail</code> 是异步的会如何呢？例如，它可能执行一个异步的 XHR 来获取数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisMightFail</span>(<span class="params">callback, errback</span>) </span>&#123;</div><div class="line">    xhrGet(<span class="string">'/result'</span>, callback, errback);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在使用 try/catch 是不可能的了，我们必须提供一个 <code>callback</code> 和 <code>errback</code> 来处理成功和失败的情况。这在 JavaScript 中相当常见，所以没什么大不了的，真是这样吗？先别急，现在 <code>getTheResult</code> 也需要稍作修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 模拟 try/catch 中从异常回复的行为</span></div><div class="line">    thisMightFail(callback, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> result = recoverFromFalure(e);</div><div class="line">        callback(result);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在，需要对最终执行结果感兴趣的调用方增加 <code>callback</code> （和可能的 <code>errback</code>）这样的回调函数。请继续阅读下面。</p><h2><span id="3-更多异步">3. 更多异步</span></h2><p>如果 <code>recoverFromFailure</code> 也是异步的，我们不得不再添加一层嵌套的回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 模拟 try/catch 中从异常回复的行为</span></div><div class="line">    thisMightFail(callback, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"></div><div class="line">        recoverFromFailure(callback, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">            <span class="comment">// 这里该如何处理？！？！</span></div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这就提出了另一个问题：如果 <code>recoverFromFailure</code> 失败了该如何处理呢？当使用同步的 try/catch 时，<code>recoverFromFailure</code> 可以简单的抛出一个 <code>Error</code>，<code>Error</code> 将传播到 <code>getTheResult</code> 的调用者。为了处理异步失败，我们不得不引入另一个 <code>errback</code>，这就导致从 <code>recoverFromFailure</code> 到调用方的路径上，函数签名到处都是 <code>callback</code> 和 <code>errback</code>，而且调用方必须提供它们。 </p><p>这也可能意味着我们不得不检查是否真地提供了 <code>callback</code> 和 <code>errback</code> 回调，以及它们是否会抛出异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisMightFail</span>(<span class="params">callback, errback</span>) </span>&#123;</div><div class="line">    xhrGet(<span class="string">'/result'</span>, callback, errback);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">recoverFromFailure</span>(<span class="params">callback, errback</span>) </span>&#123;</div><div class="line">    recoverAsync(</div><div class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(callback) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    callback(result);</div><div class="line">                &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">                    <span class="comment">// 如果执行 callback 时发生异常，我们就执行 errback 回调</span></div><div class="line">                    <span class="comment">// 这至少可以让调用者知道是某个地方出错了</span></div><div class="line">                    <span class="comment">// 但是，现在 callback 和 errback 都被执行了</span></div><div class="line">                    <span class="comment">// 这也许并不是开发者所期望的</span></div><div class="line">                    errback(e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(errback) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    errback(error);</div><div class="line">                &#125; <span class="keyword">catch</span>(ohnoes) &#123;</div><div class="line">                    <span class="comment">// 这里该如何处理呢？！？</span></div><div class="line">                    <span class="comment">// 我们可以不处理或将异常抛出，但是没有代码</span></div><div class="line">                    <span class="comment">// 可以捕获到该异常，因为这都是异步的</span></div><div class="line">                    <span class="comment">// 现在，连 console.error 也深入渗透到我们的代码中了</span></div><div class="line">                    <span class="built_in">console</span>.error(ohnoes);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params">callback, errback</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 模拟 try/catch 中从异常回复的行为</span></div><div class="line">    thisMightFail(callback, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"></div><div class="line">        recoverFromFailure(callback, errback);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码已经从一个简单的 try/catch 变为深度嵌套的回调函数，每个函数签名需要增加 <code>callback</code> 和 <code>errback</code>，而且需要额外的逻辑来检查是否可以安全地调用它们，讽刺的是，需要用两个 try/catch 块来确保 <code>recoverFromFailure</code> 真的可以从失败中恢复。</p><h2><span id="4-如何处理-finally">4. 如何处理 finally？</span></h2><p>想象一下，如果我们再将 <code>finally</code> 引入这种混乱的实现方式，事情必然会变得异常复杂。基本上有两种选择：1) 为所有方法的签名增加一个 <code>alwaysback</code> 回调函数，并做相应的检查以确保可以安全地调用它；2) 在 callback/errback 的内部处理异常，并确保总是会调用 <code>alwaysback</code>。但是无论哪种选择都不如语言所提供的 <code>finally</code> 简单和优雅。</p><h2><span id="5-总结">5. 总结</span></h2><p>在异步编程中使用回调函数改变了传统的编程模型，并且引发了下面的问题：</p><ol><li>我们再也不能使用简单的“调用 - 返回”（call-and-return）编程模型</li><li>我们再也不能使用 try/catch/finally 来处理异常</li><li>我们必须为可能执行异步操作的每个函数的签名增加 callback 和 errback 参数</li></ol><p>事实上我们可以做得更好。在 JavaScript 中，还有另一种异步编程模型，更接近于标准的“调用 - 返回”模型，非常类似于 try/catch/finally，并且不会强迫我们为大量的函数增加两个回调函数参数。</p><p>下一步，我们将看看 <a href="../simplifying-async-with-promises">Promises</a>，以及它们如何使异步编程回归到更简单、更友好的模型。</p><p></p><p class="j-quote">原文：<a href="http://know.cujojs.com/tutorials/async/async-programming-is-messy" target="_blank" rel="external">Async Programming is Messy</a></p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-异常和-try-catch&quot;&gt;&lt;a href=&quot;#1-异常和-try-catch&quot; class=&quot;headerlink&quot; title=&quot;1. 异常和 try/catch&quot;&gt;&lt;/a&gt;1. 异常和 try/catch&lt;/h2&gt;&lt;p&gt;当执行可能失败的操作时，采用异常机制和 try/catch 是一种直观的方式，这样我们就可以从异常中恢复，或将异常抛出，异常沿着调用堆栈到达调用者，调用者可以处理该异常或将其继续抛出。&lt;/p&gt;
&lt;p&gt;看一个简单的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;thisMightFail&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(badThingsHappened) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Error&lt;/span&gt;(...);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; theGoodResult;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;recoverFromFailure&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; recoveryValue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getTheResult&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        result = thisMightFail();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        result = recoverFromFailure(e);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，调用 &lt;code&gt;thisMightFail&lt;/code&gt; 时一定会失败并抛出一个 &lt;code&gt;Error&lt;/code&gt; 异常，   &lt;code&gt;getTheResult&lt;/code&gt; 捕获了该异常，然后调用 &lt;code&gt;recoverFromFailure&lt;/code&gt;（例如，返回某个默认值）来从异常中恢复。这个例子之所以能够工作，是因为 &lt;code&gt;thisMightFail&lt;/code&gt; 是&lt;strong&gt;同步&lt;/strong&gt;的。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Async" scheme="http://bubkoo.com/tags/async/"/>
    
      <category term="Promise" scheme="http://bubkoo.com/tags/promise/"/>
    
      <category term="When" scheme="http://bubkoo.com/tags/when/"/>
    
  </entry>
  
  <entry>
    <title>用 Promises 简化异步编程</title>
    <link href="http://bubkoo.com/2014/03/25/simplifying-async-with-promises/"/>
    <id>http://bubkoo.com/2014/03/25/simplifying-async-with-promises/</id>
    <published>2014-03-25T04:45:32.000Z</published>
    <updated>2014-03-25T00:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="../async-programming-is-messy">凌乱的异步编程</a>一文中，我们见识了用回调处理异步调用的尴尬局面，即使是一组简单的函数调用。</p><p>快速回顾一下，看看我们最初的代码，使用回调函数时的凌乱结果，以及我们为了回到正途而想要解决的几个问题：</p><ol><li>我们再也不能使用简单的“调用 - 返回”（call-and-return）编程模型</li><li>我们再也不能使用 try/catch/finally 来处理异常</li><li>我们必须为可能执行异步操作的每个函数的签名增加 callback 和 errback 参数</li></ol><h2><span id="1-promises">1. Promises</span></h2><p>一个 Promise（或者叫 Future, Delayed value, Deferred value）代表一个尚不可用的值，因为产生这个值的计算过程尚未完成。一个 Promise 是最终的成功结果或失败原因的占位符。</p><p>Promises 还提供了一个简单的 API（见下文），用于在结果完成或故障发生时获取通知。</p><p>Promises <a href="http://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" rel="external">不是一个新概念</a>，已经在许多语言中被实现。一些 JavaScript 实现也已经有一段时间了，并且最近变得更加流行，因为我们开始构建更庞大、更复杂的系统，需要协调更多的异步任务。</p><p>（注意：虽然 Promise API 标准存在<a href="http://wiki.commonjs.org/wiki/Promises" target="_blank" rel="external">多个提案</a>，但是 <a href="http://promises-aplus.github.io/promises-spec/" target="_blank" rel="external">Promises/A+</a> 已经在多个主流框架中被实现，似乎正在成为事实上的标准。无论哪种提案，基本的概念是相同的：1) Promises 作为结果或错误的占位符；2) 提供了一种在结果完成或错误发生时的通知方式。）</p><a id="more"></a><h2><span id="2-典型的-xhr-示例">2. 典型的 XHR 示例</span></h2><p>在 XHR Get 示例中，我们关注的是请求 url 的内容。我们知道 XHR 是一个异步操作，返回值不会立即可用。这种情况完全符合 Promise 的定义。</p><p>假设我们有一个 XHR 库，它立即返回一个 Promise 作为内容的占位符，而不是要求我们传入一个回调函数。我们可以重写 <a href="../async-programming-is-messy">Part 1</a> 中的异步函数 <code>thisMightFail</code>，像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisMightFail</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// XHR 库将返回一个 Promise 作为内容的占位符</span></div><div class="line">    <span class="comment">// XHR 本身将在稍后执行</span></div><div class="line">    <span class="keyword">var</span> promise = xhrGet(<span class="string">'/result'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 我们可以简单地返回这个 Promise，它就像真正的结果</span></div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>（需要注意的是，一些流行的 JavaScript 库，包括Dojo（参考 <a href="https://twitter.com/bryanforbes" target="_blank" rel="external">@bryanforbes</a> 写的 <a href="http://dojotoolkit.org/documentation/tutorials/1.6/deferreds/" target="_blank" rel="external">great article on Dojo’s Deferred</a>）和 <a href="http://api.jquery.com/Types/#jqXHR" target="_blank" rel="external">jQuery</a>，都使用了 Promises 来实现 XHR 操作）</p><p>现在，我们可以返回 Promise 占位符，就像它是真正的结果，这样异步函数 <code>thisMightFail</code> 看起来非常像传统的同步操作和“调用 - 返回”编程模式。</p><h2><span id="3-调用栈">3. 调用栈</span></h2><p>在没有回调函数的世界里，结果和错误沿着调用栈<em>向上</em>回传。这是一种符合预期和友好的模式。而在基于回调函数的世界里，正如我们之前看到的那样，结果和错误不再遵循这种熟悉的模式，回调函数必须<em>向下</em>传递，深入到调用栈中。</p><p>通过使用 Promises，我们可以恢复到熟悉的“调用 - 返回”编程模型，并移除回调函数。</p><h3><span id="31-回到调用-返回编程模型">3.1 回到“调用 - 返回”编程模型</span></h3><p>为了看看它是如何工作的，让我们从 <a href="../async-programming-is-messy">Part 1</a>  中同步函数 <code>getTheResult</code> 的简化版本开始，不使用 try/catch，这样异常将总是沿着调用栈向上传播。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisMightFail</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">if</span>(badThingsHappened) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(...);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> theGoodResult;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 返回 thisMightFail 的执行结果</span></div><div class="line">    <span class="comment">// 或者让异常抛出</span></div><div class="line">    <span class="keyword">return</span> thisMightFail();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在，让我们使用基于 Promise 的 XHR 库，来为上面的代码引入异步的 <code>thisMightFail</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisMightFail</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// XHR 库将返回一个 Promise 作为内容的占位符</span></div><div class="line">    <span class="comment">// XHR 本身将在稍后执行</span></div><div class="line">    <span class="keyword">var</span> promise = xhrGet(<span class="string">'/result'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 我们可以简单地返回这个 Promise，它就像真正的结果</span></div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 返回 thisMightFail 的执行结果，它是一个 Promise</span></div><div class="line">    <span class="comment">// 代表将来的执行结果或错误</span></div><div class="line">    <span class="keyword">return</span> thisMightFail();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用 Promises 时，<code>getTheResult()</code> 在同步和异步情况下是相同的！并且在这两种情况下，成功结果或失败将沿着调用栈传播到调用者。</p><h3><span id="32-移除回调函数">3.2 移除回调函数</span></h3><p>还请注意，没有向调用栈传入 callbacks  或 errbacks（或 alwaysbacks），也没有污染任何函数的签名。通过使用 Promises，我们的函数的外观和行为就像友好的、同步的“调用 - 返回”编程模型。</p><h3><span id="33-完成了吗">3.3 完成了吗？</span></h3><p>我们已经使用 Promises 重构了简单的 <code>getTheResult</code> 函数，并且解决了在 <a href="../async-programming-is-messy">Part 1</a> 提出的的两个问题。我们已经：</p><ol><li>回到了“调用 - 返回”编程模型</li><li>移除了参数 callback/errback/alwaysback 的传播</li></ol><p>但是，对于 <code>getTheResult</code> 的调用者意味着什么呢？别忘了，我们返回的是一个 Promise，并且无论成功结果（XHR 的结果）还是错误最终将落实到占位符 Promise，到那时调用者将需要采取一些行动。</p><h2><span id="4-调用者该如何处理">4. 调用者该如何处理</span></h2><p>正如上面所提到的，Promises 提供了一个 API，用于在结果可用或错误时获取通知。例如，在 Promises/A 规范提案中，一个 Promise 含有一个 <code>.then()</code> 方法，而且许多 Promise 库提供了一个 <code>when()</code> 方法来达到同样的目的。</p><p>首先，让我们看看使用回调方式时，调用代码可能的样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 基于回调的 getTheResult</span></div><div class="line">getTheResult(</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">theResult</span>) </span>&#123;</div><div class="line">        <span class="comment">// theResult 将是 XHR 的响应结果</span></div><div class="line">        resultNode.innerHTML = theResult;</div><div class="line">    &#125;,</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">        <span class="comment">// error 表示 XHR 失败的原因</span></div><div class="line">        <span class="comment">// 例如，它可能是一个 Error 对象 </span></div><div class="line">        errorNode.innerHTML = error.message;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure><p>现在，让我们如何通过 Promises/A 的 <code>.then()</code> 来使用使用 <code>getTheResult</code> 所返回的 Promise。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">getTheResult().then(</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">theResult</span>) </span>&#123;</div><div class="line">        <span class="comment">// theResult 将是 XHR 的响应结果</span></div><div class="line">        resultNode.innerHTML = theResult;</div><div class="line">    &#125;,</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">        <span class="comment">// error 表示 XHR 失败的原因</span></div><div class="line">        <span class="comment">// 例如，它可能是一个 Error 对象 </span></div><div class="line">        errorNode.innerHTML = error.message;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/funny-surprised-owl-WHAT.jpg" alt="图片来自 http://themetapicture.com/wat/"></p><p>这就是 Promises 用来<em>避免使用回调函数</em>的全部内容？我们就这么使用它们？！？</p><h2><span id="5-还没结束">5. 还没结束</span></h2><p>在 JavaScript 中，通过使用回调函数来实现 Promises，因为没有语言级的结构可以用于处理异步。回调函数是 Promises <em>必然的实现方式</em>。如果 Javascript 已经提供或者未来可能提供其他的语言结构，那么 Promises 可能会以不同的方式实现。</p><p>然而，相较于 <a href="../async-programming-is-messy">Part 1</a> 中深度传递回调函数的方式，Promises 具备一些明显的优势。</p><p>首先，我们的函数签名是正常的。我们不再需要为从调用者到 XHR 库的每个函数签名添加 callback 和 errback 参数，只需要为对最终结果感兴趣的调用者传递回调函数。</p><p>其次，Promise API 标准化了回调函数的传递。JavaScript 库可能会把 callbacks 和 errbacks 参数放到函数签名的不同位置，某些库甚至不接受 errback 参数，而且大部分库不接受 alwaysback（即“finally”）参数。我们可以依赖 Promise API，而不是许多有着潜在差异的库的 API。</p><p>第三，Promise 保障了回调函数和错误回调函数被调用的方式和时机，以及如何处理返回值和回调函数抛出的异常。在没有 Promise 的世界里，如果库和函数签名支持许多不同的回调函数，便意味着许多不同的行为：</p><ol><li>你的回调函数允许返回一个值吗？</li><li>如果允许返回会发生什么？</li><li>是否所有库都允许你的回调函数抛出一个异常？如果允许抛出会发生什么？悄悄的把它吞掉吗？</li><li>如果你的回调函数真的抛出一个异常，错误回调是否会被调用？</li></ol><p>…等等…</p><p>所以，Promises 一方面可以作为回调函数注册的标准 API，同时也为如何以及何时调用回调函数和处理异常提供了标准的、可预测的行为。</p><h2><span id="6-怎么处理-trycatchfinally">6. 怎么处理 try/catch/finally</span></h2><p>现在，我们已经回到了“调用 - 返回”编程模型，并从函数签名中移除了回调函数，我们还需要一种方式来处理失败的情况。理想情况下，我们希望使用 try/catch/finally，或者是至少在外观和行为上与它相似，并且在面对异步时可以正常工作。</p><p>在<a href="../mastering-async-error-handling-with-promises">用 Promises 控制异步错误处理</a>一文中，我们将把拼图的最后一块填到位，看看如何用 Promises 模仿 try/catch/finally。</p><p class="j-quote">原文：<a href="http://know.cujojs.com/tutorials/async/simplifying-async-with-promises" target="_blank" rel="external">Simplifying Async with Promises</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;../async-programming-is-messy&quot;&gt;凌乱的异步编程&lt;/a&gt;一文中，我们见识了用回调处理异步调用的尴尬局面，即使是一组简单的函数调用。&lt;/p&gt;
&lt;p&gt;快速回顾一下，看看我们最初的代码，使用回调函数时的凌乱结果，以及我们为了回到正途而想要解决的几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们再也不能使用简单的“调用 - 返回”（call-and-return）编程模型&lt;/li&gt;
&lt;li&gt;我们再也不能使用 try/catch/finally 来处理异常&lt;/li&gt;
&lt;li&gt;我们必须为可能执行异步操作的每个函数的签名增加 callback 和 errback 参数&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-Promises&quot;&gt;&lt;a href=&quot;#1-Promises&quot; class=&quot;headerlink&quot; title=&quot;1. Promises&quot;&gt;&lt;/a&gt;1. Promises&lt;/h2&gt;&lt;p&gt;一个 Promise（或者叫 Future, Delayed value, Deferred value）代表一个尚不可用的值，因为产生这个值的计算过程尚未完成。一个 Promise 是最终的成功结果或失败原因的占位符。&lt;/p&gt;
&lt;p&gt;Promises 还提供了一个简单的 API（见下文），用于在结果完成或故障发生时获取通知。&lt;/p&gt;
&lt;p&gt;Promises &lt;a href=&quot;http://en.wikipedia.org/wiki/Futures_and_promises&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;不是一个新概念&lt;/a&gt;，已经在许多语言中被实现。一些 JavaScript 实现也已经有一段时间了，并且最近变得更加流行，因为我们开始构建更庞大、更复杂的系统，需要协调更多的异步任务。&lt;/p&gt;
&lt;p&gt;（注意：虽然 Promise API 标准存在&lt;a href=&quot;http://wiki.commonjs.org/wiki/Promises&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多个提案&lt;/a&gt;，但是 &lt;a href=&quot;http://promises-aplus.github.io/promises-spec/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Promises/A+&lt;/a&gt; 已经在多个主流框架中被实现，似乎正在成为事实上的标准。无论哪种提案，基本的概念是相同的：1) Promises 作为结果或错误的占位符；2) 提供了一种在结果完成或错误发生时的通知方式。）&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Async" scheme="http://bubkoo.com/tags/async/"/>
    
      <category term="Promise" scheme="http://bubkoo.com/tags/promise/"/>
    
      <category term="When" scheme="http://bubkoo.com/tags/when/"/>
    
  </entry>
  
  <entry>
    <title>用 Promises 控制异步错误处理</title>
    <link href="http://bubkoo.com/2014/03/25/mastering-async-error-handling-with-promises/"/>
    <id>http://bubkoo.com/2014/03/25/mastering-async-error-handling-with-promises/</id>
    <published>2014-03-25T02:32:37.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>正如我们在<a href="http://bubkoo.com/2014/03/25/async-programming-is-messy/">凌乱的异步编程</a>一文中看到的那样，基于回调函数的异步代码的错误处理也很快变得混乱起来，丢失了许多同步代码具有的优秀品质，使我们更难定位到错误原因。在<a href="http://bubkoo.com/2014/03/25/simplifying-async-with-promises/">用 Promises 简化异步编程</a>一文中，我们介绍了 Promises，看到了它如何使我们回到“调用 - 返回”编程模型，允许异步错误像同步错误那样沿着调用堆栈向上传播，并提供一种更清晰方法来管理异步，特别是在处理错误时。</p><h2><span id="1-trycatchfinally">1. Try/catch/finally</span></h2><p>在同步代码中，try/catch/finally 提供了一种简单友好但非常强大的惯用语法来执行任务、处理错误，并且总是确保稍后可以执行清理。</p><blockquote><p>译注：idiom 习语</p></blockquote><p>下面是一个简单的 try/catch/finally 示例，与 <a href="http://bubkoo.com/2014/03/25/async-programming-is-messy/">Part 1</a> 中的原始 <code>getTheResult()</code> 一模一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同步版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> thisMightFail();</div><div class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">        <span class="keyword">return</span> recoverFromFailure(e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        alwaysCleanup();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>正如我们已经看到的那样，通过基于回调函数的方式来模拟 try/catch 充满了陷阱，加入 finally 的概念后（即确保执行清理）只会使事情变得更糟。</p><p>使用 Promises，我们可以建立一种方法，类似于友好的 try/catch/finally 惯用语法，并且没有深度回调结构。<br><a id="more"></a></p><h2><span id="2-trycatch">2. Try/catch</span></h2><p>让我们从一个简单的例子开始，只使用了 try/catch，然后看看如何用 Promises 以同样的方式处理错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同步版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> thisMightFail();</div><div class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">        <span class="keyword">return</span> recoverFromFailure(e);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在，就像在 <a href="http://bubkoo.com/2014/03/25/simplifying-async-with-promises/">Part 2</a> 中一样，我们假设 <code>thisMightFail()</code> 是异步的，并且返回一个 Promise，我们可以用 <code>then()</code> 来模拟 catch：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 异步版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisMightFail</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> thisMightFail()</div><div class="line">        .then(<span class="literal">null</span>, recoverFromFailure);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>等等，这里的代码甚至比 try/catch 的代码更少！这是怎么回事呢？</p><h3><span id="21-传播成功状态">2.1 传播成功状态</span></h3><p>这个例子引入了两个关于 Promises 行为非常重要的事实。其中第一个是：</p><p>如果没有给 <code>then</code> 提供 <code>onFulfilled</code> 处理程序，结果值将原封不动地传播到返回的 Promise。</p><p>在调用 <code>then()</code> 时，我们没有提供 <code>onFulfilled</code> 处理程序。这意味着 <code>thisMightFail()</code> 的成功结果将简单地传播，并返回给调用者。</p><h3><span id="22-处理错误">2.2 处理错误</span></h3><p>另外一个重要的行为是：</p><p>处理程序可以通过返回一个值来产生一个成功结果，也可以通过抛出错误或返回一个被拒（rejected）的 Promise 来产生一个错误。</p><p>我们提供了一个 <code>onRejected</code> 处理程序：<code>recoverFromFailure</code>。这意味着，<code>thisMightFail</code> 产生的任何错误将被传给 <code>recoverFromFailure</code>。就像同步例子中的 <code>catch</code> 语句，<code>recoverFromFailure</code> 可以处理传入的错误并 <code>return</code> 一个成功结果，也可以通过抛出错误或返回一个被拒的 Promise 来产生一个错误。</p><p>现在我们有一个完整的异步结构，它的行为就像是同步的模拟，并且也很容易编写。</p><h3><span id="23-添加一点语法糖">2.3 添加一点语法糖</span></h3><blockquote><p>译注：Syntactic sugar 语法糖</p></blockquote><p>但我们把 <code>null</code> 作为第一个参数传入是什么意思？在想要使用类似 <code>try/catch</code> 的异步结构的地方，我们为什么必须要键入 <code>null</code>？能不能做的更好点？</p><p>虽然遵循 Promises/A+ 规范的 Promise 的主要接口是 then() 方法，但是许多实现都（用很少的代码）以 <code>then()</code> 为基础构建和添加了便捷方法。例如，<a href="https://github.com/cujojs/when" target="_blank" rel="external">when.js</a> Promises 提供了一个 <code>otherwise()</code> 方法，允许我们更直观、更紧凑地编写这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 异步版本: 使用 when.js 中的 promise.otherwise();</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> thisMightFail()</div><div class="line">        .otherwise(recoverFromFailure);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在我们有了阅读起来很棒的异步结构！</p><h2><span id="3-添加-finally">3. 添加 finally</span></h2><p>让我们把 <code>finally</code> 添加到这种混合结构中，看看如何用 Promises 使异步操作达到同样的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同步版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> thisMightFail();</div><div class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">        <span class="keyword">return</span> recoverFromFailure(e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        alwaysCleanup();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先需要注意的是，这个看似简单的 <code>finally</code> 块包含了一些有趣的东西：</p><ol><li>总是在 <code>thisMightFail</code> 和/或 <code>recoverFromFailure</code> 之后执行</li><li><a name="footnote-1-ref"></a>不能访问到 <code>thisMightFail</code> 返回的值或抛出的异常 <code>e</code>，<code>也不能访问到recoverFromFailure</code> 返回的值<a href="#footnote-1">^1</a></li><li><a name="footnote-2-ref"></a>在这种情况下，<code>recoverFromFailure</code> 抛出异常时，不能将其转换回成功结果<a href="#footnote-2">^2</a></li><li>如果 <code>alwaysCleanup</code> 抛出一个异常，会将成功结果（由 <code>thisMightFail</code> 或 <code>recoverFromFailure</code> 得到）转换为一个失败</li><li>可以用一个新异常替换掉 <code>recoverFromFailure</code> 抛出的异常。也就是说，如果 <code>recoverFromFailure</code> 和 <code>alwaysCleanup</code> 都抛出了异常，<code>alwaysCleanup</code> 抛出的异常将传播到调用者，而由 <code>recoverFromFailure</code> 抛出的却不会</li></ol><p>这似乎相当复杂。让我们回到异步的 <code>getTheResult</code>，看看如何用 Promises 实现同样的特性。</p><h3><span id="31-总是会执行">3.1 总是会执行</span></h3><p>首先，让我们用 <code>then()</code> 确保 <code>alwaysCleanup</code> 在所有情况下都将会执行（为了简洁些，我们会保留 when.js 的 <code>otherwise</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 异步版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> thisMightFail()</div><div class="line">        .otherwise(recoverFromFailure);</div><div class="line">        .then(alwaysCleanup, alwaysCleanup);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这似乎很简单！现在，<code>alwaysCleanup</code> 在所有情况下都将会被执行：</p><ol><li>如果 <code>thisMightFail</code> 成功了</li><li>如果 <code>thisMightFail</code> 失败了，而 <code>recoverFromFailure</code> 成功了</li><li>如果 <code>thisMightFail</code> 和 <code>recoverFromFailure</code> 都失败了</li></ol><p>但等等，虽然我们已经确保了 <code>alwaysCleanup</code> 将总是会执行，但是也侵犯了其他两项特性：<code>alwaysCleanup</code> 会收到成功结果或错误，因此有机会访问其中之一，或者两个，并且可以通过返回一个成功值把一个错误转换为一个成功结果。</p><h3><span id="32-不要访问结果错误">3.2 不要访问结果/错误</span></h3><p>我们可以引入一个包装函数，以防把结果或错误传给 <code>alwaysCleanup</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 异步版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">alwaysCleanupWrapper</span>(<span class="params">resultOrError</span>) </span>&#123;</div><div class="line">    <span class="comment">// 不要传递成功/错误结果</span></div><div class="line">    <span class="keyword">return</span> alwaysCleanup();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> thisMightFail()</div><div class="line">        .otherwise(recoverFromFailure);</div><div class="line">        .then(alwaysCleanupWrapper, alwaysCleanupWrapper);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在，我们已经实现了曾丢掉的两项特性中的一项：<code>alwaysCleanup</code> 不再可以访问结果或错误。不幸的是，我们不得不添加一些感觉没必要的代码。不过，让我们继续探索，看看是否可以实现剩下的特性。</p><h3><span id="33-不要改变结果">3.3 不要改变结果</span></h3><p>虽然 <code>alwaysCleanupWrapper</code> 阻止了 <code>alwaysCleanup</code> 访问结果或错误，但是它仍然允许 <code>alwaysCleanup</code> 把一个错误状态转换一个成功结果。例如，如果 <code>recoverFromFailure</code> 产生一个错误，它将被传给 <code>alwaysCleanupWrapper</code>，然后调用 <code>alwaysCleanup</code>。如果 <code>alwaysCleanup</code> 成功返回，返回值将传播到调用者，从而消除了之前的错误。</p><p>这与同步的 <code>finally</code> 之句的行为并不匹配，所以让我们重构它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同步版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">alwaysCleanupOnSuccess</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">    <span class="comment">// 不要传递成功结果，并忽略 alwaysCleanup 的返回值</span></div><div class="line">    <span class="comment">// 并将传递过来的返回值返回</span></div><div class="line">    alwaysCleanup();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">alwaysCleanupOnFailure</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="comment">// 不要传递错误结果，并忽略 alwaysCleanup 的返回值</span></div><div class="line">    <span class="comment">// 并抛出原始的错误</span></div><div class="line">    alwaysCleanup();</div><div class="line">    <span class="keyword">throw</span> error;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> thisMightFail()</div><div class="line">        .otherwise(recoverFromFailure);</div><div class="line">        .then(alwaysCleanupOnSuccess, alwaysCleanupOnFailure);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在成功和失败状态下，我们已经保存了结果：<code>alwaysCleanupOnSuccess</code> 将执行 <code>alwaysCleanup</code> 但不允许它改变最终结果，<code>alwaysCleanupOnFailure</code> 也将执行 <code>alwaysCleanup</code> 并总是抛出原始的错误，从而传播错误，即使 <code>alwaysCleanup</code> 成功返回。</p><h3><span id="34-剩下的两项特性">3.4 剩下的两项特性</span></h3><p>看看上面的重构，我们还可以发现它涵盖了剩下的两项特性：</p><p>在 <code>alwaysCleanupOnSuccess</code> 中，如果 <code>alwaysCleanup</code> 抛出错误，<code>return result</code> 将永远不会被执行，并且这个新错误将传播到调用者，从而把一个成功结果转换为一个失败结果。</p><p>在 <code>alwaysCleanupOnFailure</code> 中，如果 <code>alwaysCleanup</code> 抛出错误，<code>throw error</code> 将永远不会被执行，并且这个由 <code>alwaysCleanup</code> 抛出的错误将传播到调用者，从而代之以一个新错误。</p><h2><span id="4-圆满了吗">4. 圆满了吗？</span></h2><p>通过最新重构代码，我们已经创建类似于同步的 <code>try/catch/finally</code> 的异步结构。</p><h3><span id="41-更多语法糖">4.1 更多语法糖</span></h3><p>一些 Promise 提供了类似 <code>finally</code> 行为的抽象。例如，when.js 的 Promises 提供了一个 <code>ensure()</code> 方法，它具备我们前面实现的所有特性，但是更简洁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 异步版本: 使用 when.js 的 promise.ensure();</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> thisMightFail()</div><div class="line">        .otherwise(recoverFromFailure)</div><div class="line">        .ensure(alwaysCleanup);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="5-小结">5. 小结</span></h2><p>我们一开始的目标是为异步操作寻找一种方式来模拟有用且好用的同步 <code>try/catch/finally</code> 的行为。下面是我们开始时的简单同步代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同步版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> thisMightFail();</div><div class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">        <span class="keyword">return</span> recoverFromFailure(e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        alwaysCleanup();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，下面是最终的异步模拟，结构紧凑，而且易于阅读：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 异步版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> thisMightFail()</div><div class="line">        .otherwise(recoverFromFailure)</div><div class="line">        .ensure(alwaysCleanup);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="6-tryfinally">6. Try/finally</span></h2><p>另一种常见的结构是 <code>try/finally</code>。在执行清理代码时它很有用，但是在这种没有恢复路径（catch）的情况下，它总是允许异常传播。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同步版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> thisMightFail();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        alwaysCleanup();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在，我们已经 Promises 完整地模拟了 <code>try/catch/finally</code> 结构，模拟 <code>try/finally</code> 就是小菜一碟了。就像上面简单地删除掉 <code>catch</code> 一样，我们可以在 Promise 版本中删去 <code>otherwise()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 异步版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> thisMightFail()</div><div class="line">        .ensure(alwaysCleanup);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们一直试图实现的制约（特性）仍然保留了下来：这个异步结构的行为类似于对应的同步 <code>try/finally</code>。</p><h2><span id="7-应用异步结构">7. 应用异步结构</span></h2><p>让我们来比较一下如何使用 <code>getTheResult</code> 的同步和异步版本。假设已经有下面两个用于展示结果和错误的函数。为了简单起见，我们还假设 <code>showResult</code> 可能会失败，而 <code>showError</code> 永远不会失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设 showResult 可能会失败</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showResult</span>(<span class="params">result</span>) </span>&#123; <span class="comment">/* 格式化并显示结果 */</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 假设 showError 永远不会失败</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showError</span>(<span class="params">error</span>) </span>&#123; <span class="comment">/* 显示错误，警告用户等等 */</span> &#125;</div></pre></td></tr></table></figure><h3><span id="71-同步版本">7.1 同步版本</span></h3><p>首先是同步版本，我们可能会这样使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同步版本</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    showResult(getTheResult());</div><div class="line">&#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">    showError(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>正如我们预料的，它相当简单。如果我们成功地得到结果，然后就展示结果。如果得到失败的结果（通过抛出一个异常），就展示错误。</p><p>同样需要重点注意的是，如果 <code>showResult</code> 失败了，将展示一个错误。这是同步异常的一个重要标志。我们写下的 <code>catch</code> 单句将处理来自 <code>getTheResult</code> 或 <code>showResult</code> 的错误。这种错误传播是自动的，不需要为之增加额外的代码。</p><h3><span id="72-异步版本">7.2 异步版本</span></h3><p>现在，让我们看看如何用异步版本完成同样的目标：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 异步版本</span></div><div class="line">getTheResult().then(showResult)</div><div class="line">    .otherwise(showError);</div></pre></td></tr></table></figure><p>这里的功能是类似的，而且你会惊讶，它看起来居然比同步版本更简单。我们得到了结果，或者更确切地说，是结果的一个 Promise，并且当真正的结果实现时（记住，一切都是异步的），我们将展示它。如果得到了失败的结果（通过拒绝 Promise），我们将展示错误。</p><p>由于 Promises 像传播异常一样传播错误，因此如果 <code>showResult</code> 失败了，我们也会展示一个错误。因此，这种自动的行为与同步版本是也是等价的：我们编写的 <code>otherwise</code> 单句调用将处理来自 <code>getTheResult</code> 和 <code>showResult</code> 的错误。</p><p>另外需要注意的是，同样的 <code>showResult</code> 和 <code>showError</code> 函数也可以使用在同步版本中。我们不需要为了能在 Promises 中运行而人工改造特定函数的签名 —— 与我们在任意地方编写的函数完全一样。</p><h2><span id="8-整合">8. 整合</span></h2><p>我们已经重构了 <code>getTheResult</code> 的代码，用 Promises 来模拟 <code>try/catch/finally</code>，也使调用代码用返回的 Promise 来处理与同步版本相同的错误。让我们完整地看看代码基于 Promise 的异步版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 getTheResult()</span></div><div class="line">getTheResult().then(showResult)</div><div class="line">    .otherwise(showError);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTheResult</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> thisMightFail()</div><div class="line">        .otherwise(recoverFromFailure)</div><div class="line">        .ensure(alwaysCleanup);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisMightFail</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 使用 Promises/A+ 规范推荐的 API 来创建 Promises</span></div><div class="line">    <span class="keyword">return</span> makePromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> result, error;</div><div class="line"></div><div class="line">        <span class="comment">// Do work, then:</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(error) &#123;</div><div class="line">            reject(error);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            resolve(result);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="9-结语">9. 结语</span></h2><p>当然同步执行和异步执行之间总是有所差异，但是我们可以通过使用 Promises 缩小这种差异。同步版本和我们构建的基于 Promise 的异步版本不仅看起非常相似，而且它们的行为也相似。它们有着相似的固定格式。我们可以用相似的方式揣测它们，甚至能用相似的方式重构和测试它们。</p><p>提供友好和可预测的错误处理模式，以及可组合的“调用 - 返回”语法，这是 Promises 两个强大的特性，但是这仅仅是开始。基于 Promises 的异步结构，可以轻松地将许多其他功能完全异步化：高级功能（例如 map、reduce/fold）、<a href="https://github.com/cujojs/when/blob/master/docs/api.md#concurrency" target="_blank" rel="external">并行和顺序</a>的执行任务等等。</p><p><a name="footnote-1"></a></p><ol><li>你可能会奇怪，为什么我们需要这个特性。在这篇文章中，我们选择尝试尽可能近似地模拟 <code>finally</code>。同步 <code>finally</code> 的意图是引发某种副作用，例如关闭一个文件或数据库连接，并不是执行一个函数来转换结果或错误。而且，向 <code>alwaysCleanup</code> 传入一个可能是结果或错误的参数，却不告诉 <code>alwaysCleanup</code> 正在接受的参数什么类型，可能是一个危害源。事实上，<code>finally</code> 没有”参数“，不像 <code>catch</code>，这意外着开发人员需要承担授权访问结果或错误的烦扰，通常的做法是在进入 <code>finally</code> 之前把结果或错误存储到一个局部变量中。这种做法也可以应用在基于 Promise 的方式中。<a href="#footnote-1-ref">↩</a></li><li><a name="footnote-2"></a>需要注意的是，<code>finally</code> 可以通过明确地返回一个值消除异常。但是在这种情况下，我们没有明确地返回任何东西。我从来没有在现实中见过需要用这种方式来消除异常。<a href="#footnote-2-ref">↩</a></li></ol><p class="j-quote">原文：<a href="http://know.cujojs.com/tutorials/async/mastering-async-error-handling-with-promises" target="_blank" rel="external">Mastering Async Error Handling with Promises</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正如我们在&lt;a href=&quot;http://bubkoo.com/2014/03/25/async-programming-is-messy/&quot;&gt;凌乱的异步编程&lt;/a&gt;一文中看到的那样，基于回调函数的异步代码的错误处理也很快变得混乱起来，丢失了许多同步代码具有的优秀品质，使我们更难定位到错误原因。在&lt;a href=&quot;http://bubkoo.com/2014/03/25/simplifying-async-with-promises/&quot;&gt;用 Promises 简化异步编程&lt;/a&gt;一文中，我们介绍了 Promises，看到了它如何使我们回到“调用 - 返回”编程模型，允许异步错误像同步错误那样沿着调用堆栈向上传播，并提供一种更清晰方法来管理异步，特别是在处理错误时。&lt;/p&gt;
&lt;h2 id=&quot;1-Try-catch-finally&quot;&gt;&lt;a href=&quot;#1-Try-catch-finally&quot; class=&quot;headerlink&quot; title=&quot;1. Try/catch/finally&quot;&gt;&lt;/a&gt;1. Try/catch/finally&lt;/h2&gt;&lt;p&gt;在同步代码中，try/catch/finally 提供了一种简单友好但非常强大的惯用语法来执行任务、处理错误，并且总是确保稍后可以执行清理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译注：idiom 习语&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是一个简单的 try/catch/finally 示例，与 &lt;a href=&quot;http://bubkoo.com/2014/03/25/async-programming-is-messy/&quot;&gt;Part 1&lt;/a&gt; 中的原始 &lt;code&gt;getTheResult()&lt;/code&gt; 一模一样：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 同步版本&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getTheResult&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; thisMightFail();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; recoverFromFailure(e);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alwaysCleanup();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;正如我们已经看到的那样，通过基于回调函数的方式来模拟 try/catch 充满了陷阱，加入 finally 的概念后（即确保执行清理）只会使事情变得更糟。&lt;/p&gt;
&lt;p&gt;使用 Promises，我们可以建立一种方法，类似于友好的 try/catch/finally 惯用语法，并且没有深度回调结构。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Async" scheme="http://bubkoo.com/tags/async/"/>
    
      <category term="Promise" scheme="http://bubkoo.com/tags/promise/"/>
    
      <category term="When" scheme="http://bubkoo.com/tags/when/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Promises 教程</title>
    <link href="http://bubkoo.com/2014/03/22/javascript-promises/"/>
    <id>http://bubkoo.com/2014/03/22/javascript-promises/</id>
    <published>2014-03-22T23:57:12.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>童鞋们，请准备好迎接 Web 开发历史上一个重大时刻。。。</p><p>[鼓声响起]</p><p>JavaScript 有了原生的 Promise！</p><p>[漫天的烟花绽放，人群沸腾了]</p><p>这时候你大概是这三种人之一：</p><ul><li>你的身边拥挤着欢呼的人群，但是你却不在其中，甚至你还不大清楚“Promise”是什么。你耸耸肩，烟花的碎屑在你的身边落下。不过不要担心，我也是花了多年的时间才明白 Promise 的意义，你可以<a href="#toc-async">从这里开始</a>。</li><li>你一挥拳！太赞了对么！你已经用过一些 Promise 的库，但是所有这些第三方实现在 API 上都略有差异，JavaScript 官方的 API 会是什么样子？请看<a href="#toc-promise-terminology">这里</a>！</li><li>你早就知道了，看着那些欢呼雀跃的新人你的嘴角泛起一丝不屑的微笑。你可以安静享受一会儿优越感，然后直接去看 <a href="#toc-api">API 参考</a>吧。</li></ul><a id="more"></a><p><a name="toc-async"></a></p><h2><span id="他们都在激动什么">他们都在激动什么？</span></h2><p>JavaScript 是单线程的，这意味着任何两句代码都不能同时运行，它们得一个接一个来。在浏览器中，JavaScript 和其他任务共享一个线程，不同的浏览器略有差异，共享线程的任务包括重绘、更新样式、用户交互等，所有这些任务操作都会阻塞其他任务。</p><p>作为人类，你是多线程的。你可以用多个手指同时敲键盘，也可以一边开车一遍电话。唯一的全局阻塞函数是打喷嚏，打喷嚏期间所有其他事务都会暂停。很烦人对么？尤其是当你开着车打着电话的时候。我们都不喜欢这个时候打喷嚏。</p><p>你应该会用事件加回调的办法来处理这类情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img1 = <span class="built_in">document</span>.querySelector(<span class="string">'.img-1'</span>);</div><div class="line">  </div><div class="line">img1.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 啊哈图片加载完成</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">img1.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 哎哟出问题了</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>我们为请求图片添加了几个监听函数，然后 JavaScript 就停止运行了，直到触发某个监听函数。</p><p>上面的例子中唯一的问题是，事件有可能在我们绑定监听器之前就已经发生，所以我们先要检查图片的“complete”属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img1 = <span class="built_in">document</span>.querySelector(<span class="string">'.img-1'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loaded</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 啊哈图片加载完成</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (img1.complete) &#123;</div><div class="line">  loaded();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  img1.addEventListener(<span class="string">'load'</span>, loaded);</div><div class="line">&#125;</div><div class="line"></div><div class="line">img1.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 哎哟出问题了</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这样也还不够，如果在添加监听函数之前图片加载发生错误，我们的监听函数还是白费，不幸的是 DOM 也没有为这个需求提供解决办法。而且，这还只是处理一张图片的情况，如果有一堆图片要处理那就更麻烦了。</p><h2><span id="事件不是万金油">事件不是万金油</span></h2><p>事件机制最适合处理同一个对象上反复发生的事情，如 <code>keyup</code>、<code>touchstart</code> 等等。你不需要考虑当绑定监听器之前所发生的事情，当碰到异步请求成功/失败的时候，你想要的通常是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">img1.callThisIfLoadedOrWhenLoaded(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 加载完成</span></div><div class="line">&#125;).orIfFailedCallThis(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 加载失败</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 以及……</span></div><div class="line">whenAllTheseHaveLoaded([img1, img2]).callThis(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 全部加载完成</span></div><div class="line">&#125;).orIfSomeFailedCallThis(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 一个或多个加载失败</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这就是 Promise。如果 HTML 图片元素有一个“ready()”方法的话，我们就可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">img1.ready().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 加载完成</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 加载失败</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 以及……</span></div><div class="line"><span class="built_in">Promise</span>.all([img1.ready(), img2.ready()]).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 全部加载完成</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 一个或多个加载失败</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>基本上 Promise 还是有点像事件回调的，除了：</p><ul><li>一个 Promise 只能成功或失败一次，并且状态无法改变（不能从成功变为失败，反之亦然）</li><li>如果一个 Promise 成功或者失败之后，你为其添加针对成功/失败的回调，则相应的回调函数会立即执行</li></ul><p>这些特性非常适合处理异步操作的成功/失败情景，你无需再担心事件发生的时间点，而只需对其做出响应。</p><p><a name="toc-promise-terminology"></a></p><h2><span id="promise-相关术语">Promise 相关术语</span></h2><p><a href="https://twitter.com/domenic" target="_blank" rel="external">Domenic Denicola</a> 审阅了本文初稿，给我在术语方面打了个“F”，关了禁闭并且责令我打印 <a href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md" target="_blank" rel="external">States and Fates</a> 一百遍，还写了一封家长信给我父母。即便如此，我还是对术语有些迷糊，不过基本上应该是这样：</p><p>一个 Promise 的状态可以是：</p><ul><li><strong>肯定（fulfilled）</strong> - 该 Promise 对应的操作成功了</li><li><strong>否定（rejected）</strong> - 该 Promise 对应的操作失败了</li><li><strong>等待（pending）</strong> - 还没有得到肯定或者否定结果，进行中</li><li><strong>结束（settled）</strong> - 已经肯定或者否定了</li></ul><p>规范里还使用 <strong>thenable</strong> 来描述一个对象是否是“类 Promise”（拥有名为“then”的方法）的。这个术语使我想起来前英格兰足球经理 <a href="http://en.wikipedia.org/wiki/Terry_Venables" target="_blank" rel="external">Terry Venables</a> 所以我尽量少用它。</p><h2><span id="javascript-有了-promise">JavaScript 有了 Promise！</span></h2><p>其实已经有一些第三方库实现了 Promise 的功能：</p><ul><li><a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a></li><li><a href="https://github.com/cujojs/when" target="_blank" rel="external">when</a></li><li><a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx" target="_blank" rel="external">WinJS</a></li><li><a href="https://github.com/tildeio/rsvp.js" target="_blank" rel="external">RSVP.js</a></li></ul><p>上面这些库和 JavaScript 原生 Promise 都遵守一个通用的、标准化的规范：<a href="https://github.com/promises-aplus/promises-spec" target="_blank" rel="external">Promises/A+</a>，jQuery 有个类似的方法叫 <a href="http://api.jquery.com/category/deferred-object/" target="_blank" rel="external">Deferred</a>，但不兼容 Promises/A+ 规范，于是会<a href="https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/" target="_blank" rel="external">有点小问题</a>，使用需谨慎。jQuery 还有一个 <a href="http://api.jquery.com/Types/#Promise" target="_blank" rel="external">Promise 类型</a>，它其实是 Deferred 的缩减版，所以也有同样问题。</p><p>尽管 Promise 的各路实现遵循同一规范，但它们的 API 还是各不相同。JavaScript Promise 的 API 比较接近 RSVP.js，如下创建 Promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// 做一些异步操作的事情，然后……</span></div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (<span class="comment">/* 一切正常 */</span>) &#123;</div><div class="line">    resolve(<span class="string">"Stuff worked!"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    reject(<span class="built_in">Error</span>(<span class="string">"It broke"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>Promise 的构造器接受一个函数作为参数，它会传递给这个回调函数两个变量 <code>resolve</code> 和 <code>reject</code>。在回调函数中做一些异步操作，成功之后调用 <code>resolve</code>，否则调用 <code>reject</code>。</p><p>调用 <code>reject</code> 的时候传递给它一个 <code>Error</code> 对象只是个惯例并非必须，这和经典 JavaScript 中的 <code>throw</code> 一样。传递 <code>Error</code> 对象的好处是它包含了调用堆栈，在调试的时候会有点用处。</p><p>现在来看看如何使用 Promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// “完美！”</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// Error: "出问题了"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><code>then</code>接受两个参数，成功的时候调用一个，失败的时候调用另一个，两个都是可选的，所以你可以只处理成功的情况或者失败的情况。</p><p>JavaScript Promise 最初以“Futures”为名归为 DOM 规范，后来改名为“Promises”，最终纳入 JavaScript 规范。将其加入 JavaScript 而非 DOM 的好处是方便在非浏览器环境中使用，如Node.js（他们会不会在核心API中使用就是另一回事了）。</p><p>尽管它被归位 JavaScript 特性，DOM 也很乐意拿过来用。事实上，所有包含异步成功/失败方法的新 DOM API 都会使用 Promise 机制，已经实现的包括 <a href="https://dvcs.w3.org/hg/quota/raw-file/tip/Overview.html#idl-def-StorageQuota" target="_blank" rel="external">Quota Management</a>，<a href="http://dev.w3.org/csswg/css-font-loading/#font-face-set-ready" target="_blank" rel="external">Font Load Events</a>，<a href="https://github.com/slightlyoff/ServiceWorker/blob/cf459d473ae09f6994e8539113d277cbd2bce939/service_worker.ts#L17" target="_blank" rel="external">ServiceWorker</a>，<a href="http://webaudio.github.io/web-midi-api/#widl-Navigator-requestMIDIAccess-Promise-MIDIOptions-options" target="_blank" rel="external">Web MIDI</a>，<a href="https://github.com/whatwg/streams#basereadablestream" target="_blank" rel="external">Streams</a> 等等。</p><h2><span id="浏览器支持和-polyfill">浏览器支持和 Polyfill</span></h2><p>目前的浏览器已经（部分）实现了 Promise。</p><p>用 Chrome 的话，就像个 Chroman 一样 装上 <a href="https://www.google.com/intl/en/chrome/browser/canary.html" target="_blank" rel="external">Canary</a>，默认即启用了 Promise 支持。如果是 Firefox 拥趸，则可以安装最新的 <a href="http://nightly.mozilla.org/" target="_blank" rel="external">nightly build</a>。</p><p>不过这两个浏览器的实现都还不够完整彻底，你可以 在 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=918806" target="_blank" rel="external">bugzilla</a> 上跟踪 Firefox 的最新进展或者到 <a href="http://www.chromestatus.com/features/5681726336532480" target="_blank" rel="external">Chromium Dashboard</a> 查看 Chrome 的实现情况。</p><p>要在这两个浏览器上达到兼容标准 Promise，或者在其他浏览器以及 Node.js 中使用 Promise，可以看看这个 <a href="https://github.com/jakearchibald/ES6-Promises/blob/master/README.md" target="_blank" rel="external">polyfill</a>（gzip 压缩之后只有 2K）。</p><h2><span id="与其他库的兼容性">与其他库的兼容性</span></h2><p>JavaScript Promise 的 API 会把任何包含有 then 方法的对象当作“类 Promise”（或者用术语来说就是 thenable）的对象，这些对象经过 <code>Promise.cast</code> 处理之后就和原生的 Promise 实例没有任何区别了。所以如果你使用的库返回一个 Q Promise，那没问题，无缝融入新的 JavaScript Promise。</p><p>尽管，如前所述，jQuery 的 Deferred 对象有点……没什么用，不过幸好还可以转换成标准 Promise，最好一拿到对象就马上加以转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsPromise = <span class="built_in">Promise</span>.cast($.ajax(<span class="string">'/whatever.json'</span>));</div></pre></td></tr></table></figure><p>这里 jQuery 的 <code>$.ajax</code> 返回一个 <code>Deferred</code> 对象，含有 <code>then</code> 方法，因此通过 <code>Promise.cast</code> 可以将其转换为 JavaScript Promise。不过有时候 <code>Deferred</code> 对象会给它的回调函数传递多个参数，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jqDeferred = $.ajax(<span class="string">'/whatever.json'</span>);</div><div class="line"></div><div class="line">jqDeferred.then(<span class="function"><span class="keyword">function</span>(<span class="params">response, statusText, xhrObj</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">xhrObj, textStatus, err</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>除了第一个参数，其他都会被 JavaScript Promise 忽略掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">jsPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">xhrObj</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>……还好这通常就是你想要的了，至少你能够用这个办法实现想要的。另外还要注意，jQuery 也没有遵循给否定回调函数传递 <code>Error</code> 对象的约定。</p><h2><span id="复杂的异步代码变得简单了">复杂的异步代码变得简单了</span></h2><p>OK，现在我们来写点实际的代码。假设我们想要：</p><ol><li>显示一个加载指示图标</li><li>加载一篇小说的 JSON，包含小说名和每一章内容的 URL。</li><li>在页面中填上小说名</li><li>加载所有章节正文</li><li>在页面中添加章节正文</li><li>停止加载指示</li></ol><p>如果在这个过程中发生什么错误，要通知用户，并且把加载指示停掉，不然它就会不停转下去，令人眼晕，或者搞坏界面什么的。</p><p>当然，你不会用 JavaScript 去这么繁琐地显示一篇文章，<a href="http://jakearchibald.com/2013/progressive-enhancement-is-faster/" target="_blank" rel="external">直接输出 HTML 要快得多</a>，不过这个流程是非常典型的 API 请求模式：获取多个数据，当它们全部完成之后再做一些事情。</p><p>首先，搞定从网络加载数据的步骤：</p><h2><span id="将-promise-用于-xmlhttprequest">将 Promise 用于 XMLHttpRequest</span></h2><p>只要能保持向后兼容，现有 API 都会更新以支持 Promise，<code>XMLHttpRequest</code> 是重点考虑对象之一。不过现在我们先来写个 GET 请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="comment">// 返回一个新的 Promise</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="comment">// 经典 XHR 操作</span></div><div class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    req.open(<span class="string">'GET'</span>, url);</div><div class="line"></div><div class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// 当发生 404 等状况的时候调用此函数</span></div><div class="line">      <span class="comment">// 所以先检查状态码</span></div><div class="line">      <span class="keyword">if</span> (req.status == <span class="number">200</span>) &#123;</div><div class="line">        <span class="comment">// 以响应文本为结果，完成此 Promise</span></div><div class="line">        resolve(req.response);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 否则就以状态码为结果否定掉此 Promise</span></div><div class="line">        <span class="comment">// （提供一个有意义的 Error 对象）</span></div><div class="line">        reject(<span class="built_in">Error</span>(req.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 网络异常的处理方法</span></div><div class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      reject(<span class="built_in">Error</span>(<span class="string">"Network Error"</span>));</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 发出请求</span></div><div class="line">    req.send();</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在可以调用它了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Success!"</span>, response);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(<span class="string">"Failed!"</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>点击<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/story.json" target="_blank" rel="external">这里</a>查看运行结果。现在我们不需要手敲 <code>XMLHttpRequest</code> 就可以直接发起 HTTP 请求，这样感觉好多了，能少看到一次这个狂驼峰命名的 <code>XMLHttpRequest</code> 我的快乐就多一点。</p><h2><span id="链式调用">链式调用</span></h2><p><code>then</code> 的故事还没完，你可以把这些 <code>then</code> 串联起来修改结果或者添加进行更多异步操作。</p><h3><span id="值的处理">值的处理</span></h3><p>你可以对结果做些修改然后返回一个新值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(val); <span class="comment">// 1</span></div><div class="line">  <span class="keyword">return</span> val + <span class="number">2</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(val); <span class="comment">// 3</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>回到前面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Success!"</span>, response);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>收到的响应是一个纯文本的 JSON，我们可以修改 <code>get</code> 函数，设置 <code>responseType</code> 为 JSON 来指定服务器响应格式，也可以在 Promise 的世界里搞定这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(response);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Yey JSON!"</span>, response);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>既然 <code>JSON.parse</code> 只接收一个参数，并返回转换后的结果，我们还可以再精简一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="built_in">JSON</span>.parse).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Yey JSON!"</span>, response);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>点击<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/story.json" target="_blank" rel="external">这里</a>查看代码运行结果，打开控制台查看输出结果。事实上，我们可以把 <code>getJSON</code> 函数写得超级简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> get(url).then(<span class="built_in">JSON</span>.parse);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>getJSON</code> 会返回一个获取 JSON 并加以解析的 Promise。</p><h3><span id="队列的异步操作">队列的异步操作</span></h3><p>你也可以把 <code>then</code> 串联起来依次执行异步操作。</p><p>当你从 <code>then</code> 的回调函数返回的时候，这里有点小魔法。如果你返回一个值，它就会被传给下一个 <code>then</code> 的回调；而如果你返回一个“类 Promise”的对象，则下一个 <code>then</code> 就会等待这个 Promise 明确结束（成功/失败）才会执行。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> getJSON(story.chapterUrls[<span class="number">0</span>]);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter1</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Got chapter 1!"</span>, chapter1);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这里我们发起一个对“story.json”的异步请求，返回给我们每一章的 URL，然后我们会请求其中的第一个。Promise 开始首次显现出相较于事件回调的优越性了。你甚至可以写一个抓取章节内容的独立函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> storyPromise;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getChapter</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">  storyPromise = storyPromise || getJSON(<span class="string">'story.json'</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> storyPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getJSON(story.chapterUrls[i]);</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 用起来非常简单：</span></div><div class="line">getChapter(<span class="number">0</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(chapter);</div><div class="line">  <span class="keyword">return</span> getChapter(<span class="number">1</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(chapter);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>我们一开始并不加载 story.json，直到第一次 <code>getChapter</code>，而以后每次 <code>getChapter</code> 的时候都可以重用已经加载完成的 <code>storyPromise</code>，所以 story.json 只需要请求一次。Promise 好棒！</p><h2><span id="错误处理">错误处理</span></h2><p>前面已经看到，<code>then</code>接受两个参数，一个处理成功，一个处理失败（或者说肯定和否定，按 Promise 术语）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Success!"</span>, response);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Failed!"</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>你还可以使用 <code>catch</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Success!"</span>, response);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Failed!"</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这里的 <code>catch</code> 并无任何特殊之处，只是 <code>then(undefined, func)</code> 的语法糖，更直观一点而已。注意上面两段代码的行为不仅相同，后者相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Success!"</span>, response);</div><div class="line">&#125;).then(<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Failed!"</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>差异不大，但意义非凡。Promise 被否定之后会跳转到之后第一个配置了否定回调的 <code>then</code>（或 <code>catch</code>，一样的）。对于 <code>then(func1, func2)</code> 来说，必会调用 <code>func1</code> 或 <code>func2</code> 之一，但绝不会两个都调用。而 <code>then(func1).catch(func2)</code> 这样，如果 <code>func1</code> 返回否定的话 <code>func2</code> 也会被调用，因为他们是链式调用中独立的两个步骤。看下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">asyncThing1().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> asyncThing2();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> asyncThing3();</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> asyncRecovery1();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> asyncThing4();</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> asyncRecovery2();</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Don't worry about it"</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"All done!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这段流程非常像 JavaScript 的 <code>try/catch</code> 组合，<code>try</code> 代码块中发生的错误会立即跳转到 <code>catch</code> 代码块。这是上面那段代码的流程图（我最爱流程图了）：</p><div style="max-width: 495px; margin: 10px 0"><br>  <div style="position: relative; padding-top: 93%"><br>    <iframe style="position:absolute;top:0;left:0;width:100%;height:100%;overflow:hidden" src="http://www.html5rocks.com/zh/tutorials/es6/promises/promise-flow.svg" frameborder="0" allowtransparency="true"></iframe><br>  </div><br></div><p>绿线是肯定的 Promise 流程，红线是否定的 Promise 流程。</p><h3><span id="javascript-异常和-promise">JavaScript 异常和 Promise</span></h3><p>Promise 的否定回调可以由 <code>Promise.reject()</code> 触发，也可以由构造器回调中抛出的错误触发：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsonPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果数据格式不对的话 JSON.parse 会抛出错误</span></div><div class="line">  <span class="comment">// 可以作为隐性的否定结果：</span></div><div class="line">  resolve(<span class="built_in">JSON</span>.parse(<span class="string">"This ain't JSON"</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">jsonPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="comment">// 永远不会发生：</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"It worked!"</span>, data);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// 这才是真相：</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"It failed!"</span>, err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这意味着你可以把所有 Promise 相关操作都放在它的构造函数回调中进行，这样发生任何错误都能捕捉到并且触发 Promise 否定。</p><p><code>then</code>回调中抛出的错误也一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">get(<span class="string">'/'</span>).then(<span class="built_in">JSON</span>.parse).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// This never happens, '/' is an HTML page, not JSON</span></div><div class="line">  <span class="comment">// so JSON.parse throws</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"It worked!"</span>, data);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// Instead, this happens:</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"It failed!"</span>, err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3><span id="实践错误处理">实践错误处理</span></h3><p>回到我们的故事和章节的例子，我们用 <code>catch</code> 来捕捉错误并显示给用户：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> getJSON(story.chapterUrls[<span class="number">0</span>]);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter1</span>) </span>&#123;</div><div class="line">  addHtmlToPage(chapter1.html);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  addTextToPage(<span class="string">"Failed to show chapter"</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>如果请求 <code>story.chapterUrls[0]</code> 失败（http 500 或者用户掉线什么的）了，它会跳过之后所有针对成功的回调，包括 getJSON 中将响应解析为 JSON 的回调，和这里把第一张内容添加到页面里的回调。JavaScript 的执行会进入 <code>catch</code> 回调。结果就是前面任何章节请求出错，页面上都会显示“Failed to show chapter”。</p><p>和 JavaScript 的 <code>try/catch</code> 一样，捕捉到错误之后，接下来的代码会继续执行，按计划把加载指示器给停掉。上面的代码就是下面这段的非阻塞异步版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">var</span> story = getJSONSync(<span class="string">'story.json'</span>);</div><div class="line">  <span class="keyword">var</span> chapter1 = getJSONSync(story.chapterUrls[<span class="number">0</span>]);</div><div class="line">  addHtmlToPage(chapter1.html);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (e) &#123;</div><div class="line">  addTextToPage(<span class="string">"Failed to show chapter"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div></pre></td></tr></table></figure><p>如果只是要捕捉异常做记录输出而不打算在用户界面上对错误进行反馈的话，只要抛出 <code>Error</code> 就行了，这一步可以放在 <code>getJSON</code> 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> get(url).then(<span class="built_in">JSON</span>.parse).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"getJSON failed for"</span>, url, err);</div><div class="line">    <span class="keyword">throw</span> err;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在我们已经搞定第一章的显示了，接下来搞定全部章节。</p><h2><span id="并行和串行-鱼与熊掌兼得">并行和串行 —— 鱼与熊掌兼得</span></h2><p>异步的思维方式并不符合直觉，如果你觉得起步困难，那就试试先写个同步的方法，就像这个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">var</span> story = getJSONSync(<span class="string">'story.json'</span>);</div><div class="line">  addHtmlToPage(story.heading);</div><div class="line"></div><div class="line">  story.chapterUrls.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">chapterUrl</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> chapter = getJSONSync(chapterUrl);</div><div class="line">    addHtmlToPage(chapter.html);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  addTextToPage(<span class="string">"All done"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (err) &#123;</div><div class="line">  addTextToPage(<span class="string">"Argh, broken: "</span> + err.message);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div></pre></td></tr></table></figure><p>它执行起来完全正常（<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/sync-example.html" target="_blank" rel="external">查看示例</a>）！不过它是同步的，在加载内容时会卡住整个浏览器。要让它异步工作的话，我们用 <code>then</code> 把它们一个接一个串起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">  addHtmlToPage(story.heading);</div><div class="line"></div><div class="line">  <span class="comment">// <span class="doctag">TODO:</span> 获取并显示 story.chapterUrls 中的每个 url</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 全部完成啦！</span></div><div class="line">  addTextToPage(<span class="string">"All done"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果过程中有任何不对劲的地方</span></div><div class="line">  addTextToPage(<span class="string">"Argh, broken: "</span> + err.message);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 无论如何要把 spinner 隐藏掉</span></div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>那么我们如何遍历章节的 URL 并且依次请求？这样是不行的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">story.chapterUrls.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">chapterUrl</span>) </span>&#123;</div><div class="line">  <span class="comment">// Fetch chapter</span></div><div class="line">  getJSON(chapterUrl).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">    <span class="comment">// and add it to the page</span></div><div class="line">    addHtmlToPage(chapter.html);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><code>forEach</code> 没有对异步操作的支持，所以我们的故事章节会按照它们加载完成的顺序显示，基本上《低俗小说》就是这么写出来的。我们不写低俗小说，所以得修正它：</p><h3><span id="创建序列">创建序列</span></h3><p>我们要把章节 URL 数组转换成 Promise 的序列，还是用 <code>then</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从一个完成状态的 Promise 开始</span></div><div class="line"><span class="keyword">var</span> sequence = <span class="built_in">Promise</span>.resolve();</div><div class="line"></div><div class="line"><span class="comment">// 遍历所有章节的 url</span></div><div class="line">story.chapterUrls.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">chapterUrl</span>) </span>&#123;</div><div class="line">  <span class="comment">// 从 sequence 开始把操作接龙起来</span></div><div class="line">  sequence = sequence.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getJSON(chapterUrl);</div><div class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">    addHtmlToPage(chapter.html);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这是我们第一次用到 <code>Promise.resolve</code>，它会依据你传的任何值返回一个 Promise。如果你传给它一个类 Promise 对象（带有 <code>then</code> 方法），它会生成一个带有同样肯定/否定回调的 Promise，基本上就是克隆。如果传给它任何别的值，如 <code>Promise.resolve(&#39;Hello&#39;)</code>，它会创建一个以这个值为完成结果的 Promise，如果不传任何值，则以 <code>undefined</code> 为完成结果。</p><p>还有一个对应的 <code>Promise.reject(val)</code>，会创建以你传入的参数（或 <code>undefined</code>）为否定结果的 Promise。</p><p>我们可以用 <code>array.reduce</code> 精简一下上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 遍历所有章节的 url</span></div><div class="line">story.chapterUrls.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sequence, chapterUrl</span>) </span>&#123;</div><div class="line">  <span class="comment">// 从 sequence 开始把操作接龙起来</span></div><div class="line">  <span class="keyword">return</span> sequence.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getJSON(chapterUrl);</div><div class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">    addHtmlToPage(chapter.html);</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="built_in">Promise</span>.resolve());</div></pre></td></tr></table></figure><p>它和前面的例子功能一样，但是不需要显式声明 <code>sequence</code> 变量。<code>reduce</code> 回调会依次应用在每个数组元素上，第一轮里的“sequence”是 <code>Promise.resolve()</code>，之后的调用里 <code>sequence</code> 就是上次函数执行的的结果。<code>array.reduce</code> 非常适合用于把一组值归并处理为一个值，正是我们现在对 Promise 的用法。</p><p>汇总上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">  addHtmlToPage(story.heading);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> story.chapterUrls.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sequence, chapterUrl</span>) </span>&#123;</div><div class="line">    <span class="comment">// 当前一个章节的 Promise 完成之后……</span></div><div class="line">    <span class="keyword">return</span> sequence.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ……获取下一章</span></div><div class="line">      <span class="keyword">return</span> getJSON(chapterUrl);</div><div class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">      <span class="comment">// 并添加到页面</span></div><div class="line">      addHtmlToPage(chapter.html);</div><div class="line">    &#125;);</div><div class="line">  &#125;, <span class="built_in">Promise</span>.resolve());</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 现在全部完成了！</span></div><div class="line">  addTextToPage(<span class="string">"All done"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果过程中发生任何错误</span></div><div class="line">  addTextToPage(<span class="string">"Argh, broken: "</span> + err.message);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 保证 spinner 最终会隐藏</span></div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><a href="http://www.html5rocks.com/zh/tutorials/es6/promises/async-example.html" target="_blank" rel="external">查看代码运行示例</a>，前面的同步代码改造成了完全异步的版本。我们还可以更进一步。现在页面加载的效果是这样：</p><p><img src="http://www.html5rocks.com/zh/tutorials/es6/promises/promise1.gif" alt=""></p><p>浏览器很擅长同时加载多个文件，我们这种一个接一个下载章节的方法非常低效率。我们希望同时下载所有章节，全部完成后一次搞定，正好就有这么个 API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.all(arrayOfPromises).then(<span class="function"><span class="keyword">function</span>(<span class="params">arrayOfResults</span>) </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><code>Promise.all</code> 接受一个 Promise 数组为参数，创建一个当所有 Promise 都完成之后就完成的 Promise，它的完成结果是一个数组，包含了所有先前传入的那些 Promise 的完成结果，顺序和将它们传入的数组顺序一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">  addHtmlToPage(story.heading);</div><div class="line"></div><div class="line">  <span class="comment">// 接受一个 Promise 数组并等待他们全部完成</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</div><div class="line">    <span class="comment">// 把章节 URL 数组转换成对应的 Promise 数组</span></div><div class="line">    story.chapterUrls.map(getJSON)</div><div class="line">  );</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapters</span>) </span>&#123;</div><div class="line">  <span class="comment">// 现在我们有了顺序的章节 JSON，遍历它们……</span></div><div class="line">  chapters.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">    <span class="comment">// ……并添加到页面中</span></div><div class="line">    addHtmlToPage(chapter.html);</div><div class="line">  &#125;);</div><div class="line">  addTextToPage(<span class="string">"All done"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// 捕获过程中的任何错误</span></div><div class="line">  addTextToPage(<span class="string">"Argh, broken: "</span> + err.message);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>根据连接状况，改进的代码会比顺序加载方式提速数秒（<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/async-all-example.html" target="_blank" rel="external">查看示例</a>），甚至代码行数也更少。章节加载完成的顺序不确定，但它们显示在页面上的顺序准确无误。</p><p><img src="http://www.html5rocks.com/zh/tutorials/es6/promises/promise2.gif" alt=""></p><p>然而这样还是有提高空间。当第一章内容加载完毕我们可以立即填进页面，这样用户可以在其他加载任务尚未完成之前就开始阅读；当第三章到达的时候我们不动声色，第二章也到达之后我们再把第二章和第三章内容填入页面，以此类推。</p><p>为了达到这样的效果，我们同时请求所有的章节内容，然后创建一个序列依次将其填入页面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'story.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>) </span>&#123;</div><div class="line">  addHtmlToPage(story.heading);</div><div class="line"></div><div class="line">  <span class="comment">// 把章节 URL 数组转换成对应的 Promise 数组</span></div><div class="line">  <span class="comment">// 这样就可以并行加载它们</span></div><div class="line">  <span class="keyword">return</span> story.chapterUrls.map(getJSON)</div><div class="line">    .reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sequence, chapterPromise</span>) </span>&#123;</div><div class="line">      <span class="comment">// 使用 reduce 把这些 Promise 接龙</span></div><div class="line">      <span class="comment">// 以及将章节内容添加到页面</span></div><div class="line">      <span class="keyword">return</span> sequence.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 等待当前 sequence 中所有章节和本章节的数据到达</span></div><div class="line">        <span class="keyword">return</span> chapterPromise;</div><div class="line">      &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>) </span>&#123;</div><div class="line">        addHtmlToPage(chapter.html);</div><div class="line">      &#125;);</div><div class="line">    &#125;, <span class="built_in">Promise</span>.resolve());</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  addTextToPage(<span class="string">"All done"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// 捕获过程中的任何错误</span></div><div class="line">  addTextToPage(<span class="string">"Argh, broken: "</span> + err.message);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>哈哈（<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/async-best-example.html" target="_blank" rel="external">查看示例</a>），鱼与熊掌兼得！加载所有内容的时间未变，但用户可以更早看到第一章。</p><p><img src="http://www.html5rocks.com/zh/tutorials/es6/promises/promise3.gif" alt=""></p><p>这个小例子中各部分章节加载差不多同时完成，逐章显示的策略在章节内容很多的时候优势将会更加显著。</p><p>上面的代码如果用 <a href="https://gist.github.com/jakearchibald/0e652d95c07442f205ce" target="_blank" rel="external">Node.js 风格的回调或者事件机制</a>实现的话代码量大约要翻一倍，更重要的是可读性也不如此例。然而，Promise 的厉害不止于此，和其他 ES6 的新功能结合起来还能更加高效……</p><h2><span id="附赠章节promise-和-generator">附赠章节：Promise 和 Generator</span></h2><p>接下来的内容涉及到一大堆 ES6 的新特性，不过对于现在应用 Promise 来说并非必须，把它当作接下来的第二部豪华续集的预告片来看就好了。</p><p>ES6 还给我们带来了 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators" target="_blank" rel="external">Generator</a>，允许函数在特定地方像 return 一样退出，但是稍后又能恢复到这个位置和状态上继续执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">addGenerator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    i += <span class="keyword">yield</span> i;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意函数名前的星号，这表示该函数是一个 Generator。关键字 <code>yield</code> 标记了暂停/继续的位置，使用方法像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> adder = addGenerator();</div><div class="line">adder.next().value; <span class="comment">// 0</span></div><div class="line">adder.next(<span class="number">5</span>).value; <span class="comment">// 5</span></div><div class="line">adder.next(<span class="number">5</span>).value; <span class="comment">// 10</span></div><div class="line">adder.next(<span class="number">5</span>).value; <span class="comment">// 15</span></div><div class="line">adder.next(<span class="number">50</span>).value; <span class="comment">// 65</span></div></pre></td></tr></table></figure><p>这对 Promise 有什么用呢？你可以用这种暂停/继续的机制写出来和同步代码看上去差不多（理解起来也一样简单）的代码。下面是一个辅助函数（helper function），我们在 <code>yield</code> 位置等待 Promise 完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">generatorFunc</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">continuer</span>(<span class="params">verb, arg</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      result = generator[verb](arg);</div><div class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (result.done) &#123;</div><div class="line">      <span class="keyword">return</span> result.value;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.cast(result.value).then(onFulfilled, onRejected);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> generator = generatorFunc();</div><div class="line">  <span class="keyword">var</span> onFulfilled = continuer.bind(continuer, <span class="string">"next"</span>);</div><div class="line">  <span class="keyword">var</span> onRejected = continuer.bind(continuer, <span class="string">"throw"</span>);</div><div class="line">  <span class="keyword">return</span> onFulfilled();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码<a href="https://github.com/kriskowal/q/blob/db9220d714b16b96a05e9a037fa44ce581715e41/q.js#L500" target="_blank" rel="external">原样拷贝自 Q</a>，只是改成 JavaScript Promise 的 API。把我们前面的最终方案和 ES6 最新特性结合在一起之后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">spawn(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 'yield' 会执行一个异步的等待，返回这个 Promise 的结果</span></div><div class="line">    <span class="keyword">let</span> story = <span class="keyword">yield</span> getJSON(<span class="string">'story.json'</span>);</div><div class="line">    addHtmlToPage(story.heading);</div><div class="line"></div><div class="line">    <span class="comment">// 把章节 URL 数组转换成对应的 Promise 数组</span></div><div class="line">    <span class="comment">// 以便并行加载</span></div><div class="line">    <span class="keyword">let</span> chapterPromises = story.chapterUrls.map(getJSON);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> chapterPromise <span class="keyword">of</span> chapterPromises) &#123;</div><div class="line">      <span class="comment">// 等待每个章节加载完成，将其添加至页面</span></div><div class="line">      <span class="keyword">let</span> chapter = <span class="keyword">yield</span> chapterPromise;</div><div class="line">      addHtmlToPage(chapter.html);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addTextToPage(<span class="string">"All done"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="comment">// try/catch 即可。否定的 Promise 会在这里抛出。</span></div><div class="line">    addTextToPage(<span class="string">"Argh, broken: "</span> + err.message);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.spinner'</span>).style.display = <span class="string">'none'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>功能完全一样，读起来要简单得多。这个例子目前可以在 Chrome Canary 中运行（<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/async-generators-example.html" target="_blank" rel="external">查看示例</a>），不过你得先到 <code>about:flags</code> 中开启 Enable experimental JavaScript 选项。</p><p>这里用到了一堆 ES6 的新语法：<code>Promise</code>、<code>Generator</code>、<code>let</code>、<code>for-of</code>。当我们把 <code>yield</code> 应用在一个 Promise 上，<code>spawn</code> 辅助函数会等待 Promise 完成，然后才返回最终的值。如果 Promise 给出否定结果，<code>spawn</code> 中的 <code>yield</code> 则会抛出一个异常，我们可以用 <code>try/catch</code> 捕捉到。这样写异步代码真是超级简单！</p><p><a name="toc-api"></a></p><h2><span id="promise-api-参考">Promise API 参考</span></h2><p>除非额外注明，最新版的 Chrome（Canary） 和 Firefox（nightly） 均支持下列所有方法。这个 <a href="https://github.com/jakearchibald/ES6-Promises/blob/master/README.md" target="_blank" rel="external">polyfill</a> 则在所有浏览器内实现了同样的接口。</p><h3><span id="静态方法">静态方法</span></h3><ul><li><p><strong>Promise.cast(promise);</strong></p><p>返回一个 Promise（当且仅当 promise.constructor == Promise）</p><p><strong>备注</strong>： 目前仅有 Chrome 实现</p></li></ul><ul><li><p><strong>Promise.cast(obj);</strong></p><p>创建一个以 obj 为成功结果的 Promise。</p><p><strong>备注</strong>： 目前仅有 Chrome 实现</p></li></ul><ul><li><p><strong>Promise.resolve(thenable);</strong></p><p>从 <code>thenable</code> 对象创建一个新的 Promise。一个 <code>thenable</code>（类 Promise）对象是一个带有 <code>then</code> 方法的对象。如果你传入一个原生的 JavaScript Promise 对象，则会创建一个新的 Promise。此方法涵盖了 <code>Promise.cast</code> 的特性，但是不如 <code>Promise.cast</code> 更简单高效。</p></li></ul><ul><li><p><strong>Promise.resolve(obj);</strong></p><p>创建一个以 <code>obj</code> 为肯定结果的 Promise。这种情况下等同于 <code>Promise.cast(obj)</code>。</p></li></ul><ul><li><p><strong>Promise.reject(obj);</strong></p><p>创建一个以 <code>obj</code> 为否定结果的 Promise。为了一致性和调试便利（如堆栈追踪），<code>obj</code> 应该是一个 <code>Error</code> 实例对象。</p></li></ul><ul><li><p><strong>Promise.all(array);</strong></p><p>创建一个 Promise，当且仅当传入数组中的所有 Promise 都肯定之后才肯定，如果遇到数组中的任何一个 Promise 以否定结束，则抛出否定结果。每个数组元素都会首先经过 <code>Promise.cast</code>，所以数组可以包含类 Promise 对象或者其他对象。肯定结果是一个数组，包含传入数组中每个 Promise 的肯定结果（且保持顺序）；否定结果是传入数组中第一个遇到的否定结果。</p><p><strong>备注</strong>： 目前仅有 Chrome 实现</p></li><li><p><strong>Promise.race(array);</strong></p><p>创建一个 Promise，当数组中的任意对象肯定时将其结果作为肯定结束，或者当数组中任意对象否定时将其结果作为否定结束。</p><p><strong>备注</strong>：我不大确定这个接口是否有用，我更倾向于一个 <code>Promise.all</code> 的对立方法，仅当所有数组元素全部给出否定的时候才抛出否定结果</p></li></ul><h3><span id="构造函数">构造函数</span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure><ul><li><p><strong>resolve(thenable)</strong></p><p>你的 Promise 将会根据这个 <code>thenable</code> 对象的结果而返回肯定/否定结果</p></li><li><p><strong>resolve(obj)</strong></p><p>你的 Promise 将会以 <code>obj</code> 作为肯定结果完成</p></li><li><p><strong>reject(obj)</strong></p><p>你的 Promise 将会以 <code>obj</code> 作为否定结果完成。出于一致性和调试（如栈追踪）方便，<code>obj</code> 应该是一个 <code>Error</code> 对象的实例。构造器的回调函数中抛出的错误会被立即传递给 <code>reject()</code>。</p></li></ul><h3><span id="实例方法">实例方法</span></h3><ul><li><p><strong>promise.then(onFulfilled, onRejected)</strong></p><p>当 <code>promise</code> 以肯定结束时会调用 <code>onFulfilled</code>。 当 <code>promise</code> 以否定结束时会调用 <code>onRejected</code>。 这两个参数都是可选的，当任意一个未定义时，对它的调用会跳转到 <code>then</code> 链的下一个 <code>onFulfilled/onRejected</code> 上。 这两个回调函数均只接受一个参数，肯定结果或者否定原因。 当 <code>Promise.resolve</code> 肯定结束之后，<code>then</code> 会返回一个新的 Promise，这个 Promise 相当于你从 onFulfilled/onRejected 中返回的值。如果回调中抛出任何错误，返回的 Promise 也会以此错误作为否定结果结束。</p></li><li><p><strong>promise.catch(onRejected)</strong></p><p><code>promise.then(undefined, onRejected)</code> 的语法糖。</p></li></ul><h2><span id="最后">最后</span></h2><p>非常感谢 Anne van Kesteren，Domenic Denicola，Tom Ashworth，Remy Sharp，Addy Osmani，Arthur Evans 以及 and Yutaka Hirano 对本文做出的贡献（审阅/纠错或建议）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;童鞋们，请准备好迎接 Web 开发历史上一个重大时刻。。。&lt;/p&gt;
&lt;p&gt;[鼓声响起]&lt;/p&gt;
&lt;p&gt;JavaScript 有了原生的 Promise！&lt;/p&gt;
&lt;p&gt;[漫天的烟花绽放，人群沸腾了]&lt;/p&gt;
&lt;p&gt;这时候你大概是这三种人之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你的身边拥挤着欢呼的人群，但是你却不在其中，甚至你还不大清楚“Promise”是什么。你耸耸肩，烟花的碎屑在你的身边落下。不过不要担心，我也是花了多年的时间才明白 Promise 的意义，你可以&lt;a href=&quot;#toc-async&quot;&gt;从这里开始&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;你一挥拳！太赞了对么！你已经用过一些 Promise 的库，但是所有这些第三方实现在 API 上都略有差异，JavaScript 官方的 API 会是什么样子？请看&lt;a href=&quot;#toc-promise-terminology&quot;&gt;这里&lt;/a&gt;！&lt;/li&gt;
&lt;li&gt;你早就知道了，看着那些欢呼雀跃的新人你的嘴角泛起一丝不屑的微笑。你可以安静享受一会儿优越感，然后直接去看 &lt;a href=&quot;#toc-api&quot;&gt;API 参考&lt;/a&gt;吧。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Promise" scheme="http://bubkoo.com/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>看看这些题目你会多少？</title>
    <link href="http://bubkoo.com/2014/03/20/some-javascript-quiz-from-perfectionkills/"/>
    <id>http://bubkoo.com/2014/03/20/some-javascript-quiz-from-perfectionkills/</id>
    <published>2014-03-20T10:20:47.000Z</published>
    <updated>2014-03-20T10:20:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 <a href="http://perfectionkills.com/javascript-quiz/" target="_blank" rel="external">perfectionkills</a> 上看到几道 JavaScript 题目，这里拿来分享一下，下面列举出来了题目，你可以在这里做题，答案解析可以<a href="http://www.cnblogs.com/aaronjs/archive/2013/07/05/3172112.html" target="_blank" rel="external">到这里</a>找到。</p><p><img src="http://bubkoo.qiniudn.com/some-javascript-quiz-from-perfectionkills.jpg" alt=""></p><a id="more"></a><style>    .answers {        margin: 10px;    }    .answers li{        list-style:none;        line-height: 1.4;    }</style><p>1.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">arguments</span>;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="question-1" id="answer-1-1"><br>        <label for="answer-1-1">“object”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-1" id="answer-1-2"><br>        <label for="answer-1-2">“array”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-1" id="answer-1-3"><br>        <label for="answer-1-3">“arguments”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-1" id="answer-1-4"><br>        <label for="answer-1-4">“undefined”</label><br>    </li><br></ul><p>2.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">23</span>; &#125;;</div><div class="line"><span class="keyword">typeof</span> g();</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="question-2" id="answer-2-1"><br>        <label for="answer-2-1">“number”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-2" id="answer-2-2"><br>        <label for="answer-2-2">“undefined”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-2" id="answer-2-3"><br>        <label for="answer-2-3">“function”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-2" id="answer-2-4"><br>        <label for="answer-2-4">Error</label><br>    </li><br></ul><p>3.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">delete</span> x;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;)(<span class="number">1</span>);</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="question-3" id="answer-3-1"><br>        <label for="answer-3-1">1</label><br>    </li><br>    <li><br>        <input type="radio" name="question-3" id="answer-3-2"><br>        <label for="answer-3-2">null</label><br>    </li><br>    <li><br>        <input type="radio" name="question-3" id="answer-3-3"><br>        <label for="answer-3-3">undefined</label><br>    </li><br>    <li><br>        <input type="radio" name="question-3" id="answer-3-4"><br>        <label for="answer-3-4">Error</label><br>    </li><br></ul><p>4.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> y = <span class="number">1</span>, x = y = <span class="keyword">typeof</span> x;</div><div class="line">x;</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="question-4" id="answer-4-1"><br>        <label for="answer-4-1">1</label><br>    </li><br>    <li><br>        <input type="radio" name="question-4" id="answer-4-2"><br>        <label for="answer-4-2">“number”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-4" id="answer-4-3"><br>        <label for="answer-4-3">undefined</label><br>    </li><br>    <li><br>        <input type="radio" name="question-4" id="answer-4-4"><br>        <label for="answer-4-4">“undefined”</label><br>    </li><br></ul><p>5.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> f();</div><div class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;);</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="question-5" id="answer-5-1"><br>        <label for="answer-5-1">“number”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-5" id="answer-5-2"><br>        <label for="answer-5-2">“undefined”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-5" id="answer-5-3"><br>        <label for="answer-5-3">“function”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-5" id="answer-5-4"><br>        <label for="answer-5-4">Error</label><br>    </li><br></ul><p>6.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.baz; &#125;,</div><div class="line">    baz: <span class="number">1</span></div><div class="line">  &#125;;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>]();</div><div class="line">&#125;)(foo.bar);</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="question-6" id="answer-6-1"><br>        <label for="answer-6-1">“undefined”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-6" id="answer-6-2"><br>        <label for="answer-6-2">“object”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-6" id="answer-6-3"><br>        <label for="answer-6-3">“number”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-6" id="answer-6-4"><br>        <label for="answer-6-4">“function”</label><br>    </li><br></ul><p>7.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.baz; &#125;,</div><div class="line">    baz: <span class="number">1</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">typeof</span> (f = foo.bar)();</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="question-7" id="answer-7-1"><br>        <label for="answer-7-1">“undefined”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-7" id="answer-7-2"><br>        <label for="answer-7-2">“object”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-7" id="answer-7-3"><br>        <label for="answer-7-3">“number”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-7" id="answer-7-4"><br>        <label for="answer-7-4">“function”</label><br>    </li><br></ul><p>8.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="string">"1"</span>; &#125;, <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;)();</div><div class="line"><span class="keyword">typeof</span> f;</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="question-8" id="answer-8-1"><br>        <label for="answer-8-1">“string”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-8" id="answer-8-2"><br>        <label for="answer-8-2">“number”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-8" id="answer-8-3"><br>        <label for="answer-8-3">“function”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-8" id="answer-8-4"><br>        <label for="answer-8-4">“undefined”</label><br>    </li><br></ul><p>9.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">if</span> (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;) &#123;</div><div class="line">    x += <span class="keyword">typeof</span> f;</div><div class="line">&#125;</div><div class="line">x;</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="question-9" id="answer-9-1"><br>        <label for="answer-9-1">1</label><br>    </li><br>    <li><br>        <input type="radio" name="question-9" id="answer-9-2"><br>        <label for="answer-9-2">“1function”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-9" id="answer-9-3"><br>        <label for="answer-9-3">“1undefined”</label><br>    </li><br>    <li><br>        <input type="radio" name="question-9" id="answer-9-4"><br>        <label for="answer-9-4">NaN</label><br>    </li><br></ul><p>10.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = [<span class="keyword">typeof</span> x, <span class="keyword">typeof</span> y][<span class="number">1</span>];</div><div class="line"><span class="keyword">typeof</span> <span class="keyword">typeof</span> x;</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="quiz-10" id="answer-10-1"><br>        <label for="answer-10-1">“number”</label><br>    </li><br>    <li><br>        <input type="radio" name="quiz-10" id="answer-10-2"><br>        <label for="answer-10-2">“string”</label><br>    </li><br>    <li><br>        <input type="radio" name="quiz-10" id="answer-10-3"><br>        <label for="answer-10-3">“undefined”</label><br>    </li><br>    <li><br>        <input type="radio" name="quiz-10" id="answer-10-4"><br>        <label for="answer-10-4">“object”</label><br>    </li><br></ul><p>11.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">foo</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> foo.bar;</div><div class="line">&#125;)(&#123; <span class="attr">foo</span>: &#123; <span class="attr">bar</span>: <span class="number">1</span> &#125; &#125;);</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="quiz-11" id="answer-11-1"><br>        <label for="answer-11-1">“undefined”</label><br>    </li><br>    <li><br>        <input type="radio" name="quiz-11" id="answer-11-2"><br>        <label for="answer-11-2">“object”</label><br>    </li><br>    <li><br>        <input type="radio" name="quiz-11" id="answer-11-3"><br>        <label for="answer-11-3">“number”</label><br>    </li><br>    <li><br>        <input type="radio" name="quiz-11" id="answer-11-4"><br>        <label for="answer-11-4">Error</label><br>    </li><br></ul><p>12.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</div><div class="line">    <span class="keyword">return</span> f();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="answer-12" id="answer-12-1"><br>        <label for="answer-12-1">1</label><br>    </li><br>    <li><br>        <input type="radio" name="answer-12" id="answer-12-2"><br>        <label for="answer-12-2">2</label><br>    </li><br>    <li><br>        <input type="radio" name="answer-12" id="answer-12-3"><br>        <label for="answer-12-3">Error (e.g. “Too much recursion”)</label><br>    </li><br>    <li><br>        <input type="radio" name="answer-12" id="answer-12-4"><br>        <label for="answer-12-4">undefined</label><br>    </li><br></ul><p>13.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> f; &#125;</div><div class="line"><span class="keyword">new</span> f() <span class="keyword">instanceof</span> f;</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="answer-13" id="answer-13-2"><br>        <label for="answer-13-2">true</label><br>    </li><br>    <li><br>        <input type="radio" name="answer-13" id="answer-13-1"><br>        <label for="answer-13-1">false</label><br>    </li><br></ul><p>14.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> (<span class="function"><span class="keyword">function</span>(<span class="params">x, undefined</span>)</span>&#123;&#125;) </div><div class="line">   length;</div></pre></td></tr></table></figure><ul class="answers"><br>    <li><br>        <input type="radio" name="answer-14" id="answer-14-1"><br>        <label for="answer-14-1">1</label><br>    </li><br>    <li><br>        <input type="radio" name="answer-14" id="answer-14-2"><br>        <label for="answer-14-2">2</label><br>    </li><br>    <li><br>        <input type="radio" name="answer-14" id="answer-14-3"><br>        <label for="answer-14-3">undefined</label><br>    </li><br>    <li><br>        <input type="radio" name="answer-14" id="answer-14-4"><br>        <label for="answer-14-4">Error</label><br>    </li><br></ul><p></p><p class="dot" id="quiz-result">点击下面按钮提交您的答案</p><br><a href="javascript:;" id="submitter" class="btn btn-blue" style="margin-top:15px" target="_blank" rel="external">试试手气</a><script type="text/javascript">    (function () {        function byId(id) {            return document.getElementById(id);        }        byId('submitter').onclick = function () {            var wrongAnswers = [ ];            if (!byId('answer-1-1').checked) {                wrongAnswers.push(1);            }            if (!byId('answer-2-4').checked) {                wrongAnswers.push(2);            }            if (!byId('answer-3-1').checked) {                wrongAnswers.push(3);            }            if (!byId('answer-4-4').checked) {                wrongAnswers.push(4);            }            if (!byId('answer-5-1').checked) {                wrongAnswers.push(5);            }            if (!byId('answer-6-1').checked) {                wrongAnswers.push(6);            }            if (!byId('answer-7-1').checked) {                wrongAnswers.push(7);            }            if (!byId('answer-8-2').checked) {                wrongAnswers.push(8);            }            if (!byId('answer-9-3').checked) {                wrongAnswers.push(9);            }            if (!byId('answer-10-2').checked) {                wrongAnswers.push(10);            }            if (!byId('answer-11-1').checked) {                wrongAnswers.push(11);            }            if (!byId('answer-12-2').checked) {                wrongAnswers.push(12);            }            if (!byId('answer-13-1').checked) {                wrongAnswers.push(13);            }            if (!byId('answer-14-2').checked) {                wrongAnswers.push(14);            }            var message = (wrongAnswers.length === 14) ? '你全部答错了' : '你答错了 <strong>' + wrongAnswers.length + ' </strong>题';            message += (wrongAnswers.length === 14) ? '' : '<br/>答错的题目：' + wrongAnswers.join(' , ');            document.getElementById('quiz-result').innerHTML = message;        };    })();</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在 &lt;a href=&quot;http://perfectionkills.com/javascript-quiz/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;perfectionkills&lt;/a&gt; 上看到几道 JavaScript 题目，这里拿来分享一下，下面列举出来了题目，你可以在这里做题，答案解析可以&lt;a href=&quot;http://www.cnblogs.com/aaronjs/archive/2013/07/05/3172112.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;到这里&lt;/a&gt;找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/some-javascript-quiz-from-perfectionkills.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Quiz" scheme="http://bubkoo.com/tags/quiz/"/>
    
  </entry>
  
  <entry>
    <title>理解正则表达式的全局匹配</title>
    <link href="http://bubkoo.com/2014/03/19/understanding-the-flag-g-of-JavaScript&#39;s-regular-expressions/"/>
    <id>http://bubkoo.com/2014/03/19/understanding-the-flag-g-of-JavaScript&#39;s-regular-expressions/</id>
    <published>2014-03-19T19:22:18.000Z</published>
    <updated>2014-03-19T19:22:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文讨论何时以及如何使用正则表达式全局匹配（/g），以及使用全局匹配可能会遇到的一些坑。</p><p><img src="http://bubkoo.qiniudn.com/regex-with-global-flag-in-javascript.png" alt="你真的懂全局匹配吗？"></p><h2><span id="什么是全局匹配">什么是全局匹配</span></h2><p>有时候你可能期望重复匹配目标字符串多次，那么你就会创建一个全局匹配的正则表达式（通过正则表达式字面量 <code>/.../g</code> 或创建 <code>new RegExp(..., &#39;g&#39;)</code> 对象），这样正则表达式的 <code>global</code> 属性将会是 <code>true</code>，并且会导致一些行为的不同，下面会具体介绍。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/x/g</span>;</div><div class="line">regex.global <span class="comment">// true</span></div></pre></td></tr></table></figure><p>全局的正则表达式的另一个属性 <code>lastIndex</code> 表示上一次匹配文本之后的第一个字符的位置，上次匹配的结果是由方法 <code>RegExp.prototype.exec()</code> 和 <code>RegExp.prototype.test()</code> 找到的，它们都以 <code>lastIndex</code> 属性所指的位置作为下次检索的起始点。这样，就可以通过反复调用这两个方法来遍历一个字符串中的所有匹配文本。<code>lastIndex</code> 属性是可读可写的，只要目标字符串的下一次搜索开始，就可以对它进行设置。当方法 <code>RegExp.prototype.exec()</code> 或 <code>RegExp.prototype.test()</code> 再也找不到可以匹配的文本时，它们会自动把 <code>lastIndex</code> 属性重置为 0。</p><a id="more"></a><h2><span id="regexpprototypetest检测是否存在匹配">RegExp.prototype.test()：检测是否存在匹配</span></h2><p>对于非全局的正则表达式，<code>test()</code>只会检测是否存在某个目标字符串，多次检测的结果都相同，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'_x_x'</span>;</div><div class="line"></div><div class="line">/x/.test(str); <span class="comment">// true</span></div><div class="line">/x/.test(str); <span class="comment">// true</span></div><div class="line">/x/.test(str); <span class="comment">// true</span></div><div class="line">/x/.test(str); <span class="comment">// true</span></div></pre></td></tr></table></figure><p>当设置全局标志 <code>/g</code> 时，一旦字符串中还存在匹配，<code>test()</code> 方法都将返回 <code>true</code>，同时匹配成功后将把 <code>lastIndex</code> 属性的值设置为上次匹配成功之后的第一个字符所在的位置，下次匹配将从 <code>lastIndex</code> 指示的位置开始；匹配不成功时返回 <code>false</code>，同时将 <code>lastIndex</code> 属性的值重置为 0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'_x_x'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/x/g</span>; <span class="comment">// 全局的正则表达式</span></div><div class="line">regex.lastIndex;  <span class="comment">// 初始化时为 0</span></div><div class="line"></div><div class="line">regex.test(str);  <span class="comment">// true , 第一次匹配成功</span></div><div class="line">regex.lastIndex;  <span class="comment">// 2</span></div><div class="line"></div><div class="line">regex.test(str);  <span class="comment">// true , 第二次匹配成功</span></div><div class="line">regex.lastIndex;  <span class="comment">// 4</span></div><div class="line"></div><div class="line">regex.test(str);  <span class="comment">// false , 匹配失败</span></div><div class="line">regex.lastIndex;  <span class="comment">// 0 ， 被重置为 0</span></div></pre></td></tr></table></figure><h2><span id="regexpprototypeexec捕获指定的字符串">RegExp.prototype.exec()：捕获指定的字符串</span></h2><p>如果没有设置全局项 <code>/g</code>，该方法将始终返回第一个匹配项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'_x_x'</span>;</div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/x/</span>;</div><div class="line"></div><div class="line">regex.lastIndex; <span class="comment">// 0</span></div><div class="line"></div><div class="line">regex.exec(str); <span class="comment">// ["x", index: 1, input: "_x_x"] </span></div><div class="line">regex.lastIndex; <span class="comment">// 0</span></div><div class="line"></div><div class="line">regex.exec(str); <span class="comment">// ["x", index: 1, input: "_x_x"] </span></div><div class="line">regex.lastIndex; <span class="comment">// 0</span></div><div class="line"></div><div class="line">regex.exec(str); <span class="comment">// ["x", index: 1, input: "_x_x"] </span></div><div class="line">regex.lastIndex; <span class="comment">// 0</span></div></pre></td></tr></table></figure><p>当全局匹配时，该方法每次返回一个匹配项，直到没有匹配项时返回 <code>null</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'_x_x'</span>;</div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/x/g</span>;</div><div class="line"></div><div class="line">regex.lastIndex; <span class="comment">// 0</span></div><div class="line"></div><div class="line">regex.exec(str); <span class="comment">// ["x", index: 1, input: "_x_x"] </span></div><div class="line">regex.lastIndex; <span class="comment">// 2</span></div><div class="line"></div><div class="line">regex.exec(str); <span class="comment">// ["x", index: 3, input: "_x_x"] </span></div><div class="line">regex.lastIndex; <span class="comment">// 4</span></div><div class="line"></div><div class="line">regex.exec(str); <span class="comment">// null</span></div><div class="line">regex.lastIndex; <span class="comment">// 0</span></div></pre></td></tr></table></figure><h2><span id="stringprototypesearch查找匹配位置">String.prototype.search()：查找匹配位置</span></h2><p>该方法将忽略全局设置项，简单地返回<strong>首次</strong>匹配的位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 非全局</span></div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/x/</span>;</div><div class="line"><span class="keyword">var</span> str = <span class="string">'_x_x'</span>;</div><div class="line">str.search(regex); <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="comment">// 全局</span></div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/x/g</span>;</div><div class="line"><span class="keyword">var</span> str = <span class="string">'_x_x'</span>;</div><div class="line"></div><div class="line">regex.lastIndex;   <span class="comment">// 初始化时为 0</span></div><div class="line"></div><div class="line">str.search(regex); <span class="comment">// 1</span></div><div class="line">regex.lastIndex;   <span class="comment">// 任然是 0，因为该方法忽略了全局设置项</span></div></pre></td></tr></table></figure><h2><span id="stringprototypematch找到一个或多个正则表达式的匹配">String.prototype.match()：找到一个或多个正则表达式的匹配</span></h2><p>非全局匹配时，多次执行结果一样，都返回首次匹配结果，忽略 <code>lastIndex</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/x/</span>;</div><div class="line"><span class="keyword">var</span> str = <span class="string">'_x_x'</span>;</div><div class="line"></div><div class="line">str.match(regex); <span class="comment">// ["x", index: 1, input: "_x_x"] </span></div><div class="line">regex.lastIndex   <span class="comment">// 0</span></div><div class="line"></div><div class="line">str.match(regex); <span class="comment">// ["x", index: 1, input: "_x_x"]</span></div><div class="line">regex.lastIndex   <span class="comment">// 0</span></div><div class="line"></div><div class="line">str.match(regex); <span class="comment">// ["x", index: 1, input: "_x_x"]</span></div><div class="line">regex.lastIndex   <span class="comment">// 0</span></div></pre></td></tr></table></figure><p>全局匹配时，该方法返回所有匹配结果，并忽略 <code>lastIndex</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/x/g</span>;</div><div class="line"><span class="keyword">var</span> str = <span class="string">'_x_x'</span>;</div><div class="line"></div><div class="line">str.match(regex); <span class="comment">// ["x", "x"]</span></div><div class="line">regex.lastIndex   <span class="comment">// 0</span></div><div class="line"></div><div class="line">str.match(regex); <span class="comment">// ["x", "x"]</span></div><div class="line">regex.lastIndex   <span class="comment">// 0</span></div><div class="line"></div><div class="line">str.match(regex); <span class="comment">// ["x", "x"]</span></div><div class="line">regex.lastIndex   <span class="comment">// 0</span></div></pre></td></tr></table></figure><h2><span id="stringprototypereplace替换与正则表达式匹配的子串">String.prototype.replace()：替换与正则表达式匹配的子串</span></h2><p>如果没有设置全局匹配，那么将替换首次匹配的位置；如果设置了全局匹配，那么将替换所有匹配位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 非全局匹配</span></div><div class="line"><span class="string">'_x_x'</span>.replace(<span class="regexp">/x/</span>, <span class="string">'y'</span>);  <span class="comment">// '_y_x'</span></div><div class="line"><span class="comment">// 全局匹配</span></div><div class="line"><span class="string">'_x_x'</span>.replace(<span class="regexp">/x/g</span>, <span class="string">'y'</span>); <span class="comment">// '_y_y'</span></div></pre></td></tr></table></figure><h2><span id="一些坑">一些坑</span></h2><p>使用全局匹配的正则表达式可能会出现一些问题，比如<a href="http://qianduanblog.com/2542.html" target="_blank" rel="external">这篇文章</a>中提到的关于正则全局匹配结果为奇偶真假的小疑问；还有当使用 <code>RegExp.prototype.test()</code> 和 <code>RegExp.prototype.exec()</code> 方法时，必须调用多次才能返回所有结果，这样我们就可能在 JavaScript 循环中滥用正则表达式，这将导致一些问题。</p><p>当使用这些方法时，正则表达式不能用内联的方式，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (<span class="regexp">/a/g</span>.test(<span class="string">'babaa'</span>)) count++;</div></pre></td></tr></table></figure><p>上面代码将导致死循环，因为每次循环都创建了一个新的正则表达式对象，每次匹配就相当于重新开始，所以上面代码应该像这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/a/g</span>;</div><div class="line"><span class="keyword">while</span> (regex.test(<span class="string">'babaa'</span>)) count++;</div></pre></td></tr></table></figure><p><strong>注意</strong>：最佳实践是不论何时都不要用内联的方式。</p><p>还有将正则表达式作为函数的参数，并在函数内部使用 <code>test()</code> 或 <code>exec()</code> 循环执行时，必须要小心。</p><p>下面函数将检测字符串 <code>str</code> 中匹配正则表达式 <code>regex</code> 的次数： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countOccurrences</span>(<span class="params">regex, str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (regex.test(str)) count++;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">countOccurrences(<span class="regexp">/x/g</span>, <span class="string">'_x_x'</span>); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>第一个问题是，如果我们的正则表达式忘记设置为全局的，那么上面方法可能导致死循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">countOccurrences(<span class="regexp">/x/</span>, <span class="string">'_x_x'</span>);</div></pre></td></tr></table></figure><p>第二个问题是，该函数可能不会返回预期的结果，因为参数 <code>regex</code> 的  <code>lastIndex</code> 属性可能并不为 0： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/x/g</span>;</div><div class="line">regex.lastIndex = <span class="number">2</span>; <span class="comment">// 将 lastIndex 设置为 2</span></div><div class="line">countOccurrences(<span class="regexp">/x/g</span>, <span class="string">'_x_x'</span>); <span class="comment">// 返回 1 ，不是预期结果</span></div></pre></td></tr></table></figure><p>按照下面的实现可以解决这两个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countOccurrences</span>(<span class="params">regex, str</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (! regex.global) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Please set flag /g of regex'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> origLastIndex = regex.lastIndex;  <span class="comment">// 保存 lastIndex 的值</span></div><div class="line">    regex.lastIndex = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (regex.test(str)) count++;</div><div class="line"></div><div class="line">    regex.lastIndex = origLastIndex;  <span class="comment">// 恢复 lastIndex 的值</span></div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一个更简单的代替方法是使用 <code>String.prototype.match()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countOccurrences</span>(<span class="params">regex, str</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (! regex.global) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Please set flag /g of regex'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (str.match(regex) || []).length;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>性能比较：<a href="https://twitter.com/juandopazo" target="_blank" rel="external">Juan Ignacio Dopazo</a> 对这两种实现做了<a href="http://jsperf.com/regex-counting" target="_blank" rel="external">性能比较</a>，结果是使用 <code>test()</code> 的性能更好，因为它不需要将匹配结果放到数组中。</p><h2><span id="参考资料">参考资料</span></h2><ul><li><a href="http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp" target="_blank" rel="external">http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp</a></li><li><a href="http://stackoverflow.com/questions/1520800/why-regexp-with-global-flag-in-javascript-give-wrong-results" target="_blank" rel="external">http://stackoverflow.com/questions/1520800/why-regexp-with-global-flag-in-javascript-give-wrong-results</a></li><li><a href="http://www.2ality.com/2013/08/regexp-g.html" target="_blank" rel="external">http://www.2ality.com/2013/08/regexp-g.html</a></li><li><a href="http://qianduanblog.com/2542.html" target="_blank" rel="external">http://qianduanblog.com/2542.html</a></li><li><a href="http://www.oschina.net/question/141557_46091" target="_blank" rel="external">http://www.oschina.net/question/141557_46091</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讨论何时以及如何使用正则表达式全局匹配（/g），以及使用全局匹配可能会遇到的一些坑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/regex-with-global-flag-in-javascript.png&quot; alt=&quot;你真的懂全局匹配吗？&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是全局匹配&quot;&gt;&lt;a href=&quot;#什么是全局匹配&quot; class=&quot;headerlink&quot; title=&quot;什么是全局匹配&quot;&gt;&lt;/a&gt;什么是全局匹配&lt;/h2&gt;&lt;p&gt;有时候你可能期望重复匹配目标字符串多次，那么你就会创建一个全局匹配的正则表达式（通过正则表达式字面量 &lt;code&gt;/.../g&lt;/code&gt; 或创建 &lt;code&gt;new RegExp(..., &amp;#39;g&amp;#39;)&lt;/code&gt; 对象），这样正则表达式的 &lt;code&gt;global&lt;/code&gt; 属性将会是 &lt;code&gt;true&lt;/code&gt;，并且会导致一些行为的不同，下面会具体介绍。 &lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; regex = &lt;span class=&quot;regexp&quot;&gt;/x/g&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;regex.global &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;全局的正则表达式的另一个属性 &lt;code&gt;lastIndex&lt;/code&gt; 表示上一次匹配文本之后的第一个字符的位置，上次匹配的结果是由方法 &lt;code&gt;RegExp.prototype.exec()&lt;/code&gt; 和 &lt;code&gt;RegExp.prototype.test()&lt;/code&gt; 找到的，它们都以 &lt;code&gt;lastIndex&lt;/code&gt; 属性所指的位置作为下次检索的起始点。这样，就可以通过反复调用这两个方法来遍历一个字符串中的所有匹配文本。&lt;code&gt;lastIndex&lt;/code&gt; 属性是可读可写的，只要目标字符串的下一次搜索开始，就可以对它进行设置。当方法 &lt;code&gt;RegExp.prototype.exec()&lt;/code&gt; 或 &lt;code&gt;RegExp.prototype.test()&lt;/code&gt; 再也找不到可以匹配的文本时，它们会自动把 &lt;code&gt;lastIndex&lt;/code&gt; 属性重置为 0。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Regex" scheme="http://bubkoo.com/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>理解 JavaScript 中的原型</title>
    <link href="http://bubkoo.com/2014/03/12/prototypes-in-javascript/"/>
    <id>http://bubkoo.com/2014/03/12/prototypes-in-javascript/</id>
    <published>2014-03-12T10:26:25.000Z</published>
    <updated>2014-03-12T10:26:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你在JavaScript中定义一个函数，它有一些预定义的属性，其中之一就是令人迷惑的原型。本文将详细解释什么是原型，以及为什么要在项目中使用它。</p><p><img src="http://bubkoo.qiniudn.com/prototypes-in-javascript.jpg" alt=""></p><h2><span id="什么是原型">什么是原型</span></h2><p>对象初始化时原型是一个空对象，你可以将任何其他对象添加到原型上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myObject.prototype); <span class="comment">// object</span></div><div class="line"><span class="built_in">console</span>.log(myObject.prototype); <span class="comment">// Object &#123;&#125;</span></div><div class="line"> </div><div class="line">myObject.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(myObject.prototype); <span class="comment">// Object &#123;getName: function...&#125;</span></div></pre></td></tr></table></figure><p>上面的代码中，我们创建了一个函数，如果我们调用 <code>myObject()</code>，它将简单的返回一个 <code>window</code> 对象，因为它还没有被实例化，而这个函数是在全局作用域中定义的，<code>this</code> 理所当然地指向了全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(myObject() === <span class="built_in">window</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure><a id="more"></a><h2><span id="一个隐秘属性">一个“隐秘”属性</span></h2><p>继续之前，我想讨论一下关于原型的一个的“隐秘”属性。</p><p>JavaScript 中的每一个对象在被定义或实例化之后，都有一个叫做 <code>__proto__</code> 的隐秘属性，这是原型链的核心。但是，我并不建议在代码中直接访问 <code>__proto__</code>，因为并不是所有的浏览器都支持它。</p><p>不能将 <code>__proto__</code> 和对象的原型混为一谈，它们是两个不同的属性，但又紧密相关，可能初学者会感到非常困惑，很难将他们区分开来，下面我将详细道来。当我们创建 <code>myObject</code> 这个函数时，实际上是定义了一个 <code>Function</code> 类型的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'function'</span> === <span class="keyword">typeof</span> myObject); <span class="comment">// true</span></div></pre></td></tr></table></figure><p><code>Function</code> 是 JavaScript 中的一个预定义对象，它有自己的一些属性（比如 <code>length</code> 和 <code>arugments</code>） 和方法（比如 <code>call</code> 和 <code>apply</code>），还有自己的原型对象，以及“隐秘”的 <code>__proto__</code> 属性。这意味着，在 JavaScript 引擎内的某个位置，可能有一些类似于下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype = &#123;</div><div class="line">    <span class="built_in">arguments</span>: <span class="literal">null</span>,</div><div class="line">    length: <span class="number">0</span>,</div><div class="line">    call: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">// secret code</span></div><div class="line">    &#125;,</div><div class="line">    apply: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">// secret code</span></div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>事实上，<code>Function</code> 的定义并不是如此简单，这里只是为了说明原型链的原理。</p><p>目前为止，我们定义了 <code>myObject</code> 这个函数，并为其指定了名为 <code>name</code> 的形参，但我们并没有为其设定任何属性（如 <code>length</code>）和方法（如 <code>call</code>），那么下面的代码是怎么回事呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(myObject.length); <span class="comment">// 1 (形参的数量)</span></div></pre></td></tr></table></figure><p>这是因为在定义 <code>myObject</code> 这个对象时，它内置了 <code>__proto__</code> 这个属性，并且其值是 <code>Function.prototype</code>。所以，当我们使用 <code>myObject.length</code> 时，首先将在 <code>myObject</code> 对象中查找名为 <code>length</code> 的属性， 没有找到，然后将通过 <code>__proto__</code> 这个“隐秘”的属性查找其原型链，最后找到 <code>length</code> 这个属性并返回。</p><p>您可能想知道为什么 <code>length</code> 的值为什么是 1，而不是 0，或任何其他数字。这是因为 <code>myObject</code> 实际上是 <code>Function</code> 的一个实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(myObject <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(myObject === <span class="built_in">Function</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure><p>当一个对象的实例被创建时，<code>__proto__</code> 将指向构造函数的原型，在我们的例子中就是 <code>Function</code> 的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(myObject.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">// true</span></div></pre></td></tr></table></figure><p>当创建一个新的 <code>Function</code> 对象时，在 <code>Function</code> 的构造函数内将获取形参的数量，并更新 <code>this.length</code> 的值，在这里是 1。</p><p>如果我们使用 <code>new</code> 操作符创建一个 <code>myObject</code> 的实例，该实例的 <code>__proto__</code> 将指向 <code>myObject.prototype</code>，因为 <code>myObject</code> 是该实例的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myInstance = <span class="keyword">new</span> myObject(“foo”);</div><div class="line"><span class="built_in">console</span>.log(myInstance.__proto__ === myObject.prototype); <span class="comment">// true</span></div></pre></td></tr></table></figure><p>现在 <code>myInstance</code> 除了可以访问 <code>Function.prototype</code> 中的原生方法（比如 <code>call</code> 和 <code>apply</code>）之外，还可以访问到 <code>myObject.prototype</code> 中的方法： <code>getName</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(myInstance.getName()); <span class="comment">// foo</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> mySecondInstance = <span class="keyword">new</span> myObject(“bar”);</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(mySecondInstance.getName()); <span class="comment">// bar</span></div><div class="line"><span class="built_in">console</span>.log(myInstance.getName()); <span class="comment">// foo</span></div></pre></td></tr></table></figure><p>译者注：一个对象实际上包含 <code>__proto__</code> 和 <code>prototype</code> 两个属性，这两个属性代表着不一样的东西，<code>__proto__</code> 指向创建该对象的构造函数的原型，原型链查找就是借助于 <code>__proto__</code> 来实现；而 <code>prototype</code> 指向该对象自身的原型。</p><p>可以想象，这是非常方便的，我们可以用它来获取一个对象的结构，并根据需要创建实例，让我们开始讨论下一个话题。</p><h2><span id="为什么要使用原型">为什么要使用原型</span></h2><p>我们先来看一个实例，现在我们需要开发一个 canvas 上的游戏，需要在 canvas 一次性绘制一些（可能是数百个）对象，每个对象都包含一些自己的属性，比如 <code>x</code> 和 <code>y</code> 坐标、<code>width</code>、<code>height</code>等等。</p><p>我们可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> GameObject1 = &#123;</div><div class="line">    x: <span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random() * myCanvasWidth) + <span class="number">1</span>),</div><div class="line">    y: <span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random() * myCanvasHeight) + <span class="number">1</span>),</div><div class="line">    width: <span class="number">10</span>,</div><div class="line">    height: <span class="number">10</span>,</div><div class="line">    draw: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        myCanvasContext.fillRect(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</div><div class="line">    &#125;</div><div class="line">   ...</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> GameObject2 = &#123;</div><div class="line">    x: <span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random() * myCanvasWidth) + <span class="number">1</span>),</div><div class="line">    y: <span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random() * myCanvasHeight) + <span class="number">1</span>),</div><div class="line">    width: <span class="number">10</span>,</div><div class="line">    height: <span class="number">10</span>,</div><div class="line">    draw: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        myCanvasContext.fillRect(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>… 重复做 98 次 …</p><p>这将在内存中创建所有这些对象，这些对象都有单独的方法，比如 <code>draw</code> 和其他一些所需要的方法。这当然会很糟糕，因为这个游戏很可能将占光浏览器内存，并运行的非常缓慢，甚至停止响应。</p><p>虽然只有 100 个对象的时候这还不可能发生，但会对性能造成很大的影响，因为它需要查找一百个不同的对象，而不是一个相同的原型对象。</p><h2><span id="如何使用原型">如何使用原型</span></h2><p>为了使我们的应用运行的更快，遵循最佳实践，我们来重新定义 <code>GameObject</code> 的原型，<code>GameObject</code> 对象的每一个实例将使用 <code>GameObject.prototype</code> 中的方法，就像它们自身的方法一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义 GameObject 的构造函数</span></div><div class="line"><span class="keyword">var</span> GameObject = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random() * myCanvasWidth) + <span class="number">1</span>);</div><div class="line">    <span class="keyword">this</span>.y = <span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random() * myCanvasHeight) + <span class="number">1</span>);</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// 定义 GameObject 的原型</span></div><div class="line">GameObject.prototype = &#123;</div><div class="line">    x: <span class="number">0</span>,</div><div class="line">    y: <span class="number">0</span>,</div><div class="line">    width: <span class="number">5</span>,</div><div class="line">    width: <span class="number">5</span>,</div><div class="line">    draw: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        myCanvasContext.fillRect(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>然后，我们来实例化 100 个 GameObject 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">100</span>,</div><div class="line">arrayOfGameObjects = [];</div><div class="line"> </div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    arrayOfGameObjects.push(<span class="keyword">new</span> GameObject(<span class="number">10</span>, <span class="number">10</span>));</div><div class="line">&#125; <span class="keyword">while</span>(x--);</div></pre></td></tr></table></figure><p>现在，我们有了一个有 100 个 GameObjects 实例的数组，这些实例对象共享相同的原型，这大大节省了应用所占用的内存。</p><p>当我们调用 <code>draw</code> 方法时，实际上调用的都是原型上相同的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> GameLoop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(gameObject <span class="keyword">in</span> arrayOfGameObjects) &#123;</div><div class="line">        gameObject.draw();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2><span id="原型是活动对象live-object">原型是活动对象（Live Object）</span></h2><p>对象的原型是一个活动对象，什么意思呢？根据上面示例来说就是，当我创建 <code>GameObject</code> 对象的实例之后，我们可以修改 <code>GameObject.prototype.draw</code> 方法，来画一个圆，而不是画一个矩形，这样调用所有已经实例化的对象或后面再实例化的对象中的 <code>draw</code> 方法就会画一个圆。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GameObject.prototype.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    myCanvasContext.arc(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.width, <span class="number">0</span>, <span class="built_in">Math</span>.PI*<span class="number">2</span>, <span class="literal">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="修改内置对象的原型">修改内置对象的原型</span></h2><p>你可能熟悉一些 JavaScript 库，比如 <a href="http://www.prototypejs.org/" target="_blank" rel="external">Prototype</a>，他们都充分利用了这种方法。</p><p>来看一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, ‘’);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>现在我们可以在任何字符串上使用该方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"foo bar"</span>.trim(); <span class="comment">// "foo bar"</span></div></pre></td></tr></table></figure><p>不过这样做也有一定的缺点。比如，你将这个方法应用到你的代码中，也许一两年之后，JavaScript 可能会在 <code>String</code> 的原型中实现了该方法，这意味着你的方法将覆盖 JavaScript 的原生方法。为了避免这种情况，我们需要在定义自身的方法前，做一个简单的判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="built_in">String</span>.prototype.trim) &#123;</div><div class="line">    <span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, ‘’);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果存在原生的 <code>trim</code> 方法，我们就会使用原生的 <code>trim</code> 方法。</p><blockquote><p>根据经验法则，通常也被认为是最佳实践，最好避免扩展内置对象的原型。但是，如果有必要，也可以不遵循这个规则。</p></blockquote><h2><span id="总结">总结</span></h2><p>希望本文已经阐释清楚了 JavaScript 中的原型，现在你应该能够编写更加高效的代码了。</p><p>如果你有关于原型的任何问题，你可以写在评论中，我会尽力解答。</p><p>英文原文：<a href="http://hub.tutsplus.com/authors/leigh-kaszick" target="_blank" rel="external">Leigh Kaszick</a>，翻译：<a href="http://bubkoo.com/">布谷 bubkoo</a></p><p>原文链接：<a href="http://code.tutsplus.com/tutorials/prototypes-in-javascript--net-24949" target="_blank" rel="external">Prototypes in JavaScript</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你在JavaScript中定义一个函数，它有一些预定义的属性，其中之一就是令人迷惑的原型。本文将详细解释什么是原型，以及为什么要在项目中使用它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/prototypes-in-javascript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是原型&quot;&gt;&lt;a href=&quot;#什么是原型&quot; class=&quot;headerlink&quot; title=&quot;什么是原型&quot;&gt;&lt;/a&gt;什么是原型&lt;/h2&gt;&lt;p&gt;对象初始化时原型是一个空对象，你可以将任何其他对象添加到原型上。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myObject = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; myObject.prototype); &lt;span class=&quot;comment&quot;&gt;// object&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(myObject.prototype); &lt;span class=&quot;comment&quot;&gt;// Object &amp;#123;&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;myObject.prototype.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(myObject.prototype); &lt;span class=&quot;comment&quot;&gt;// Object &amp;#123;getName: function...&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码中，我们创建了一个函数，如果我们调用 &lt;code&gt;myObject()&lt;/code&gt;，它将简单的返回一个 &lt;code&gt;window&lt;/code&gt; 对象，因为它还没有被实例化，而这个函数是在全局作用域中定义的，&lt;code&gt;this&lt;/code&gt; 理所当然地指向了全局对象。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(myObject() === &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Prototype" scheme="http://bubkoo.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>解释 JavaScript 的作用域和闭包</title>
    <link href="http://bubkoo.com/2014/03/10/explaining-javascript-scope-and-closures/"/>
    <id>http://bubkoo.com/2014/03/10/explaining-javascript-scope-and-closures/</id>
    <published>2014-03-10T20:39:23.000Z</published>
    <updated>2014-03-10T20:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试或被面试时基本都会涉及到这个最原始的 JavaScript 基础问题，试想一下您有没有在某些时候向别人解释这些概念时，把自己给绕进去了；网络上偶遇一篇英文文章，细读之后觉得有参考价值，文章不长，就顺手翻译了一下，希望某些同学可以用的上。</p><p>原文文中的 Scope 翻译成中文是“<strong>变量作用域</strong>”，译文某些地方直接简称为“<strong>作用域</strong>” ，Closure 翻译后是“闭包”。<a href="http://robertnyman.com/" target="_blank" rel="external">Rebort Nyman</a> 的原文是 <a href="http://robertnyman.com/2008/10/09/explaining-javascript-scope-and-closures/" target="_blank" rel="external">Explaining JavaScript Scope And Closures</a>，某些不清楚的地方可以直接参考原文。</p><p>以下是译文</p><h2><span id="背景">背景</span></h2><p>很多文章或博客都在试着解释作用域和闭包，但大多数都没有解释的很清楚（crystal-clear）。此外，很多人想当然地认为每个人都有大约 15 种其他语言的开发经验，但依我的经验，大多数 JavaScript 开发人员是来自 HTML 和 CSS 的背景，而不是 C 或者 Java。（译者注：在 Node 盛行的今天，情况或许有些不一样。）</p><p>因此，文本谦虚的目标是想让大家都能理解作用域和闭包，他们的原理是什么，尤其重要的是如果更好地使用他们。在阅读本文之前，需要您有一些 JavaScript 中变量和函数的基础知识。<br><a id="more"></a></p><h2><span id="作用域scope">作用域（Scope）</span></h2><p>作用域表示变量或函数能够被访问的范围，以及它们在什么样的上下文中被执行。一般来说，变量和函数可以被定义在全局和局部作用域范围中，变量有所谓的“<strong>函数作用域</strong>”，函数也有和变量一样的作用域。</p><h3><span id="全局作用域global-scope">全局作用域（Global Scope）</span></h3><p>当某个东西是全局的，就意味着它可以在你代码中的任何地方被访问到，看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局变量</span></div><div class="line"><span class="keyword">var</span> monkey = <span class="string">"Gorilla"</span>;</div><div class="line"> </div><div class="line"><span class="comment">// 全局函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greetVisitor</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> alert(<span class="string">"Hello dear blog reader!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果上面的代码运行在浏览器环境中，<code>monkey</code> 和 <code>greetVisitor</code> 的作用域将是 <code>window</code> 对象，因此跑在同一页面下的代码都能存取这两个变量。</p><h3><span id="局部作用域local-scope">局部作用域（Local Scope ）</span></h3><p>与全局作用域相反，局部作用域表示变量和函数定义在代码的某些区域中，也只能在这些区域中被访问到，例如在函数内部定义的变量或函数，举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">talkDirty</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> saying = <span class="string">"Oh, you little VB lover, you"</span>;</div><div class="line">    <span class="keyword">return</span> alert(saying);</div><div class="line">&#125;</div><div class="line">alert(saying); <span class="comment">// 将抛出异常</span></div></pre></td></tr></table></figure><p>上面代码中，<code>saying</code> 这个变量只能在 <code>talkDirty</code> 函数内部被访问到。在函数外部，它根本就没有被定义。特别要注意的是，如果你在第二行没有用关键字 <code>var</code> 来定义 <code>saying</code>，那它会自动变成全域变量。</p><p>这也意味着，在嵌套的函数中，内层函数可以访问到外层函数中定义的变量或函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveName</span> (<span class="params">firstName</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">capitalizeName</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> firstName.toUpperCase();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> capitalized = capitalizeName();</div><div class="line">    <span class="keyword">return</span> capitalized; </div><div class="line">&#125;</div><div class="line">alert(saveName(<span class="string">"Robert"</span>)); <span class="comment">// Returns "ROBERT"</span></div></pre></td></tr></table></figure><p>像你看到的那样，内层函数 <code>capitalizeName</code> 不需要参数任何参数，但是它能访问到外层函数 <code>saveName</code> 中的 <code>firstName</code> 这个变量。为了更加清晰地解释，我们再来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">siblings</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> siblings = [<span class="string">"John"</span>, <span class="string">"Liza"</span>, <span class="string">"Peter"</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">siblingCount</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> siblingsLength = siblings.length;</div><div class="line">        <span class="keyword">return</span> siblingsLength;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">joinSiblingNames</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"I have "</span> + siblingCount() + <span class="string">" siblings:\n\n"</span> + siblings.join(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> joinSiblingNames(); </div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(siblings()); <span class="comment">// Outputs "I have 3 siblings: John Liza Peter"</span></div></pre></td></tr></table></figure><p>两个内层的函数都可以访问到外层函数中的 <code>siblings</code> 数组，同时两个同级别的函数也能彼此访问（在本例中，<code>joinSiblingNames</code> 调用了 <code>siblingCount</code> 函数）。然而，定义在 <code>siblingCount</code> 函数内部的变量 <code>siblingsLength</code>，只能在这个函数内部被访问到，这个函数就是它的作用域。</p><h2><span id="闭包closures">闭包（Closures）</span></h2><p>现在你应该对作用域有了比较清晰的认识，下面我们来看看闭包。闭包是一些表达式，通常是函数，它可以使用特定作用域中的变量。说简单一点就是，当内层函数引用了外层函数中的变量就形成了闭包。看例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> x + y;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> add5 = add(<span class="number">5</span>);</div><div class="line"><span class="keyword">var</span> no8 = add5(<span class="number">3</span>);</div><div class="line">alert(no8); <span class="comment">// Returns 8</span></div></pre></td></tr></table></figure><p>哇，哇 !刚刚发生什么事了？我们一步步分解来看：</p><ol><li>当调用 add 函数时，它返回了一个函数</li><li>这个返回的函数封闭了它的作用域，并记住了封闭时参数 <code>x</code> 的值（也就是上面代码中的 5）</li><li>用变量 <code>add5</code> 保存返回的函数，它将一直记得初始化时 <code>x</code> 的值</li><li><code>add5</code> 这个变量就引用到一个永远会把传入的变量加上 5 的函数</li><li>当调用 <code>add5</code> 时，传入参数 3，它就会把 3 跟 5 相加，然后返回 8</li></ol><p>因此，在 JavaScript 的世界中，<code>add5</code> 引用的函数实际上看起来像这样： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add5</span> (<span class="params">y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">5</span> + y;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="臭名昭著的循环问题">臭名昭著的循环问题</span></h3><p>你曾经有多少次遇到过这样的情况，在一个循环中，你想将变量 i 的值赋给其他地方（比如，赋给一个元素），但是却发现传回的是 i 的最后一个值。</p><h4><span id="错误的引用">错误的引用</span></h4><p>我们来看看这个错误的示例，代码中循环创建了 5 个 <code>a</code> 元素，并把 <code>i</code> 的值作为其显示的文字的一部分，然后再为每个元素绑定了 click 事件，当点击 <code>a</code> 元素时 <code>alert</code> 出对应的 <code>i</code> 的值，最后将元素 <code>append</code> 到 <code>body</code> 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addLinks</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, link; i&lt;<span class="number">5</span>; i++) &#123;</div><div class="line">        link = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</div><div class="line">        link.innerHTML = <span class="string">"Link "</span> + i;</div><div class="line">        link.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            alert(i);</div><div class="line">        &#125;;</div><div class="line">        <span class="built_in">document</span>.body.appendChild(link);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.onload = addLinks;</div></pre></td></tr></table></figure><p>运行代码后，你将发现，每个元素都显示了预期的文字，也就是”Link 0”，”Link 1”等等。但是，不管我们点击哪一个元素，<code>alert</code> 出来的都是 5。怎么会这样呢？原因是 <code>i</code> 的值在每次循环后都会加 1，而绑定的 <code>click</code> 事件还没有被触发，只是绑定到了元素的事件上，<code>i</code> 的值也会累加上去。</p><p>因此，循环结束后 <code>i</code> 的值是 5，也就是在函数 <code>addLinks</code> 退出时，<code>i</code> 的值成为了其最终值。然后，不管你点击哪一个元素，它都会拿到 <code>i</code> 的最终值。</p><h4><span id="正确的引用">正确的引用</span></h4><p>你需要做的是，建立一个闭包，这样当你把 <code>i</code> 的值绑定到事件上时，它就会获取到 <code>i</code> 当下的那个值。像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addLinks</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, link; i&lt;<span class="number">5</span>; i++) &#123;</div><div class="line">        link = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</div><div class="line">        link.innerHTML = <span class="string">"Link "</span> + i;</div><div class="line">        link.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                alert(num);</div><div class="line">            &#125;;</div><div class="line">        &#125;(i);</div><div class="line">        <span class="built_in">document</span>.body.appendChild(link);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.onload = addLinks;</div></pre></td></tr></table></figure><p>运行这段代码时，如果你点击第一个元素，它会 <code>alert</code> 出 0，点击第二个 <code>alert</code> 出 1，依次类推，这正是你期望的那样。解决方案是，在绑定事件时创建了一个闭包，将 <code>i</code> 的值通过参数 <code>num</code> 传递给了事件的回调函数，这样就能获取到 <code>i</code> 的当前值。</p><h3><span id="立即执行的函数self-invoking-functions">立即执行的函数（Self-Invoking Functions）</span></h3><p>立即执行的函数是一个立即中，并构建自己的闭包的一种函数。看下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dog = <span class="string">"German Shepherd"</span>;</div><div class="line">    alert(dog);</div><div class="line">&#125;)();</div><div class="line">alert(dog); <span class="comment">// Returns undefined</span></div></pre></td></tr></table></figure><p><code>dog</code> 这个变量只能在它所在的作用域中被访问到。有什么了不起的嘛，不就是一只被隐藏起来的狗吗！但是，朋友们，这正是它有趣的地方。这解决了上面的循环问题，并且这也是 <a href="http://yuiblog.com/blog/2007/06/12/module-pattern/" target="_blank" rel="external">Yahoo 模块模式</a>的基础。</p><h4><span id="yahoo-模块模式">Yahoo 模块模式</span></h4><p>这种模式的核心是通过立即执行的函数建立起一个闭包，因此可以定义出私有和共有的变量或方法。下面是一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 私有变量</span></div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Robert"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        getName : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        setName : <span class="function"><span class="keyword">function</span> (<span class="params">newName</span>) </span>&#123;</div><div class="line">            name = newName;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;();</div><div class="line"></div><div class="line">alert(person.name); <span class="comment">// Undefined</span></div><div class="line"></div><div class="line">alert(person.getName()); <span class="comment">// "Robert"</span></div><div class="line"></div><div class="line">person.setName(<span class="string">"Robert Nyman"</span>);</div><div class="line"></div><div class="line">alert(person.getName()); <span class="comment">// "Robert Nyman"</span></div></pre></td></tr></table></figure><p>这样做的美好之处在于，从此你可以决定哪些东西需要公开，哪些东西是私有的。上面的 <code>name</code> 这个变量，在函数外部不能被访问，但是能通过 <code>getName</code> 方法来取值，以及通过 <code>setName</code> 方法来设置其值。因为这两个函数形成了闭包，他们保存了对变量 <code>name</code> 的引用。</p><h2><span id="结论">结论</span></h2><p>无论是新手还是有经验的程序猿，我真诚地希望你在看完这篇文章之后，都能够清楚的领会到作用域和闭包在 JavaScript 中的机制。欢迎各位提出问题，如果你的建议够重要，我会把它加到我的文章里面。</p><p>Happy coding!</p><p>（原文完）</p><p>英文原文：<a href="http://robertnyman.com/" target="_blank" rel="external">Robert Nyman</a>，翻译：<a href="http://bubkoo.com/">布谷 bubkoo</a></p><p>原文链接：<a href="http://robertnyman.com/2008/10/09/explaining-javascript-scope-and-closures/" target="_blank" rel="external">Explaining JavaScript Scope And Closures</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试或被面试时基本都会涉及到这个最原始的 JavaScript 基础问题，试想一下您有没有在某些时候向别人解释这些概念时，把自己给绕进去了；网络上偶遇一篇英文文章，细读之后觉得有参考价值，文章不长，就顺手翻译了一下，希望某些同学可以用的上。&lt;/p&gt;
&lt;p&gt;原文文中的 Scope 翻译成中文是“&lt;strong&gt;变量作用域&lt;/strong&gt;”，译文某些地方直接简称为“&lt;strong&gt;作用域&lt;/strong&gt;” ，Closure 翻译后是“闭包”。&lt;a href=&quot;http://robertnyman.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Rebort Nyman&lt;/a&gt; 的原文是 &lt;a href=&quot;http://robertnyman.com/2008/10/09/explaining-javascript-scope-and-closures/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Explaining JavaScript Scope And Closures&lt;/a&gt;，某些不清楚的地方可以直接参考原文。&lt;/p&gt;
&lt;p&gt;以下是译文&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;很多文章或博客都在试着解释作用域和闭包，但大多数都没有解释的很清楚（crystal-clear）。此外，很多人想当然地认为每个人都有大约 15 种其他语言的开发经验，但依我的经验，大多数 JavaScript 开发人员是来自 HTML 和 CSS 的背景，而不是 C 或者 Java。（译者注：在 Node 盛行的今天，情况或许有些不一样。）&lt;/p&gt;
&lt;p&gt;因此，文本谦虚的目标是想让大家都能理解作用域和闭包，他们的原理是什么，尤其重要的是如果更好地使用他们。在阅读本文之前，需要您有一些 JavaScript 中变量和函数的基础知识。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Scope" scheme="http://bubkoo.com/tags/scope/"/>
    
      <category term="Closure" scheme="http://bubkoo.com/tags/closure/"/>
    
  </entry>
  
  <entry>
    <title>学习使用 Timing API</title>
    <link href="http://bubkoo.com/2014/03/01/learning-and-using-the-user-timing-api/"/>
    <id>http://bubkoo.com/2014/03/01/learning-and-using-the-user-timing-api/</id>
    <published>2014-03-01T23:53:16.000Z</published>
    <updated>2014-03-01T23:53:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>高性能的 Web 应用是获得伟大用户体验的关键。随着 Web 应用越来越复杂，要想建立吸引人的用户体验，了解性能的影响是至关重要的。在过去的几年中，浏览器中也新增了许多 API 来帮助我们分析网络性能、页面加载时间等。但这些并没有给出详尽的足够灵活的方式，来帮助我们分析具体是什么降低了我们网站的性能。<a href="http://www.w3.org/TR/user-timing/" target="_blank" rel="external">User Timing API</a> 提供了一套机制来帮助我们测量我们的应用，从而找到应用中耗时的部分。在本文中，我将介绍这个 API 并提供一些如何使用它的例子。</p><h2><span id="你不能优化那些不能被测量的东西">你不能优化那些不能被测量的东西</span></h2><p>给运行缓慢的应用提速的第一步是，找到应用中耗时的部位。要想找到这些烫手山药，最理想的方式就是对 JavaScript 代码进行区域性的运行时间测量，这是寻找如何提高网站性能的第一步。幸运的是，可以在代码的不同部位去调用 <a href="http://www.w3.org/TR/user-timing/" target="_blank" rel="external">User Timing API</a>，提取到时间的详细数据，来帮助你进行性能优化。</p><h2><span id="高精度时间和now">高精度时间和<code>now()</code></span></h2><p>准确测量时间的一个基础是精确度，之前我们是基于毫秒的时间测量，这种方式工作良好，但是对于一个每帧需要在 16ms 内绘制完成的 60FPS 的网站，如果只有毫秒精度的测量，对于网站的分析就缺乏所需要的精度。<a href="http://www.w3.org/TR/hr-time/" target="_blank" rel="external">High Resolution Time</a> 是现代浏览器内置的一种新的测量时间的方式，它给我们提供了一个精确到微秒的浮点类型的时间戳，是之前精度的 1000 倍。</p><p>可以通过调用 <a href="http://www.w3.org/TR/navigation-timing/#performance" target="_blank" rel="external">Performance</a> 对象中的<a href="http://www.w3.org/TR/hr-time/#sec-extenstions-performance-interface" target="_blank" rel="external">扩展方法</a> <code>now()</code> 来获取当前的时间，就像下面代码这样：<br><a id="more"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myTime = <span class="built_in">window</span>.performance.now();</div></pre></td></tr></table></figure><p>另一个接口 <a href="http://www.w3.org/TR/navigation-timing/#sec-navigation-timing-interface" target="_blank" rel="external">PerformanceTiming</a> 提供了一系列关于页面加载情况的时间。调用 <code>now()</code> 返回的时间是当前时间与 <a href="http://www.w3.org/TR/navigation-timing/#dom-performancetiming-navigationstart" target="_blank" rel="external">navigationStart</a> 对应时间的差值。</p><h3><span id="domhighrestimestamp-类型">DOMHighResTimeStamp 类型</span></h3><p>在过去我们通过 <code>Date.now()</code> 在网页中测量时间，它的返回是 <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Core-DOMTimeStamp" target="_blank" rel="external">DOMTimeStamp</a> 类型，它返回一个整数的毫秒值。为了提高精度，我们需要高分辨率的时间，所以有了 <a href="http://www.w3.org/TR/hr-time/#sec-DOMHighResTimeStamp" target="_blank" rel="external">DOMHighResTimeStamp</a> 这个类型，它返回的一个浮点数的毫秒值，由于是浮点数，所以小数部分就能得到千分之一毫秒的精度。</p><h2><span id="user-timing-接口">User Timing 接口</span></h2><p>现在我们有了高分辨率的时间戳，我们可以使用 <a href="http://www.w3.org/TR/user-timing/" target="_blank" rel="external">User Timing 接口</a>来获取时间信息。</p><p>User Timing 接口提供了很多方法，让我们可以在应用中的不同位置去调用这些方法，像《奇幻森林历险记》中的面包屑那样，我们可以跟踪到时间花费在了应用中的哪些位置。</p><h3><span id="使用mark方法">使用<code>mark()</code>方法</span></h3><p><code>mark()</code> 方法是时间分析工具中的主要方法，它的功能就是为我们记录时间，其超级有用之处在于我们可以为我们记录的时间命名，它会将这个名字和时间作为一个独立的单元来记住。</p><p>在应用中不同位置调用 <code>mark()</code> 方法可以让你知道应用中被标记的位置所花费的时间。</p><p>接口调用规范中建议使用一些有意义的或能自我解释的命名方式，例如：“mark_fully_loaded”、“mark_fully_visible”、“mark_above_the_fold”等等。</p><p>例如，我们想在页面加载完成之后设置一个标志，可以使用下面这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.performance.mark(<span class="string">'mark_fully_loaded'</span>);</div></pre></td></tr></table></figure><p>通过在页面中设置一些命名的时间标志，我们可以收集到一大堆时间数据，进而可以分析出来我们的应用在什么时候做了什么。</p><h3><span id="通过measure来计算测量结果">通过<code>measure()</code>来计算测量结果</span></h3><p>一旦你设置了一系列的时间标志，你就想得到他们之间的运行时间。这可以通过调用 <code>measure()</code> 方法来实现。</p><p><code>measure()</code> 方法不仅可以计算标志之间的时间，而且也能计算标志和 <a href="http://www.w3.org/TR/navigation-timing/#sec-navigation-timing-interface" target="_blank" rel="external">PerformanceTiming</a> 接口中那些已知的事件名之间的时间。</p><p>例如，你可以通过下面的代码来获取到 DOM 加载完成到页面 loaded 之间的时间：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.performance.measure(<span class="string">'measure_load_from_dom'</span>, <span class="string">'domComplete'</span>, <span class="string">'mark_fully_loaded'</span>);</div></pre></td></tr></table></figure><p>注意：在上面例子中，我们使用了 PerformanceTiming 接口中的事件名：domComplete。</p><p>当调用 <code>measure()</code> 方法时，它会根据你设置的标志来独立储存计算结果。在应用运行时将时间记录下来，同时保持了应用的可交互性，在应用执行完某些工作之后，再将这些数据转存起来，稍候你就可以对这些数据进行分析。</p><h3><span id="通过clearmarks来清除标记">通过<code>clearMarks()</code>来清除标记</span></h3><p>有时候清除一些你设置的标志也非常有用，比如，你可能在批量运行一些代码，然后想重新开始单独运行。</p><p>通过调用 <code>clearMarks()</code> 方法可以很简单滴来清除标志。</p><p>下面的代码会清除所有你设置的标志，这样你就可以设置新的标志来重新运行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.performance.clearMarks();</div></pre></td></tr></table></figure><p>当然，也有可能你并不想清除所有的标志，而是想清除某些特定的标志，你只需要给 <code>clearMarks()</code> 方法传递你想清除的标志名即可，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.peformance.clearMarks(<span class="string">'mark_fully_loaded'</span>);</div></pre></td></tr></table></figure><p>上面代码清除了我们之前设置的标志，而保留了其他标志。</p><p>也许你还想清除哪些你已经测量的结果，这里有一个对应的 <code>clearMeasures()</code> 方法，调用方法与 <code>clearMarks()</code> 类似，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.performance.clearMeasures(<span class="string">'measure_load_from_dom'</span>);</div></pre></td></tr></table></figure><p>上面代码清除了之前我们做的 measure() 示例中的测量结果。如果你想清除所有的测量结果，和 clearMarks() 一样，只需要调用不传参数的 <code>clearMeasures()</code> 方法即可。</p><h2><span id="获取时间数据">获取时间数据</span></h2><p>现在设置标志和测量时间间隔都没有问题了，但通常你需要获取到这些时间数据并进行一些分析。通过 PerformanceTimeline 提供的接口，这也非常简单。</p><p>例如，通过调用 <code>getEntriesByType()</code> 方法，可以获取到所有的标志和测量的时间间隔，它返回一个数组，我们可以循环这个数组，并对数据进行处理。不错的是，它返回的数据的顺序与你在页面上标记的顺序一样。</p><p>下面代码返回页面中所有标记的数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items = <span class="built_in">window</span>.performance.getEntriesByType(<span class="string">'mark'</span>);</div></pre></td></tr></table></figure><p>下面代码返回所有时间测量的数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items = <span class="built_in">window</span>.performance.getEntriesByType(<span class="string">'measure'</span>);</div></pre></td></tr></table></figure><p>你也可以获取到特定名字的实体数组，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items = <span class="built_in">window</span>.performance.getEntriesByName(<span class="string">'mark_fully_loaded'</span>);</div></pre></td></tr></table></figure><h2><span id="示例测量-xhr-的请求时间">示例：测量 XHR 的请求时间</span></h2><p>现在我们对 User Timing API 有了比较清晰的认识，我们可以借助它来测量一个 <a href="http://www.w3.org/TR/XMLHttpRequest/" target="_blank" rel="external">XMLHttpRequests</a> 请求所花费的时间。</p><p>首先，我们需要修改 <code>send()</code> 方法，在请求发出之前设置一个标志，同时修改我们的 success 回调方法，在回调方法中设置另一个标志。然后，生成一个请求耗时的测量结果。</p><p>通常，我们的 XMLHttpRequest 代码像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myReq = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">myReq.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</div><div class="line">myReq.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  do_something(e.responseText);</div><div class="line">&#125;</div><div class="line">myReq.send();</div></pre></td></tr></table></figure><p>在我们的代码中，我们将添加一个全局的计数器变量 <code>reqCount</code>，表示发送请求的次数，也将用它来储存每次的测量结果，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reqCount = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myReq = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">myReq.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</div><div class="line">myReq.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">window</span>.performance.mark(<span class="string">'mark_end_xhr'</span>);</div><div class="line">  reqCnt++;</div><div class="line">  <span class="built_in">window</span>.performance.measure(<span class="string">'measure_xhr_'</span> + reqCnt, <span class="string">'mark_start_xhr'</span>, <span class="string">'mark_end_xhr'</span>);</div><div class="line">  do_something(e.responseText);</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.performance.mark(<span class="string">'mark_start_xhr'</span>);</div><div class="line">myReq.send();</div></pre></td></tr></table></figure><p>上面的代码为每次 XMLHttpRequest 请求生成了包含一个唯一名字的测量，我们假设所有请求有序发生 - 要使请求有序发生，需要更复杂的处理，我把这个留给读者练习。</p><p>一旦应用完成一系列请求之后，我们就可以将结果输出到控制台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items = <span class="built_in">window</span>.performance.getEntriesByType(<span class="string">'measure'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length(); ++i) &#123;</div><div class="line">  <span class="keyword">var</span> req = items[i];</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'XHR '</span> + req.name + <span class="string">' took '</span> + req.duration + <span class="string">'ms'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>User Timing API 提供了很多实用的方法，适用于 Web 应用的任何方面。通过在你的应用中设置大量的 API 调用来缩小热点范围，然后通过分析生成的时间数据，就可以清晰地知道时间被花费在了什么地方。但是，如果你的浏览器不支持这些 API 怎么办？没关系，<a href="https://gist.github.com/pmeenan/5902672" target="_blank" rel="external">这里</a>有一个强大的模拟 API，而且在 <a href="http://www.webpagetest.org/" target="_blank" rel="external">webpagetest.org</a> 应用的非常好。那么你还在等什么呢?立刻在你的应用中使用 User Timing API 吧，你将找到方法如何使你的应用运行的更快，然后你的用户将感激你为他们提供了更好的用户体验。</p><p>英文原文：<a href="http://www.html5rocks.com/profiles/#alexdanilo" target="_blank" rel="external">Alex Danilo</a>，翻译：<a href="http://bubkoo.com/">布谷 bubkoo</a></p><p>原文链接：<a href="http://www.html5rocks.com/en/tutorials/webperformance/usertiming/" target="_blank" rel="external">User Timing API</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高性能的 Web 应用是获得伟大用户体验的关键。随着 Web 应用越来越复杂，要想建立吸引人的用户体验，了解性能的影响是至关重要的。在过去的几年中，浏览器中也新增了许多 API 来帮助我们分析网络性能、页面加载时间等。但这些并没有给出详尽的足够灵活的方式，来帮助我们分析具体是什么降低了我们网站的性能。&lt;a href=&quot;http://www.w3.org/TR/user-timing/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;User Timing API&lt;/a&gt; 提供了一套机制来帮助我们测量我们的应用，从而找到应用中耗时的部分。在本文中，我将介绍这个 API 并提供一些如何使用它的例子。&lt;/p&gt;
&lt;h2 id=&quot;你不能优化那些不能被测量的东西&quot;&gt;&lt;a href=&quot;#你不能优化那些不能被测量的东西&quot; class=&quot;headerlink&quot; title=&quot;你不能优化那些不能被测量的东西&quot;&gt;&lt;/a&gt;你不能优化那些不能被测量的东西&lt;/h2&gt;&lt;p&gt;给运行缓慢的应用提速的第一步是，找到应用中耗时的部位。要想找到这些烫手山药，最理想的方式就是对 JavaScript 代码进行区域性的运行时间测量，这是寻找如何提高网站性能的第一步。幸运的是，可以在代码的不同部位去调用 &lt;a href=&quot;http://www.w3.org/TR/user-timing/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;User Timing API&lt;/a&gt;，提取到时间的详细数据，来帮助你进行性能优化。&lt;/p&gt;
&lt;h2 id=&quot;高精度时间和now&quot;&gt;&lt;a href=&quot;#高精度时间和now&quot; class=&quot;headerlink&quot; title=&quot;高精度时间和now()&quot;&gt;&lt;/a&gt;高精度时间和&lt;code&gt;now()&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;准确测量时间的一个基础是精确度，之前我们是基于毫秒的时间测量，这种方式工作良好，但是对于一个每帧需要在 16ms 内绘制完成的 60FPS 的网站，如果只有毫秒精度的测量，对于网站的分析就缺乏所需要的精度。&lt;a href=&quot;http://www.w3.org/TR/hr-time/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;High Resolution Time&lt;/a&gt; 是现代浏览器内置的一种新的测量时间的方式，它给我们提供了一个精确到微秒的浮点类型的时间戳，是之前精度的 1000 倍。&lt;/p&gt;
&lt;p&gt;可以通过调用 &lt;a href=&quot;http://www.w3.org/TR/navigation-timing/#performance&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Performance&lt;/a&gt; 对象中的&lt;a href=&quot;http://www.w3.org/TR/hr-time/#sec-extenstions-performance-interface&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;扩展方法&lt;/a&gt; &lt;code&gt;now()&lt;/code&gt; 来获取当前的时间，就像下面代码这样：&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://bubkoo.com/categories/javascript/"/>
    
    
      <category term="Performance" scheme="http://bubkoo.com/tags/performance/"/>
    
      <category term="Timing" scheme="http://bubkoo.com/tags/timing/"/>
    
  </entry>
  
  <entry>
    <title>JSHint 选项列表</title>
    <link href="http://bubkoo.com/2014/02/22/JSHint-options/"/>
    <id>http://bubkoo.com/2014/02/22/JSHint-options/</id>
    <published>2014-02-22T00:22:44.000Z</published>
    <updated>2017-09-25T11:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bubkoo.qiniudn.com/jshint-dark.png" alt="JSHint"></p><p>有时候会查找 <a href="http://jshint.com/" target="_blank" rel="external">JSHint</a> 某些选项的具体含义，针对项目需求开启或关闭某些选项，所以从<a href="https://github.com/basecss/jshint-doc-cn" target="_blank" rel="external">这里</a>转载了 JSHint 选项列表的中文翻译，供不时之需。</p><p>这是 JSHint 所有配置选项的完整列表。如果发现遗漏了某些信息，你可以给作者提<a href="https://github.com/jshint/jshint/issues/new" target="_blank" rel="external"> issues</a> 或者<a href="https://github.com/basecss/jshint-doc-cn/blob/master/anton@kovalyov.net" target="_blank" rel="external">发邮件</a>。</p><a id="more"></a><style>table thead tr th:first-child{width:100px;}</style><h2><span id="enforcing-选项">Enforcing 选项</span></h2><p>当下列选项设置为 <code>true</code> 时，JSHint 会基于这些选项对代码产生更多的警告信息。</p><h3><span id="bitwise">bitwise</span></h3><p>这个选项禁止在 JavaScript 中使用位运算符，如 <code>^</code> (XOR)，<code>|</code> (OR)。在 JavaScript 中位运算很少见，<code>&amp;</code> 与 <code>&amp;&amp;</code> 经常容易混淆，大多数情况下应该使用 <code>&amp;&amp;</code>。</p><h3><span id="camelcase">camelcase</span></h3><p>这个选项允许代码块中的变量名用驼峰式或者用下划线连接的全大写。</p><h3><span id="curly">curly</span></h3><p>这个选项要求在循环和条件判断的代码块中总是使用大括号包围，即使是单行代码，否则极易引起错误：</p><p>JavaScript 允许在单行语句的情况下不使用大括号，如下例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(day) </div><div class="line">  shuffle();</div></pre></td></tr></table></figure><p>然而，在某些情况容易导致bug，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (day)</div><div class="line">  shuffle();</div><div class="line">  sleep();</div></pre></td></tr></table></figure><h3><span id="eqeqeq">eqeqeq</span></h3><p>这个选项禁止使用 <code>==</code> 和 <code>!=</code>，而是 <code>===</code> 和 <code>!==</code>。前者会在比较之前强制类型转换，这样会导致一些无法预期的结果；而后者不会，所以更安全。如果想了解更多关 JavaScript 强制类型，请参考 <a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/" target="_blank" rel="external">Truth, Equality and JavaScript by Angus Croll</a>。</p><h3><span id="es3">es3</span></h3><p>这个选项指当前代码严格最受 ECMAScript 3 规范，一般当 JavaScript 程序需要在 IE6、IE7、IE8 或者其它遗留的 JavaScript 运行环境中工作时需要用到这个选项。</p><h3><span id="forin">forin</span></h3><p>这个选项要求所有的 <code>for...in</code> 循环过滤对象的 items。<code>for...in</code> 语句允许依据对象的所有属性名称进行循环，包括从原型链中集成来的属性，这个行为可以导致一些在代码中没有期望的属性出现，所以一般在使用<code>for...in</code> 的时候需过滤掉继承的属性。如下例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</div><div class="line">  <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</div><div class="line">    <span class="comment">// We are sure that obj[key] belongs to the object and was not inherited.</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>想深入了解 <code>for...in</code> 循环，请参见 <a href="http://javascriptweblog.wordpress.com/2011/01/04/exploring-javascript-for-in-loops/" target="_blank" rel="external">Exploring JavaScript for-in loops by Angus Croll</a>。</p><h3><span id="immed">immed</span></h3><p>这个选项禁止使用没有括号的调用函数的方法。函数加括号意味着这段代码是执行方法的返回结果，而非方法本身，减少一些阅读的困惑。</p><h3><span id="indent">indent</span></h3><p>强制代码使用特定的 tab 宽度，例如下面代码会报 indent 警告信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*jshint indent:4 */</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (cond) &#123;</div><div class="line">  doSomething(); <span class="comment">// We used only two spaces for indentation here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="latedef">latedef</span></h3><p>latedef 选项是关于变量的声明与使用的先后顺序，它禁止变量没有定义就使用。JavaScript 只有函数作用域，另外，JavaScript 解析时所有的变量都回被搬到或者提升到函数的最顶端，这种行为会导致一些很怪异的 Bug，所以在变量定义后在使用总是安全的。</p><p>将 latedef 的选项值设为 <code>”nofunc”</code> 允许忽略函数的声明。深入研究，请参见 <a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html" target="_blank" rel="external">JavaScript Scoping and Hoisting by Ben Cherry</a>。</p><h3><span id="newcap">newcap</span></h3><p>要求将构造函数的名字大写，这只是一种惯例，标志这些函数将会用 <code>new</code> 操作符构建对象，用以区分其它的函数类型，避免一些错误。不这么做也没什么问题，但是会对代码的理解增加一些难度，同时如果本来应该用 <code>new</code> 构建但却没有 <code>new</code>，可能会使得变量指向全局对象而不是一个 <code>new</code> 的对象。</p><h3><span id="noarg">noarg</span></h3><p>禁止在 JavaScript 代码中使用 <code>arguments.caller and arguments.callee</code>。这些调用阻止了 JavaScript 一批量的优化措施变，在新版本的规法中已经将它门定义为过时，实际上 ECMAScript 5 已经禁止在严格模式下使用这两种方式。</p><h3><span id="noempty">noempty</span></h3><p>当发现代码有空的代码块是会发出警告信息。</p><h3><span id="nonew">nonew</span></h3><p>禁止使用构造函数，因为它会带来一些不必要的副作用。一些程序员喜欢调用构造函数，但并不将它的结果赋予任何变量。<code>new MyConstructor()</code>。</p><p>这种方式没有与简单的 <code>MyConstructor()</code> 相比没有什么优势，因为用 <code>new</code> 操作符创建的对象没有被任何地方使用。</p><h3><span id="plusplus">plusplus ++</span></h3><p>禁止使用一元递增和递减的操作符，有些人认为 <code>++</code> 和 <code>-–</code> 会降低代码风格的质量，也有人认为使用 <code>++</code> 和 <code>-–</code> 有性能上的优化。</p><h3><span id="quotmark">quotmark</span></h3><p>强制项目代码的引用保持一致，它介绍三个值，<code>true</code>, <code>single</code> 和 <code>double</code>。<code>true</code> 指不想引入任何一种具体的引号风格，但想保持一致。<code>single</code> 指单引号，<code>double</code> 指只允许双引号。</p><h3><span id="undef">undef</span></h3><p>禁止使用显示的未声明的变量，这个选项在寻找泄露以及输入错误的变量时很有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*jshint undef:true */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> myVar = <span class="string">'Hello, World'</span>;</div><div class="line">  <span class="built_in">console</span>.log(myvar); <span class="comment">// Oops, typoed here. JSHint with undef will complain</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果所使用的变量在另一个文件中定义，可以使用 <code>/global … / directive</code> 来声明。</p><h3><span id="unused">unused</span></h3><p>发现定义了但为被使用的变量时报警告信息。当要进行代码清理的时候特别有用，常与 <code>undef</code> 一起使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*jshint unused:true */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c, d = <span class="number">2</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> a + d;</div><div class="line">&#125;</div><div class="line"></div><div class="line">test(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// Line 3: 'b' was defined but never used.</span></div><div class="line"><span class="comment">// Line 4: 'c' was defined but never used.</span></div></pre></td></tr></table></figure><p>另外，它也可以警告关于没有用到的全局变量。它的值可以设为 ”vars”，只检查变量，不包括函数参数或者严格的只检查变量和参数。缺省位 <code>true</code>，允许未使用的参数后面跟一个使用过的参数。</p><h3><span id="strict">strict</span></h3><p>要求所有函数遵循 ECMAScript 5 的严格模式。严格模式消除了一些 JavaScript 易混淆的痛点，修复了一些阻碍 JavaScript 引擎进行优化的错误。严格模式只在函数作用域生效，禁止全局范围的严格模式，因为会破坏第三方依赖的代码，如果一定要使用，请参见 globalstrict 选项。</p><h3><span id="trailing">trailing</span></h3><p>当发现代码的尾部有空行会报错。尾部有空格会导致一些怪异的 Bug，尤其是在多行字符串的情况下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This otherwise perfectly valid string will error if</span></div><div class="line"><span class="comment">// there is a whitespace after \</span></div><div class="line"><span class="keyword">var</span> str = <span class="string">"Hello \</span></div><div class="line"><span class="string">World"</span>;</div></pre></td></tr></table></figure><h3><span id="maxparams">maxparams</span></h3><p>可以设置一个函数最多允许的参数个数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*jshint maxparams:3 */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">request, onSuccess</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JSHint: Too many parameters per function (4).</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logout</span>(<span class="params">request, isManual, whereAmI, onSuccess</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="maxdepth">maxdepth</span></h3><p>允许控制代码的嵌套层次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*jshint maxdepth:2 */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">meaning</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> day = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (meaning === <span class="number">42</span>) &#123;</div><div class="line">    <span class="keyword">while</span> (day) &#123;</div><div class="line">      shuffle();</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (tired) &#123; <span class="comment">// JSHint: Blocks are nested too deeply (3).</span></div><div class="line">          sleep();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="maxstatements">maxstatements</span></h3><p>设置一个函数最多允许的有效代码行数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*jshint maxstatements:4 */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">var</span> j = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Function declarations count as one statement. Their bodies</span></div><div class="line">  <span class="comment">// don't get taken into account for the outer function.</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i2 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> j2 = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> i2 + j2;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  j = i + j;</div><div class="line">  <span class="keyword">return</span> j; <span class="comment">// JSHint: Too many statements per function. (5)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="maxcomplexity">maxcomplexity</span></h3><p>允许控制代码的圈复杂度。圈复杂度测量代码中独立路径的数量，请参见 <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity" target="_blank" rel="external">cyclomatic complexity on Wikipedia</a>。</p><h3><span id="maxlen">maxlen</span></h3><p>设置一行的最大长度。</p><h2><span id="relaxing-选项">Relaxing 选项</span></h2><p>当下面这些选项设为 <code>true</code>，将会减少警告信息的产生。</p><h3><span id="asi">asi</span></h3><p>asi选项针对 JavaScript 代码的分号问题，有很多人认为应该严格的在行尾添加分号，更多信息请参见 <a href="http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding" target="_blank" rel="external">An Open Letter to JavaScript Leaders Regarding Semicolons by Isaac Schlueter</a> 和 <a href="http://inimino.org/~inimino/blog/javascript_semicolons" target="_blank" rel="external">JavaScript Semicolon Insertion</a>。</p><h3><span id="boss">boss</span></h3><p>经常在代码中会出先应该是用条件判断的地方出现了赋值语句，boss 选项设为 <code>true</code> 会隐藏这些错误信息。</p><h3><span id="eqnull">eqnull</span></h3><p>eqnull 与 <code>null</code> 比较相关，如果设为 <code>true</code>，在看到 <code>==null</code> 操作时不会报错。</p><h3><span id="esnext">esnext</span></h3><p>要求代码使用 ECMAScript 6 规范语法。注意这个 feature 还没有最后确定并且不是所有的浏览器都实现。 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts" target="_blank" rel="external">Draft Specification for ES.next (ECMA-262 Ed. 6)</a></p><h3><span id="evil">evil</span></h3><p>隐藏 <code>eval</code> 使用的警告。<code>eval</code> 的使用使得代码有了被攻击的缺陷，并且阻碍了 JavaScript 解析器的一些优化措施。</p><h3><span id="expr">expr</span></h3><p>隐藏了关于 expressions 异常使用的代码，通常期待赋值或者函数定义而出现的 expression 往往是一种错误，但规范中并没有禁止此种使用方式，所以对这种代码只是警告信息。</p><h3><span id="funcscope">funcscope</span></h3><p>关于变量的作用域问题，有些变量在控制结构内声明，然而在之外企图访问。尽管 JavaScript 只有两种作用域，函数作用域与全局作用域，然而这种跨作用域的使用方式会对 JavaScript 的初学者造成困惑，并很难调试，缺省 JSHint 会对这种使用提示警告信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  x += <span class="number">1</span>; <span class="comment">// Default: 'x' used out of scope.</span></div><div class="line">            <span class="comment">// No warning when funcscope:true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="globalstrict">globalstrict</span></h3><p>隐藏了全局作用域使用严格模式的警告信息，它可能会到第三方代码的功能破化，所以不推荐使用，参见 strict 选项。</p><h3><span id="iterator">iterator</span></h3><p>隐藏了 <code>iterator</code> 属性的警告信息，并不是所有浏览器都支持，所以使用要首先确认支持的浏览器。</p><h3><span id="lastsemic">lastsemic</span></h3><p>只针对在只有一行的代码块的最后一行，如果缺失分号缺省会报警告信息；如果 lastsemic 设为 <code>true</code>，即隐藏了这类的警告信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'Anton'</span> &#125;());</div></pre></td></tr></table></figure><h3><span id="laxbreak">laxbreak</span></h3><p>隐藏了可能不安全的换行代码。对于以逗号分隔的代码参见 laxcomma。</p><h3><span id="laxcomma">laxcomma</span></h3><p>针对逗号开头的代码风格。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name: <span class="string">'Anton'</span></div><div class="line">  , <span class="attr">handle</span>: <span class="string">'valueof'</span></div><div class="line">  , <span class="attr">role</span>: <span class="string">'SW Engineer'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3><span id="loopfunc">loopfunc</span></h3><p>针对循环内定义 function 的代码块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nums = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  nums[i] = <span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> i + j;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">nums[<span class="number">0</span>](<span class="number">2</span>); <span class="comment">// Prints 12 instead of 2</span></div></pre></td></tr></table></figure><p>使用闭包可解决以上问题，此时 <code>nums[i]</code> 的 <code>i</code> 是 for 循环 <code>i</code> 的一个复本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nums = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</div><div class="line">    nums[i] = <span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> i + j;</div><div class="line">    &#125;;</div><div class="line">  &#125;(i));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="moz">moz</span></h3><p>声明代码使用mozilla JavaScript 扩展。</p><h3><span id="multistr">multistr</span></h3><p>关于多行字符串的。多行字符串是很危险的，如果不小心在转义符或者换行符之间插入了一个空格，那么代码就被破坏了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*jshint multistr:true */</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> text = <span class="string">"Hello\</span></div><div class="line"><span class="string">World"</span>; <span class="comment">// All good.</span></div><div class="line"></div><div class="line">text = <span class="string">"Hello</span></div><div class="line"><span class="string">World"</span>; <span class="comment">// Warning, no escape character.</span></div><div class="line"></div><div class="line">text = <span class="string">"Hello\</span></div><div class="line"><span class="string">World"</span>; <span class="comment">// Warning, there is a space after \</span></div></pre></td></tr></table></figure><h3><span id="proto">proto</span></h3><p>关于 proto 属性。</p><h3><span id="scripturl">scripturl</span></h3><p>关于 script-trageted URLS，诸如 javascript: …</p><h3><span id="smarttabs">smarttabs</span></h3><p>隐藏当空格用来对齐，tab 和空格混用的代码。</p><h3><span id="shadow">shadow</span></h3><p>指在不同作用域重复定义变量，特指在外层作用域已经定义了，在小作用域内定义会 shadow 外层的变量。</p><h3><span id="sub">sub</span></h3><p>提示需要用 <code>.</code> 访问属性而不是 <code>[]</code>，例如 <code>person[‘name’]</code> 和 <code>person.name</code>。</p><h3><span id="supernew">supernew</span></h3><p>隐藏关于一些器官的构造方式，诸如 <code>new function(){…}</code> 和 <code>new Object</code>。这些代码块在一些场合下用来创建单例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> privateVar;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.publicMethod  = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">  <span class="keyword">this</span>.publicMethod2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3><span id="validthis">validthis</span></h3><p>只在函数作用域内生效，隐藏了违反严格模式使用标准的代码，或则在非构造函数中使用 <code>this</code>。</p><h2><span id="environments">Environments</span></h2><p>下列选项是关于一些预定以的全局变量。</p><ul><li>browser</li><li>couch</li><li>devel</li><li>dojo</li><li>jquery</li><li>mootools</li><li>node</li><li>nonstandard</li><li>phantom</li><li>prototypejs</li><li>rhino</li><li>worker</li><li>wsh</li><li>yui</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/jshint-dark.png&quot; alt=&quot;JSHint&quot;&gt;&lt;/p&gt;
&lt;p&gt;有时候会查找 &lt;a href=&quot;http://jshint.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSHint&lt;/a&gt; 某些选项的具体含义，针对项目需求开启或关闭某些选项，所以从&lt;a href=&quot;https://github.com/basecss/jshint-doc-cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;转载了 JSHint 选项列表的中文翻译，供不时之需。&lt;/p&gt;
&lt;p&gt;这是 JSHint 所有配置选项的完整列表。如果发现遗漏了某些信息，你可以给作者提&lt;a href=&quot;https://github.com/jshint/jshint/issues/new&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; issues&lt;/a&gt; 或者&lt;a href=&quot;https://github.com/basecss/jshint-doc-cn/blob/master/anton@kovalyov.net&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;发邮件&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="前端工具" scheme="http://bubkoo.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="JSHint" scheme="http://bubkoo.com/tags/jshint/"/>
    
      <category term="Tools" scheme="http://bubkoo.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>使用 Developer Tools 进行 JavaScript 性能分析</title>
    <link href="http://bubkoo.com/2014/02/19/javascript-profiling-chrome-developer-tools/"/>
    <id>http://bubkoo.com/2014/02/19/javascript-profiling-chrome-developer-tools/</id>
    <published>2014-02-19T01:13:32.000Z</published>
    <updated>2014-02-19T01:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://coding.smashingmagazine.com/2012/06/12/javascript-profiling-chrome-developer-tools/" target="_blank" rel="external">JavaScript Profiling With The Chrome Developer Tools</a></p><p>现在，让我们来让你的网站跑得更快，网站性能通常包括两个方面：页面加载速度和脚本执行速度，有很多方法可以让网站加载更快，例如，压缩文件和 CND 等，但是要让脚本执行更快就得靠开发人员自己了。</p><p>代码很小的改动就可能对性能产生巨大影响，不同位置的几行代码可能就意味着一个快的网站和产生可怕的“无响应脚本”对话框的网站之间的区别。本文展示了使用 Chrome 开发工具来找到这些性能关键点代码的一些方法。</p><h2><span id="建立基准线">建立基准线</span></h2><p>我们来看一个简单的<a href="http://zgrossbart.github.io/jsprofarticle/index1.htm" target="_blank" rel="external">颜色排序应用</a>，这个应用展示了一个由各种颜色构成的网格，您可以拖放任意一个颜色点来混淆。每一个颜色点都是一个 div 标签，使用了一些 CSS 来让它们看起来像一个圆点。</p><p><img src="http://bubkoo.qiniudn.com/color%20sorter.png" alt="Color Sorter"></p><p><a href="http://zgrossbart.github.io/jsprofarticle/index1.htm" target="_blank" rel="external">点击这里</a>访问该应用。</p><p>生成一个这些颜色有点棘手，所以我参考了 <a href="http://krazydad.com/tutorials/makecolors.php" target="_blank" rel="external">Making Annoying Rainbows in JavaScript</a> 这篇文章。</p><a id="more"></a><p>这个页面载入很快，但是仍需要一些时间，是时候来优化它使其运行更快了。</p><p>在开始对一个网站进行性能优化之前，我们需要设置一个基准线，从而得知优化效果怎么样，并帮助我们权衡利弊。在本文中，我们将使用 <a href="http://code.google.com/chrome/devtools/docs/overview.html" target="_blank" rel="external">Chrome 开发者工具</a>。</p><p>性能分析器（profiler）是 Chrome 开发者工具的一部分，通过点击“工具”菜单下的小扳手来打开它。<a href="http://getfirebug.com/" target="_blank" rel="external">Firebug</a> 也有性能分析工具，但是，WebKit 内核的浏览器（Chrome 和 Safari）在代码分析和展示时间线方面是最好的。Chrome 还提供了一个很棒的事件跟踪工具，叫 <a href="https://developers.google.com/web-toolkit/speedtracer/" target="_blank" rel="external">Speed Tracer</a>。</p><p>为了建立我们的基线，首先在“Timeline”选项卡中点击“Record”开始记录，加载页面，然后停止记录，Chrome 非常智能，只有当开始加载页面的时候才开始记录。这里记录了三次，然后取三次的平均值，以防在第一次测试时我的电脑运行的很慢。</p><p><img src="http://bubkoo.qiniudn.com/Developer%20Tools&#39;%20baseline-1.png" alt=""></p><p>我的平均基线，也就是从第一次请求页面到页面渲染完成所花费的时间是 1.25 秒，这个并不算慢，但是对于这样的小型应用还不够好。</p><p>我想让我的代码运行的更快，但是我还不知道是哪里导致代码运行缓慢的。性能分析工具（profiler）将帮助我找到原因。</p><h2><span id="创建一个-profile">创建一个 Profile</span></h2><p>通过时间线（timeline）我们知道代码运行了多久，但是我们并不知道代码在运行时具体发生了什么。虽然可以通过修改代码后，再次记录时间线，然后重复这个过程，来找到影响性能的代码，但这太盲目了，很难找到性能瓶颈点。“Profiles”选项卡给我们提供了一个更好的方式，去了解代码的具体执行情况。</p><p>“Profiles”选项卡直观地显示了哪个函数占用了大部分执行时间，在Chrome 开发者工具的“Profiles”选项卡中，提供了三种性能分析方式：</p><ol><li>JavaScript CPU profile，显示我们的 JavaScript 运行时占用了多少 CPU 时间。</li><li>CSS selector profile，显示处理 CSS 选择器时占用了多少 CPU 时间。</li><li>Heap snapshot，显示 JavaScript 对象的内存占用情况。</li></ol><p>我们想让代码执行更快，所以我们将使用 CPU 性能测试。点击开始分析，刷新页面，加载完成之后停止分析器。</p><p><img src="http://bubkoo.qiniudn.com/Developer%20Tools&#39;%20baseline-2.png" alt=""></p><p>从分析结果知道页面上有很多函数在执行。在这个应用中使用了 jQuery 和 jQuery UI 来管理插件和解析正则表达式等工作。同时，我们可以看到我们的这两个函数：<code>decimalToHex</code> 和 <code>makeColorSorter</code> 位居列表的顶部，这两个函数总共占用了 13.2% 的执行时间，所以他们是很好的性能优化点。</p><p>在分析工具中，我们可以点击函数名称左边的小箭头来展开函数的调用堆栈，可以看出，<code>decimalToHex</code> 被 <code>makeColorSorter</code> 调用，<code>makeColorSorter</code> 又被 <code>$(document).ready</code> 调用。</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    makeColorSorter(<span class="number">.05</span>, <span class="number">.05</span>, <span class="number">.05</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">128</span>, <span class="number">127</span>, <span class="number">121</span>);</div><div class="line">    makeSortable();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>从调用来源可以知道 <code>makeSortable</code> 方法并不是我们最大的性能问题。通常情况下排序操作会带来一些<a href="http://37signals.com/svn/posts/3137-using-event-capturing-to-improve-basecamp-page-load-times" target="_blank" rel="external">性能问题</a>，但是，在我们的代码中添加 DOM 元素花费了比排序还要多的时间。</p><p>在开始优化之前，我们首先需要孤立将要优化的代码，页面加载的时候执行的函数太多了，我不想这些影响到我们的性能分析。</p><h2><span id="隔离代码">隔离代码</span></h2><p>我编写了<a href="http://zgrossbart.github.com/jsprofarticle/index2.htm" target="_blank" rel="external">第二个版本</a>的颜色排序应用，在这个版本中，页面载入的时候并不会执行我们的应用，直到我们点击页面上的一个按钮时，才执行我们的应用。这样就让我们的代码从页面加载过程中隔离出来，当我们优化完成之后再修改回去。</p><p>将隔离出来的代码放在一个新函数中，命名为 <code>testColorSorter</code> ，然后将其绑定在按钮上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testColorSorter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    makeColorSorter(<span class="number">.05</span>, <span class="number">.05</span>, <span class="number">.05</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">128</span>, <span class="number">127</span>, <span class="number">121</span>);</div><div class="line">    makeSortable();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;button id=<span class="string">"clickMe"</span> onclick=<span class="string">"testColorSorter();"</span>&gt;Click me&lt;<span class="regexp">/button&gt;</span></div></pre></td></tr></table></figure><p>在我们进行性能分析之前修改代码可能会导致意外的结果。虽然这个改动看起来很安全，但是我还是要重新运行性能分析，来看看我是不是无意中改变了什么。我会开始一次新的性能分析，点击应用中的按钮，等应用加载完成后，点击停止。</p><p><img src="http://bubkoo.qiniudn.com/Developer%20Tools&#39;%20baseline-3.png" alt=""></p><p>现在 <code>decimalToHex</code> 函数的载入只占用了 4.23% 的时间，这是代码执行花费时间最多的地方。我们需要创建一个新的基线来看看这个方案将会有多大优化。</p><p><img src="http://bubkoo.qiniudn.com/Developer%20Tools&#39;%20baseline-4.png" alt=""></p><p>在点击按钮之前有一些事件被触发了，但是我只关心从我点击按钮到浏览器渲染完成“颜色排序器”所花费的时间。鼠标在 390 毫秒的时间点击，渲染事件在 726 毫秒时被触发。726 减去 390 就得到基线值 336 毫秒。同样，我重复了三次，然后取平均值。</p><p>此时，我知道在哪里看代码的运行时间了，现在我们可以开始解决性能问题。</p><h2><span id="优化代码">优化代码</span></h2><p>通过性能分析器我们只知道是哪个函数有性能问题，我们还需要查看函数的内部实现，来了解函数具体做了什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimalToHex</span>(<span class="params">d</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hex = <span class="built_in">Number</span>(d).toString(<span class="number">16</span>);</div><div class="line">    hex = <span class="string">"00"</span>.substr(<span class="number">0</span>, <span class="number">2</span> - hex.length) + hex; </div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'converting '</span> + d + <span class="string">' to '</span> + hex);</div><div class="line">    <span class="keyword">return</span> hex;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>“颜色排序器”中的每一个颜色点都有一个 <a href="http://en.wikipedia.org/wiki/Hexadecimal" target="_blank" rel="external">16 进制</a>的颜色值，例如 <code>#86F01B</code> 和 <code>#2345FE</code>，这些值分别表示了颜色中红、绿、蓝三原色各自的值。例如背景色是 <code>#2456FE</code> 的颜色点，就代表红色的值是 36，绿色的值是 86，蓝色的是 254，每一个数值必须在 0 到 255 之间。</p><p><code>decimalToHex</code> 函数就是把这用 RGB 值表示的颜色转化为页面中我们使用的十六进制颜色。</p><p>这个函数非常简单，但是我还是留下了一个可以去掉的调试代码 <code>console.log</code> 在那里。</p><p>由于某些十进制数字对应的十六进制数字只有一位，例如十进制的 10 表示为十六进制后是 C，而三原色中的颜色值需要两位十六进制的数字，所以有必要在 <code>decimalToHex</code> 函数中进行补位。为了让这个转换函数执行更加快，我们可以修改里面的补位操作，使其并不那么泛化。由于我们知道需要补位的数字的长度都为 1，所以我们可以这样重构这个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimalToHex</span>(<span class="params">d</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hex = <span class="built_in">Number</span>(d).toString(<span class="number">16</span>);</div><div class="line">    <span class="keyword">return</span> hex.length === <span class="number">1</span> ? <span class="string">'0'</span> + hex : hex; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<a href="http://zgrossbart.github.com/jsprofarticle/index3.htm" target="_blank" rel="external">第三个版本</a>的颜色排序器中，只有在需要补位的时候才会修改字符串，并且不用调用 <code>substr</code> 函数。有了这个新函数，我们的运行时间是 137 毫秒，再次对代码进行性能测试，可以发现 <code>decimalToHex</code> 函数只占用了总时间的 0.04%，到了性能列表的下部。</p><p><img src="http://bubkoo.qiniudn.com/Developer%20Tools&#39;%20baseline-5..png" alt=""></p><p>我们还可以发现占用 CPU 时间最多的函数是 jQuery 的 <code>e.extend.merge</code>。我并不知道这个函数的作用，因为 jQuery 代码是被压缩过的。我们可以使用开发版本的 jQuery，但是我发现这个函数是被 <code>makeColorSorter</code> 调用的。所以下一步我们先让这个函数执行的更快。</p><h2><span id="减小内容改动">减小内容改动</span></h2><p>“颜色排序器”中的颜色是用过正弦曲线生成的。在光谱中设置一个中心点，然后以一定的偏移来创建这个曲线，这就把颜色变成了一个“彩虹模型”。我们还可以通过改变红、绿、蓝三原色的频率来改变颜色。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeColorSorter</span>(<span class="params">frequency1, frequency2, frequency3,</span></span></div><div class="line"><span class="function"><span class="params">                         phase1, phase2, phase3,</span></span></div><div class="line"><span class="function"><span class="params">                         center, width, len</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i)</div><div class="line">    &#123;</div><div class="line">       <span class="keyword">var</span> red = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sin(frequency1 * i + phase1) * width + center);</div><div class="line">       <span class="keyword">var</span> green = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sin(frequency2 * i + phase2) * width + center);</div><div class="line">       <span class="keyword">var</span> blue = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sin(frequency3 * i + phase3) * width + center);</div><div class="line"></div><div class="line">       <span class="built_in">console</span>.log(<span class="string">'red: '</span> + decimalToHex(red));</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">'green: '</span> + decimalToHex(green));</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">'blue: '</span> + decimalToHex(blue));</div><div class="line"></div><div class="line">       <span class="keyword">var</span> div = $(<span class="string">'&lt;div class="colorBlock"&gt;&lt;/div&gt;'</span>);</div><div class="line">       div.css(<span class="string">'background-color'</span>, <span class="string">'#'</span> + decimalToHex(red) + decimalToHex(green) + decimalToHex(blue));</div><div class="line">       $(<span class="string">'#colors'</span>).append(div);</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们应该去掉 <code>console.log</code> 函数。这样调用非常糟糕，因为每次执行都会调用 <code>decimalToHex</code> 函数，这意味着 <code>decimalToHex</code> 的调用次数将会增加一倍。</p><p>这个函数还会频繁地修改 DOM 结构。每次循环，都向 ID 为 <code>colors</code> 的 <code>div</code> 中添加一个新的 <code>div</code>。这就让我怀疑这可能就是 <code>e.extend.merge</code> 函数所做的事情。用性能分析器做一个小实验就可以搞清楚。</p><p>我想要在循环结束后一次性把所有的 <code>div</code> 添加进去，而不是在每个循环中添加都一个新的 <code>div</code>，我们需要在循环外创建一个变量来存储这些 <code>div</code>，然后在最后一次性添加进去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeColorSorter</span>(<span class="params">frequency1, frequency2, frequency3,</span></span></div><div class="line"><span class="function"><span class="params">                         phase1, phase2, phase3,</span></span></div><div class="line"><span class="function"><span class="params">                         center, width, len</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> colors = <span class="string">""</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i)</div><div class="line">    &#123;</div><div class="line">       <span class="keyword">var</span> red = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sin(frequency1 * i + phase1) * width + center);</div><div class="line">       <span class="keyword">var</span> green = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sin(frequency2 * i + phase2) * width + center);</div><div class="line">       <span class="keyword">var</span> blue = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sin(frequency3 * i + phase3) * width + center);</div><div class="line"></div><div class="line">       colors += <span class="string">'&lt;div class="colorBlock" style="background-color: #'</span> + </div><div class="line">           decimalToHex(red) + decimalToHex(green) + decimalToHex(blue) + <span class="string">'"&gt;&lt;/div&gt;'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $(<span class="string">'#colors'</span>).append(colors);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个微小改动意味着在添加所有这些 <code>div</code> 的时候，只有一次 DOM 操作。用时间线进行测试，我们发现从点击到渲染只用了 31 毫秒。这个一次性的 DOM 操作，使得<a href="http://zgrossbart.github.com/jsprofarticle/index4.htm" target="_blank" rel="external">第四个版本</a>的运行时间降低了 86%。我可以再次打开性能分析器(profiler)，发现 <code>e.extend.merge</code> 函数占用了仅很少的时间，在性能列表中已经看不到它了。</p><p>我们还可以移除 <code>decimalToHex</code> 函数让代码更快一点。因为 <a href="http://www.w3schools.com/cssref/css_colors.asp" target="_blank" rel="external">CSS 支持 RGB 颜色值</a>，所以我们不需要把他们转换到十六进制。现在我们可以这样修改 <code>makeColorSorter</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeColorSorter</span>(<span class="params">frequency1, frequency2, frequency3,</span></span></div><div class="line"><span class="function"><span class="params">                         phase1, phase2, phase3,</span></span></div><div class="line"><span class="function"><span class="params">                         center, width, len</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> colors = <span class="string">""</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i)</div><div class="line">    &#123;</div><div class="line">       <span class="keyword">var</span> red = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sin(frequency1 * i + phase1) * width + center);</div><div class="line">       <span class="keyword">var</span> green = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sin(frequency2 * i + phase2) * width + center);</div><div class="line">       <span class="keyword">var</span> blue = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sin(frequency3 * i + phase3) * width + center);</div><div class="line"></div><div class="line">       colors += <span class="string">'&lt;div class="colorBlock" style="background-color: rgb('</span> + </div><div class="line">           red + <span class="string">','</span> + green + <span class="string">','</span> + blue + <span class="string">')"&gt;&lt;/div&gt;'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $(<span class="string">'#colors'</span>).append(colors);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="http://zgrossbart.github.com/jsprofarticle/index5.htm" target="_blank" rel="external">第五个版本</a>的执行只用了 26 毫秒，而且代码也从 28 行减少到 18 行。</p><h2><span id="在你的应用中进行-javascript-性能分析">在你的应用中进行 Javascript 性能分析</span></h2><p>现实环境中的应用要不这里的“颜色排序器”要复杂得多，但是做性能分析都遵循相同的基本步骤：</p><ol><li><strong>建立基准线</strong>，这样你就知道从何开始</li><li><strong>隔离代码</strong>，将可能有性能问题的代码与其他代码隔离开来</li><li><strong>优化代码</strong>，频繁的使用时间线（timelines）和性能分析器（profiles），在可控的条件下进行逐步优化</li></ol><p>还有一些性能优化的准则：</p><ol><li><strong>从最慢的部分开始</strong>，这样在时间优化上可以得到最大的提升</li><li><strong>保持环境统一</strong>，如果你换了电脑或者做了任何大的改动，都要设置新的基线</li><li><strong>多次分析</strong>以防电脑的异常而影响了结果的准确性</li></ol><p>每个人都想要自己的网站更快，同时还必须开发新的功能，但是新的功能通常会让网站更慢。所以花费时间来做性能优化是有价值的。</p><p>性能分析和优化使得<a href="http://zgrossbart.github.com/jsprofarticle/index6.htm" target="_blank" rel="external">最终版</a>的“颜色分类器”的执行时间减少了 92%。你的网站可以变快多少？</p><p>英文原文：<a href="http://coding.smashingmagazine.com/2012/06/12/javascript-profiling-chrome-developer-tools/" target="_blank" rel="external">Zack Grossbart</a>，翻译：<a href="http://bubkoo.com/">布谷 bubkoo</a></p><p>原文链接：<a href="http://coding.smashingmagazine.com/2012/06/12/javascript-profiling-chrome-developer-tools/" target="_blank" rel="external">JavaScript Profiling With The Chrome Developer Tools</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://coding.smashingmagazine.com/2012/06/12/javascript-profiling-chrome-developer-tools/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript Profiling With The Chrome Developer Tools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在，让我们来让你的网站跑得更快，网站性能通常包括两个方面：页面加载速度和脚本执行速度，有很多方法可以让网站加载更快，例如，压缩文件和 CND 等，但是要让脚本执行更快就得靠开发人员自己了。&lt;/p&gt;
&lt;p&gt;代码很小的改动就可能对性能产生巨大影响，不同位置的几行代码可能就意味着一个快的网站和产生可怕的“无响应脚本”对话框的网站之间的区别。本文展示了使用 Chrome 开发工具来找到这些性能关键点代码的一些方法。&lt;/p&gt;
&lt;h2 id=&quot;建立基准线&quot;&gt;&lt;a href=&quot;#建立基准线&quot; class=&quot;headerlink&quot; title=&quot;建立基准线&quot;&gt;&lt;/a&gt;建立基准线&lt;/h2&gt;&lt;p&gt;我们来看一个简单的&lt;a href=&quot;http://zgrossbart.github.io/jsprofarticle/index1.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;颜色排序应用&lt;/a&gt;，这个应用展示了一个由各种颜色构成的网格，您可以拖放任意一个颜色点来混淆。每一个颜色点都是一个 div 标签，使用了一些 CSS 来让它们看起来像一个圆点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/color%20sorter.png&quot; alt=&quot;Color Sorter&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zgrossbart.github.io/jsprofarticle/index1.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击这里&lt;/a&gt;访问该应用。&lt;/p&gt;
&lt;p&gt;生成一个这些颜色有点棘手，所以我参考了 &lt;a href=&quot;http://krazydad.com/tutorials/makecolors.php&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Making Annoying Rainbows in JavaScript&lt;/a&gt; 这篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Performance" scheme="http://bubkoo.com/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>【译】Javascript 基准测试</title>
    <link href="http://bubkoo.com/2014/02/18/bulletproof-javascript-benchmarks/"/>
    <id>http://bubkoo.com/2014/02/18/bulletproof-javascript-benchmarks/</id>
    <published>2014-02-18T20:51:29.000Z</published>
    <updated>2014-02-18T20:51:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文发表在 <a href="http://calendar.perfplanet.com/" target="_blank" rel="external">Performance Calendar</a> 上，作为其 2010 年系列文章的一部分。在<a href="http://bubkoo.com/2014/02/13/writing-fast-memory-efficient-javascript/">上一篇</a>翻译的文章中，作者推荐了这篇文章，译者阅读之后觉得有一定的价值，而且网络上没有这篇文章的中文翻译，权当学习就在此翻译成了中文，水平有限，如果有表达不恰当或者表达有误的地方，请直接在评论中指出。</p><p>原文链接：<a href="http://calendar.perfplanet.com/2010/bulletproof-javascript-benchmarks/" target="_blank" rel="external">Bulletproof JavaScript benchmarks</a>，下面开始翻译正文。</p><p>编写 JavaScript 基准测试并不是想象的那么容易，撇开潜在的跨浏览器兼容问题不说，还将面临很多陷阱（甚至诡雷）。</p><p>这也是我创建 <a href="http://jsperf.com/" target="_blank" rel="external">jsPerf</a> 的一部分原因，jsPerf 提供了一个非常简单的 Web 接口，您可以非常轻松地创建和分享不同代码片段的性能测试用例。您不需要考虑其他问题，只需要输入你想做基准测试的代码，jsPerf 就会为您创建一个运行在不同的浏览器和设备上测试用例。</p><p>其实，jsPerf 最开始使用的是一个基于 <a href="https://github.com/broofa/jslitmus" target="_blank" rel="external">JSLitmus</a> 的基准测试库 - <a href="https://github.com/mathiasbynens/benchmark.js" target="_blank" rel="external">Benchmark.js</a><br>。后来添加了很多新功能，最近，<a href="http://allyoucanleet.com/" target="_blank" rel="external">John-David Dalton</a><br> 又从头开始完全重写了该代码，Benchmark.js 也变得越来越完善。</p><p>本文将阐明编写和运行 JavaScript 基准测试的各种陷阱。<br><a id="more"></a></p><h2><span id="基准测试的方式">基准测试的方式</span></h2><p>目前，有很多方法可以对 JavaScript 代码片段进行性能基准测试。最常见的模式如下：</p><h3><span id="方式-a">方式 A</span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> totalTime,</div><div class="line">    start = <span class="keyword">new</span> <span class="built_in">Date</span>,</div><div class="line">    iterations = <span class="number">6</span>;</div><div class="line"><span class="keyword">while</span> (iterations--) &#123;</div><div class="line">  <span class="comment">// 您的 JavaScript 代码片段</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// totalTime → 代码片段的总共执行时间</span></div><div class="line"><span class="comment">// 代码片段循环了 6 次</span></div><div class="line">totalTime = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</div></pre></td></tr></table></figure><p>将要测试的代码片段放在一个循环中，并使其执行预定义的次数（这里是 6 次），然后，用结束时间减去开始时间就可以得到整个代码的执行时间。方式 A 被 <a href="https://github.com/kamicane/slickspeed/" target="_blank" rel="external">SlickSpeed</a>、<a href="https://github.com/phiggins42/taskspeed" target="_blank" rel="external">Taskspeed</a>、<a href="http://www2.webkit.org/perf/sunspider/sunspider.html" target="_blank" rel="external">SunSpider</a> 和 <a href="http://krakenbenchmark.mozilla.org/" target="_blank" rel="external">Kraken</a> 这样一些流行的基准测试组件采纳。</p><h3><span id="方式-a-的问题">方式 A 的问题</span></h3><p>由于浏览器和设备变得越来越快，方式 A 的测试很大可能会得到 0ms，这使得测试结果不可用。</p><h3><span id="方式-b">方式 B</span></h3><p>另一种方法是计算在指定时间段内可以执行多少次操作，这种方式的优点是不需要您指定一个迭代次数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hz,</div><div class="line">    period,</div><div class="line">    startTime = <span class="keyword">new</span> <span class="built_in">Date</span>,</div><div class="line">    runs = <span class="number">0</span>;</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">  <span class="comment">// 您的代码片段</span></div><div class="line">  runs++;</div><div class="line">  totalTime = <span class="keyword">new</span> <span class="built_in">Date</span> - startTime;</div><div class="line">&#125; <span class="keyword">while</span> (totalTime &lt; <span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 将毫秒转换成秒</span></div><div class="line">totalTime /= <span class="number">1000</span>;</div><div class="line"></div><div class="line"><span class="comment">// period → 执行每个操作需要的时间</span></div><div class="line">period = totalTime / runs;</div><div class="line"></div><div class="line"><span class="comment">// hz → 每秒可以执行多少个操作</span></div><div class="line">hz = <span class="number">1</span> / period;</div><div class="line"></div><div class="line"><span class="comment">// 可以简写为</span></div><div class="line"><span class="comment">// hz = (runs * 1000) / totalTime;</span></div></pre></td></tr></table></figure><p>这里的代码片段大约执行了 1 秒钟，方式 B 被使用在 <a href="http://dromaeo.com/" target="_blank" rel="external">Dromaeo</a> 和  <a href="http://code.google.com/apis/v8/benchmarks.html" target="_blank" rel="external">V8 基准测试组件</a>中。</p><h3><span id="方式-b-的问题">方式 B 的问题</span></h3><p>在进行这种基准测试时，由于垃圾回收机制、引擎优化和其他后台进程的影响，测试结果会有所不同。由于这种差异，就需要运行数次基准测试代码来取得平均结果。然而，在 V8 中每个基准测试只会运行 1 次，Dromaeo 也仅仅只会运行 5 次。我们可以通过运行更多次来减少误差幅度，方法之一是通过减少每次基准测试运行的时间，例如从 1000ms 减少到 50ms，这样在相同的时间内就可以运行更多次数的基准测试。</p><h3><span id="方式-c">方式 C</span></h3><p><a href="http://www.broofa.com/Tools/JSLitmus/" target="_blank" rel="external">JSLitmus</a> 是基于上面这两种方式来构建的，它使用方式 A 来将一个测试运行 n 次，同时使用方式 B 来动态增加 n 来保持测试运行，直到达到最小测试时间。</p><h3><span id="方式-c-的问题">方式 C 的问题</span></h3><p>JSLitmus 避免了方式 A 的问题，但仍有方式 B 的问题。为了提高结果的准确性，JSLitmus 通过获取三次空测试中最快的那个时间，然后将每次基准测试的时间减去这个最快时间，来校准测试结果。不幸的是，这种方法混淆了最终结果，因为“获取 3 个空测试中的最快时间”不是一个统计上有效的方法。虽然 JSLitmus 运行基准测试数次，并且从基准测试的平均结果中减去了校验平均值，还是增加了最终结果的误差幅度，也吞噬了增加准确性的希望。</p><h3><span id="方式-d">方式 D</span></h3><p>方式 A、B 和 C 的缺点可以通过编译函数和展开循环来避免。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  x == y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (iterations--) &#123;</div><div class="line">  test();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ...would compile to →</span></div><div class="line"><span class="keyword">var</span> hz,</div><div class="line">    startTime = <span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line"></div><div class="line">x == y;</div><div class="line">x == y;</div><div class="line">x == y;</div><div class="line">x == y;</div><div class="line">x == y;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">hz = (runs * <span class="number">1000</span>) / (<span class="keyword">new</span> <span class="built_in">Date</span> - startTime);</div></pre></td></tr></table></figure><h3><span id="方式-d-的问题">方式 D 的问题</span></h3><p>然而，这也有它的短板。编译函数会大大增加内存使用量和减慢您的CPU，当您重复运行测试几百万次时，基本上就等于创建了一个非常大的字符串和编译了一个庞大的函数。</p><p>使用展开循环的另一个警告是，<code>return</code> 语句可以使测试提前退出。花了很大成本去编译一个有数百万行代码的函数，然而这个函数在执行到第 3 行就返回了，这非常没有意义。有必要进行早期退出检测，如果有早期退出就回到使用 while 循环的模式，并在需要时通过循环校准。</p><h3><span id="提取函数体">提取函数体</span></h3><p>Benchmark.js 使用了稍微有些不同的方法，可以说它使用了前面四种方式中的最好的部分。因为内存问题，我们不展开循环，为了减少可能会使结果不准确的因素，并允许测试访问本地方法和变量，我们在每个测试中提取出函数体。例如，当测试这样的代码时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>,</div><div class="line">    y = <span class="string">"1"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  x == y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (iterations--) &#123;</div><div class="line">  test();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ...would compile to →</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>,</div><div class="line">    y = <span class="string">"1"</span>;</div><div class="line"><span class="keyword">while</span> (iterations--) &#123;</div><div class="line">  x == y;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，Benchmark.js 使用了和 JSLitmus 类似的方法：将提取的函数体放在一个 while 循环中运行（方式 A），重复运作直到达到最小的运行次数（方式 B），并将整个过程重复数次，来得到有统计意义的结果。</p><h2><span id="需要考虑的问题">需要考虑的问题</span></h2><h3><span id="不准确的毫秒计时器">不准确的毫秒计时器</span></h3><p>在一些浏览器/操作系统中，由于<a href="http://www.microsoft.com/whdc/system/sysinternals/mm-timer.mspx#EQB" target="_blank" rel="external">各种各样</a>的<a href="http://alivebutsleepy.srnet.cz/unreliable-system-nanotime/" target="_blank" rel="external">因素</a>，计时器可能是不准确的。</p><p>例如：</p><blockquote><p>当 Windows XP 启动后，典型的默认时钟中断期是 10 毫秒，尽管在一些系统使用的是 15 毫秒。这意味着，每 10 毫秒，操作系统就接收来自系统定时器硬件中断通知。</p></blockquote><p>一些老的浏览器（IE，Firefox 2）依靠内部操作系统的定时器，这意味着每次调用 <code>new Date().getTime()</code> 都是直接从操作系统中获取。很明显，如果内部定时器每 10 或 15毫秒才更新，是的测试结果的准确性大大降低。我们需要解决这个问题。</p><p>幸运的是，可以使用 JavaScript 来<a href="http://mathiasbynens.be/demo/javascript-timers" target="_blank" rel="external">获得最小测量单位</a>，然后，通过一个<a href="http://spiff.rit.edu/classes/phys273/uncert/uncert.html" target="_blank" rel="external">数学方法</a>来使我们的测试结果的不确定度减少到 1% 。要做到这一点，我们需要将测量的最小单位除以 2 来得到的不确定度。假如我们正在 Windows XP 上使用 IE6，最小测量单位是 15 毫秒，那么不确定度就是 15ms / 2 = 7.5ms，然后将其除以 0.01（1%），这样就得到了我们所需的最小测试时间是：7.5ms / 0.01 = 750ms。</p><h3><span id="替代计时器">替代计时器</span></h3><p>当使用 <code>--enable-benchmarking</code> 标志来启动 Chrome 时，Chrome 将暴露 <code>chrome.Interval</code> 方法，这个可以用作一个高精度微秒计时器。</p><p>回到我们的 Benchmark.js，John-David Dalton 偶然发现了 <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/System.html#nanoTime" target="_blank" rel="external">Java 中的纳秒计时器</a>，并通过一个<a href="https://github.com/mathiasbynens/benchmark.js/blob/master/nano.java#files" target="_blank" rel="external">微小的 Java 应用</a>提供给 JavaScript 使用。</p><p>使用高精度计时器可以将测试时间分类，它允许更大的样本大小，减小了结果的误差幅度。</p><h3><span id="firebug-会禁用-firefox-的-jit">Firebug 会禁用 Firefox 的 JIT</span></h3><p>开启 Firebug 插件会禁用 Firefox 所有的高性能实时（JIT）本地代码编译功能，这意味着你会在解释器运行这些测试，也就是说，您的测试将运行得非常缓慢。你应该永远记住，在 Firefox 下进行基准测试时要禁用 Firebug 插件。</p><p>虽然这个影响似乎要小得多，这同样也适用于有 inspector 工具的其他浏览器，比如 WebKit 的 Web Inspector 或 Opera 的 Dragonfly。在进行基准测试时避免这些打开这些工具，因为它可能会影响结果。</p><h3><span id="浏览器-bug-和特性">浏览器 bug 和特性</span></h3><p>基准测试中某些形式的循环机制容易受到浏览器一些怪癖的影响，比如最近 IE9 的 <a href="http://www.zdnet.com/blog/bott/ie9-takes-top-benchmark-prize-no-cheating-involved/2671" target="_blank" rel="external">dead-code-removal</a> 的演示，Mozilla 浏览器的 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=509069" target="_blank" rel="external">TraceMonkey engine bug</a>，还有 Opera 的 <a href="http://jsperf.com/jquery-css3-not-vs-not" target="_blank" rel="external">caching of qSA results</a> 也将导致基准测试结果的不准确。当创建基准测试时，记住这些非常重要。</p><h3><span id="统计学意义">统计学意义</span></h3><p>大多数基准测试产生的结果没都有统计学意义，John Resig 在他的文章（<a href="http://ejohn.org/blog/javascript-benchmark-quality/" target="_blank" rel="external">JavaScript benchmark quality</a>）中讨论过这个问题。总之，有必要考虑每个结果的误差幅度，并尽可能减少。使用更大的样本量，并沉着等待测试完成，有助于减少误差幅度。</p><h3><span id="跨浏览器测试">跨浏览器测试</span></h3><p>如果你想在不同的浏览器下运行基准测试并得到可靠的结果，一定要在真正的浏览器环境中进行测试。不要信任 IE 的兼容模式 - 这些都<a href="http://jsperf.com/join-concat#comments" target="_blank" rel="external">不同于实际的浏览器版本</a>。</p><p>同时，请注意这一事实，IE（IE8 及其以下）将脚本的最大指令数限制为 500 万，而不是像其他浏览器一样，限制一个脚本的执行时间。在现代的硬件环境下，一个密集型 CPU 可以在半秒内触发这个脚本，如果你有一个相当快的系统，在 IE 中你可能会遇到“脚本警告”对话框，在这种情况下，最好的解决方案是修改您的 Windows 注册表，增加指令的数量。幸运的是，微软提供了一个简单的方法来做这个，所有你需要做的就是运行一个简单的“修复”向导，更好的是，在 IE9 中删除了这个愚蠢的限制。</p><h2><span id="结论">结论</span></h2><p>不管您只是运行一些基准测试，还是编写自己的测试套件，甚至是编写您自己的基准测试库，都比您在本文中看到的要复杂得多。Benchmark.js 和 jsPerf <a href="https://github.com/mathiasbynens/benchmark.js/commits/master" target="_blank" rel="external">每周更新一次</a>，伴随着 bug 的修复、新的特性和一些提高测试结果的准确性的小技巧。如果您只想在当前流行的浏览器下做一些基准测试，那就不要重复造轮子。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文发表在 &lt;a href=&quot;http://calendar.perfplanet.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Performance Calendar&lt;/a&gt; 上，作为其 2010 年系列文章的一部分。在&lt;a href=&quot;http://bubkoo.com/2014/02/13/writing-fast-memory-efficient-javascript/&quot;&gt;上一篇&lt;/a&gt;翻译的文章中，作者推荐了这篇文章，译者阅读之后觉得有一定的价值，而且网络上没有这篇文章的中文翻译，权当学习就在此翻译成了中文，水平有限，如果有表达不恰当或者表达有误的地方，请直接在评论中指出。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://calendar.perfplanet.com/2010/bulletproof-javascript-benchmarks/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bulletproof JavaScript benchmarks&lt;/a&gt;，下面开始翻译正文。&lt;/p&gt;
&lt;p&gt;编写 JavaScript 基准测试并不是想象的那么容易，撇开潜在的跨浏览器兼容问题不说，还将面临很多陷阱（甚至诡雷）。&lt;/p&gt;
&lt;p&gt;这也是我创建 &lt;a href=&quot;http://jsperf.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jsPerf&lt;/a&gt; 的一部分原因，jsPerf 提供了一个非常简单的 Web 接口，您可以非常轻松地创建和分享不同代码片段的性能测试用例。您不需要考虑其他问题，只需要输入你想做基准测试的代码，jsPerf 就会为您创建一个运行在不同的浏览器和设备上测试用例。&lt;/p&gt;
&lt;p&gt;其实，jsPerf 最开始使用的是一个基于 &lt;a href=&quot;https://github.com/broofa/jslitmus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSLitmus&lt;/a&gt; 的基准测试库 - &lt;a href=&quot;https://github.com/mathiasbynens/benchmark.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Benchmark.js&lt;/a&gt;&lt;br&gt;。后来添加了很多新功能，最近，&lt;a href=&quot;http://allyoucanleet.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;John-David Dalton&lt;/a&gt;&lt;br&gt; 又从头开始完全重写了该代码，Benchmark.js 也变得越来越完善。&lt;/p&gt;
&lt;p&gt;本文将阐明编写和运行 JavaScript 基准测试的各种陷阱。&lt;br&gt;
    
    </summary>
    
    
      <category term="Performance" scheme="http://bubkoo.com/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>【译】编写快速、高效的 JavaScript</title>
    <link href="http://bubkoo.com/2014/02/13/writing-fast-memory-efficient-javascript/"/>
    <id>http://bubkoo.com/2014/02/13/writing-fast-memory-efficient-javascript/</id>
    <published>2014-02-13T13:35:27.000Z</published>
    <updated>2014-02-13T13:35:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文连接：<a href="http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/" target="_blank" rel="external">Writing Fast, Memory-Efficient JavaScript</a> </p><p>许多 JavaScript 引擎都是为了快速执行的大型 JavaScript 应用程序设计而特别设计，如 Google <a href="http://code.google.com/p/v8/" target="_blank" rel="external">V8</a> 引擎（正被 Chrome 和 <a href="http://nodejs.org/" target="_blank" rel="external">NodeJS</a> 使用）。在开发过程中，如果你关心内存使用情况和页面性能，你应该了解户浏览器的 JavaScript 引擎的内部运作原理。</p><p>无论是V8、<a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey" target="_blank" rel="external">SpiderMonkey</a>（Firefox）、<a href="http://my.opera.com/ODIN/blog/carakan-faq" target="_blank" rel="external">Carakan</a>（Opera）、<a href="http://en.wikipedia.org/wiki/Chakra_(JScript_engine" target="_blank" rel="external">Chakra</a>)（IE）或其他 JavaScript  引擎，了解引擎背后的一些运行机制可以帮助你<strong>更好地优化你的应用程序</strong>。但，这并不是说应该专门为某一浏览器或引擎进行程序的优化，而且，永远不要这样做。</p><p>你应该先问自己下面几个问题：</p><ul><li>我可以做些什么来让我的代码更加高效</li><li>主流的 JavaScript 引擎都做了哪些优化</li><li>什么是引擎无法优化的，垃圾回收器是不是按照我预想的那样，回收了我不需要的内存空间</li></ul><p>在我们编写高效、快速的代码的时候，有许多常见的陷阱，本文将讨论一些经过验证的、更好的编写代码的方式。<br><a id="more"></a></p><h2><span id="那么javascript-在-v8-中是如何工作的呢">那么，JavaScript 在 V8 中是如何工作的呢？</span></h2><p>虽然在没有彻底了解J avaScript 引擎的情况下，也可以开发出大型应用，就好比会开车的人不都看过车盖下的引擎一样。Chrome 作为我的首选浏览器，所以我将简单聊一下它的 JavaScript 引擎的工作机制，V8 引擎由以下几个核心部分组成：</p><ul><li><strong>基本编译器（base compiler）</strong>，在你的代码运行之前，它会分析你的 JavaScript 代码并生成本地机器码，而不是执行字节码或简单地解释它。这种机器码起初是没有被高度优化的。</li><li>V8 将对象解析为<strong>对象模型（object model）</strong>。对象是在 JavaScript 中是以关联数组的方式呈现的，但是在 V8 引擎中，它们是通过隐藏类（<a href="https://developers.google.com/v8/design" target="_blank" rel="external">hidden classes</a>）的方式来表示的。这是一种可以优化查找的内部类型机制。</li><li><strong>一个运行时分析器（runtime profiler）</strong>，它监视正在运行的系统，并标识 “hot” 函数，也就是那些最后会花费大量运行时间的代码。</li><li><strong>一个优化编译器（optimizing compiler）</strong>，它重新编译和优化那些被运行时分析器标识为 “hot” 的代码，并进行 “内联” 等优化（例如，在函数被调用的地方用函数主体去取代）。</li><li>V8支持<strong>逆优化（deoptimization）</strong>，这意味着，如果优化编译器发现在某些假定的情况下，把一些已经优化的代码进行了过度的优化，它会舍弃优化后的代码。</li><li><strong>垃圾回收器</strong>，理解它的运作原理和理解如何优化你的JavaScript代码同等重要。</li></ul><h2><span id="垃圾回收">垃圾回收</span></h2><p>垃圾回收是<strong>内存管理的一种机制</strong>，垃圾回收器的概念是，它将试图回收那些不再被使用的对象所占据的内存，在像 JavaScript 这种支持垃圾回收的语言中，如果程序中仍然存在指向一个对象的引用，那么该对象将不会被回收。</p><p>在大多数情况下，我们没有必要去手动得解除对象的引用（de-referencing）。只需要简单滴将变量放在需要它们的位置（在理想的情况下，尽可能使用局部变量，也就是说，在它们被使用的函数中声明它们，而不是在更外层的作用域），垃圾就能正确地被回收。</p><p>在 JavaScript 中，强制进行垃圾回收是不可能的，而且你也不应该尝试这样做，因为垃圾回收是由运行时控制，并且它通常知道垃圾回收的最佳时机。</p><p><img src="http://bubkoo.qiniudn.com/robot-cleaner.jpg" alt=""></p><h2><span id="删除引用的误解">删除引用的误解</span></h2><p>在网上不少关于 JavaScript 内存回收问题的讨论中，<code>delete</code> 操作符频繁被提及，虽然它可以用来删除对象（map）的属性（key），但是一些开发者认为它可以用来强制删除引用。在可能的情况下，尽量避免使用 <code>delete</code>，在下面例子中 <code>delete o.x</code> 的弊大于利，因为它改变了 <code>o</code> 的“隐藏类”，并使它成为一个“慢对象”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;; </div><div class="line"><span class="keyword">delete</span> o.x; <span class="comment">// true </span></div><div class="line">o.x; <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>尽管如此，你肯定会发在许多流行的 JavaScript 库中使用了 delete - 这有它语言目的。这里的主旨是，避免在运行时修改 “hot” 对象的结构，JavaScript 引擎可以检测到这些 “hot” 的对象，并尝试对其进行优化。如果在对象的生命期中没有遇到重大的结构改变，引擎的检测和优化过程会来得更加容易，而使用 <code>delete</code> 则会触发对象结构上的这种改变。</p><p>不少人对 <code>null</code> 的使用上也存在误解。将一个对象引用设置为 <code>null</code>，并不是意味着“清空”该对象，只是将它的引用指向 <code>null</code>。使用 <code>o.x = null</code> 比使用 <code>delete</code> 会更好些，但这甚至可能也是不必要的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;; </div><div class="line">o = <span class="literal">null</span>;</div><div class="line">o; <span class="comment">// null</span></div><div class="line">o.x <span class="comment">// TypeError</span></div></pre></td></tr></table></figure><p>如果此引用是当前对象的最后引用，那么该对象就满足了垃圾回收的资格。如果此引用不是当前对象的最后引用，则该对象是可访问的，而不会被垃圾回收。</p><p>另外需要注意的是，全局变量在页面的生命周期中是不会被垃圾回收器清理的。只要页面保持打开状态，全局对象就会常驻在内存当中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myGlobalNamespace = &#123;&#125;;</div></pre></td></tr></table></figure><p>只有当刷新页面、导航到其他页面、关闭标签页或退出浏览器时，全局变量才会被清理。函数作用域的变量超出作用域范围时，它就会被清理。当函数完全结束，并且再没有任何引用指向其中的变量，函数中的变量会被清理。</p><h2><span id="经验法则">经验法则</span></h2><p>为了使垃圾回收器尽早回收尽可能多的对象，<strong>请不要保留（hold on）不再需要的对象</strong>。这里有几点需要谨记：</p><ul><li>就像之前所说的那样，比手动删除变量引用更好的方式是，在恰当的作用域中使用变量，例如，尽量在函数作用域中声明变量，而尽可能不要声明不会被回收的全局变量，这将意味着更干净更省心的代码。</li><li>确保解绑那些不再需要的事件监听器，尤其是那些即将被移除的 DOM 对象所绑定的事件。</li><li>如果你正在使用数据缓存，确保手动清理缓存或者使用衰老机制，避免缓存中储存大量不会被重用的数据。</li></ul><h2><span id="函数">函数</span></h2><p>接下来，我们讨论一下函数。正如我们前面所说，垃圾回收是通过回收那些不会再被使用的内存块（对象）来工作的。更好的说明这个问题，我们来看几个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> bar = <span class="keyword">new</span> LargeObject();</div><div class="line">    bar.someCall();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当 <code>foo</code> 返回时，变量 <code>bar</code> 所指向的对象将被垃圾回收，因为已经没有任何引用指向该对象了。</p><p>对比一下下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> bar = <span class="keyword">new</span> LargeObject();</div><div class="line">    bar.someCall();</div><div class="line">    <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// somewhere else</span></div><div class="line"><span class="keyword">var</span> b = foo();</div></pre></td></tr></table></figure><p>现在有一个指向 <code>bar</code> 对象的引用，当 <code>foo</code> 调用结束后，<code>bar</code> 对象不会被回收，直到到给变量 <code>b</code> 分配其他引用（或者 <code>b</code> 超出了作用域范围）。</p><h2><span id="闭包">闭包</span></h2><p>在一个外部函数中返回一个内部的函数，在内部函数中含有对外部函数作用域中变量的引用，当外部函数返回时，外部函数作用域中的变量不会被垃圾回收器回收，这样就构成了一个<a href="http://robertnyman.com/2008/10/09/explaining-javascript-scope-and-closures/" target="_blank" rel="external">闭包</a>。看下面例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sumIt</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> x + y;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> sumIt;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Usage</span></div><div class="line"><span class="keyword">var</span> sumA = sum(<span class="number">4</span>);</div><div class="line"><span class="keyword">var</span> sumB = sumA(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(sumB); <span class="comment">// Returns 7</span></div></pre></td></tr></table></figure><p>在 <code>sum</code> 调用上下文中生成的函数对象 <code>sumIt</code> 是无法被回收的，它被全局变量 <code>sumA</code> 所引用，并且可以通过 <code>sumA(n)</code> 来执行。</p><p>请看另外一个例子，可以访问变量 <code>largeStr</code> 吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> largeStr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'x'</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> largeStr;</div><div class="line">    &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure><p>答案是肯定的，我们可以通过调用 <code>a()</code> 访问 <code>largeStr</code>，所以它不会被回收。那下面这个呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> smallStr = <span class="string">'x'</span>;</div><div class="line">    <span class="keyword">var</span> largeStr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'x'</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> smallStr;</div><div class="line">    &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure><p>我们不能再访问 <code>largeStr</code> 了，因为内部函数并没有将其返回，它会成为垃圾回收的候选对象。</p><h2><span id="定时器">定时器</span></h2><p>最糟的内存泄漏之一是在循环或 <code>setTimeout/setInterval</code> 中，但这相当常见。</p><p>思考下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObj = &#123;</div><div class="line">    callMeMaybe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> myRef = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">var</span> val = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'Time is running out!'</span>); </div><div class="line">            myRef.callMeMaybe();</div><div class="line">        &#125;, <span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>当我们调用 <code>callMeMaybe</code> 来启动定时器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myObj.callMeMaybe();</div></pre></td></tr></table></figure><p>在 console 控制台中，每秒输出 “Time is running out!” 。</p><p>如果接着运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myObj = <span class="literal">null</span></div></pre></td></tr></table></figure><p>定时器仍然会被触发，由于闭包将 <code>myObj</code> 传递给 <code>setTimeout</code> ，这样 <code>myObj</code> 指向的对象就无法被回收，通过 <code>myRef</code> 保持着对 <code>myObj</code> 的引用。如果我们把该闭包函数传入其他任何的函数，同样的事情一样会发生，函数中仍然会存在指向对象的引用。</p><p>同样值得牢记的是，<code>setTimeout/setInterval</code> 调用(如函数)中的引用，在运行完成之前是不会被垃圾回收的。</p><h2><span id="当心性能陷阱">当心性能陷阱</span></h2><p>很重要的一点是，除非你真正需要，否则没有必要优化你的代码，这个怎么强调都不为过。现在经常可以看到一些基准测试，显示 N 比 M 在 V8 中更为优化，但是如果在真实的代码模型或者在真正的应用程序中进行测试，<strong>这些优化真正的效果比你期望的要小的多</strong>。</p><p><img src="http://bubkoo.qiniudn.com/speed-trap.jpg" alt="做的过多还不如什么都不做"></p><p>假设我们想要创建一个这个的模块：</p><ul><li>需要一个本地的数据源，每项数据包含数字 ID</li><li>绘制一个包含这些数据的表格</li><li>添加事件处理程序，当用户点击的任何单元格时切换单元格的 class</li></ul><p>对于这个模块需要注意几个问题，虽然这些问题很容易解决。如何存储这些数据？如何高效地绘制表格并将它添加到 DOM 中？如何更优地处理表格事件？</p><p>第一个（也是幼稚的）的方案可能是将每块数据存储在一个对象数中，然后把所有数据对象放到一个数组中。有人也许会使用 jQuery 去循环访问数组，生成表格内容，然后把它添加到 DOM 中，最后使用事件绑定我们期望地点击行为。</p><p><strong>注意：你千万不要这样做</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> moduleA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line"></div><div class="line">        data: dataArrayObject,</div><div class="line"></div><div class="line">        init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.addTable();</div><div class="line">            <span class="keyword">this</span>.addEvents();</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        addTable: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">                $tr = $(<span class="string">'&lt;tr&gt;&lt;/tr&gt;'</span>);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.data.length; j++) &#123;</div><div class="line">                    $tr.append(<span class="string">'&lt;td&gt;'</span> + <span class="keyword">this</span>.data[j][<span class="string">'id'</span>] + <span class="string">'&lt;/td&gt;'</span>);</div><div class="line">                &#125;</div><div class="line">                $tr.appendTo($tbody);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;,</div><div class="line">        addEvents: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            $(<span class="string">'table td'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                $(<span class="keyword">this</span>).toggleClass(<span class="string">'active'</span>);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure><p>代码虽简单，但也完成了我们需要的功能。</p><p>然而，在这种情况下我们需要迭代的唯一数据是数值类型的 ID，可以直接用标准数组来储存这些数据。有趣的是，在生成表格时，直接使用 <code>DocumentFragment</code> 对象和原生操作 DOM 的方法要比使用 jQuery 更优。同时，使用事件代理比为每个 <code>td</code> 都进行事件绑定会有更好的性能。</p><p>细心的同学会想： jQuery 内部也使用 <code>DocumentFragment</code> 进行了优化啊，但在我们的例子中，代码中在循环中调用 <code>append()</code>，每一次调用都要进行额外的操作，因此在这里起到的优化作用不大。希望这不会是一个痛点，但是一定要用基准测试来确保自己的代码没有问题。</p><p>对于我们的例子，添加以上这些优化会带来一些不错（预期）的性能提升。相对于简单的绑定，事件委托提供了相当好的改进，且选择用 <code>documentFragment</code> 会是一个真正的<a href="http://jsperf.com/first-pass" target="_blank" rel="external">性能助推器</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> moduleD = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line"></div><div class="line">        data: dataArray,</div><div class="line"></div><div class="line">        init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.addTable();</div><div class="line">            <span class="keyword">this</span>.addEvents();</div><div class="line">        &#125;,</div><div class="line">        addTable: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> td, tr;</div><div class="line">            <span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line">            <span class="keyword">var</span> frag2 = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">                tr = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.data.length; j++) &#123;</div><div class="line">                    td = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</div><div class="line">                    td.appendChild(<span class="built_in">document</span>.createTextNode(<span class="keyword">this</span>.data[j]));</div><div class="line"></div><div class="line">                    frag2.appendChild(td);</div><div class="line">                &#125;</div><div class="line">                tr.appendChild(frag2);</div><div class="line">                frag.appendChild(tr);</div><div class="line">            &#125;</div><div class="line">            tbody.appendChild(frag);</div><div class="line">        &#125;,</div><div class="line">        addEvents: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            $(<span class="string">'table'</span>).on(<span class="string">'click'</span>, <span class="string">'td'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                $(<span class="keyword">this</span>).toggleClass(<span class="string">'active'</span>);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;();</div></pre></td></tr></table></figure><p>我们可能还会寻找其他的方案来提高性能。你也许曾经在其他地方读到过使用<strong>原型模式</strong>比<strong>模块模式</strong>更加优化（我们不久前已经证明了事实并非如此），或听说过使用 JavaScript 模版框架性能更好。有时确实如此，不过使用它们其实是为了让代码更具可读性，同时，还有预编译！让我们测试一下，实际上这有多少是能带来真正优化的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">moduleG = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"> </div><div class="line">moduleG.prototype.data = dataArray;</div><div class="line">moduleG.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.addTable();</div><div class="line">    <span class="keyword">this</span>.addEvents();</div><div class="line">&#125;;</div><div class="line">moduleG.prototype.addTable = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> template = _.template($(<span class="string">'#template'</span>).text());</div><div class="line">    <span class="keyword">var</span> html = template(&#123;<span class="string">'data'</span> : <span class="keyword">this</span>.data&#125;);</div><div class="line">    $tbody.append(html);</div><div class="line">&#125;;</div><div class="line">moduleG.prototype.addEvents = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   $(<span class="string">'table'</span>).on(<span class="string">'click'</span>, <span class="string">'td'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       $(<span class="keyword">this</span>).toggleClass(<span class="string">'active'</span>);</div><div class="line">   &#125;);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> modG = <span class="keyword">new</span> moduleG();</div></pre></td></tr></table></figure><p>事实证明，在这种情况下的带来的性能提升可以忽略不计。<a href="http://jsperf.com/second-pass" target="_blank" rel="external">选择模板和原型</a>不会真正带来多大的性能提升。据说，性能并不是现代开发者使用它们的真正原因，给代码带来可读性、继承模型和可维护性才是真正的原因。</p><p>更复杂的问题包括如何<a href="http://jsperf.com/canvas-drawimage-vs-webgl-drawarrays/6" target="_blank" rel="external">高效地在 canvas 上绘制图片</a>和使用或不使用<a href="http://jsperf.com/typed-arrays-for-pixel-manipulation" target="_blank" rel="external">类型数组</a>去<a href="http://jsperf.com/canvas-pixel-manipulation/30" target="_blank" rel="external">操作像素数据</a>。</p><p>在将一些方法用在你自己的应用之前，一定要多了解这些方案的基准测试。也许有人还记得 <a href="http://jsperf.com/dom-vs-innerhtml-based-templating/473" target="_blank" rel="external">JavaScript 模版的 shoot-off</a> 和<a href="http://jsperf.com/javascript-templating-shootoff-extended/26" target="_blank" rel="external">随后的扩展版</a>。如果你想确保测试不会被现实的应用程序的中你看不到的约束所影响，请在真实的代码中和优化一起测试。</p><h2><span id="v8-优化技巧">V8 优化技巧</span></h2><p>详细的介绍每一个 V8 引擎的每一种优化点显然超出了本文的讨论范围，其中有许多特定的优化技巧值得注意，记住这些技巧你就能减少写出那些性能低下的代码的可能性。</p><ul><li>特定的模式会导致 V8 放弃优化。例如使用 try-catch，就会导致这种情况的发生。如果想要了解跟多关于什么函数可以被优化，什么函数不可以，你可以在 V8 引擎中附带的 D8shell 中使用 –trace-optfile.js 命令。</li><li>如果你关心运行速度，尽量使你的函数职责单一，即确保变量（包括属性，数组，函数参数）只使用相同隐藏类包含的对象。举个例子，永远不要干这种事：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123; </div><div class="line">   <span class="keyword">return</span> x+y;</div><div class="line">&#125; </div><div class="line"> </div><div class="line">add(<span class="number">1</span>, <span class="number">2</span>); </div><div class="line">add(<span class="string">'a'</span>,<span class="string">'b'</span>); </div><div class="line">add(my_custom_object, <span class="literal">undefined</span>);</div></pre></td></tr></table></figure><ul><li>不要从未初始化的或已经被删除的元素上加载内容。如果这么做也不会出现什么错误，但是它会使得程序运行得更慢。</li><li>不要使函数体过大，这样会使得优化更加困难。</li></ul><p>如果想知道更多的优化技巧，可以观看 Daniel Clifford 在 Google I/O 大会上的演讲 <a href="http://www.youtube.com/watch?v=UJPdhx5zTaw" target="_blank" rel="external">Breaking the JavaScript Speed Limit with V8</a>，它同时也涵盖了上面我们所说的优化技巧。 <a href="http://floitsch.blogspot.co.uk/2012/03/optimizing-for-v8-introduction.html" target="_blank" rel="external">Optimizing For V8 — A Series</a> 也非常值得一读。</p><h3><span id="对象-vs-数组我应该用哪个">对象 VS 数组：我应该用哪个？</span></h3><ul><li>如果你想存储一串数字，或者一些相同类型的对象，使用一个数组。</li><li>如果你语义上需要的是一堆对象的属性（不同类型），使用一个对象和属性。这在内存方面非常高效，速度也相当快。</li><li>整数索引的元素，无论存储在一个数组或对象中，都要<a href="http://jsperf.com/performance-of-array-vs-object/3" target="_blank" rel="external">比遍历对象的属性快得多</a>。</li><li>对象的属性比较复杂：它们可以被 setter 创建，具有不同的枚举性和可写性。数组中则不具有如此的定制性，而只存在有和无这两种状态，在引擎层面，这允许更多存储结构方面的优化，特别是当数组中存放数字时。例如，当你需要向量时，不用定义具有 x，y，z 属性的类，只用数组就可以了。</li></ul><p>JavaScript 中对象和数组之间只有一个的主要区别，那就是数组神奇的 length 属性。如果你自己来维护这个属性，那么 V8 中对象和数组的速度是一样快。</p><h3><span id="使用对象的提示">使用对象的提示</span></h3><ul><li><strong>使用一个构造函数来创建对象</strong>。这将确保它创建的所有对象具有相同的隐藏类，并有助于避免更改这些类。有一个额外的好处就是，它也略快于 <code>Object.create()</code>。</li><li>在程序中，对象属性的数量和其复杂度并没有限制，但请注意，长原型链往往是有害的，并且只有一些极少数属性的小对象比大对象会快一点。对于 “hot” 对象，尽量保持短原型链，并且少属性。</li></ul><h3><span id="对象克隆">对象克隆</span></h3><p>对象克隆对于应用开发者来说是一种常见的问题。虽然各种基准测试可以证明 V8 对这个问题处理得很好，但仍要小心。当复制较大的对象时通常很会慢，因此，尽量不要这么做。JavaScript 中的 <code>for..in</code> 循环尤其糟糕，因为它有着恶魔般的规范，并且无论是在哪个引擎对于哪个对象，都不可能快得起来。</p><p>当你不得不要在一些关键性能代码中复制对象时，使用数组或一个自定义的“拷贝构造函数”来明确地复制每个属性。这可能是最快的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">original</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.foo = original.foo;</div><div class="line">  <span class="keyword">this</span>.bar = original.bar;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> copy = <span class="keyword">new</span> clone(original);</div></pre></td></tr></table></figure><h3><span id="模块模式中缓存函数">模块模式中缓存函数</span></h3><p>使用模块模式时缓存函数，可能会带来性能方面的提升。参阅下面的例子，因为它总是创建成员函数的新副本，你看到的变化可能会比较慢。</p><p>另外请注意，使用这种方法明显更优，不仅仅是依靠原型模式（经过jsPerf测试确认）。</p><p><img src="http://bubkoo.qiniudn.com/test%20of%20prototype%20versus%20module%20pattern%20performance.png" alt="使用模块模式或原型模式时的性能提升"></p><p>这是一个<a href="http://jsperf.com/prototypal-performance/12" target="_blank" rel="external">原型模式与模块模式的性能对比测试</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型模式</span></div><div class="line">  Klass1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">  Klass1.prototype.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      log(<span class="string">'foo'</span>);</div><div class="line">  &#125;</div><div class="line">  Klass1.prototype.bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      log(<span class="string">'bar'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 模块模式</span></div><div class="line">  Klass2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          log(<span class="string">'foo'</span>);</div><div class="line">      &#125;,</div><div class="line">      bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          log(<span class="string">'bar'</span>);</div><div class="line">      &#125;;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">          foo: foo,</div><div class="line">          bar: bar</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// 模块模式和缓存函数</span></div><div class="line">  <span class="keyword">var</span> FooFunction = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      log(<span class="string">'foo'</span>);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">var</span> BarFunction = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      log(<span class="string">'bar'</span>);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  Klass3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">          foo: FooFunction,</div><div class="line">          bar: BarFunction</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// 下面是基准测试</span></div><div class="line"></div><div class="line">  <span class="comment">// 原型模式</span></div><div class="line">  <span class="keyword">var</span> i = <span class="number">1000</span>,</div><div class="line">      objs = [];</div><div class="line">  <span class="keyword">while</span> (i--) &#123;</div><div class="line">      <span class="keyword">var</span> o = <span class="keyword">new</span> Klass1()</div><div class="line">      objs.push(<span class="keyword">new</span> Klass1());</div><div class="line">      o.bar;</div><div class="line">      o.foo;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 模块模式</span></div><div class="line">  <span class="keyword">var</span> i = <span class="number">1000</span>,</div><div class="line">      objs = [];</div><div class="line">  <span class="keyword">while</span> (i--) &#123;</div><div class="line">      <span class="keyword">var</span> o = Klass2()</div><div class="line">      objs.push(Klass2());</div><div class="line">      o.bar;</div><div class="line">      o.foo;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 模块模式和缓存函数</span></div><div class="line">  <span class="keyword">var</span> i = <span class="number">1000</span>,</div><div class="line">      objs = [];</div><div class="line">  <span class="keyword">while</span> (i--) &#123;</div><div class="line">      <span class="keyword">var</span> o = Klass3()</div><div class="line">      objs.push(Klass3());</div><div class="line">      o.bar;</div><div class="line">      o.foo;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// See the test for full details</span></div></pre></td></tr></table></figure><p><strong>注意</strong>：如果你不需要一个类，那就不要麻烦地去创建。这里有一个示例，演示了如何通过移除类开销来获得性能的提升。</p><p><a href="http://jsperf.com/prototypal-performance/54" target="_blank" rel="external">http://jsperf.com/prototypal-performance/54</a></p><h3><span id="使用数组的技巧">使用数组的技巧</span></h3><p>接下来说说数组相关的技巧。在一般情况下，<strong>不要删除数组元素</strong>，这样将使数组过渡到较慢的内部表示。当索引变得稀疏，V8 将会使元素转为更慢的字典模式。</p><p><strong>数组字面量</strong></p><p>数组字面量非常有用，它可以暗示数组的大小和类型。它通常用在体积不大的数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// V8 知道你需要一个长度为 4 并且储存数字的数组：</span></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// 不要这样做：</span></div><div class="line">a = []; <span class="comment">// V8 将对数组一无所知</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</div><div class="line">     a.push(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>存储单一类型 VS 多类型</strong></p><p>将混合类型（比如数字、字符串、undefined、true/false）的数据存在数组中绝不是一个好想法。例如 <code>var arr = [1, “1”, undefined, true, “true”]</code>。</p><p><a href="http://jsperf.com/type-inference-performance/2" target="_blank" rel="external">类型推断的性能测试</a></p><p>正如我们所看到的结果，整数的数组是最快的。</p><p><strong>稀疏数组 VS 满数组</strong></p><p>当你使用稀疏数组时，要注意访问元素将远远慢于满数组。因为 V8 不会分配一整块空间给只用到部分空间的数组。取而代之的是，它被管理在字典中，既节约了空间，但花费访问的时间。</p><p><a href="http://jsperf.com/sparse-arrays-vs-full-arrays" target="_blank" rel="external">稀疏数组与满数组的测试</a></p><p><strong>预分配空间 VS 动态分配</strong></p><p>不要预分配大数组（如大于 64K 的元素），其最大的大小，而应该动态分配。在我们这篇文章的性能测试之前，请记住这只适用部分 JavaScript 引擎。</p><p><img src="http://bubkoo.qiniudn.com/Test%20of%20pre-allocated%20arrays.jpg" alt="空字面量与预分配数组在不同的浏览器进行测试"></p><p>Nitro (Safari) 对预分配的数组更有利。而在其他引擎（V8，SpiderMonkey）中，预先分配并不是高效的。</p><p><a href="http://jsperf.com/pre-allocated-arrays" target="_blank" rel="external">预分配数组测试</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Empty array</span></div><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</div><div class="line">    arr[i] = i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Pre-allocated array</span></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</div><div class="line">    arr[i] = i;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="优化你的应用">优化你的应用</span></h2><p>在 Web 应用的世界中，<strong>速度就是一切</strong>。没有用户希望用一个要花几秒钟计算某列总数或花几分钟汇总信息的表格应用。这是为什么你要在代码中压榨每一点性能的重要原因。</p><p><img src="http://bubkoo.qiniudn.com/improving-apps.jpg" alt=""></p><p>理解和提高应用程序的性能是非常有用的同时，它也是困难的。我推荐以下的步骤来解决性能的痛点：</p><ul><li>测量：在您的应用程序中找到慢的地方（约45％）</li><li>理解：找出实际的问题是什么（约45％）</li><li>修复它！ （约10％）</li></ul><p>下面推荐的一些工具和技术可以协助你。</p><h3><span id="基准化benchmarking">基准化（BENCHMARKING）</span></h3><p>有很多方式来测试 JavaScript 代码片段的性能，一般情况是，简单地比较两个时间戳。这中模式被 <a href="http://jsperf.com/" target="_blank" rel="external">jsPerf</a> 团队指出，并在 <a href="http://www.webkit.org/perf/sunspider/sunspider.html" target="_blank" rel="external">SunSpider</a> 和 <a href="http://krakenbenchmark.mozilla.org/" target="_blank" rel="external">Kraken</a> 的基准套件中使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> totalTime,</div><div class="line">    start = <span class="keyword">new</span> <span class="built_in">Date</span>,</div><div class="line">    iterations = <span class="number">1000</span>;</div><div class="line"><span class="keyword">while</span> (iterations--) &#123;</div><div class="line">  <span class="comment">// Code snippet goes here</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// totalTime → the number of milliseconds taken </span></div><div class="line"><span class="comment">// to execute the code snippet 1000 times</span></div><div class="line">totalTime = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</div></pre></td></tr></table></figure><p>在这里，要测试的代码被放置在一个循环中，并运行一个设定的次数（例如6次）。在此之后，开始日期减去结束日期，就得出在循环中执行操作所花费的时间。</p><p>然而，这种基准测试做的事情过于简单了，特别是如果你想运行在多个浏览器和环境的基准。垃圾收集器本身对结果是有一定影响的。即使你使用 <code>window.performance</code> 这样的解决方案，也必须考虑到这些缺陷。</p><p>不管你是否只运行基准部分的代码，编写一个测试套件或编码基准库，JavaScript 基准其实比你想象的要复杂。如需更详细的指南基准，我强烈建议你阅读由 Mathias Bynens 和 John-David Dalton 提供的 <a href="http://mathiasbynens.be/notes/javascript-benchmarking" target="_blank" rel="external">Javascript 基准测试</a>。</p><h3><span id="分析profiling">分析（PROFILING）</span></h3><p>Chrome 开发者工具为 JavaScript 分析有很好的支持。可以使用此功能检测哪些函数占用了大部分时间，这样你就可以去优化它们。这很重要，即使是代码很小的改变会对整体表现产生重要的影响。</p><p><img src="http://bubkoo.qiniudn.com/Profiles%20Panel%20in%20Chrome%20Developer%20Tools.jpg" alt="Chrome 开发者工具的分析面板"></p><p>分析过程开始获取代码性能基线，然后以时间线的形式体现。这将告诉我们代码需要多长时间运行。“Profiles”选项卡给了我们一个更好的视角来了解应用程序中发生了什么。JavaScript CPU 分析展示了多少 CPU 时间被用于我们的代码，CSS 选择器分析文件展示了多少时间花费在处理选择器上，堆快照显示多少内存正被用于我们的对象。</p><p>利用这些工具，我们可以分离、调整和重新分析来衡量我们的功能或操作对性能优化是否真的起到了效果。</p><p><img src="http://bubkoo.qiniudn.com/Profile%20tab%20gives%20you%20information%20about%20your%20code&#39;s%20performance.jpg" alt="“Profile”选项卡展示了代码性能信息"></p><p>一个很好的分析介绍，阅读 Zack Grossbart 的 <a href="http://coding.smashingmagazine.com/2012/06/12/javascript-profiling-chrome-developer-tools/" target="_blank" rel="external">JavaScript Profiling With The Chrome Developer Tools</a>。</p><p>提示：在理想情况下，若想确保你的分析并未受到已安装的应用程序或扩展的影响，可以使用 –user-data-dir <empty_directory> 标志来启动 Chrome。在大多数情况下，这种方法优化测试应该是足够的，但也需要你更多的时间。这是 V8 标志能有所帮助的。</empty_directory></p><h3><span id="避免内存泄漏-3快照技术">避免内存泄漏 —— 3快照技术</span></h3><p>在谷歌内部，Chrome 开发者工具被 Gmail 等团队大量使用，用来帮助发现和排除内存泄漏。</p><p><img src="http://bubkoo.qiniudn.com/Memory%20statistics%20in%20Chrome%20Developer%20Tools.jpg" alt="Chrome 开发者工具中的内存统计"></p><p>内存统计出我们团队所关心的私有内存使用、JavaScript 堆的大小、DOM 节点数量、存储清理、事件监听计数器和垃圾收集器正要回收的东西。推荐阅读 Loreena Lee 的 <a href="https://docs.google.com/presentation/d/1wUVmf78gG-ra5aOxvTfYdiLkdGaR9OhXRnOlIcEmu2s/pub?start=false&amp;loop=false&amp;delayms=3000#slide=id.g1d65bdf6_0_0" target="_blank" rel="external">3 snapshot</a>。该技术的要点是，在你的应用程序中记录一些行为，强制垃圾回收，检查 DOM 节点的数量有没有恢复到预期的基线，然后分析三个堆的快照来确定是否有内存泄漏。</p><h3><span id="单页面应用的内存管理">单页面应用的内存管理</span></h3><p>单页面应用程序（例如AngularJS，Backbone，Ember）的内存管理是非常重要的，它们几乎永远不会刷新页面，这意味着内存泄漏可能相当明显。移动终端上的单页面应用充满了陷阱，因为设备的内存有限，并在长期运行 Email 客户端或社交网络等应用程序。<strong>能力愈大责任愈重</strong>。</p><p>有很多办法解决这个问题。在 Backbone 中，确保使用 <code>dispose()</code> 来处理旧视图和引用（目前在 <a href="https://github.com/documentcloud/backbone/blob/master/backbone.js#L1234" target="_blank" rel="external">Backbone(Edge)</a> 中可用）。这个函数是最近加上的，移除添加到视图 <code>event</code> 对象中的处理函数，以及通过传给 view 的第三个参数（回调上下文）的 model 或 collection 的事件监听器。<code>dispose()</code> 也会被视图的 <code>remove()</code> 调用，处理当元素被移除时的主要清理工作。Ember 等其他的库当检测到元素被移除时，会清理监听器以避免内存泄漏。</p><p>Derick Bailey 的一些明智的建议：</p><blockquote><p>与其了解事件与引用是如何工作的，不如遵循的标准规则来管理 JavaScript 中的内存。如果你想加载数据到的一个存满用户对象的 Backbone 集合中，你要清空这个集合使它不再占用内存，那必须清除这个集合的所有引用以及集合内对象的引用。一旦清除了所用的引用，资源就会被回收。这就是标准的 JavaScript 垃圾回收规则。</p></blockquote><p>在文章中，Derick 涵盖了许多使用 Backbone.js 时的常见<a href="http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/" target="_blank" rel="external">内存缺陷</a>，以及如何解决这些问题。</p><p>Felix Geisendörfer 的<a href="https://github.com/felixge/node-memory-leak-tutorial" target="_blank" rel="external">在 Node 中调试内存泄漏</a>的教程也值得一读，尤其是当它形成了更广泛 SPA 堆栈的一部分。</p><h3><span id="减少回流reflows">减少回流（REFLOWS）</span></h3><p>当浏览器重新渲染文档中的元素时需要重新计算它们的位置和几何形状时，我们称之为<a href="https://www.youtube.com/watch?feature=player_embedded&amp;v=ZHxbs5WEQzE" target="_blank" rel="external">回流</a>。回流会阻塞用户在浏览器中的操作，因此理解提升回流时间是非常有帮助的。</p><p><img src="http://bubkoo.qiniudn.com/Chart%20of%20reflow%20time.jpg" alt="回流时间图表"></p><p>你应该批量地触发回流或重绘，但是要有节制地使用这些方法，尽量不处理 DOM 也很重要。可以使用 <code>DocumentFragment</code>，一个轻量级的文档对象。你可以把它作为一种方法来提取文档树的一部分，或创建一个新的文档“片段”。与其不断地添加 DOM 节点，不如使用文档片段后只执行一次 DOM 插入操作，以避免过多的回流。</p><p>例如，我们写一个函数给一个元素添加 20 个 <code>div</code> 。如果只是简单地每次 append 一个 <code>div</code> 到元素中，这会触发 20 次回流。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addDivs</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> div;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i ++) &#123;</div><div class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">    div.innerHTML = <span class="string">'Heya!'</span>;</div><div class="line">    element.appendChild(div);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>要解决这个问题，可以使用 <code>DocumentFragment</code> 来代替，我们可以每次添加一个新的 <code>div</code> 到里面。完成后将 <code>DocumentFragment</code> 添加到 DOM 中只会触发一次回流。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addDivs</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> div; </div><div class="line">  <span class="comment">// Creates a new empty DocumentFragment.</span></div><div class="line">  <span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i ++) &#123;</div><div class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line">    div.innerHTML = <span class="string">'Heya!'</span>;</div><div class="line">    fragment.appendChild(div);</div><div class="line">  &#125;</div><div class="line">  element.appendChild(fragment);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以参阅 <a href="https://developers.google.com/speed/articles/javascript-dom" target="_blank" rel="external">Make the Web Faster</a>，<a href="http://blog.tojicode.com/2012/03/javascript-memory-optimization-and.html" target="_blank" rel="external">JavaScript Memory Optimization</a> 和 <a href="http://gent.ilcore.com/2011/08/finding-memory-leaks.html" target="_blank" rel="external">Finding Memory Leaks</a>。</p><h3><span id="javascript-内存泄漏探测器">JavaScript 内存泄漏探测器</span></h3><p>为了帮助发现 JavaScript 内存泄漏，谷歌的开发人员（Marja Hölttä 和 Jochen Eisinger）开发了一种工具，它与 Chrome 开发人员工具结合使用，检索堆的快照并检测出是什么对象导致了内存泄漏。</p><p><img src="http://bubkoo.qiniudn.com/tool%20for%20detecting%20JavaScript%20memory%20leaks.jpg" alt="一个 JavaScript 内存泄漏检测工具"></p><p>有完整的文章介绍了<a href="http://google-opensource.blogspot.de/2012/08/leak-finder-new-tool-for-javascript.html" target="_blank" rel="external">如何使用这个工具</a>，建议你自己到<a href="http://code.google.com/p/leak-finder-for-javascript/" target="_blank" rel="external">内存泄漏探测器项目页面</a>看看。</p><p>如果你想知道为什么这样的工具还没集成到我们的开发工具，是因为它最初是在 Closure 库中帮助我们捕捉一些特定的内存场景，它更适合作为一个外部工具。</p><h3><span id="v8-优化调试和垃圾回收的标志位">V8 优化调试和垃圾回收的标志位</span></h3><p>Chrome 支持直接通过传递一些标志给 V8，以获得更详细的引擎优化输出结果。例如，这样可以追踪 V8 的优化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"/Applications/Google Chrome/Google Chrome"</span> --js-flags=<span class="string">"--trace-opt --trace-deopt"</span></div></pre></td></tr></table></figure><p>Windows 用户可以这样运行 <code>chrome.exe –js-flags=”–trace-opt –trace-deopt”</code><br>，在开发应用程序时，下面的 V8 标志都可以使用。</p><ul><li>trace-opt —— 记录优化函数的名称，并显示跳过的代码，因为优化器不知道如何优化。</li><li>trace-deopt —— 记录运行时将要“去优化”的代码。</li><li>trace-gc —— 记录每次的垃圾回收。</li></ul><p>V8 的处理脚本用 <code>*</code> 标识优化过的函数，用 <code>~</code> 表示未优化的函数。</p><p>如果有想了解更多关于 V8 的标志和 V8 的内部是如何工作的，强烈建议阅读 Vyacheslav Egorov 的 <a href="http://mrale.ph/blog/2011/12/18/v8-optimization-checklist.html" target="_blank" rel="external">excellent post on V8 internals</a>。</p><h3><span id="高精度时间和导航计时-api">高精度时间和导航计时 API</span></h3><p><a href="http://www.w3.org/TR/hr-time/" target="_blank" rel="external">高精度时间</a>（HRT）是一个提供不受系统时间和用户调整影响的亚毫秒级高精度时间接口，可以把它当做是比 <code>new Date</code> 和 <code>Date.now()</code> 更精准的度量方法。这对我们编写基准测试帮助很大。</p><p><img src="http://bubkoo.qiniudn.com/High%20Resolution%20Time.jpg" alt="高精度时间（HRT）提供了当前亚毫秒级的时间精度"></p><p>目前 HRT 在 Chrome（稳定版）中是以 <code>window.performance.webkitNow()</code> 方式使用，但在 Chrome Canary 中前缀被丢弃了，这使得它可以通过 <code>window.performance.now()</code> 方式调用。Paul Irish 在 HTML5Rocks 上有<a href="http://updates.html5rocks.com/2012/08/When-milliseconds-are-not-enough-performance-now" target="_blank" rel="external">更多关于 HRT</a>的文章。</p><p>现在我们知道当前的精准时间，那有可以准确测量页面性能的 API 吗？好吧，现在有个 Navigation Timing API 可以使用，这个 API 提供了一种简单的方式，来获取网页在加载呈现给用户时，精确和详细的时间测量记录。可以在 console 中使用 <code>window.performance.timing</code> 来获取时间信息：</p><p><img src="http://bubkoo.qiniudn.com/Timing%20information%20is%20shown%20in%20the%20console.jpg" alt="显示在控制台中的时间信息"></p><p>我们可以从上面的数据获取很多有用的信息，例如网络延时为 <code>responseEnd – fetchStart</code>，页面加载时间为 <code>loadEventEnd – responseEnd</code>，处理导航和页面加载的时间为 <code>loadEventEnd – navigationStart</code>。</p><p>正如你所看到的，<code>perfomance.memory</code> 的属性也能显示 JavaScript 的内存数据使用情况，如总的堆大小。</p><p>更多 Navigation Timing API 的细节，阅读 Sam Dutton 的 <a href="http://www.html5rocks.com/en/tutorials/webperformance/basics/" target="_blank" rel="external">Measuring Page Load Speed With Navigation Timing</a>。</p><h3><span id="aboutmemory-和-abouttracing">ABOUT:MEMORY 和 ABOUT:TRACING</span></h3><p>Chrome 中的 <code>about:tracing</code> 提供了浏览器的性能视图，记录了 Chrome 的所有线程、tab 页和进程。</p><p><img src="http://bubkoo.qiniudn.com/About-Tracing.jpg" alt="About:Tracing提供了浏览器的性能视图"></p><p>这个工具的真正用处是允许你捕获 Chrome 的运行数据，这样你就可以适当地调整 JavaScript 执行，或优化资源加载。</p><p>Lilli Thompson 有一篇<a href="http://www.html5rocks.com/en/tutorials/games/abouttracing/" target="_blank" rel="external">写给游戏开发者</a>的使用 about:tracing 分析 WebGL 游戏的文章，同时也适合 JavaScript 的开发者。</p><p>在 Chrome 的导航栏里可以输入 about:memory，同样十分实用，可以获得每个 tab 页的内存使用情况，对定位内存泄漏很有帮助。</p><h2><span id="总结">总结</span></h2><p>我们看到，JavaScript 的世界中有很多隐藏的陷阱，而且并没有提升性能的银弹。只有把一些优化方案综合使用到（现实世界）测试环境，才能获得最大的性能收益。即便如此，了解引擎是如何解释和优化代码，可以帮助你调整应用程序。</p><p><strong>测量</strong>，<strong>理解</strong>，<strong>修复</strong>。不断重复这个过程。</p><p><img src="http://bubkoo.qiniudn.com/barometer.jpg" alt=""></p><p>谨记关注优化，但为了便利也可以舍弃一些很小的优化。例如，有些开发者选择 <code>forEach</code> 和 <code>Object.keys</code> 代替 <code>for</code> 和 <code>for..in</code> 循环，尽管这会更慢但使用起来更方便。要保持清醒的头脑，知道什么优化是需要的，什么优化是不需要的。</p><p>同时注意，虽然 JavaScript 引擎越来越快，但下一个真正的瓶颈是 DOM。回流和重绘的减少也是重要的，所以必要时再去操作 DOM。还有就是要关注网络，HTTP 请求是珍贵的，特别是移动终端上，因此要使用 HTTP 的缓存去减少资源的加载。</p><p>记住以上这几点，你就已经获取了本文的大部分信息，希望对你有所帮助！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文连接：&lt;a href=&quot;http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing Fast, Memory-Efficient JavaScript&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;许多 JavaScript 引擎都是为了快速执行的大型 JavaScript 应用程序设计而特别设计，如 Google &lt;a href=&quot;http://code.google.com/p/v8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;V8&lt;/a&gt; 引擎（正被 Chrome 和 &lt;a href=&quot;http://nodejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NodeJS&lt;/a&gt; 使用）。在开发过程中，如果你关心内存使用情况和页面性能，你应该了解户浏览器的 JavaScript 引擎的内部运作原理。&lt;/p&gt;
&lt;p&gt;无论是V8、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/SpiderMonkey&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SpiderMonkey&lt;/a&gt;（Firefox）、&lt;a href=&quot;http://my.opera.com/ODIN/blog/carakan-faq&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Carakan&lt;/a&gt;（Opera）、&lt;a href=&quot;http://en.wikipedia.org/wiki/Chakra_(JScript_engine&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Chakra&lt;/a&gt;)（IE）或其他 JavaScript  引擎，了解引擎背后的一些运行机制可以帮助你&lt;strong&gt;更好地优化你的应用程序&lt;/strong&gt;。但，这并不是说应该专门为某一浏览器或引擎进行程序的优化，而且，永远不要这样做。&lt;/p&gt;
&lt;p&gt;你应该先问自己下面几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我可以做些什么来让我的代码更加高效&lt;/li&gt;
&lt;li&gt;主流的 JavaScript 引擎都做了哪些优化&lt;/li&gt;
&lt;li&gt;什么是引擎无法优化的，垃圾回收器是不是按照我预想的那样，回收了我不需要的内存空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我们编写高效、快速的代码的时候，有许多常见的陷阱，本文将讨论一些经过验证的、更好的编写代码的方式。&lt;br&gt;
    
    </summary>
    
    
      <category term="Performance" scheme="http://bubkoo.com/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 用户和身份验证</title>
    <link href="http://bubkoo.com/2014/02/07/mongodb-authentication/"/>
    <id>http://bubkoo.com/2014/02/07/mongodb-authentication/</id>
    <published>2014-02-07T14:21:42.000Z</published>
    <updated>2014-02-07T14:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.mongodb.org/" target="_blank" rel="external">MongoDB</a>是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。这里推荐一个快速入门教程 - <a href="http://www.cnblogs.com/huangxincheng/category/355399.html" target="_blank" rel="external">8天学通 MongoDB</a>，写的很全面。这里讨论的是 MongoDB 的用户和身份验证。</p><p>在默认情况下，MongoDB 不会进行身份验证，也没有账号，只要能连接上服务就可以对数据库进行各种操作，如果你在一个面向公众的服务器上使用它，那么这的确是一个问题。</p><p><img src="http://bubkoo.qiniudn.com/logo-mongodb-tagline.png" alt="http://blog.mongodb.org/"><br><a id="more"></a></p><p>作为数据库软件，我们肯定不想谁都可以访问，为了确保数据的安全，MongoDB 也会像其他的数据库软件一样可以采用用户验证的方法，那么该怎么做呢？其实很简单，MongoDB 提供了 addUser 方法，该方法包含三个参数：</p><ul><li>user - 字符串，表示用户名</li><li>password - 字符串，对应的密码</li><li>readOnly - boolean，可选参数，默认值为 <code>false</code>，表示是否是只读用户</li></ul><p>添加用户：<code>db.addUser(&quot;guest&quot;, &quot;pass&quot;, true)</code></p><p>修改用户密码： <code>db.addUser(&quot;guest&quot;, &quot;newpass&quot;)</code></p><p>删除用户： <code>db.removeUser(&quot;guest&quot;)</code></p><p>更复杂的使用方式请参考<a href="http://docs.mongodb.org/manual/reference/method/db.addUser/" target="_blank" rel="external">官方文档</a>。</p><p>可以将 MongoDB 的用户分为两类：超级用户和数据库用户。超级用户拥有最大权限，可以对所有数据库进行任意操作，超级用户储存在 admin 数据库中，刚安装的 MongoDB 中 admin 数据库是空的；数据库用户存储在单个数据库中，只能访问对应的数据库。另外，用户信息保存在 db.system.users 中。</p><p>关于用户和权限有以下特性：</p><ol><li>数据库是由超级用户来创建的，一个数据库可以包含多个用户，一个用户只能在一个数据库下，不同数据库中的用户可以同名</li><li>如果在 admin 数据库中不存在用户，即使 mongod 启动时添加了 –auth 参数，此时不进行任何认证还是可以做任何操作</li><li>在 admin 数据库创建的用户具有超级权限，可以对 MongoDB 系统内的任何数据库的数据对象进行操作</li><li>特定数据库比如 test1 下的用户 test_user1，不能够访问其他数据库 test2，但是可以访问本数据库下其他用户创建的数据</li><li>不同数据库中同名的用户不能够登录其他数据库。比如数据库 test1 和 test2 都有用户 test_user，以 test_user 登录 test1 后,不能够登录到 test2 进行数据库操作</li></ol><h2><span id="实验验证">实验验证</span></h2><p>开始之前，说明以下我的文件目录结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">─mongodb<span class="number">-2.4</span><span class="number">.8</span></div><div class="line">  ├─bin   <span class="comment">// MongoDB 的二进制文件</span></div><div class="line">  ├─data  <span class="comment">// MongoDB 数据库存放目录</span></div><div class="line">  └─log   <span class="comment">// MongoDB 日志存放目录</span></div></pre></td></tr></table></figure><p>首次安装 MongoDB 后，admin 数据库中没有用户，此时不管是否以 –auth 方式启动数据库，其他数据库(比如 test1 数据库)中的用户都可以对另外的数据库(比如 test2 数据库)中的数据进行操作。</p><p>以普通的方式启动 MongoDB</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8&gt;.\<span class="title">bin</span>\<span class="title">mongod</span> --<span class="title">dbpath</span>=.\<span class="title">data</span> --<span class="title">logpath</span>=.\<span class="title">log</span>\<span class="title">log.log</span></span></div></pre></td></tr></table></figure><p>打开另一个命令提示符窗口，进入 MongoDB Shell，默认直接连接 test 数据库，并且此时用户拥有超级权限，可以操作任何数据库对象。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8\<span class="title">bin</span>&gt;<span class="title">mongo</span></span></div><div class="line"><span class="function"><span class="title">MongoDB</span> <span class="title">shell</span> <span class="title">version</span>: 2.4.8</span></div><div class="line"><span class="function"><span class="title">connecting</span> <span class="title">to</span>: <span class="title">test</span></span></div><div class="line"><span class="function"><span class="title">Welcome</span> <span class="title">to</span> <span class="title">the</span> <span class="title">MongoDB</span> <span class="title">shell</span>.</span></div><div class="line"><span class="function"><span class="title">For</span> <span class="title">interactive</span> <span class="title">help</span>, <span class="title">type</span> "<span class="title">help</span>".</span></div><div class="line"><span class="function"><span class="title">For</span> <span class="title">more</span> <span class="title">comprehensive</span> <span class="title">documentation</span>, <span class="title">see</span></span></div><div class="line"><span class="function">        <span class="title">http</span>://<span class="title">docs.mongodb.org</span>/</span></div><div class="line"><span class="function"><span class="title">Questions</span>? <span class="title">Try</span> <span class="title">the</span> <span class="title">support</span> <span class="title">group</span></span></div><div class="line"><span class="function">        <span class="title">http</span>://<span class="title">groups.google.com</span>/<span class="title">group</span>/<span class="title">mongodb</span>-<span class="title">user</span></span></div></pre></td></tr></table></figure><p>显示所有数据库，默认只有 local 数据库。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; show dbs</div><div class="line">local   <span class="number">0</span>.<span class="number">078125</span>GB</div></pre></td></tr></table></figure><p>查看 admin 数据库中的用户信息，因为是刚建立的数据库所以 user 为空</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; use admin</div><div class="line">switched to db admin</div><div class="line">&gt; db.system.users.<span class="built_in">find</span>(); # 默认 admin 数据库中不存在用户</div></pre></td></tr></table></figure><p>操作 test 数据库，插入测试数据，并创建用户 test_user，密码为 password</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&gt; use test</div><div class="line">switched to db test</div><div class="line">&gt; db.system.users.<span class="built_in">find</span>(); # 默认 test 数据库中也不存在用户</div><div class="line">&gt; db.test_data.insert(&#123;"id":<span class="number">1</span>,"info":"I am <span class="keyword">in</span> test"&#125;)</div><div class="line">&gt; db.test_data.insert(&#123;"id":<span class="number">2</span>,"info":"I am <span class="keyword">in</span> test"&#125;)</div><div class="line">&gt; db.test_data.insert(&#123;"id":<span class="number">3</span>,"info":"I am <span class="keyword">in</span> test"&#125;)</div><div class="line"></div><div class="line">&gt; db.test_data.<span class="built_in">find</span>()</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f5922125d9e18cd51581b6"), "id" : <span class="number">1</span>, "info" : "I am <span class="keyword">in</span> test" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f5926d25d9e18cd51581b7"), "id" : <span class="number">2</span>, "info" : "I am <span class="keyword">in</span> test" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f5927125d9e18cd51581b8"), "id" : <span class="number">3</span>, "info" : "I am <span class="keyword">in</span> test" &#125;</div><div class="line"></div><div class="line"># 创建用户</div><div class="line">&gt; db.addUser("test_user","password")</div><div class="line">&#123;</div><div class="line">        "user" : "test_user",</div><div class="line">        "readOnly" : false,</div><div class="line">        "pwd" : "bf7a0adf9822a3379d6dfb1ebd38b92e",</div><div class="line">        "_id" : ObjectId("<span class="number">52</span>f5928625d9e18cd51581b9")</div><div class="line">&#125;</div><div class="line">&gt; db.system.users.<span class="built_in">find</span>()</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f5928625d9e18cd51581b9"), "user" : "test_user", "readOnly" : false, </div><div class="line">pwd" : "bf7a0adf9822a3379d6dfb1ebd38b92e" &#125;</div><div class="line"></div><div class="line"># 验证函数，验证数据库中是否存在对应的用户</div><div class="line">&gt; db.auth("test_user","password")</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure><p>创建 test1 数据库，并创建对象 test1_data，插入数据：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; use test1</div><div class="line">switched to db test1</div><div class="line">&gt; db.test1_data.insert(&#123;"id":<span class="number">1</span>,"info":"I am <span class="keyword">in</span> test1"&#125;)</div><div class="line">&gt; db.test1_data.insert(&#123;"id":<span class="number">2</span>,"info":"I am <span class="keyword">in</span> test1"&#125;)</div><div class="line">&gt; db.test1_data.insert(&#123;"id":<span class="number">3</span>,"info":"I am <span class="keyword">in</span> test1"&#125;)</div><div class="line">&gt; db.test1_data.<span class="built_in">find</span>()</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f593e925d9e18cd51581ba"), "id" : <span class="number">1</span>, "info" : "I am <span class="keyword">in</span> test1" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f593ef25d9e18cd51581bb"), "id" : <span class="number">2</span>, "info" : "I am <span class="keyword">in</span> test1" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f593f425d9e18cd51581bc"), "id" : <span class="number">3</span>, "info" : "I am <span class="keyword">in</span> test1" &#125;</div></pre></td></tr></table></figure><p>创建 test2 数据库，并创建对象 test2_data，插入数据：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; use test2</div><div class="line">switched to db test2</div><div class="line">&gt; db.test2_data.insert(&#123;"id":<span class="number">1</span>,"info":"I am <span class="keyword">in</span> test2"&#125;)</div><div class="line">&gt; db.test2_data.insert(&#123;"id":<span class="number">2</span>,"info":"I am <span class="keyword">in</span> test2"&#125;)</div><div class="line">&gt; db.test2_data.insert(&#123;"id":<span class="number">3</span>,"info":"I am <span class="keyword">in</span> test2"&#125;)</div><div class="line">&gt; db.test2_data.<span class="built_in">find</span>()</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f5947725d9e18cd51581bd"), "id" : <span class="number">1</span>, "info" : "I am <span class="keyword">in</span> test2" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f5947c25d9e18cd51581be"), "id" : <span class="number">2</span>, "info" : "I am <span class="keyword">in</span> test2" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f5948125d9e18cd51581bf"), "id" : <span class="number">3</span>, "info" : "I am <span class="keyword">in</span> test2" &#125;</div></pre></td></tr></table></figure><p><strong>重新以认证的方式启动数据库</strong>，启动时添加 –auth 参数：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8&gt;.\<span class="title">bin</span>\<span class="title">mongod</span> --<span class="title">dbpath</span>=.\<span class="title">data</span> --<span class="title">logpath</span>=.\<span class="title">log</span>\<span class="title">log.log</span> --<span class="title">auth</span></span></div></pre></td></tr></table></figure><p>再次登录，虽然在 test 中创建了用户，但是<strong>没有在 admin 数据库中创建用户</strong>，所以以默认方式登录的用户依然具有超级权限</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8\<span class="title">bin</span>&gt;<span class="title">mongo</span></span></div><div class="line"><span class="function"><span class="title">MongoDB</span> <span class="title">shell</span> <span class="title">version</span>: 2.4.8</span></div><div class="line"><span class="function"><span class="title">connecting</span> <span class="title">to</span>: <span class="title">test</span></span></div></pre></td></tr></table></figure><p>默认具有超级权限，可以进行所有操作</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&gt; show dbs</div><div class="line">admin   (empty)</div><div class="line">local   <span class="number">0</span>.<span class="number">078125</span>GB</div><div class="line">test    <span class="number">0</span>.<span class="number">203125</span>GB</div><div class="line">test1   <span class="number">0</span>.<span class="number">203125</span>GB</div><div class="line">test2   <span class="number">0</span>.<span class="number">203125</span>GB</div><div class="line"></div><div class="line">&gt; use test</div><div class="line">switched to db test</div><div class="line">&gt; db.system.users.<span class="built_in">find</span>()</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f5928625d9e18cd51581b9"), "user" : "test_user", "readOnly"</div><div class="line"> : false, "pwd" : "bf7a0adf9822a3379d6dfb1ebd38b92e" &#125;</div><div class="line"></div><div class="line">&gt; use test1</div><div class="line">switched to db test1</div><div class="line">&gt; db.test1_data.<span class="built_in">find</span>()</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f593e925d9e18cd51581ba"), "id" : <span class="number">1</span>, "info" : "I am <span class="keyword">in</span> test1" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f593ef25d9e18cd51581bb"), "id" : <span class="number">2</span>, "info" : "I am <span class="keyword">in</span> test1" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f593f425d9e18cd51581bc"), "id" : <span class="number">3</span>, "info" : "I am <span class="keyword">in</span> test1" &#125;</div><div class="line"></div><div class="line"># 插入数据</div><div class="line">&gt; db.test1_data.insert(&#123;"id":<span class="number">4</span>,"info":"I am <span class="keyword">in</span> test1"&#125;)</div><div class="line">&gt; db.test1_data.<span class="built_in">find</span>()</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f593e925d9e18cd51581ba"), "id" : <span class="number">1</span>, "info" : "I am <span class="keyword">in</span> test1" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f593ef25d9e18cd51581bb"), "id" : <span class="number">2</span>, "info" : "I am <span class="keyword">in</span> test1" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f593f425d9e18cd51581bc"), "id" : <span class="number">3</span>, "info" : "I am <span class="keyword">in</span> test1" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f5ae44bee8a41e4b495370"), "id" : <span class="number">4</span>, "info" : "I am <span class="keyword">in</span> test1" &#125;</div><div class="line"></div><div class="line"># 创建数据库 test3，并插入数据</div><div class="line">&gt; use test3</div><div class="line">switched to db test3</div><div class="line">&gt; db.test3_data.insert(&#123;"id":<span class="number">1</span>,"info":"I am <span class="keyword">in</span> test3"&#125;)</div><div class="line">&gt; db.test3_data.insert(&#123;"id":<span class="number">2</span>,"info":"I am <span class="keyword">in</span> test3"&#125;)</div><div class="line">&gt; db.test3_data.insert(&#123;"id":<span class="number">3</span>,"info":"I am <span class="keyword">in</span> test3"&#125;)</div><div class="line">&gt; db.test3_data.<span class="built_in">find</span>()</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f5aee9bee8a41e4b495371"), "id" : <span class="number">1</span>, "info" : "I am <span class="keyword">in</span> test3" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f5af28bee8a41e4b495372"), "id" : <span class="number">2</span>, "info" : "I am <span class="keyword">in</span> test3" &#125;</div><div class="line">&#123; "_id" : ObjectId("<span class="number">52</span>f5af2cbee8a41e4b495373"), "id" : <span class="number">3</span>, "info" : "I am <span class="keyword">in</span> test3" &#125;</div></pre></td></tr></table></figure><p><strong>使用特定用户登录数据库，也可以访问其他的数据库</strong>。下面的例子中，使用 test 数据库中的用户 test_user 登录，但是由于 admin 数据库中不存在用户，所以任然具有超级权限。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8\<span class="title">bin</span>&gt;<span class="title">mongo</span> -<span class="title">utest_user</span> -<span class="title">ppassword</span></span></div><div class="line"><span class="function"><span class="title">MongoDB</span> <span class="title">shell</span> <span class="title">version</span>: 2.4.8</span></div><div class="line"><span class="function"><span class="title">connecting</span> <span class="title">to</span>: <span class="title">test</span></span></div><div class="line"><span class="function">&gt; <span class="title">show</span> <span class="title">dbs</span></span></div><div class="line"><span class="function"><span class="title">admin</span>   (<span class="title">empty</span>)</span></div><div class="line"><span class="function"><span class="title">local</span>   0.078125<span class="title">GB</span></span></div><div class="line"><span class="function"><span class="title">test</span>    0.203125<span class="title">GB</span></span></div><div class="line"><span class="function"><span class="title">test1</span>   0.203125<span class="title">GB</span></span></div><div class="line"><span class="function"><span class="title">test2</span>   0.203125<span class="title">GB</span></span></div><div class="line"><span class="function"><span class="title">test3</span>   0.203125<span class="title">GB</span></span></div><div class="line"><span class="function">&gt; <span class="title">use</span> <span class="title">test</span></span></div><div class="line"><span class="function"><span class="title">switched</span> <span class="title">to</span> <span class="title">db</span> <span class="title">test</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.test_data.find</span>()</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5922125d9e18cd51581b6</span>"), "<span class="title">id</span>" : 1, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5926d25d9e18cd51581b7</span>"), "<span class="title">id</span>" : 2, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5927125d9e18cd51581b8</span>"), "<span class="title">id</span>" : 3, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&gt; <span class="title">use</span> <span class="title">test4</span></span></div><div class="line"><span class="function"><span class="title">switched</span> <span class="title">to</span> <span class="title">db</span> <span class="title">test4</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.test4_data.insert</span>(&#123;"<span class="title">id</span>":1,"<span class="title">info</span>":"<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test4</span>"&#125;)</span></div><div class="line"><span class="function">&gt; <span class="title">db.test4_data.insert</span>(&#123;"<span class="title">id</span>":2,"<span class="title">info</span>":"<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test4</span>"&#125;)</span></div><div class="line"><span class="function">&gt; <span class="title">db.test4_data.insert</span>(&#123;"<span class="title">id</span>":3,"<span class="title">info</span>":"<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test4</span>"&#125;)</span></div><div class="line"><span class="function">&gt; <span class="title">db.test4_data.find</span>()</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5bce439a90d49d27742d2</span>"), "<span class="title">id</span>" : 1, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test4</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5bce839a90d49d27742d3</span>"), "<span class="title">id</span>" : 2, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test4</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5bcec39a90d49d27742d4</span>"), "<span class="title">id</span>" : 3, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test4</span>" &#125;</span></div></pre></td></tr></table></figure><p><strong>在 admin.system.users 中添加用户，使 MongoDB 的认证授权服务生效</strong></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 在 admin 数据库中创建用户 supper，密码为 password</div><div class="line">&gt; use admin</div><div class="line">switched to db admin</div><div class="line">&gt; db.addUser("supper","password")</div><div class="line">&#123;</div><div class="line">        "user" : "supper",</div><div class="line">        "readOnly" : false,</div><div class="line">        "pwd" : "<span class="number">0</span>d345bf64f4c1e8bc3e3bbb04c46b4d3",</div><div class="line">        "_id" : ObjectId("<span class="number">52</span>f5bdf439a90d49d27742d5")</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 认证</div><div class="line">&gt; db.auth("supper","password")</div><div class="line"><span class="number">1</span></div><div class="line">&gt;</div></pre></td></tr></table></figure><p>以默认方式登录，即以无认证用户登录，查询的时候会显示无权限：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8\<span class="title">bin</span>&gt;<span class="title">mongo</span></span></div><div class="line"><span class="function"><span class="title">MongoDB</span> <span class="title">shell</span> <span class="title">version</span>: 2.4.8</span></div><div class="line"><span class="function"><span class="title">connecting</span> <span class="title">to</span>: <span class="title">test</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.system.users.find</span>()</span></div><div class="line"><span class="function"><span class="title">error</span>: &#123; "$<span class="title">err</span>" : "<span class="title">not</span> <span class="title">authorized</span> <span class="title">for</span> <span class="title">query</span> <span class="title">on</span> <span class="title">test.system.users</span>", "<span class="title">code</span>" : 16550 &#125;</span></div><div class="line"><span class="function">&gt; <span class="title">show</span> <span class="title">dbs</span></span></div><div class="line"><span class="function"><span class="title">Sat</span> <span class="title">Feb</span> 08 13:20:27.831 <span class="title">listDatabases</span> <span class="title">failed</span>:&#123; "<span class="title">ok</span>" : 0, "<span class="title">errmsg</span>" : "<span class="title">unauthorized</span>" &#125; <span class="title">at</span> <span class="title">src</span>/<span class="title">mongo</span>/<span class="title">shell</span>/<span class="title">mongo.js</span>:46</span></div></pre></td></tr></table></figure><p>在 admin 数据库创建用户后，使用认证方式登录，可进行对应数据库的查询操作且仅仅能够查询对应的数据库中的信息，不能够查询其他 MongoDB 系统的其他数据库信息：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># 使用 test 数据库中的用户可以查询 test 的数据，但是不能查看其他的数据库的数据</div><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8\<span class="title">bin</span>&gt;<span class="title">mongo</span> -<span class="title">utest_user</span> -<span class="title">ppassword</span></span></div><div class="line"><span class="function"><span class="title">MongoDB</span> <span class="title">shell</span> <span class="title">version</span>: 2.4.8</span></div><div class="line"><span class="function"><span class="title">connecting</span> <span class="title">to</span>: <span class="title">test</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.system.users.find</span>()</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5928625d9e18cd51581b9</span>"), "<span class="title">user</span>" : "<span class="title">test_user</span>", "<span class="title">readOnly</span>"</span></div><div class="line"><span class="function"> : <span class="title">false</span>, "<span class="title">pwd</span>" : "<span class="title">bf7a0adf9822a3379d6dfb1ebd38b92e</span>" &#125;</span></div><div class="line"><span class="function">&gt; <span class="title">db.test_data.find</span>()</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5922125d9e18cd51581b6</span>"), "<span class="title">id</span>" : 1, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5926d25d9e18cd51581b7</span>"), "<span class="title">id</span>" : 2, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5927125d9e18cd51581b8</span>"), "<span class="title">id</span>" : 3, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"># 查询系统数据库信息，报错</span></div><div class="line"><span class="function">&gt; <span class="title">show</span> <span class="title">dbs</span></span></div><div class="line"><span class="function"><span class="title">Sat</span> <span class="title">Feb</span> 08 13:23:03.423 <span class="title">listDatabases</span> <span class="title">failed</span>:&#123; "<span class="title">ok</span>" : 0, "<span class="title">errmsg</span>" : "<span class="title">unauthorized</span>" &#125; <span class="title">at</span> <span class="title">src</span>/<span class="title">mongo</span>/<span class="title">shell</span>/<span class="title">mongo.js</span>:46</span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"># 查询 <span class="title">test1</span> 数据库，报错</span></div><div class="line"><span class="function">&gt; <span class="title">use</span> <span class="title">test1</span></span></div><div class="line"><span class="function"><span class="title">switched</span> <span class="title">to</span> <span class="title">db</span> <span class="title">test1</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.test1_data.find</span>()</span></div><div class="line"><span class="function"><span class="title">error</span>: &#123; "$<span class="title">err</span>" : "<span class="title">not</span> <span class="title">authorized</span> <span class="title">for</span> <span class="title">query</span> <span class="title">on</span> <span class="title">test1.test1_data</span>", "<span class="title">code</span>" : 16550 &#125;</span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"># 查询 <span class="title">test2</span> 数据库，报错</span></div><div class="line"><span class="function">&gt; <span class="title">use</span> <span class="title">test2</span></span></div><div class="line"><span class="function"><span class="title">switched</span> <span class="title">to</span> <span class="title">db</span> <span class="title">test2</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.test2_data.find</span>()</span></div><div class="line"><span class="function"><span class="title">error</span>: &#123; "$<span class="title">err</span>" : "<span class="title">not</span> <span class="title">authorized</span> <span class="title">for</span> <span class="title">query</span> <span class="title">on</span> <span class="title">test2.test2_data</span>", "<span class="title">code</span>" : 16550 &#125;</span></div></pre></td></tr></table></figure><p>使用 supper 用户登录，可以对 MongoDB 系统内的所有数据库进行操作：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8\<span class="title">bin</span>&gt;<span class="title">mongo</span> 127.0.0.1/<span class="title">admin</span> -<span class="title">usupper</span> -<span class="title">ppassword</span></span></div><div class="line"><span class="function"><span class="title">MongoDB</span> <span class="title">shell</span> <span class="title">version</span>: 2.4.8</span></div><div class="line"><span class="function"><span class="title">connecting</span> <span class="title">to</span>: 127.0.0.1/<span class="title">admin</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">&gt; <span class="title">show</span> <span class="title">dbs</span></span></div><div class="line"><span class="function"><span class="title">admin</span>   0.203125<span class="title">GB</span></span></div><div class="line"><span class="function"><span class="title">local</span>   0.078125<span class="title">GB</span></span></div><div class="line"><span class="function"><span class="title">test</span>    0.203125<span class="title">GB</span></span></div><div class="line"><span class="function"><span class="title">test1</span>   0.203125<span class="title">GB</span></span></div><div class="line"><span class="function"><span class="title">test2</span>   0.203125<span class="title">GB</span></span></div><div class="line"><span class="function"><span class="title">test3</span>   0.203125<span class="title">GB</span></span></div><div class="line"><span class="function"><span class="title">test4</span>   0.203125<span class="title">GB</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">&gt; <span class="title">use</span> <span class="title">test</span></span></div><div class="line"><span class="function"><span class="title">switched</span> <span class="title">to</span> <span class="title">db</span> <span class="title">test</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.addUser</span>("<span class="title">test_user1</span>","<span class="title">password</span>")</span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">        "<span class="title">user</span>" : "<span class="title">test_user1</span>",</span></div><div class="line"><span class="function">        "<span class="title">readOnly</span>" : <span class="title">false</span>,</span></div><div class="line"><span class="function">        "<span class="title">pwd</span>" : "<span class="title">af20fbd43eb73735b7fc7271f0d18ce4</span>",</span></div><div class="line"><span class="function">        "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5c0c01caaf8492f79da16</span>")</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">&gt; <span class="title">db.test_data.find</span>()</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5922125d9e18cd51581b6</span>"), "<span class="title">id</span>" : 1, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5926d25d9e18cd51581b7</span>"), "<span class="title">id</span>" : 2, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5927125d9e18cd51581b8</span>"), "<span class="title">id</span>" : 3, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&gt; <span class="title">db.test_data.insert</span>(&#123;"<span class="title">id</span>":4,"<span class="title">info</span>":"<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>"&#125;)</span></div><div class="line"><span class="function">&gt; <span class="title">db.test_data.find</span>()</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5922125d9e18cd51581b6</span>"), "<span class="title">id</span>" : 1, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5926d25d9e18cd51581b7</span>"), "<span class="title">id</span>" : 2, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5927125d9e18cd51581b8</span>"), "<span class="title">id</span>" : 3, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5c10e1caaf8492f79da17</span>"), "<span class="title">id</span>" : 4, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div></pre></td></tr></table></figure><p>特定数据库比如 test 下的用户 test_user，是可以访问本数据库下其他用户创建的数据：</p><p>用 test_user1 登录 test 数据库，并插入数据</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8\<span class="title">bin</span>&gt;<span class="title">mongo</span> 127.0.0.1/<span class="title">test</span> -<span class="title">utest_user1</span> -<span class="title">ppassword</span></span></div><div class="line"><span class="function"><span class="title">MongoDB</span> <span class="title">shell</span> <span class="title">version</span>: 2.4.8</span></div><div class="line"><span class="function"><span class="title">connecting</span> <span class="title">to</span>: 127.0.0.1/<span class="title">test</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.test_data.insert</span>(&#123;"<span class="title">id</span>":5,"<span class="title">info</span>":"<span class="title">I</span> <span class="title">am</span> <span class="title">created</span> <span class="title">by</span> <span class="title">test_user1</span>"&#125;)</span></div><div class="line"><span class="function">&gt; <span class="title">db.test_data.insert</span>(&#123;"<span class="title">id</span>":6,"<span class="title">info</span>":"<span class="title">I</span> <span class="title">am</span> <span class="title">created</span> <span class="title">by</span> <span class="title">test_user1</span>"&#125;)</span></div><div class="line"><span class="function">&gt; <span class="title">db.test_data.find</span>()</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5922125d9e18cd51581b6</span>"), "<span class="title">id</span>" : 1, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5926d25d9e18cd51581b7</span>"), "<span class="title">id</span>" : 2, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5927125d9e18cd51581b8</span>"), "<span class="title">id</span>" : 3, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5c10e1caaf8492f79da17</span>"), "<span class="title">id</span>" : 4, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5c1eb15944f80880dfb1f</span>"), "<span class="title">id</span>" : 5, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">created</span> <span class="title">by</span> <span class="title">test_user1</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5c1f015944f80880dfb20</span>"), "<span class="title">id</span>" : 6, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">created</span> <span class="title">by</span> <span class="title">test_user1</span>" &#125;</span></div></pre></td></tr></table></figure><p>用 test_user 重新登录 test 数据库，可以查询到 test_user1 创建的数据：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8\<span class="title">bin</span>&gt;<span class="title">mongo</span> 127.0.0.1/<span class="title">test</span> -<span class="title">utest_user</span> -<span class="title">ppassword</span></span></div><div class="line"><span class="function"><span class="title">MongoDB</span> <span class="title">shell</span> <span class="title">version</span>: 2.4.8</span></div><div class="line"><span class="function"><span class="title">connecting</span> <span class="title">to</span>: 127.0.0.1/<span class="title">test</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.test_data.find</span>()</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5922125d9e18cd51581b6</span>"), "<span class="title">id</span>" : 1, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5926d25d9e18cd51581b7</span>"), "<span class="title">id</span>" : 2, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5927125d9e18cd51581b8</span>"), "<span class="title">id</span>" : 3, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5c10e1caaf8492f79da17</span>"), "<span class="title">id</span>" : 4, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">in</span> <span class="title">test</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5c1eb15944f80880dfb1f</span>"), "<span class="title">id</span>" : 5, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">created</span> <span class="title">by</span> <span class="title">test_user1</span>" &#125;</span></div><div class="line"><span class="function">&#123; "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5c1f015944f80880dfb20</span>"), "<span class="title">id</span>" : 6, "<span class="title">info</span>" : "<span class="title">I</span> <span class="title">am</span> <span class="title">created</span> <span class="title">by</span> <span class="title">test_user1</span>" &#125;</span></div></pre></td></tr></table></figure><p>不同数据库中的用户可以同名，不同数据库中同名的用户不能登录其他数据库。例如 test1 和 test2 中都有 some_user，以 some_user 登录 test1 后，不能够登录到 test2 进行数据库操作</p><p>首先，在  test1 和 test2 中创建同名用户 some_user，密码都为 password：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># 创建用户需要超级权限，用 supper 用户登录 admin 数据库</div><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8\<span class="title">bin</span>&gt;<span class="title">mongo</span> 127.0.0.1/<span class="title">admin</span> -<span class="title">usupper</span> -<span class="title">ppassword</span></span></div><div class="line"><span class="function"><span class="title">MongoDB</span> <span class="title">shell</span> <span class="title">version</span>: 2.4.8</span></div><div class="line"><span class="function"><span class="title">connecting</span> <span class="title">to</span>: 127.0.0.1/<span class="title">admin</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">&gt; <span class="title">use</span> <span class="title">test1</span></span></div><div class="line"><span class="function"><span class="title">switched</span> <span class="title">to</span> <span class="title">db</span> <span class="title">test1</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.addUser</span>("<span class="title">some_user</span>","<span class="title">password</span>")</span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">        "<span class="title">user</span>" : "<span class="title">some_user</span>",</span></div><div class="line"><span class="function">        "<span class="title">readOnly</span>" : <span class="title">false</span>,</span></div><div class="line"><span class="function">        "<span class="title">pwd</span>" : "<span class="title">ed235c1f49990c04775a33e58ede9f99</span>",</span></div><div class="line"><span class="function">        "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5c385daeb9d6bbdf0a741</span>")</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">&gt; <span class="title">use</span> <span class="title">test2</span></span></div><div class="line"><span class="function"><span class="title">switched</span> <span class="title">to</span> <span class="title">db</span> <span class="title">test2</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.addUser</span>("<span class="title">some_user</span>","<span class="title">password</span>")</span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">        "<span class="title">user</span>" : "<span class="title">some_user</span>",</span></div><div class="line"><span class="function">        "<span class="title">readOnly</span>" : <span class="title">false</span>,</span></div><div class="line"><span class="function">        "<span class="title">pwd</span>" : "<span class="title">ed235c1f49990c04775a33e58ede9f99</span>",</span></div><div class="line"><span class="function">        "<span class="title">_id</span>" : <span class="title">ObjectId</span>("52<span class="title">f5c3a1daeb9d6bbdf0a742</span>")</span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure><p>然后，以 some_user 登录 test1，并尝试对 test2 进行操作：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8\<span class="title">bin</span>&gt;<span class="title">mongo</span> 127.0.0.1/<span class="title">test1</span> -<span class="title">usome_user</span> -<span class="title">ppassword</span></span></div><div class="line"><span class="function"><span class="title">MongoDB</span> <span class="title">shell</span> <span class="title">version</span>: 2.4.8</span></div><div class="line"><span class="function"><span class="title">connecting</span> <span class="title">to</span>: 127.0.0.1/<span class="title">test1</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"># 查询数据库 <span class="title">test2</span>，出错</span></div><div class="line"><span class="function">&gt; <span class="title">use</span> <span class="title">test2</span></span></div><div class="line"><span class="function"><span class="title">switched</span> <span class="title">to</span> <span class="title">db</span> <span class="title">test2</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.test2_data.find</span>()</span></div><div class="line"><span class="function"><span class="title">error</span>: &#123; "$<span class="title">err</span>" : "<span class="title">not</span> <span class="title">authorized</span> <span class="title">for</span> <span class="title">query</span> <span class="title">on</span> <span class="title">test2.test2_data</span>", "<span class="title">code</span>" : 16550 &#125;</span></div></pre></td></tr></table></figure><p>使用 db.auth() 可以对数据库中的用户进行验证，如果验证成功则返回 1，否则返回 0。db.auth() 只能针对登录用户所属的数据库的用户信息进行验证，不能验证其他数据库的用户信息。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">D:\<span class="title">MongoDB</span>\<span class="title">mongodb</span>-2.4.8\<span class="title">bin</span>&gt;<span class="title">mongo</span> 127.0.0.1/<span class="title">test</span> -<span class="title">utest_user</span> -<span class="title">ppassword</span></span></div><div class="line"><span class="function"><span class="title">MongoDB</span> <span class="title">shell</span> <span class="title">version</span>: 2.4.8</span></div><div class="line"><span class="function"><span class="title">connecting</span> <span class="title">to</span>: 127.0.0.1/<span class="title">test</span></span></div><div class="line"><span class="function">&gt; <span class="title">db.auth</span>("<span class="title">test_user1</span>","<span class="title">password</span>")</span></div><div class="line"><span class="function">1</span></div><div class="line"><span class="function">&gt; <span class="title">db.auth</span>("<span class="title">some_user</span>","<span class="title">password</span>")</span></div><div class="line"><span class="function"><span class="title">Error</span>: 18 &#123; <span class="title">code</span>: 18, <span class="title">ok</span>: 0.0, <span class="title">errmsg</span>: "<span class="title">auth</span> <span class="title">fails</span>" &#125;</span></div><div class="line"><span class="function">0</span></div></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>启用 MongoDB 用户认证的步骤：</p><ol><li>在要启用认证的数据库中创建对应的用户</li><li>如果 admin 中没有用户，则必须在 admin 中添加用户，否则即使使用 –auth 的方式启动 MongoDB，认证方式也无效，默认会拥有超级权限</li><li>以认证方式，即 –auth 参数的方式启动 MongoDB 数据库</li><li>用数据库对应的用户登录数据库，比如：mongo 127.0.0.1/test -utest_user -ppasword</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.mongodb.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MongoDB&lt;/a&gt;是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。这里推荐一个快速入门教程 - &lt;a href=&quot;http://www.cnblogs.com/huangxincheng/category/355399.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;8天学通 MongoDB&lt;/a&gt;，写的很全面。这里讨论的是 MongoDB 的用户和身份验证。&lt;/p&gt;
&lt;p&gt;在默认情况下，MongoDB 不会进行身份验证，也没有账号，只要能连接上服务就可以对数据库进行各种操作，如果你在一个面向公众的服务器上使用它，那么这的确是一个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/logo-mongodb-tagline.png&quot; alt=&quot;http://blog.mongodb.org/&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://bubkoo.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 JavaScript 中的 delete 操作符</title>
    <link href="http://bubkoo.com/2014/01/23/deep-in-delete/"/>
    <id>http://bubkoo.com/2014/01/23/deep-in-delete/</id>
    <published>2014-01-23T16:26:07.000Z</published>
    <updated>2014-01-23T16:26:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>delete 操作符用于删除对象的属性。</p><p>似乎很多同学（包括我）对 delete 操作符都是似是而非，为什么有的属性可以被删除，有的却不能被删除？为什么能够删除对象的属性却不能删除变量或函数？在 eval 和 <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Strict_mode" target="_blank" rel="external">严格模式</a>下，delete 操作符又有哪些特性？等等。。</p><p>本文将从基本概念到 ECMPScript 内部原理来学习 delete 操作符。</p><h2><span id="语法">语法</span></h2><p><strong>表达式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> object.property    <span class="comment">// 点操作符方式，常用方式</span></div><div class="line"><span class="keyword">delete</span> object[<span class="string">'property'</span>] <span class="comment">// 字符串属性名方式</span></div></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li>object - 对象名称，或者返回一个对象的表达式</li><li>property - 将要删除的属性</li></ul><p><strong>返回值</strong></p><p>delete 操作符返回 true 或 false。当被 delete 的对象的属性存在并且拥有 DontDelete (对象属性的一个内部属性，拥有该内部属性表明该属性不能被删除) 时返回 false（在<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Strict_mode" target="_blank" rel="external">严格模式</a>下将抛出异常），否则返回 true。需要注意的是，对象属性不存在时也返回 true，<em>所以返回值并非完全等同于删除成功与否</em>。</p><p><img src="http://bubkoo.qiniudn.com/delete-operator.jpg" alt=""></p><a id="more"></a><h2><span id="delete-删除了什么">delete 删除了什么</span></h2><p>delete 操作符用来删除对象的属性，这里所说的属性实际上是属性本身，而不是属性指向的对象（对于引用类型来说）。所以，对于引用类型的值，delete 删除了对象属性的本身，不会删除属性指向的对象。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">o.x = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="keyword">delete</span> o.x;     <span class="comment">// 上一行new的Object对象依然存在</span></div><div class="line">o.x;            <span class="comment">// undefined，o的名为x的属性被删除了</span></div></pre></td></tr></table></figure><p>在实际的 JavaScrip t中，<code>delete o.x</code> 之后，Object 对象会由于失去了引用而被垃圾回收， 所以 <code>delete o.x</code> 也就“相当于”删除了 <code>o.x</code> 所指向的对象，但这个动作并不是 ECMAScript 标准，也就是说，即使某个实现完全不删除 Object 对象，也不算是违反 ECMAScript 标准。</p><p>下面代码说明了 delete 只删除属性本身，而不会删除属性所指的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> a = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</div><div class="line">o.a = a;</div><div class="line"><span class="keyword">delete</span> o.a;    <span class="comment">// o.a属性被删除</span></div><div class="line">o.a;           <span class="comment">// undefined</span></div><div class="line">a.x;           <span class="comment">// 10, 因为&#123; x: 10 &#125; 对象依然被 a 引用，所以不会被回收</span></div></pre></td></tr></table></figure><p>虽然是一个小小的 delete 操作符，其行为却异常复杂。</p><p>为什么我们能删除一个对象的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</div><div class="line"><span class="keyword">delete</span> x.a; <span class="comment">// true</span></div><div class="line">x.a; <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>但却不能删除一个变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">delete</span> x; <span class="comment">// false;</span></div><div class="line">x; <span class="comment">// 1</span></div></pre></td></tr></table></figure><p>也不能删除一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123; &#125;;</div><div class="line"><span class="keyword">delete</span> x; <span class="comment">// false;</span></div><div class="line"><span class="keyword">typeof</span> x; <span class="comment">// "function"</span></div></pre></td></tr></table></figure><p>要知道其中的原委，我们需要先了解一些基本概念。</p><h2><span id="代码类型">代码类型</span></h2><p>在 ECMAScript 中，有 3 种不同类型的可执行代码：</p><ol><li>全局代码 (Global code) - 当一段源代码被看成程序 (Program) 时，它将会在全局作用域内执行，并且被认为是全局代码。在浏览器环境中，脚本元素的内容通常被解释为程序，因此被作为全局代码来执行。</li><li>函数代码 (Function code) - 在一段函数中直接执行的代码就被认为是一段函数代码，在浏览器环境下，节点的事件属性（如 <code>&lt;a onclick=&quot;...&quot;</code>）通常都作为函数代码来解析和执行。</li><li>Eval代码 (Eval code) - 被内置函数 <code>eval</code> 执行的代码文本被解释成 Eval 代码</li></ol><h2><span id="执行上下文-execution-context">执行上下文 (Execution context)</span></h2><p>代码的执行都是在特定的执行上下文中进行的，对于以上三种代码类型都有一个执行上下文与其对应。比如，当一个函数被执行时，程序控制就进入了函数代码执行上下文；当一段全局代码被执行时，程序控制就进入了全局代码执行上下文，等等。</p><p>执行上下文在逻辑上是一个栈（stack）。首先可能有一段全局代码，它拥有属于自己的执行上下文；在这段代码中可能调用一个函数，这个函数同样拥有属于自己的执行上下文；这个函数可能调用另一个函数，等等。即使当函数递归调用自己时，在每一步调用中仍然进入了不同的执行上下文。</p><p>执行上下文与作用域链和闭包等概念息息相关，欲深入了解执行上下文可以查阅作用域链和闭包的相关资料。</p><h2><span id="活动对象-activation-object-变量对象-variable-object">活动对象 (Activation object) / 变量对象 (Variable Object)</span></h2><p>每个执行上下文都有一个与之相关联的<strong>变量对象 (Variable object)</strong>，在某个执行上下文中申明的变量和函数将被当着属性 (properties) 附加到这个变量对象上面。</p><p>当在全局代码的执行上下文时，全局对象 (Global object) 成为当前执行上下文的变量对象，在浏览器中就是 window 对象。因此，声明的全局函数和变量就成为全局对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* this 指代全局对象 */</span></div><div class="line"><span class="keyword">var</span> GLOBAL_OBJECT = <span class="keyword">this</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line">GLOBAL_OBJECT.foo; <span class="comment">// 1</span></div><div class="line">foo === GLOBAL_OBJECT.foo; <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">typeof</span> GLOBAL_OBJECT.bar; <span class="comment">// "function"</span></div><div class="line">GLOBAL_OBJECT.bar === bar; <span class="comment">// true</span></div></pre></td></tr></table></figure><p>局部变量（那些在函数代码中定义的变量）是怎么样的呢？当在函数代码的执行上下文时，<strong>活动对象 (Activation object)</strong> 成为当前执行上下文中的变量对象，在函数代码中申明的变量和函数成为活动对象的属性，并且函数的参数（形参名为属性名）和 Arguments 对象（arguments 为属性名）也将成为活动对象的属性。</p><p>注意，活动对象只是一个内部描述机制，在程序代码中不能直接访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">foo</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> bar = <span class="number">2</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">        抽象的过程</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        'arguments' 对象成为所在函数的活化对象的属性：</span></div><div class="line"><span class="comment">        ACTIVATION_OBJECT.arguments = arguments;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        ...参数 'foo' 也是一样：</span></div><div class="line"><span class="comment">        ACTIVATION_OBJECT.foo; // 1</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        ...变量 'bar' 也是一样：</span></div><div class="line"><span class="comment">        ACTIVATION_OBJECT.bar; // 2</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        ...函数 'baz' 也是一样：</span></div><div class="line"><span class="comment">        typeof ACTIVATION_OBJECT.baz; // "function"</span></div><div class="line"><span class="comment">    */</span></div><div class="line">&#125;)(<span class="number">1</span>);</div></pre></td></tr></table></figure><p>在 eval 代码中申明的变量会根据 eval 所在的执行上下文来确定变量将成为哪个变量对象的属性。例如：</p><p>在全局环境中执行 eval，那么变量将成为全局对象的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> GLOBAL_OBJECT = <span class="keyword">this</span>;</div><div class="line"><span class="built_in">eval</span>(<span class="string">'var foo = 1'</span>);</div><div class="line">GLOBAL_OBJECT.foo; <span class="comment">// 1;</span></div></pre></td></tr></table></figure><p>在函数作用域中执行 eval，变量将成为活动对象的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> GLOBAL_OBJECT = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">eval</span>(<span class="string">'var bar = 2;'</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    抽象过程</span></div><div class="line"><span class="comment">    ACTIVATION_OBJECT.bar; // 1</span></div><div class="line"><span class="comment">    */</span></div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// 全局环境下不能访问 bar</span></div><div class="line"><span class="keyword">this</span>.bar <span class="comment">// undefined</span></div></pre></td></tr></table></figure><h2><span id="属性的内部属性">属性的内部属性</span></h2><p>我们马上就接近本文主题了，从上面我们知道声明的变量成了变量对象（全局对象或活动对象）的属性，同时每个属性都可以拥有一个或多个内部属性：<code>ReadOnly</code>、<code>DontEnum</code>、<code>DontDelete</code> 和 <code>Internal</code>。这里我们关注的是 <code>DontDelete</code> 这个内部属性，拥有这个内部属性的变量表明该变量不能使用 delete 操作符删除。</p><p><strong>当被声明的变量和函数成为变量对象的属性时，这些属性在创建时就带上了 DontDelete 这个内部属性</strong>。然而，<strong>任何显式/隐式赋值的属性不生成 DontDelete</strong>。这就是为什么我们能够删除一些属性，但有的却不能删除。</p><p>上面的分析可能不好理解，直接看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> GLOBAL_OBJECT = <span class="keyword">this</span>;</div><div class="line"></div><div class="line"><span class="comment">/* 'foo' 是全局对象的一个属性，</span></div><div class="line"><span class="comment">    它通过变量声明而生成，因此拥有内部属性 DontDelete</span></div><div class="line"><span class="comment">    这就是为什么它不能被删除</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line"><span class="keyword">delete</span> foo; <span class="comment">// false</span></div><div class="line"><span class="keyword">typeof</span> foo; <span class="comment">// "number"</span></div><div class="line"></div><div class="line"><span class="comment">/* 'bar' 是全局对象的一个属性，</span></div><div class="line"><span class="comment">    它通过变量声明而生成，因此拥有 DontDelete</span></div><div class="line"><span class="comment">    这就是为什么它同样不能被删除</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="keyword">delete</span> bar; <span class="comment">// false</span></div><div class="line"><span class="keyword">typeof</span> bar; <span class="comment">// "function"</span></div><div class="line"></div><div class="line"><span class="comment">/* 'baz' 也是全局对象的一个属性，</span></div><div class="line"><span class="comment">    然而，它通过属性赋值而生成，因此没有DontDelete</span></div><div class="line"><span class="comment">    这就是为什么它可以被删除</span></div><div class="line"><span class="comment">*/</span></div><div class="line">GLOBAL_OBJECT.baz = <span class="string">"baz"</span>;</div><div class="line"><span class="keyword">delete</span> GLOBAL_OBJECT.baz; <span class="comment">// true</span></div><div class="line"><span class="keyword">typeof</span> GLOBAL_OBJECT.baz; <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure><h2><span id="内置对象和dontdelete">内置对象和DontDelete</span></h2><p>所以，某些属性不能被删除的<strong>根本原因在于：这些属性拥有内部属性 <code>DontDelete</code></strong>，该内部属性控制着该属性是否可以被删除。注意：内置对象的一些属性拥有内部属性 <code>DontDelete</code>，因此不能被删除； 特殊的 arguments 变量（活化对象的属性）拥有 <code>DontDelete</code>； 任何函数实例的 length (返回形参长度)属性也拥有 <code>DontDelete</code>： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//不能删除'arguments'，因为有DontDelete</span></div><div class="line">    <span class="keyword">delete</span> <span class="built_in">arguments</span>; <span class="comment">// false;</span></div><div class="line">    <span class="keyword">typeof</span> <span class="built_in">arguments</span>; <span class="comment">// "object"</span></div><div class="line"></div><div class="line">    <span class="comment">//也不能删除函数的'length',因为有DontDelete</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    <span class="keyword">delete</span> f.length; <span class="comment">// false;</span></div><div class="line">    <span class="keyword">typeof</span> f.length; <span class="comment">// "number"</span></div><div class="line">&#125;) ();</div></pre></td></tr></table></figure><p>与函数 arguments 相关联的属性也拥有 DontDelete，同样不能被删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">foo, bar</span>) </span>&#123;</div><div class="line">    <span class="keyword">delete</span> foo; <span class="comment">// false</span></div><div class="line">    foo; <span class="comment">// 1</span></div><div class="line"></div><div class="line">    <span class="keyword">delete</span> bar; <span class="comment">// false</span></div><div class="line">    bar; <span class="comment">// "bah"</span></div><div class="line">&#125;) (<span class="number">1</span>, <span class="string">"bah"</span>);</div></pre></td></tr></table></figure><h2><span id="未声明的变量赋值">未声明的变量赋值</span></h2><p>我们知道，直接给未声明的变量赋值会成为全局对象的属性，除非这一属性在作用域链内的其他地方被找到。而我们之前提到过，属性赋值和变量声明的区别：后者生成 <code>DontDelete</code> 而前者不生成，这也就是为什么未声明的变量赋值可以被删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> GLOBAL_OBJECT = <span class="keyword">this</span>;</div><div class="line"></div><div class="line"><span class="comment">/* 通过变量声明生成全局对象的属性，拥有 DontDelete */</span></div><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">/* 通过未声明的变量赋值生成全局对象的属性，没有 DontDelete */</span></div><div class="line">bar = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">delete</span> foo; <span class="comment">// false</span></div><div class="line"><span class="keyword">delete</span> bar; <span class="comment">// true</span></div></pre></td></tr></table></figure><p>注意：内部属性是在属性生成时确定的，之后的赋值过程不会改变已有的属性的内部属性。理解这点非常重要。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 'foo'创建的同时生成 DontDelete */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* 之后的赋值过程不改变已有属性的内部属性，DontDelete仍然存在 */</span></div><div class="line">foo = <span class="number">1</span>;</div><div class="line"><span class="keyword">delete</span> foo; <span class="comment">// false;</span></div><div class="line"><span class="keyword">typeof</span> foo; <span class="comment">// "number"</span></div><div class="line"></div><div class="line"><span class="comment">/* 但赋值一个不存在的属性时，创建了一个没有内部属性的属性，因此没有 DontDelete */</span></div><div class="line"><span class="keyword">this</span>.bar = <span class="number">1</span>;</div><div class="line"><span class="keyword">delete</span> bar; <span class="comment">// true;</span></div><div class="line"><span class="keyword">typeof</span> bar; <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure><h2><span id="原型中声明的属性和对象自带的属性">原型中声明的属性和对象自带的属性</span></h2><p>原型 prototype 中声明的属性和对象自带的属性(其实这些属性也是在原型 prototype 中的)可以认为是带有 DontDelete 特性的，无法被删除。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//原型中声明的属性无法被删除</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.x = <span class="number">42</span>; &#125;</div><div class="line">C.prototype.x = <span class="number">12</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> C();</div><div class="line">o.x;     <span class="comment">// 42, 构造函数中定义的o.x</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> o.x;</div><div class="line">o.x;     <span class="comment">// 12,  prototype中定义的o.x，即使再次执行delete o.x也不会被删除</span></div><div class="line"></div><div class="line"><span class="comment">//对象自带的属性无法被删除</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> re = <span class="regexp">/abc/i</span>;</div><div class="line"><span class="keyword">delete</span> re.ignoreCase;</div><div class="line">re.ignoreCase; <span class="comment">// true, ignoreCase无法删除</span></div></pre></td></tr></table></figure><h2><span id="eval-和-firebug-控制台">Eval 和 Firebug 控制台</span></h2><p><strong>在 console 中的所有文本都会被当做 eval 代码来解析和执行，而不是全局或函数代码。</strong>我之前说过，eval 在处理变量声明时有一个特殊的行为：<strong>在 eval 中声明的变量事实上没有 DontDelete 属性</strong>。所以，下面声明的所有变量最后都没有 DontDelete 这个内部属性，所以它们都能被删除。所以要小心普通的全局代码和 Firebug 控制台中代码的区别。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">'var foo = 1;'</span>);</div><div class="line">foo; <span class="comment">// 1</span></div><div class="line"><span class="keyword">delete</span> foo; <span class="comment">// true</span></div><div class="line"><span class="keyword">typeof</span> foo; <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure><p>在函数代码中也是一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">eval</span>(<span class="string">'var foo = 1;'</span>);</div><div class="line">    foo; <span class="comment">// 1</span></div><div class="line">    <span class="keyword">delete</span> foo; <span class="comment">// true</span></div><div class="line">    <span class="keyword">typeof</span> foo; <span class="comment">// "undefined"</span></div><div class="line">&#125;) ();</div></pre></td></tr></table></figure><p>但是这也有一点<strong>例外</strong>，在 eval 代码中的函数内部通过 <code>var</code> 定义的变量具有 DontDelete，不能被删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">"(function() &#123; var x = 42; delete x; return x; &#125;)();"</span>);</div><div class="line"><span class="comment">// 返回 42</span></div></pre></td></tr></table></figure><h2><span id="浏览器兼容性">浏览器兼容性</span></h2><p>了解事物的工作原理是重要的，但实际的实现情况更重要。浏览器在创建和删除变量/属性时都遵守这些标准吗？ 对于大部分来说，是的。</p><p>这里有一个<a href="http://kangax.github.com/jstests/delete_compliance_test/" target="_blank" rel="external">简单的测试集</a>来检查全局代码、函数代码和 Eval 代码的遵守情况。 测试单元同时检测了 delete 操作的返回值和属性是否像预期那样被删除。delete 的返回值并不像它的实际结果那样重要，delete 操作返回 true 或 false 并不重要， 重要的是拥有/没有 DontDelete 的属性是否被删除。</p><p>现代浏览器总的来说还是遵守删除规则的，以下浏览器全部通过测试： Opera 7.54+，Firefox 1.0+，Safari 3.1.2+，Chrome 4+。</p><p>Safari 2.x 和 3.0.4 在删除函数 arguments 时存在问题，似乎这些属性在创建时不带 DontDelete，因此可以被删除。Safari 2.x 还有其他问题——删除无引用时（例如 delete 1）抛出错误（译者按：IE 同样有）；函数声明生成了可删除的属性（奇怪的是变量声明则正常）；eval 中的变量声明变成不可删除（而 eval 中的函数声明则正常）。</p><p>与 Safari 类似，Konqueror（3.5，而非4.3）在 delete 无引用和删除 arguments 是也存在同样问题。</p><p><strong>Gecko DontDelete bug</strong><br>Gecko 1.8.x 浏览器—— Firefox 2.x, Camino 1.x, Seamonkey 1.x, etc. ——存在一个有趣的 bug：显式赋值值给一个属性能移除它的 DontDelete，即使该属性通过变量或函数声明而生成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; &#125;;</div><div class="line"><span class="keyword">delete</span> foo; <span class="comment">// false;</span></div><div class="line"><span class="keyword">typeof</span> foo; <span class="comment">// "function"</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.foo = <span class="number">1</span>;</div><div class="line"><span class="keyword">delete</span> foo; <span class="comment">// true</span></div><div class="line"><span class="keyword">typeof</span> foo; <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure><p>令人惊讶的是，IE5.5-8 也通过了绝大部分测试，除了删除非引用抛出错误（e.g. delete 1，就像旧的 Safari）。 但是，虽然不能马上发现，事实上 IE 存在更严重的 bug，这些 bug 是关于全局对象。</p><h2><span id="ie-bugs">IE bugs</span></h2><p>在 IE 中（至少在 IE6-8 中），下面的表达式抛出异常（在全局代码中）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line"><span class="keyword">delete</span> x; <span class="comment">// TypeError: Object doesn't support this action</span></div></pre></td></tr></table></figure><p>下面则是另一个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x =<span class="number">1</span>;</div><div class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x; <span class="comment">// TypeError: Cannot delete 'this.x'</span></div><div class="line"><span class="comment">// 译者按：在IE8下抛出此异常，在IE6,7下抛出的是和上面一样的异常</span></div></pre></td></tr></table></figure><p>这似乎说明，在 IE 中在<strong>全局代码中的变量声明并没有生成全局对象的同名属性</strong>。 通过赋值创建的属性（this.x = 1）然后通过 delete x 删除时抛出异常； 通过变量声明（var x = 1）创建的属性然后通过 delete this.x 删除时抛出另一个（译者按：在 IE6,7 下错误信息与上面的相同）。</p><p>但不只是这样，事实上通过显式赋值创建的属性<strong>在删除时总是抛出异常</strong>。 这不只是一个错误，而是创建的属性看上去拥有了 DontDelete 内部属性，而按规则应该是没有的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x; <span class="comment">// TypeError: Object doesn't support this action</span></div><div class="line"><span class="keyword">delete</span> x; <span class="comment">// TypeError: Object doesn't support this action</span></div></pre></td></tr></table></figure><p>另一方面，未声明的变量赋值（那些同样生成全局对象的属性）又确实在IE下能够正常删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">1</span>;</div><div class="line"><span class="keyword">delete</span> x; <span class="comment">// true</span></div></pre></td></tr></table></figure><p>但如果你试图通过 this 关键字来进行删除（delete this.x），那么上面的异常又将抛出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">1</span>;</div><div class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x; <span class="comment">//TypeError: Cannot delete 'this.x'</span></div></pre></td></tr></table></figure><p>如果归纳一下，我们将发现在全局代码中 <code>delete this.x</code> 永远不会成功。当通过显式赋值来生成属性（this.x = 1）时抛出一个异常； 当通过声明/非声明变量的方式（var x = 1 or x = 1）生成属性时抛出另一个异常。而另一方面，delete x 只有在显示赋值生成属性(this.x = 1)时才抛出异常。</p><h2><span id="宿主对象host-object">宿主对象(Host Object)</span></h2><p>小小总结一下 delete 操作符：</p><ol><li>如果操作数不是引用类型，则返回 <code>true</code></li><li>如果对象没有同名的<strong>直接属性</strong>，返回 <code>true</code> （对象可以是活动对象或全局对象）</li><li>如果属性存在但是有 DontDelete 特性, 返回 <code>false</code></li><li>其它情况，删除属性并且返回 <code>true</code></li></ol><p>然而，<strong>对于宿主对象（host object）的 delete 操作的行为却可能是不可预料的</strong>。</p><p>我们已经看到了在IE中的一些问题：当删除某些对象（那些实现为了宿主对象）属性时抛出异常。 一些版本的 firefox 当试图删除 window.location 时抛出异常（译者按：IE 同样抛出）。 同样，在一些宿主对象中你也不能相信 delete 的返回值， 例如下面发生在 firefox 中的(译者按：chrome 中同样结果；IE 中抛出异常；opera 和 safari 允许删除，并且删除后无法调用，姑且算’正常‘，尽管，从下面的讨论来看似乎却是不正常的，它们事实上删除了不能删除的属性，而前面的浏览器没有)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 'alert'是’window‘的一个直接属性（如果我们能够相信'hasOwnProperty'） */</span></div><div class="line"><span class="built_in">window</span>.hasOwnProperty(<span class="string">'alert'</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.alert; <span class="comment">// true</span></div><div class="line"><span class="keyword">typeof</span> <span class="built_in">window</span>.alert; <span class="comment">// "function"</span></div></pre></td></tr></table></figure><p><code>delete window.alert</code> 返回 <code>true</code>，尽管这个属性没有任何条件可能产生这个结果（按照上面的算法）：它解析为一个引用，因此不能在第一步返回 <code>true</code>；它是 window 对象的直接属性，因此不能在第二步返回 true；唯一能返回 true 的是当算法达到最后一步同时确实删除这个属性，而事实上它并没有被删除。（译者按：不，在 opera 和 safari 中确实被删除了…）。</p><p>所以这个故事告诉我们永远不要相信宿主对象。</p><h2><span id="es5-严格模式">ES5 严格模式</span></h2><p>在 ES5 严格模式下，当删除操作指向一个变量/函数参数/函数声明的直接引用时抛出 SyntaxError。 此外，如果属性拥有内部属性 [[Configurable]] == false，将抛出 TypeError：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">foo</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>; <span class="comment">//在函数中开启严格模式</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> bar;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>;</span></div><div class="line"><span class="function">    <span class="title">delete</span> <span class="title">foo</span>; // <span class="title">SyntaxError</span>，当删除函数参数时</span></div><div class="line"><span class="function">    <span class="title">delete</span> <span class="title">bar</span>; // <span class="title">SyntaxError</span>，当删除变量时</span></div><div class="line"><span class="function">    <span class="title">delete</span> <span class="title">baz</span>; // <span class="title">SyntaxError</span>，当删除由函数声明创建的变量时</span></div><div class="line"><span class="function"></span></div><div class="line">    /* function实例的length拥有[[Configurable]] : false */</div><div class="line">    <span class="keyword">delete</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).length; <span class="comment">// TypeError</span></div><div class="line">&#125;) ();</div></pre></td></tr></table></figure><p>而且，在严格模式下，删除未声明的变量（换句话说，未解析的引用），同样抛出 SyntaxError；同时，在严格模式下未声明的赋值也将抛出异常 ReferenceError：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">delete</span> i_dont_exist; <span class="comment">// SyntaxError</span></div><div class="line"></div><div class="line">i_dont_exist_either = <span class="number">1</span>; <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure><p>看了之前给出的变量、函数声明和参数的例子，相信现在你也理解了，所有这些限制都是有其意义的。严格模式采取了更积极的和描述性的措施，而不只是忽略这些问题。</p><h2><span id="总结">总结</span></h2><p>下面是对于 JavaScript 中 delete 操作是如何工作的简短的总结：</p><ul><li>变量和函数声明都是活化对象(Activation Object) 或全局对象(Global Object)的属性</li><li>属性拥有内部属性，其中 DontDelete 这个内部属性负责确定一个属性是否能够被删除</li><li>在<strong>全局或者函数代码</strong>中的变量和函数声明总是创建<strong>带有 DontDelete 特性</strong>的属性</li><li><strong>函数参数</strong>总是活动对象的属性, 并且<strong>带有 DontDelete</strong></li><li>在 <strong>Eval 代码</strong>中声明的变量和函数总是创建<strong>不带 DontDelete 特性</strong> 的属性</li><li><strong>新的未声明的属性</strong>在生成时带空的内部属性，因此也<strong>不带 DontDelete 特性</strong></li><li>永远不要相信<strong>宿主对象</strong>对 delete 操作做出的反应</li></ul><p>如果你想要对这里所描述的东西更加熟悉的话，请参阅 <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" target="_blank" rel="external">ECMA-262 3rd edition specification</a>。</p><h2><span id="参考资源">参考资源</span></h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FOperators%2Fdelete#section_5" target="_blank" rel="external">MDN &gt; Web technology for developers &gt; JavaScript &gt; JavaScript reference &gt; Operators &gt; delete</a></li><li><a href="http://perfectionkills.com/understanding-delete/" target="_blank" rel="external">Perfection Kills: Understanding delete</a></li><li><a href="http://www.ituring.com.cn/article/7620" target="_blank" rel="external">理解delete</a></li><li><a href="http://blog.charlee.li/javascript-variables-and-delete-operator/" target="_blank" rel="external">Javascript的变量与delete操作符</a></li><li><a href="http://www.css88.com/archives/5137" target="_blank" rel="external">Javascript中的delete操作符</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;delete 操作符用于删除对象的属性。&lt;/p&gt;
&lt;p&gt;似乎很多同学（包括我）对 delete 操作符都是似是而非，为什么有的属性可以被删除，有的却不能被删除？为什么能够删除对象的属性却不能删除变量或函数？在 eval 和 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Strict_mode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;严格模式&lt;/a&gt;下，delete 操作符又有哪些特性？等等。。&lt;/p&gt;
&lt;p&gt;本文将从基本概念到 ECMPScript 内部原理来学习 delete 操作符。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;表达式&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; object.property    &lt;span class=&quot;comment&quot;&gt;// 点操作符方式，常用方式&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; object[&lt;span class=&quot;string&quot;&gt;&#39;property&#39;&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;// 字符串属性名方式&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;object - 对象名称，或者返回一个对象的表达式&lt;/li&gt;
&lt;li&gt;property - 将要删除的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;delete 操作符返回 true 或 false。当被 delete 的对象的属性存在并且拥有 DontDelete (对象属性的一个内部属性，拥有该内部属性表明该属性不能被删除) 时返回 false（在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Strict_mode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;严格模式&lt;/a&gt;下将抛出异常），否则返回 true。需要注意的是，对象属性不存在时也返回 true，&lt;em&gt;所以返回值并非完全等同于删除成功与否&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/delete-operator.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="delete" scheme="http://bubkoo.com/tags/delete/"/>
    
  </entry>
  
  <entry>
    <title>【译】构建您自己的 AngularJS，第一部分：scopes 和 digest</title>
    <link href="http://bubkoo.com/2014/01/19/angular/make-your-own-angular-part-1-scopes-and-digest/"/>
    <id>http://bubkoo.com/2014/01/19/angular/make-your-own-angular-part-1-scopes-and-digest/</id>
    <published>2014-01-19T21:26:18.000Z</published>
    <updated>2014-01-19T21:26:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://teropa.info/blog/2013/11/03/make-your-own-angular-part-1-scopes-and-digest.html" target="_blank" rel="external">Make Your Own AngularJS, Part 1: Scopes And Digest</a></p><p><img src="http://bubkoo.qiniudn.com/AngularJS-large.png" alt="AngularJS"></p><p>Angular 是一个成熟和功能强大的 JavaScript 框架，也是一个庞大的框架，要正真有效地使用它，需要掌握许多新概念。在 Web 开发人员涌向 Angular 的同时，许多人都面临着同样的疑问：Digest 到底是做什么的？可以有哪些不同的方式来定义一个指令（directive）？service 和 provider 之间有些什么区别？</p><p><a href="http://docs.angularjs.org/" target="_blank" rel="external">Angular官方文档</a>是非常好的学习资源，并且还有越来越多的<a href="http://syntaxspectrum.com/tag/angularjs/" target="_blank" rel="external">第三方资源</a>，不过，想要深入了解一个新的框架，没有比分解它，然后研究其内部运作原理更加有效。</p><p>在本系列文章中，我将从零开始建立一个 AngularJS 类库，并逐步深入讲解，最后，您将对 Angular 的工作原理有一个全面深刻地理解。</p><p>这是本系列的第一部分，我们将分析 Angular 中的 scopes 的工作原理，并且将知道像 <code>$eval</code>、<code>$digest</code> 和 <code>$apply</code> 这些方法到底有些什么作用，Angular 的脏值检查（dirty-checking）貌似很神奇，但是后面您将看到的并非如此。</p><a id="more"></a><h2><span id="关于源代码">关于源代码</span></h2><p>您可以在 GitHub 上获取到本项目的<a href="https://github.com/teropa/schmangular.js" target="_blank" rel="external">完整代码</a>，但是我更加鼓励您自己一步一步地跟着教程来构建，并从各个方面去研究每一行代码。同时，我在页面中嵌入了 <a href="http://jsbin.com/" target="_blank" rel="external">JSBins</a>，这样您就可以直接在页面上与代码进行交互。</p><p>我将使用 <a href="http://lodash.com/" target="_blank" rel="external">Lo-Dash</a> 来对数组和对象做一些基本操作，Angular 本身并没有使用 Lo-Dash，但是为了更好地达到我们的学习目的，就引入 Lo-Dash 来省去一些重复造轮子的工作。如果您在代码中看到以 <code>_</code> 开始的方法或对象，表示这些方法或对象都是由 Lo-Dash 提供。</p><p>在代码中我还使用了 <a href="https://developers.google.com/chrome-developer-tools/docs/console-api#consoleassertexpression_object" target="_blank" rel="external"><code>console.assert</code></a> 方法来做一些随机测试，该方法在现代 JavaScript 环境下应该是可用的。</p><p>下面是  Lo-Dash 和 <code>console.assert</code> 方法的使用示例：</p><iframe src="http://jsbin.com/UGOVUk/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><h2><span id="scope-对象">Scope 对象</span></h2><p>Scope 对象其实就是一个普通的 JavaScript 对象，您可以像在其他对象上添加属性那样在 Scope 对象添加一些属性，Scope 对象是由 Scope 构造函数创建，这里我们实现了一个最简单的版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在，我们就可以通过 new 操作符来创建一个 Scope 对象了，并且可以在上面添加属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> aScope = <span class="keyword">new</span> Scope();</div><div class="line">aScope.firstName = <span class="string">'Jane'</span>;</div><div class="line">aScope.lastName = <span class="string">'Smith'</span>;</div></pre></td></tr></table></figure><p>这些属性并没有什么特别，也不需要调用一些特殊的 setter 方法，并且对属性值的类型也没有限制。其实真正神奇的地方在于两个特殊的方法：<code>$watch</code> 和 <code>$digest</code>。</p><h2><span id="监视对象属性watch-和-digest">监视对象属性：$watch 和 $digest</span></h2><p><code>$watch</code> 和 <code>$digest</code> 是硬币的正反两面，它们一起构成了 Scope 的核心：数据变化的响应（译者注：双向数据绑定）。</p><p>您可以使用 <code>$watch</code> 方法来给 scope 添加一个监视器，当 scope 发生变化时监视器就会收到通知。创建监视器需要给 <code>$watch</code> 传递两个参数：</p><ul><li>一个监视函数，它指定了您将要监视数据</li><li>一个监听回调函数，当监视的数据发生变化时将被调用</li></ul><p class="dot">作为 Angular 的使用者，您通常会指定 watch 表达式而不是 watch 方法，表达式是一个字符串，比如 “user.firstName”，通常在数据绑定、指示器属性或者 JavaScript 代码中指定。表达式将被 Angular 编译成一个监视函数。在后面的文章中，我们将分析 Angular 如何编译一个表达式，在本文中我们将简单滴直接使用监视函数。</p><p>为了实现 <code>$watch</code> 方法，我们需要储存所有注册的监视器，在 Scope 构造函数中添加一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$watchers = [];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>双美元符号 <code>$$</code> 表示该变量是 Angular 框架中的一个私有变量，不能被外部代码调用。</p><p>现在我们来定义 <code>$watch</code> 方法，把上面提到的两个函数作为参数，并将它们储存在 <code>$$watchers</code> 数组中。同时，我们希望 Scope 的每一个实例都具有该方法，所以将其定义在 Scope 的原型上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params">watchFn, listenerFn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> watcher = &#123;</div><div class="line">    watchFn: watchFn,</div><div class="line">    listenerFn: listenerFn</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.$$watchers.push(watcher);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>硬币的另一面就是 <code>$digest</code> 方法，它将运行所有注册在 scope 上的监视器。这里定义了一个简化的版本，仅仅实现了遍历监视器和调用侦听函数的功能，同样也将其定义在 Scope 的原型上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watch</span>) </span>&#123;</div><div class="line">    watch.listenerFn();</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>现在，我们来注册一个监视器，然后调用 <code>$digest</code> 方法，来触发所有的侦听函数：</p><iframe src="http://jsbin.com/oMaQoxa/2/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 198px"></iframe><p>当然，这并不是很有用。我们真正想要的是当监视的值发生改变时，才触发调用侦听函数。</p><h2><span id="脏值检查">脏值检查</span></h2><p>正如上文所述，监视器中的监视函数应该返回被监视数据的变更情况，通常，被监视的数据是绑定在 Scope 上的数据，为了更方便的访问 Scope 上的数据，监视函数把当前 Scope 作为它的一个参数。例如下面，在监视函数中访问 Scope 上的 <code>firstName</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> scope.firstName;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是监控函数的一般形式：从 Scope 中获取一些值，然后返回。</p><p><code>$digest</code> 的职责就是调用监视函数，并且将监视函数的返回值与上一次返回值进行比较，如果发现两次的返回值不一样，说明出现了脏值，同时，与监视函数对应的侦听函数将被调用。</p><p>想要实现这个功能，<code>$digest</code> 必须记住每个监视函数的上次返回值，既然我们为每一个监视器中都创建了一个对象，那么我们可以很方便地保存上一次监视函数的返回值，下面是为每个监视器检查脏值的 <code>$digest</code> 的新的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watch</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newValue = watch.watchFn(self);</div><div class="line">    <span class="keyword">var</span> oldValue = watch.last;</div><div class="line">    <span class="keyword">if</span> (newValue !== oldValue) &#123;</div><div class="line">      watch.listenerFn(newValue, oldValue, self);</div><div class="line">      watch.last = newValue;</div><div class="line">    &#125;</div><div class="line">  &#125;);  </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>通过循环，调用每个监视器中的监视函数，并将 Scope 作为监视函数的参数，然后将返回值与储存在 <code>last</code> 属性中的上一次返回值进行比较。如果发生改变，我们将调用侦听函数，为了方便，我们把监视函数的新返回值、上一次返回值和 Scope 作为侦听函数的参数。最后，我们将监视函数的新返回值储存在 <code>last</code> 属性中，作为下一次比较的值。</p><p>下面的示例演示了当我们调用 <code>$digest</code> 时侦听器是如果工作的：</p><iframe src="http://jsbin.com/OsITIZu/5/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><p>现在，我们已经实现了 Angular 中 Scope 的精髓部分：添加监视并在 <code>$digest</code> 中调用它们。</p><p>我们已经可以看到 Scope 两个重要的特性：</p><ul><li>将数据附加到 Scope 上，数据自身不会对性能产生影响，如果没有监视器来监视这个属性，那个这个属性在不在 Scope 上是无关重要的；Angular 并不会遍历 Scope 上的属性，它将遍历所有的观察器。</li><li>每个监视函数是在每次 <code>$digest</code> 过程中被调用的。因此，我们要注意观察器的数量以及每个监视函数或者监视表达式的性能。</li></ul><h2><span id="收到-digests-的通知-getting-notified-of-digests">收到 Digests 的通知 (Getting Notified Of Digests)</span></h2><p>如果想在每次 digest 之后都收到通知，我们可以利用监视函数将在每次 digest 过程中都会被调用这个事实，只要注册一个监视函数而没有侦听函数的监视器就可以了。</p><p>为了支持这个使用场景，我们需要检查监视器中的侦听函数是否为空，如果为空则将一个空函数赋给侦听函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params">watchFn, listenerFn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> watcher = &#123;</div><div class="line">    watchFn: watchFn,</div><div class="line">    listenerFn: listenerFn || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.$$watchers.push(watcher);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>如果使用了这种方式，需要注意的是，即使没有提供 <code>listenerFn</code>，Angular 也将检查 <code>watchFn</code> 的返回值。如果返回了一个值，该值必须经过脏值检查，所以，为了确保在使用这种模式时不会引起额外的工作，我们在观察函数中不返回任何值。在这种情况下观察函数的返回值将始终是 <code>undefined</code>。</p><iframe src="http://jsbin.com/OsITIZu/6/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><p>核心就是现在这样，但我们还远远没有完成。例如，有一个相当典型的场景我们还不支持：监听函数本身也可能改变 Scope 的属性，如果发生这种情况，并且还有另外一个监视函数监视了刚刚改变的属性值，那么就有可能在同一个 <code>digest</code> 过程中不会收到这个改变通知。</p><iframe src="http://jsbin.com/eTIpUyE/3/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><p>下面让我们来修复这个问题。</p><h2><span id="当有脏值时保持-digest-过程-keep-digesting-while-dirty">当有脏值时保持 digest 过程 (Keep Digesting While Dirty)</span></h2><p>我们需要修改 <code>digest</code> 函数，通过不间断循环遍历所有观察函数，直到所有被监视的值停止改变。 </p><p>首先，将现有的 <code>$digest</code> 函数重命名为 <code>$$digestOnce</code>，修改这个函数的实现，让它运行一次所有的观察函数，并返回一个布尔值，表示是否有任何变化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$digestOnce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self  = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watch</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newValue = watch.watchFn(self);</div><div class="line">    <span class="keyword">var</span> oldValue = watch.last;</div><div class="line">    <span class="keyword">if</span> (newValue !== oldValue) &#123;</div><div class="line">      watch.listenerFn(newValue, oldValue, self);</div><div class="line">      dirty = <span class="literal">true</span>;</div><div class="line">      watch.last = newValue;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> dirty;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>然后，重新定义一个 <code>$digest</code> 函数，只要改变还在发生，在函数内部将不断循环调用 <code>$$digestOnce</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    dirty = <span class="keyword">this</span>.$$digestOnce();</div><div class="line">  &#125; <span class="keyword">while</span> (dirty);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>现在 <code>$digest</code> 函数将至少运行一次所有的观察函数。如果在第一次运行后，有任何的观察值发生了改变，这个过程叫标记为“脏”，然后所有的观察函数将被运行第二遍，这样继续下去，直到有一个完整的过程中所有观察值都没有发生改变，这种情况被认为是稳定的。</p><p class="dot">实际上在 Angular 的 Scope 中并没有一个函数叫 <code>$$digestOnce</code>，所有的 digest  循环都是嵌套在 <code>$digest</code> 函数中。我们的目标是清晰地呈现整个过程，所以将内层循环提取到一个单独的函数中。</p><p>下面是新的实现代码：</p><iframe src="http://jsbin.com/Imoyosa/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><p>现在我们对观察函数有另外一个重要的认识：在一次 digest 过程中观察函数可能被运行多次，这就是为什么人们常说观察函数应该是<a href="http://en.wikipedia.org/wiki/Idempotence" target="_blank" rel="external">幂等</a>的：观察函数应该没有副作用，或者仅发生有限次数的副作用。例如，如果观察函数触发一个 Ajax 请求，这将不确定你的应用程序将发起多少次请求。</p><p>在我们现在的实现中有一个明显的遗漏：如果有两个观察函数监视着彼此彼此的变化，这将发生什么？也就是说，如果状态永远不稳定我们将怎么办？下面代码展示了这种情况。代码中 <code>$digest</code> 的调用被注释掉了，去掉注释看看将发生什么：</p><iframe src="http://jsbin.com/eKEvOYa/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><p>一段时间之后 JSBin 将强制停止函数的执行（在我的机器上它运行了 100000 次迭代）。如果在像 Node.js 这样的平台上运行这段代码，它会永远运行下去。</p><h2><span id="丢弃一个不稳定的-digest-过程-giving-up-on-an-unstable-digest">丢弃一个不稳定的 Digest 过程 (Giving Up On An Unstable Digest)</span></h2><p>我们需要做的是，在可接受数量的迭代范围内是保持运行 Digest 过程。如果超出迭代范围后，Scope 任然没有稳定下来，我们必须停止 Digest 过程，因为 Scope 可能永远不会稳定下来。对于这一点，我们不妨抛出一个异常，因为 Scope 的任何状态都不太可能是用户所期待的的结果。</p><p>最大数量迭代次数被称作 TTL (Time To Live)，默认情况下是 10 次，这个值看起来很小（我们刚刚运行了 100000 次 digest 过程），但请记住这是一个性能敏感地带，因为 digest 过程将经常发生，并且每次 digest 过程都将循环调用观察函数，超过 10 次的迭代通常是不可能的。</p><p class="dot">事实上在 Angular 中 TTL 的值是可以<a href="http://docs.angularjs.org/api/ng.$rootScopeProvider" target="_blank" rel="external">调整</a>的，在后面的文章中，讨论 provider 和依赖注入时我们将再次讨论这个。</p><p>接着，在 digest 循环外添加一个循环计数变量，如果计数到达 TTL，我们将抛出一个异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ttl = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    dirty = <span class="keyword">this</span>.$$digestOnce();</div><div class="line">    <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (dirty);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这个更新版本会导致我们循环引用的观察函数抛出一个异常：</p><iframe src="http://jsbin.com/uNapUWe/3/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><p>这些应该已经把 digest 说清楚了。</p><p>下面，让我们将注意力转向如何检测值变更上。</p><h2><span id="基于值的脏值检查-value-based-dirty-checking">基于值的脏值检查 (Value-Based Dirty-Checking)</span></h2><p>现在我们是通过严格相等操作符 <code>===</code> 来比较新值和旧值。这在大多数情况下是不错的，因为这可以检测到所有值类型（Number、String等）的变化，也可以检测到对象和数组改变为另一个新值（译者注：引用类型的引用改变）。但 Angular 还有另一种方式，并可以检测到对象或数组内部的改变。也就是说，必须基于值来做检测，而不是引用。</p><p>这种脏值检测机制需要在 <code>$watch</code> 函数上引入一个可选的布尔标志参数，如果标志参数为 <code>true</code>，将基于值来进行脏值检测。让我们来重新定义观察器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params">watchFn, listenerFn, valueEq</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> watcher = &#123;</div><div class="line">    watchFn: watchFn,</div><div class="line">    listenerFn: listenerFn,</div><div class="line">    valueEq: !!valueEq</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.$$watchers.push(watcher);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>我们做的是将标记添加到观察器，通过 <code>!!</code> 运算强制将其转换为布尔类型。当用户调用 <code>$watch</code> 时并没有提供第三个参数，那么 <code>valueEq</code> 将是 <code>undefined</code>，在 <code>watcher</code> 对象的内部将是 fasle。</p><p>基于值的脏值检测意味着我们必须遍历新旧对象或数组中所有的值，如果新旧两个值有任何差异，就表示发现了脏值。如果有其他对象或数组嵌套，也将递归比较其中的值。</p><p>Angular 是通过自身的<a href="https://github.com/angular/angular.js/blob/8d4e3fdd31eabadd87db38aa0590253e14791956/src/Angular.js#L812" target="_blank" rel="external">比较函数</a>来进行基于值的比较，我们将使用 <a href="http://lodash.com/docs#isEqual" target="_blank" rel="external">Lo-Dash 提供的一个函数</a>来替代。这里我们定义了一个新的函数，函数包含两个待比较的值和一个布尔标志，并比较相应的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$areEqual = <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, valueEq</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (valueEq) &#123;</div><div class="line">    <span class="keyword">return</span> _.isEqual(newValue, oldValue);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> newValue === oldValue;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>为了得到值改变的通知，我们也需要在观察器中修改储存旧值的方式，储存值的引用并不够，因为如果值的内部发生改变其引用并不会改变，<code>$$areEqual</code> 函数将认为这两个引用是相同的，不能监控到值的变化。因此，我们需要对将要储存的值进行深拷贝，然后再将其储存起来。</p><p>和相等检测函数一样，Angular 有一个自身的<a href="https://github.com/angular/angular.js/blob/8d4e3fdd31eabadd87db38aa0590253e14791956/src/Angular.js#L725" target="_blank" rel="external">深拷贝函数</a>，但是我们将使用 <a href="http://lodash.com/docs#cloneDeep" target="_blank" rel="external">Lo-Dash 内部提供的一个函数</a>。让我们来修改一下 <code>$digestOnce</code> 函数，这样在 <code>$digestOnce</code> 函数中将使用新的 <code>$$areEqual</code> 函数，并在需要的时进行深拷贝来储存更新后的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$digestOnce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self  = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watch</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newValue = watch.watchFn(self);</div><div class="line">    <span class="keyword">var</span> oldValue = watch.last;</div><div class="line">    <span class="keyword">if</span> (!self.$$areEqual(newValue, oldValue, watch.valueEq)) &#123;</div><div class="line">      watch.listenerFn(newValue, oldValue, self);</div><div class="line">      dirty = <span class="literal">true</span>;</div><div class="line">      watch.last = (watch.valueEq ? _.cloneDeep(newValue) : newValue);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> dirty;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>现在，我们可以看到两种脏值检查之间的区别：</p><iframe src="http://jsbin.com/ARiWENO/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><p>基于值进行检查明显比仅仅检查引用更复杂，有时可能会很复杂，遍历嵌套的数据结构需要时间，并且进行深拷贝也占用内存，这就是为什么 Angular 默认不是基于值进行脏值检测的原因，用户需要显式地设置标志来启用它。</p><p class="dot">Angular 还提供了第三种脏值检测的机制：检测集合。与基于值的脏值检测机制一样，也将检测对象和数组的内部，不一样的是，它是一个浅检测，不递归到更深层次，这使其性能比基于值检测更好。通过调用 <code>$watchCollection</code> 函数来实现这种检测机制，在本系列的后续文章中我们将看到它是如何实现的。</p><p>在完成值比较之前，我们还需要处理一个 JavaScript 陷阱。</p><h2><span id="非数字nan">非数字（NaN）</span></h2><p>在 JavaScript 中 NaN (Not a Number) 与自身并不相等，这听起来可能有点怪，但是确实就是这样。如果我们不在脏值检测函数中对 NaN 进行特殊处理，那么包含 NaN 的观察器将始终是脏的。</p><p>在基于值的脏值检测函数中，Lo-Dash 的 <code>isEqual</code> 函数已经为我们处理了这种情况，但是在基于引用的脏值检测函数中我们需要自己来处理，我们需要对 <code>$$areEqual</code> 函数进行微小的修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$areEqual = <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue, valueEq</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (valueEq) &#123;</div><div class="line">    <span class="keyword">return</span> _.isEqual(newValue, oldValue);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> newValue === oldValue ||</div><div class="line">      (<span class="keyword">typeof</span> newValue === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> oldValue === <span class="string">'number'</span> &amp;&amp;</div><div class="line">       <span class="built_in">isNaN</span>(newValue) &amp;&amp; <span class="built_in">isNaN</span>(oldValue));</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这样，包含 NaN 的观察器也将符合预期：</p><iframe src="http://jsbin.com/ijINaRA/3/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><p>有了脏值检测的实现，现在该将我们的注意力转向应用程序中与 Scope 进行交互的方式上了。</p><h2><span id="eval-在-scope-上下文中执行代码">$eval - 在 Scope 上下文中执行代码</span></h2><p>在 Angular 中有几种方法来容许你在 Scope 上下文中执行代码。其中最简单的就是 <code>$eval</code> 方法，它使用一个函数作为参数，在方法内部该函数将被调用，调用时将 Scope 自身作为一个参数传递给它，然后返回该函数的返回值。<code>$eval</code> 方法也可以有一个可选的第二个参数，该参数将作为第一个参数被调用时的参数。</p><p><code>$eval</code> 的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$<span class="built_in">eval</span> = <span class="function"><span class="keyword">function</span>(<span class="params">expr, locals</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> expr(<span class="keyword">this</span>, locals);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>使用 <code>$eval</code> 也非常简单：</p><iframe src="http://jsbin.com/UzaWUC/3/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><p>那么，为什么要使用这种看似迂回的方式来调用一个函数呢？这是因为 <code>$eval</code> 明确指定了代码在 Scope 的上下文中执行。接下来我们将会看到 <code>$eval</code> 也构建了 <code>$apply</code> 的上下文。</p><p>然而，或许使用 <code>$eval</code> 最有趣的地方不是传入函数，而是前面提到过的表达式。就和 <code>$watch</code> 方法一样，你可以给 <code>$eval</code> 方法传递一个字符串表达式，<code>$eval</code> 将编译该字符串然后在 Scope 的上下文中执行。我们将在本系列的后续文章中实现这个。</p><h2><span id="apply-集成外部代码到-digest-循环">$apply - 集成外部代码到 digest 循环</span></h2><p>或许 Scope 上我们知道最多的是 <code>$apply</code>，它被誉为 Angular 集成外部代码的标准方法，这样说是有原因的。</p><p><code>$apply</code> 把一个函数作为参数，接着在其内部使用 <code>$eval</code> 掉用该函数，然后再进行 digest 循环。下面是简单的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$apply = <span class="function"><span class="keyword">function</span>(<span class="params">expr</span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$<span class="built_in">eval</span>(expr);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">this</span>.$digest();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>将 <code>$digest</code> 放在 finally 中，来确保即使函数中发生了异常，也会执行 digest 过程。</p><p><code>$apply</code> 的最大创意在于执行一些不受 Angular 管控的代码，这些代码可能修改 Scope 中的某些值， <code>$apply</code> 可以确保观察器可以收到这些改变的通知。当人们提到使用 <code>$apply</code> 来将外部代码集成到 Abgular 的生命周期中时，他们指的就是这个事情，实在没有比这更重要的了。</p><p>下面是 <code>$apply</code> 的实例：</p><iframe src="http://jsbin.com/UzaWUC/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><h2><span id="evalasync-延迟执行">$evalAsync - 延迟执行</span></h2><p>在 JavaScript 中延迟执行一段代码很常见 - 把执行延迟到当前执行上下文结束之后的未来某个时间点，通常的方法是通过调用 <code>setTimeout()</code> 函数，传递一个 0 (或很小)延迟参数。</p><p>这种模式也适用于 Angular 应用程序，尽管首选的方法是通过使用 <code>$timeout</code> <a href="http://docs.angularjs.org/api/ng.$timeout" target="_blank" rel="external">服务</a>，不同的是，<code>$timeout</code> 将通过 <code>$apply</code> 方法将延迟函数集成到 digest 循环的生命周期中。</p><p>但在 Angular 中还有另外一种方式来延迟代码的执行，那就是 <code>Scope.$evalAsync</code> 函数， <code>$evalAsync</code> 接收一个函数作为参数，并使其在当前 digest 循环或下一个 digest 循环之前被执行。例如，你可以在观察函数中延迟执行一段代码，虽然被延迟执行，但任然会在当前 digest 循环中被调用。</p><p>首先，我们需要一种方式来储存 <code>$evalAsync</code> 中计划的任务，可以在 Scope 的构造函数中初始化一个数组来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$watchers = [];</div><div class="line">  <span class="keyword">this</span>.$$asyncQueue = [];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，定义 <code>$evalAsync</code> 函数，将需要延迟执行的方法添加到队列中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$evalAsync = <span class="function"><span class="keyword">function</span>(<span class="params">expr</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$asyncQueue.push(&#123;<span class="attr">scope</span>: <span class="keyword">this</span>, <span class="attr">expression</span>: expr&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p class="dot">我们将当前 Scope 显示地设置在延迟队列中的目的在于 Scope 的继承，我们将在本系列的下一篇文章中讨论。</p><p>接着，我们在 <code>$digest</code> 函数中使用 <code>$eval</code> 调用延迟队列中的所有被延迟的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ttl = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.$$asyncQueue.length) &#123;</div><div class="line">      <span class="keyword">var</span> asyncTask = <span class="keyword">this</span>.$$asyncQueue.shift();</div><div class="line">      <span class="keyword">this</span>.$<span class="built_in">eval</span>(asyncTask.expression);</div><div class="line">    &#125;</div><div class="line">    dirty = <span class="keyword">this</span>.$$digestOnce();</div><div class="line">    <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (dirty);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这个实现确保了：当 Scope 正处于“脏”的状态时你推迟一个函数的执行，这个函数会被延迟，但是还是处于当前的 digest 循环中。</p><p>下面是 <code>$evalAsync</code> 的使用实例：</p><iframe src="http://jsbin.com/ilepOwI/2/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><h2><span id="scope-的阶段状态scope-phases">Scope 的阶段状态（Scope Phases）</span></h2><p><code>$evalAsync</code> 所做的另外一件事是：如果当前没有正在运行的 digest 循环，就延迟执行一个，这样就可以确保，每当调用 <code>$evalAsync</code> 方法时，digest 循环将很快被触发，而不是等待引发一个 digest 循环。</p><p><code>$evalAsync</code> 需要一个机制来检查是否已经有一个 digest 循环正在运行，如果已经有一个 digest 循环就不必再执行一个。为此，Angular 引入了 <em>phase</em>，它就是 Scope 上的一个字符串属性，储存了当前正在发生着什么。</p><p>在 Scope 的构造函数中引入 <code>$$phase</code> 字段，并初始化为 null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$watchers = [];</div><div class="line">  <span class="keyword">this</span>.$$asyncQueue = [];</div><div class="line">  <span class="keyword">this</span>.$$phase = <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，我们定义了两个方法来控制 phase：一个用于设置，另一个用于清理，同时添加一个额外的检查，以确保我们不会试图设置一个已经激活的 phase：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$beginPhase = <span class="function"><span class="keyword">function</span>(<span class="params">phase</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.$$phase) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">this</span>.$$phase + <span class="string">' already in progress.'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.$$phase = phase;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">Scope.prototype.$clearPhase = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$phase = <span class="literal">null</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在 <code>$digest</code> 方法中，在 digest 循环开始前将 pahse 的值设置为 “$digest” ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ttl = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  <span class="keyword">this</span>.$beginPhase(<span class="string">"$digest"</span>);</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.$$asyncQueue.length) &#123;</div><div class="line">      <span class="keyword">var</span> asyncTask = <span class="keyword">this</span>.$$asyncQueue.shift();</div><div class="line">      <span class="keyword">this</span>.$<span class="built_in">eval</span>(asyncTask.expression);</div><div class="line">    &#125;</div><div class="line">    dirty = <span class="keyword">this</span>.$$digestOnce();</div><div class="line">    <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      <span class="keyword">this</span>.$clearPhase();</div><div class="line">      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (dirty);</div><div class="line">  <span class="keyword">this</span>.$clearPhase();</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>把 <code>$apply</code> 函数也修改一下，在其内部设置 phase，这对我们调试非常有帮助：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$apply = <span class="function"><span class="keyword">function</span>(<span class="params">expr</span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">this</span>.$beginPhase(<span class="string">"$apply"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$<span class="built_in">eval</span>(expr);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">this</span>.$clearPhase();</div><div class="line">    <span class="keyword">this</span>.$digest();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>最后，我们在 <code>$evalAsync</code> 函数中添加 digest 计划任务，它将检查当前 Scope 的 phase，如果 phase 没有被设置（并且没有异步的计划任务），就把这个 digest 列入计划。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$evalAsync = <span class="function"><span class="keyword">function</span>(<span class="params">expr</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">if</span> (!self.$$phase &amp;&amp; !self.$$asyncQueue.length) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (self.$$asyncQueue.length) &#123;</div><div class="line">        self.$digest();</div><div class="line">      &#125;</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line">  self.$$asyncQueue.push(&#123;<span class="attr">scope</span>: self, <span class="attr">expression</span>: expr&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这样，不管什么时候调用 <code>$evalAsync</code>，都可以确保一定有一个 digest 将在稍候就发生。</p><iframe src="http://jsbin.com/iKeSaGi/2/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 206px"></iframe><h2><span id="postdigest-digest-之后执行代码">$$postDigest - digest 之后执行代码</span></h2><p>通过计划执行一个 <code>$$postDigest</code> 函数，也可以把代码附加到 digest 循环中。</p><p>双美元符号 <code>$$</code> 表示该函数是 Angular 的一个内部函数，不是应用开发人员应该使用的，但是它确实存在，因此我们也要实现它。</p><p>和 <code>$evalAsync</code> 一样，<code>$$postDigest</code> 也是延迟执行一个任务，不同的是，被延迟的任务是在下一次 digest 循环结束之后执行。<code>$$postDigest</code> 并不会引起计划执行一个 digest 循环，所以只有某些其他原因引发 digest 循环后才会调用被延迟的函数，因此，如果在延迟函数内部也修改了 Scope 上的数据，您需要手动调用 <code>$digest</code> 或 <code>$apply</code> 来使得这些变更会被监视到。</p><p>首先，我们在 Scope 的构造函数中添加一个 <code>$$postDigest</code> 将要使用到的队列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$watchers = [];</div><div class="line">  <span class="keyword">this</span>.$$asyncQueue = [];</div><div class="line">  <span class="keyword">this</span>.$$postDigestQueue = [];</div><div class="line">  <span class="keyword">this</span>.$$phase = <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，实现 <code>$$postDigest</code> 函数，它所做的就是将给定的函数添加到队列中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$postDigest = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$$postDigestQueue.push(fn);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>最后，在 <code>$digest</code> 函数中，当 digest 循环结束之后，遍历并调用队列中的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ttl = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  <span class="keyword">this</span>.$beginPhase(<span class="string">"$digest"</span>);</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.$$asyncQueue.length) &#123;</div><div class="line">      <span class="keyword">var</span> asyncTask = <span class="keyword">this</span>.$$asyncQueue.shift();</div><div class="line">      <span class="keyword">this</span>.$<span class="built_in">eval</span>(asyncTask.expression);</div><div class="line">    &#125;</div><div class="line">    dirty = <span class="keyword">this</span>.$$digestOnce();</div><div class="line">    <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      <span class="keyword">this</span>.$clearPhase();</div><div class="line">      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (dirty);</div><div class="line">  <span class="keyword">this</span>.$clearPhase();</div><div class="line"> </div><div class="line">  <span class="keyword">while</span> (<span class="keyword">this</span>.$$postDigestQueue.length) &#123;</div><div class="line">    <span class="keyword">this</span>.$$postDigestQueue.shift()();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这样我们就可以使用 <code>$$postDigest</code> 函数了：</p><iframe src="http://jsbin.com/IMEhowO/5/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px"></iframe><h2><span id="异常处理">异常处理</span></h2><p>我们现有的实现已经非常接近 Angular 的实际样子了，但是还比较脆弱，这是因为我们还没有花太多心思去做异常处理。</p><p>在 Angular 中，Scope 在遇到错误时是非常健壮的： 当在监控函数、<code>$evalAsync</code> 函数或者 <code>$$postDigest</code> 函数中发生异常时，并不会导致 digest 循环的终止。在我们现在实现中，以上任何函数中发生异常都会导致 digest 循环的终止。</p><p>不过，这也很容易修复，把上面三个函数的调用都包在 <code>try...catch</code> 中就可以了。</p><p class="dot"><br>Angular 实际上是把这些异常抛给了它的 <a href="http://docs.angularjs.org/api/ng.$exceptionHandler" target="_blank" rel="external">$exceptionHandler 服务</a>。但是我们现在还没有实现这个服务，所以就先把这些异常打印到控制台上。<br></p><p>对 <code>$evalAsync</code> 和 <code>$$postDigest</code> 的异常处理是在 <code>$digest</code> 函数内部进行的，在延迟函数中抛出的异常将被记录成日志，而后面的延迟函数将继续正常执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ttl = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  <span class="keyword">this</span>.$beginPhase(<span class="string">"$digest"</span>);</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.$$asyncQueue.length) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">var</span> asyncTask = <span class="keyword">this</span>.$$asyncQueue.shift();</div><div class="line">        <span class="keyword">this</span>.$<span class="built_in">eval</span>(asyncTask.expression);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        (<span class="built_in">console</span>.error || <span class="built_in">console</span>.log)(e);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    dirty = <span class="keyword">this</span>.$$digestOnce();</div><div class="line">    <span class="keyword">if</span> (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      <span class="keyword">this</span>.$clearPhase();</div><div class="line">      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (dirty);</div><div class="line">  <span class="keyword">this</span>.$clearPhase();</div><div class="line"> </div><div class="line">  <span class="keyword">while</span> (<span class="keyword">this</span>.$$postDigestQueue.length) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">this</span>.$$postDigestQueue.shift()();</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      (<span class="built_in">console</span>.error || <span class="built_in">console</span>.log)(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>对观察函数的异常处理是在 <code>$$digestOnce</code> 函数中进行的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$digestOnce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self  = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> dirty;</div><div class="line">  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span>(<span class="params">watch</span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">var</span> newValue = watch.watchFn(self);</div><div class="line">      <span class="keyword">var</span> oldValue = watch.last;</div><div class="line">      <span class="keyword">if</span> (!self.$$areEqual(newValue, oldValue, watch.valueEq)) &#123;</div><div class="line">        watch.listenerFn(newValue, oldValue, self);</div><div class="line">        dirty = <span class="literal">true</span>;</div><div class="line">        watch.last = (watch.valueEq ? _.cloneDeep(newValue) : newValue);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      (<span class="built_in">console</span>.error || <span class="built_in">console</span>.log)(e);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> dirty;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>现在我们的 digest 循环碰到异常的时候健壮多了：</p><iframe src="http://jsbin.com/IMEhowO/6/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px"></iframe><h2><span id="销毁监听器">销毁监听器</span></h2><p>通常，我们注的监视器都一直存在于 Scope 的生命周期中，很少需要显示地去移除这些监视器。但是在有些场景下，我么需要在 Scope 的生命周期中把某个监听器移除。</p><p>Angular 中的 <code>$watch</code> 函数实际上是有返回值的，它返回的是一个函数，当调用该函数时，可以移除刚刚注册的监视器。为了实现我们自己的版本，我们需要返回一个函数来将监视器从 <code>$$watchers</code> 数组中移除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params">watchFn, listenerFn, valueEq</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> watcher = &#123;</div><div class="line">    watchFn: watchFn,</div><div class="line">    listenerFn: listenerFn,</div><div class="line">    valueEq: !!valueEq</div><div class="line">  &#125;;</div><div class="line">  self.$$watchers.push(watcher);</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> index = self.$$watchers.indexOf(watcher);</div><div class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</div><div class="line">      self.$$watchers.splice(index, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>现在，我们可以储存 <code>$watch</code> 函数的返回值，以后通过调用它来移除这个监视器：</p><iframe src="http://jsbin.com/IMEhowO/7/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px"></iframe><h2><span id="展望">展望</span></h2><p>我们已经取得了很大的进展，并且已经实现了一个完美可用的，类似 Angular 这样基于脏检测的 Scope 系统，但是 Angular 中的 Scope 要复杂得多。</p><p>更重要的是，在 Angular 里 Scope 对象并不是孤立对象，相反，一个 Scope 对象是可以继承另外一个 Scope 对象的，并且监视器不仅可以监视当前 Scope 对象上的数据变化，还可以监视其父 Scope 对象。概念虽然简单，这却让很多初学者很困惑。所以，本系列的下一篇文章主题就是 Scope 的继承。</p><p>随后，我们还会讨论 Angular 的事件系统，这也是在 Scope 上实现的。</p><p><img src="http://bubkoo.qiniudn.com/Build%20Your%20Own%20AngularJS.jpg" alt=""></p><p><a href="http://teropa.info/build-your-own-angular" target="_blank" rel="external">这里</a>有该书的电子版，不过要花钱。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://teropa.info/blog/2013/11/03/make-your-own-angular-part-1-scopes-and-digest.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Make Your Own AngularJS, Part 1: Scopes And Digest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/AngularJS-large.png&quot; alt=&quot;AngularJS&quot;&gt;&lt;/p&gt;
&lt;p&gt;Angular 是一个成熟和功能强大的 JavaScript 框架，也是一个庞大的框架，要正真有效地使用它，需要掌握许多新概念。在 Web 开发人员涌向 Angular 的同时，许多人都面临着同样的疑问：Digest 到底是做什么的？可以有哪些不同的方式来定义一个指令（directive）？service 和 provider 之间有些什么区别？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Angular官方文档&lt;/a&gt;是非常好的学习资源，并且还有越来越多的&lt;a href=&quot;http://syntaxspectrum.com/tag/angularjs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;第三方资源&lt;/a&gt;，不过，想要深入了解一个新的框架，没有比分解它，然后研究其内部运作原理更加有效。&lt;/p&gt;
&lt;p&gt;在本系列文章中，我将从零开始建立一个 AngularJS 类库，并逐步深入讲解，最后，您将对 Angular 的工作原理有一个全面深刻地理解。&lt;/p&gt;
&lt;p&gt;这是本系列的第一部分，我们将分析 Angular 中的 scopes 的工作原理，并且将知道像 &lt;code&gt;$eval&lt;/code&gt;、&lt;code&gt;$digest&lt;/code&gt; 和 &lt;code&gt;$apply&lt;/code&gt; 这些方法到底有些什么作用，Angular 的脏值检查（dirty-checking）貌似很神奇，但是后面您将看到的并非如此。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://bubkoo.com/tags/angularjs/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法【归档】</title>
    <link href="http://bubkoo.com/2014/01/17/sort-algorithm/archives/"/>
    <id>http://bubkoo.com/2014/01/17/sort-algorithm/archives/</id>
    <published>2014-01-17T00:54:42.000Z</published>
    <updated>2014-01-17T00:54:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近整理了一些常见的排序算法，资料基本上都来自网上，大部分参考了维基百科，分析了常见算法的原理，并举例分步说明，有的还给出了排序动画演示，但没有涉及算法复杂度等方面的概念，最后对每一种排序算法都给出了至少一种 JavaScript 的实现方法（因为我是做前端方面的，所以只给出了 JavaScript 代码）。</p><p>由于自己能力和经验有限，难免出现某些纰漏和错误，欢迎指正。</p><p>日本程序员 norahiko，写了一个排序算法的<a href="http://jsdo.it/norahiko/oxIy/fullscreen" target="_blank" rel="external">动画演示</a>，非常有趣。另外，今天一同事告诉我有一个排序算法的舞蹈，请点击【<a href="http://www.cnbeta.com/articles/202221.htm" target="_blank" rel="external">程序员的艺术：排序算法舞蹈</a>】。</p><ul><li><a href="/2014/01/12/sort-algorithm/bubble-sort/">常见排序算法 - 冒泡排序 (Bubble Sort)</a></li><li><a href="/2014/01/12/sort-algorithm/quick-sort/">常见排序算法 - 快速排序 (Quick Sort)</a></li><li><a href="/2014/01/13/sort-algorithm/selection-sort/">常见排序算法 - 选择排序 (Selection Sort)</a></li><li><a href="/2014/01/14/sort-algorithm/heap-sort/">常见排序算法 - 堆排序 (Heap Sort)</a></li><li><a href="/2014/01/14/sort-algorithm/insertion-sort/">常见排序算法 - 插入排序 (Insertion Sort)</a></li><li><a href="/2014/01/15/sort-algorithm/shell-sort/">常见排序算法 - 希尔排序 (Shell Sort)</a></li><li><a href="/2014/01/15/sort-algorithm/merge-sort/">常见排序算法 - 归并排序 (Merge Sort)</a></li><li><a href="/2014/01/15/sort-algorithm/shaker-sort/">常见排序算法 - 鸡尾酒排序 (Cocktail Sort/Shaker Sort)</a></li><li><a href="/2014/01/15/sort-algorithm/bogo-sort/">常见排序算法 - 猴子排序 (Bogo Sort)</a></li><li><a href="/2014/01/15/sort-algorithm/bucket-sort/">常见排序算法 - 桶排序 (Bucket Sort)</a></li><li><a href="/2014/01/15/sort-algorithm/radix-sort/">常见排序算法 - 基数排序 (Radix sort)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近整理了一些常见的排序算法，资料基本上都来自网上，大部分参考了维基百科，分析了常见算法的原理，并举例分步说明，有的还给出了排序动画演示，但没有涉及算法复杂度等方面的概念，最后对每一种排序算法都给出了至少一种 JavaScript 的实现方法（因为我是做前端方面的，所以只给
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Sort" scheme="http://bubkoo.com/tags/sort/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
      <category term="Archives" scheme="http://bubkoo.com/tags/archives/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 - 基数排序 (Radix Sort)</title>
    <link href="http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/"/>
    <id>http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/</id>
    <published>2014-01-15T22:38:55.000Z</published>
    <updated>2014-01-15T22:38:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="算法原理">算法原理</span></h2><p>基数排序 (Radix Sort) 是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的发明可以追溯到 1887 年<a href="http://zh.wikipedia.org/wiki/%E8%B5%AB%E7%88%BE%E6%9B%BC%C2%B7%E4%BD%95%E6%A8%82%E7%A6%AE" target="_blank" rel="external">赫尔曼·何乐礼</a>在<a href="http://zh.wikipedia.org/w/index.php?title=%E6%89%93%E5%AD%94%E5%8D%A1%E7%89%87%E5%88%B6%E8%A1%A8%E6%9C%BA&amp;action=edit&amp;redlink=1" target="_blank" rel="external">打孔卡片制表机 (Tabulation Machine)</a>上的贡献。</p><p>排序过程：将所有待比较数值（<strong>正整数</strong>）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><p>基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法。</p><p><a href="http://www.cs.usfca.edu/~galles/visualization/RadixSort.html" target="_blank" rel="external">Data Structure Visualizations</a> 提供了一个基数排序的分步动画演示。<br><a id="more"></a></p><h2><span id="实例分析">实例分析</span></h2><p>基数排序的方式可以采用 LSD (Least sgnificant digital) 或 MSD (Most sgnificant digital)，LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。 以 LSD 为例，假设原来有一串数值如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">36</span>   <span class="number">9</span>   <span class="number">0</span>   <span class="number">25</span>   <span class="number">1</span>   <span class="number">49</span>   <span class="number">64</span>   <span class="number">16</span>   <span class="number">81</span>   <span class="number">4</span></div></pre></td></tr></table></figure><p>首先根据个位数的数值，按照个位置等于桶编号的方式，将它们分配至编号0到9的桶子中：</p><table><thead><tr><th>编号</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td></td><td>0</td><td>1</td><td></td><td></td><td>64</td><td>25</td><td>36</td><td></td><td></td><td>9</td></tr><tr><td></td><td></td><td>81</td><td></td><td></td><td>4</td><td></td><td>16</td><td></td><td></td><td>49</td></tr></tbody></table><p>然后，将这些数字按照桶以及桶内部的排序连接起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">81</span>   <span class="number">64</span>   <span class="number">4</span>   <span class="number">25</span>   <span class="number">36</span>   <span class="number">16</span>   <span class="number">9</span>   <span class="number">49</span></div></pre></td></tr></table></figure><p>接着按照十位的数值，分别对号入座：</p><table><thead><tr><th>编号</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td></td><td>0</td><td>16</td><td>25</td><td>36</td><td>49</td><td></td><td>64</td><td></td><td>81</td><td></td></tr><tr><td></td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>4</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>9</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>最后按照次序重现连接，完成排序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">4</span>   <span class="number">9</span>   <span class="number">16</span>   <span class="number">25</span>   <span class="number">36</span>   <span class="number">49</span>   <span class="number">64</span>   <span class="number">81</span></div></pre></td></tr></table></figure><h2><span id="javascript-语言实现">JavaScript 语言实现</span></h2><p>暴力上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> bucket = [],</div><div class="line">        l = array.length,</div><div class="line">        loop,</div><div class="line">        str,</div><div class="line">        i,</div><div class="line">        j,</div><div class="line">        k,</div><div class="line">        t,</div><div class="line">        max = array[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; l; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</div><div class="line">            max = array[i]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    loop = (max + <span class="string">''</span>).length;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        bucket[i] = [];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loop; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l; j++) &#123;</div><div class="line">            str = array[j] + <span class="string">''</span>;</div><div class="line">            <span class="keyword">if</span> (str.length &gt;= i + <span class="number">1</span>) &#123;</div><div class="line">                k = <span class="built_in">parseInt</span>(str[str.length - i - <span class="number">1</span>]);</div><div class="line">                bucket[k].push(array[j]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 高位为 0</span></div><div class="line">                bucket[<span class="number">0</span>].push(array[j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        array.splice(<span class="number">0</span>, l);</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">            t = bucket[j].length;</div><div class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; t; k++) &#123;</div><div class="line">                array.push(bucket[j][k]);</div><div class="line">            &#125;</div><div class="line">            bucket[j] = [];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科，自由的百科全书</a></li><li><a href="http://www.cs.usfca.edu/~galles/visualization/RadixSort.html" target="_blank" rel="external">Data Structure Visualizations</a></li><li><a href="http://openhome.cc/Gossip/AlgorithmGossip/RadixSort.htm" target="_blank" rel="external">Algorithm Gossip: 基数排序法</a></li><li><a href="https://www.cs.auckland.ac.nz/software/AlgAnim/radixsort.html" target="_blank" rel="external">Radix Sorting</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;p&gt;基数排序 (Radix Sort) 是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的发明可以追溯到 1887 年&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E8%B5%AB%E7%88%BE%E6%9B%BC%C2%B7%E4%BD%95%E6%A8%82%E7%A6%AE&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;赫尔曼·何乐礼&lt;/a&gt;在&lt;a href=&quot;http://zh.wikipedia.org/w/index.php?title=%E6%89%93%E5%AD%94%E5%8D%A1%E7%89%87%E5%88%B6%E8%A1%A8%E6%9C%BA&amp;amp;action=edit&amp;amp;redlink=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;打孔卡片制表机 (Tabulation Machine)&lt;/a&gt;上的贡献。&lt;/p&gt;
&lt;p&gt;排序过程：将所有待比较数值（&lt;strong&gt;正整数&lt;/strong&gt;）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。&lt;/p&gt;
&lt;p&gt;基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cs.usfca.edu/~galles/visualization/RadixSort.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Data Structure Visualizations&lt;/a&gt; 提供了一个基数排序的分步动画演示。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Sort" scheme="http://bubkoo.com/tags/sort/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 - 桶排序 (Bucket Sort)</title>
    <link href="http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/"/>
    <id>http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/</id>
    <published>2014-01-15T22:27:51.000Z</published>
    <updated>2014-01-15T22:27:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="算法原理">算法原理</span></h2><p>桶排序 (Bucket sort)或所谓的<strong>箱排序</strong>的原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。</p><p>排序过程：</p><ol><li>假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶</li><li>将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序</li><li>将各个桶中的数据有序的合并起来</li></ol><p><a href="http://www.cs.usfca.edu/~galles/visualization/BucketSort.html" target="_blank" rel="external">Data Structure Visualizations</a> 提供了一个桶排序的分步动画演示。<br><a id="more"></a></p><h2><span id="实例分析">实例分析</span></h2><p>设有数组 array = [29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，先设置 5 个桶，那么每个桶可存放数的范围为：0<sub>9、10</sub>19、20<sub>29、30</sub>39、40~49，然后分别将这些数放人自己所属的桶，如下图：</p><p><img src="http://bubkoo.qiniudn.com/bucket-sort-1.png" alt=""></p><p>然后，分别对每个桶里面的数进行排序，或者在将数放入桶的同时用插入排序进行排序。最后，将各个桶中的数据有序的合并起来，如下图：</p><p><img src="http://bubkoo.qiniudn.com/bucket-sort-2.png" alt=""></p><h2><span id="javascript-语言实现">JavaScript 语言实现</span></h2><p>首先用最笨的方法，每一个桶只能放相同的数字，最大桶的数量为数组中的正数最大值加上负数最小值的绝对值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> bucket = [], <span class="comment">// 正数桶</span></div><div class="line">        negativeBucket = [], <span class="comment">// 负数桶</span></div><div class="line">        result = [],</div><div class="line">        l = array.length,</div><div class="line">        i,</div><div class="line">        j,</div><div class="line">        k,</div><div class="line">        abs;</div><div class="line"></div><div class="line">    <span class="comment">// 入桶</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (array[i] &lt; <span class="number">0</span>) &#123;</div><div class="line">            abs = <span class="built_in">Math</span>.abs(array[i]);</div><div class="line">            <span class="keyword">if</span> (!negativeBucket[abs]) &#123;</div><div class="line">                negativeBucket[abs] = [];</div><div class="line">            &#125;</div><div class="line">            negativeBucket[abs].push(array[i]);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (!bucket[array[i]]) &#123;</div><div class="line">                bucket[array[i]] = [];</div><div class="line">            &#125;</div><div class="line">            bucket[array[i]].push(array[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 出桶</span></div><div class="line">    l = negativeBucket.length;</div><div class="line">    <span class="keyword">for</span> (i = l - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">if</span> (negativeBucket[i]) &#123;</div><div class="line">            k = negativeBucket[i].length;</div><div class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; j++) &#123;</div><div class="line">                result.push(negativeBucket[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    l = bucket.length;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (bucket[i]) &#123;</div><div class="line">            k = bucket[i].length;</div><div class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; j++) &#123;</div><div class="line">                result.push(bucket[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面这种方式就是文中举例分析的那样，每个桶存放一定范围的数字，用 step 参数来设置该范围，取 step 为 1 就退化成前一种实现方式。关键部位代码有注释，慢慢看，逻辑稍微有点复杂。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* @array 将要排序的数组</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* @step 划分桶的步长，比如 step = 5，表示每个桶存放的数字的范围是 5，像 -4&lt;sub&gt;1、0&lt;/sub&gt;5、6~11</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">array, step</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [],</div><div class="line">        bucket = [],</div><div class="line">        bucketCount,</div><div class="line">        l = array.length,</div><div class="line">        i,</div><div class="line">        j,</div><div class="line">        k,</div><div class="line">        s,</div><div class="line">        max = array[<span class="number">0</span>],</div><div class="line">        min = array[<span class="number">0</span>],</div><div class="line">        temp;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; l; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</div><div class="line">            max = array[i]</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (array[i] &lt; min) &#123;</div><div class="line">            min = array[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    min = min - <span class="number">1</span>;</div><div class="line"></div><div class="line">    bucketCount = <span class="built_in">Math</span>.ceil((max - min) / step); <span class="comment">// 需要桶的数量</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; i++) &#123;</div><div class="line">        temp = array[i];</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; bucketCount; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (temp &gt; (min + step * j) &amp;&amp; temp &lt;= (min + step * (j + <span class="number">1</span>))) &#123; <span class="comment">// 判断放入哪个桶</span></div><div class="line">                <span class="keyword">if</span> (!bucket[j]) &#123;</div><div class="line">                    bucket[j] = [];</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 通过插入排序将数字插入到桶中的合适位置</span></div><div class="line">                s = bucket[j].length;</div><div class="line">                <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">for</span> (k = s - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</div><div class="line">                        <span class="keyword">if</span> (bucket[j][k] &gt; temp) &#123;</div><div class="line">                            bucket[j][k + <span class="number">1</span>] = bucket[j][k];</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    bucket[j][k + <span class="number">1</span>] = temp;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    bucket[j].push(temp);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123; <span class="comment">// 循环取出桶中数据</span></div><div class="line">        <span class="keyword">if</span> (bucket[i]) &#123;</div><div class="line">            k = bucket[i].length;</div><div class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; j++) &#123;</div><div class="line">                result.push(bucket[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科，自由的百科全书</a></li><li><a href="https://www-927.ibm.com/ibm/cas/hspc/student/algorithms/BucketSort.html" target="_blank" rel="external">Programming Contest Central</a></li><li><a href="http://www.roading.org/algorithm/introductiontoalgorithm/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%884%EF%BC%89-%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88bucket-sort%EF%BC%89.html" target="_blank" rel="external">桶排序（Bucket sort）</a></li><li><a href="http://www.cs.usfca.edu/~galles/visualization/BucketSort.html" target="_blank" rel="external">Data Structure Visualizations</a></li><li><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.6.1.1.htm" target="_blank" rel="external">箱排序(Bin Sort)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;p&gt;桶排序 (Bucket sort)或所谓的&lt;strong&gt;箱排序&lt;/strong&gt;的原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。&lt;/p&gt;
&lt;p&gt;排序过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶&lt;/li&gt;
&lt;li&gt;将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序&lt;/li&gt;
&lt;li&gt;将各个桶中的数据有序的合并起来&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cs.usfca.edu/~galles/visualization/BucketSort.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Data Structure Visualizations&lt;/a&gt; 提供了一个桶排序的分步动画演示。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Sort" scheme="http://bubkoo.com/tags/sort/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 - 猴子排序 (Bogo Sort)</title>
    <link href="http://bubkoo.com/2014/01/15/sort-algorithm/bogo-sort/"/>
    <id>http://bubkoo.com/2014/01/15/sort-algorithm/bogo-sort/</id>
    <published>2014-01-15T22:04:22.000Z</published>
    <updated>2014-01-15T22:04:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="算法原理">算法原理</span></h2><p>猴子排序 (Bogo Sort) 是个既不实用又原始的排序算法，其原理等同将一堆卡片抛起，落在桌上后检查卡片是否已整齐排列好，若非就再抛一次。其名字源自 Quantum bogodynamics，又称 bozo sort、blort sort 或猴子排序（参见<a href="http://zh.wikipedia.org/wiki/%E7%84%A1%E9%99%90%E7%8C%B4%E5%AD%90%E5%AE%9A%E7%90%86" target="_blank" rel="external">无限猴子定理</a>）。并且在最坏的情况下所需时间是无限的。</p><p>伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> not InOrder(list) <span class="keyword">do</span></div><div class="line">   Shuffle(list)</div><div class="line">done</div></pre></td></tr></table></figure><a id="more"></a><p>这个排序方法没有办法给出实例分析，下面直接看代码。</p><h2><span id="javascript-语言实现">JavaScript 语言实现</span></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bogoSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> temp = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 随机交换顺序</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> i,</div><div class="line">            l = array.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</div><div class="line">            <span class="keyword">var</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * l)</div><div class="line">            swap(array, i, j)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 判断是否已经排好序</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isSorted</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> i,</div><div class="line">            l = array.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; l; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[i - <span class="number">1</span>] &gt; array[i]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> sorted = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span> (sorted == <span class="literal">false</span>) &#123; <span class="comment">// 效率低下的位置</span></div><div class="line">        v = shuffle(array);</div><div class="line">        sorted = isSorted(array);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://zh.wikipedia.org/wiki/Bogo%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科，自由的百科全书</a></li><li><a href="http://rosettacode.org/wiki/Sorting_algorithms/Bogosort" target="_blank" rel="external">Sorting algorithms/Bogosort</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;p&gt;猴子排序 (Bogo Sort) 是个既不实用又原始的排序算法，其原理等同将一堆卡片抛起，落在桌上后检查卡片是否已整齐排列好，若非就再抛一次。其名字源自 Quantum bogodynamics，又称 bozo sort、blort sort 或猴子排序（参见&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E7%84%A1%E9%99%90%E7%8C%B4%E5%AD%90%E5%AE%9A%E7%90%86&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;无限猴子定理&lt;/a&gt;）。并且在最坏的情况下所需时间是无限的。&lt;/p&gt;
&lt;p&gt;伪代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; not InOrder(list) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Shuffle(list)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;done&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Sort" scheme="http://bubkoo.com/tags/sort/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 - 鸡尾酒排序 (Cocktail Sort/Shaker Sort)</title>
    <link href="http://bubkoo.com/2014/01/15/sort-algorithm/shaker-sort/"/>
    <id>http://bubkoo.com/2014/01/15/sort-algorithm/shaker-sort/</id>
    <published>2014-01-15T20:50:02.000Z</published>
    <updated>2014-01-15T20:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="算法原理">算法原理</span></h2><p>为什么叫鸡尾酒排序？其实我也不知道，知道的小伙伴请告诉我。</p><p>其实它还有很多<strong>奇怪</strong>的名称，比如双向冒泡排序 (Bidirectional Bubble Sort)、波浪排序 (Ripple Sort)、摇曳排序 (Shuffle Sort)、飞梭排序 (Shuttle Sort) 和欢乐时光排序 (Happy Hour Sort)。本文中就以鸡尾酒排序来称呼它。</p><p>鸡尾酒排序是<a href="/2014/01/12/sort-algorithm/bubble-sort/">冒泡排序</a>的轻微变形。不同的地方在于，鸡尾酒排序是从低到高然后从高到低来回排序，而冒泡排序则仅从低到高去比较序列里的每个元素。他可比冒泡排序的效率稍微好一点，原因是冒泡排序只从一个方向进行比对(由低到高)，每次循环只移动一个项目。</p><p>以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。但是在乱数序列状态下，鸡尾酒排序与冒泡排序的效率都很差劲，优点只有原理简单这一点。</p><p>排序过程：</p><ol><li>先对数组从左到右进行冒泡排序（升序），则最大的元素去到最右端</li><li>再对数组从右到左进行冒泡排序（降序），则最小的元素去到最左端</li><li>以此类推，依次改变冒泡的方向，并不断缩小未排序元素的范围，直到最后一个元素结束</li></ol><p><img src="http://bubkoo.qiniudn.com/sorting-shaker-sort-anim.gif" alt="图片来自维基百科"></p><a id="more"></a><h2><span id="实例分析">实例分析</span></h2><p>以数组 array = [45, 19, 77, 81, 13, 28, 18, 19, 77] 为例，排序过程如下：</p><p>从左到右，找到最大的数 81，放到数组末尾：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">┌─────────────────────────────────────────┐</div><div class="line">│  <span class="number">19</span>   <span class="number">45</span>   <span class="number">77</span>   <span class="number">13</span>   <span class="number">28</span>   <span class="number">18</span>   <span class="number">19</span>   <span class="number">77</span>  │  <span class="number">81</span></div><div class="line">└─────────────────────────────────────────┘</div></pre></td></tr></table></figure><p>从右到左，找到剩余数组（先框中的部分）中最小的数 ，放到数组开头：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    ┌────────────────────────────────────┐</div><div class="line"><span class="number">13</span>  │  <span class="number">19</span>   <span class="number">45</span>   <span class="number">77</span>   <span class="number">18</span>   <span class="number">28</span>   <span class="number">19</span>   <span class="number">77</span>  │   <span class="number">81</span></div><div class="line">    └────────────────────────────────────┘</div></pre></td></tr></table></figure><p>从左到右，在剩余数组中找到最大数，放在剩余数组的末尾：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    ┌───────────────────────────────┐</div><div class="line"><span class="number">13</span>  │  <span class="number">19</span>   <span class="number">45</span>   <span class="number">18</span>   <span class="number">28</span>   <span class="number">18</span>   <span class="number">77</span>  │   <span class="number">77</span>   <span class="number">81</span></div><div class="line">    └───────────────────────────────┘</div></pre></td></tr></table></figure><p>从右到左</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">         ┌──────────────────────────┐</div><div class="line"><span class="number">13</span>   <span class="number">18</span>  │  <span class="number">19</span>   <span class="number">45</span>   <span class="number">18</span>   <span class="number">28</span>   <span class="number">77</span>  │   <span class="number">77</span>   <span class="number">81</span></div><div class="line">         └──────────────────────────┘</div></pre></td></tr></table></figure><p>从左到右</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">         ┌─────────────────────┐</div><div class="line"><span class="number">13</span>   <span class="number">18</span>  │  <span class="number">19</span>   <span class="number">18</span>   <span class="number">28</span>   <span class="number">45</span>  │  <span class="number">77</span>   <span class="number">77</span>   <span class="number">81</span></div><div class="line">         └─────────────────────┘</div></pre></td></tr></table></figure><p>从右到左</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">              ┌────────────────┐</div><div class="line"><span class="number">13</span>   <span class="number">18</span>   <span class="number">18</span>  │  <span class="number">19</span>   <span class="number">28</span>   <span class="number">45</span>  │  <span class="number">77</span>   <span class="number">77</span>   <span class="number">81</span></div><div class="line">              └────────────────┘</div></pre></td></tr></table></figure><p>从左到右</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">              ┌───────────┐</div><div class="line"><span class="number">13</span>   <span class="number">18</span>   <span class="number">18</span>  │  <span class="number">19</span>   <span class="number">28</span>  │  <span class="number">45</span>   <span class="number">77</span>   <span class="number">77</span>   <span class="number">81</span></div><div class="line">              └───────────┘</div></pre></td></tr></table></figure><p>从右到左</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">                   ┌──────┐</div><div class="line"><span class="number">13</span>   <span class="number">18</span>   <span class="number">18</span>   <span class="number">19</span>  │  <span class="number">28</span>  │  <span class="number">45</span>   <span class="number">77</span>   <span class="number">77</span>   <span class="number">81</span></div><div class="line">                   └──────┘</div></pre></td></tr></table></figure><h2><span id="javascript-语言实现">JavaScript 语言实现</span></h2><p>惯例，看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shakerSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> temp = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> length = array.length,</div><div class="line">        left = <span class="number">0</span>,</div><div class="line">        right = length - <span class="number">1</span>,</div><div class="line">        lastSwappedLeft = left,</div><div class="line">        lastSwappedRight = right,</div><div class="line">        i,</div><div class="line">        j;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">        <span class="comment">// 从左到右</span></div><div class="line">        lastSwappedRight = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (i = left; i &lt; right; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[i] &gt; array[i + <span class="number">1</span>]) &#123;</div><div class="line">                swap(array, i, i + <span class="number">1</span>);</div><div class="line">                lastSwappedRight = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        right = lastSwappedRight;</div><div class="line">        <span class="comment">// 从右到左</span></div><div class="line">        lastSwappedLeft = length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (j = right; left &lt; j; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; array[j]) &#123;</div><div class="line">                swap(array, j - <span class="number">1</span>, j)</div><div class="line">                lastSwappedLeft = j</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        left = lastSwappedLeft;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科，自由的百科全书</a></li><li><a href="http://www.codingunit.com/cocktail-sort-algorithm-or-shaker-sort-algorithm" target="_blank" rel="external">Cocktail Sort Algorithm or Shaker Sort Algorithm</a></li><li><a href="http://buffered.io/posts/sorting-algorithms-the-cocktail-sort/" target="_blank" rel="external">Sorting Algorithms: The Cocktail Sort</a></li><li><a href="http://notepad.yehyeh.net/Content/Algorithm/Sort/Shaker/Shaker.php" target="_blank" rel="external">[演算法]摇晃排序法(Shaker Sort)</a></li><li><a href="http://www.cnblogs.com/wuweiblog/archive/2011/07/11/2103325.html" target="_blank" rel="external">冒泡排序与鸡尾酒排序</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;p&gt;为什么叫鸡尾酒排序？其实我也不知道，知道的小伙伴请告诉我。&lt;/p&gt;
&lt;p&gt;其实它还有很多&lt;strong&gt;奇怪&lt;/strong&gt;的名称，比如双向冒泡排序 (Bidirectional Bubble Sort)、波浪排序 (Ripple Sort)、摇曳排序 (Shuffle Sort)、飞梭排序 (Shuttle Sort) 和欢乐时光排序 (Happy Hour Sort)。本文中就以鸡尾酒排序来称呼它。&lt;/p&gt;
&lt;p&gt;鸡尾酒排序是&lt;a href=&quot;/2014/01/12/sort-algorithm/bubble-sort/&quot;&gt;冒泡排序&lt;/a&gt;的轻微变形。不同的地方在于，鸡尾酒排序是从低到高然后从高到低来回排序，而冒泡排序则仅从低到高去比较序列里的每个元素。他可比冒泡排序的效率稍微好一点，原因是冒泡排序只从一个方向进行比对(由低到高)，每次循环只移动一个项目。&lt;/p&gt;
&lt;p&gt;以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。但是在乱数序列状态下，鸡尾酒排序与冒泡排序的效率都很差劲，优点只有原理简单这一点。&lt;/p&gt;
&lt;p&gt;排序过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先对数组从左到右进行冒泡排序（升序），则最大的元素去到最右端&lt;/li&gt;
&lt;li&gt;再对数组从右到左进行冒泡排序（降序），则最小的元素去到最左端&lt;/li&gt;
&lt;li&gt;以此类推，依次改变冒泡的方向，并不断缩小未排序元素的范围，直到最后一个元素结束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/sorting-shaker-sort-anim.gif&quot; alt=&quot;图片来自维基百科&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Sort" scheme="http://bubkoo.com/tags/sort/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 - 归并排序 (Merge Sort)</title>
    <link href="http://bubkoo.com/2014/01/15/sort-algorithm/merge-sort/"/>
    <id>http://bubkoo.com/2014/01/15/sort-algorithm/merge-sort/</id>
    <published>2014-01-15T02:32:28.000Z</published>
    <updated>2014-01-15T02:32:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="算法原理">算法原理</span></h2><p>归并排序（Merge Sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用<a href="http://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95" target="_blank" rel="external">分治法</a>（Divide and Conquer）的一个非常典型的应用。</p><p>归并操作(Merge)，也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。归并排序有多路归并排序、两路归并排序 , 可用于内排序，也可以用于外排序。这里仅对内排序的两路归并方法进行讨论。 </p><p>算法思路：</p><ol><li>把 n 个记录看成 n 个长度为 l 的有序子表</li><li>进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表</li><li>重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。</li></ol><p><img src="http://bubkoo.qiniudn.com/merge-sort-animation.gif" alt="图片来自维基百科"></p><a id="more"></a><h2><span id="实例分析">实例分析</span></h2><p>以数组 array = [6, 5, 3, 1, 8, 7, 2, 4] 为例，首先将数组分为长度为 2 的子数组，并使每个子数组有序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">6</span>, <span class="number">5</span>]  [<span class="number">3</span>, <span class="number">1</span>]  [<span class="number">8</span>, <span class="number">7</span>]  [<span class="number">2</span>, <span class="number">4</span>]</div><div class="line">   ↓       ↓       ↓       ↓</div><div class="line">[<span class="number">5</span>, <span class="number">6</span>]  [<span class="number">1</span>, <span class="number">3</span>]  [<span class="number">7</span>, <span class="number">8</span>]  [<span class="number">2</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure><p>然后再两两合并：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>]  [<span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>]</div><div class="line">      ↓             ↓</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]  [<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure><p>最后将两个子数组合并：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>]</div><div class="line">            ↓</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure><p>排序过程动画演示如下：</p><p><img src="http://bubkoo.qiniudn.com/merge-sort-example-300px.gif" alt="图片来自维基百科"></p><p>再有数组 array = [5, 2, 4, 6, 1, 3, 2, 6]，归并排序流程也可以如下表示：</p><p><img src="http://bubkoo.qiniudn.com/merge-sort-example.gif" alt=""></p><h2><span id="javascript-语言实现">JavaScript 语言实现</span></h2><p>屌丝的惯例，上代码，由于要两两归并的子数组都是有序的数组，同时我们在<a href="/2014/01/15/sort-algorithm/shell-sort/">希尔排序</a>中提到过“插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率”，所以我们可以将其中一个子数组中的元素依次插入到另一个数组当中，使其归并后成为一个有序的数组。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array, first, last</span>) </span>&#123;</div><div class="line">        first = (first === <span class="literal">undefined</span>) ? <span class="number">0</span> : first</div><div class="line">        last = (last === <span class="literal">undefined</span>) ? array.length - <span class="number">1</span> : last</div><div class="line">        <span class="keyword">if</span> (last - first &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor((first + last) / <span class="number">2</span>);</div><div class="line">        sort(array, first, middle);</div><div class="line">        sort(array, middle + <span class="number">1</span>, last);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> f = first,</div><div class="line">            m = middle,</div><div class="line">            i,</div><div class="line">            temp;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (f &lt;= m &amp;&amp; m + <span class="number">1</span> &lt;= last) &#123;</div><div class="line">            <span class="keyword">if</span> (array[f] &gt;= array[m + <span class="number">1</span>]) &#123; <span class="comment">// 这里使用了插入排序的思想</span></div><div class="line">                temp = array[m + <span class="number">1</span>];</div><div class="line">                <span class="keyword">for</span> (i = m; i &gt;= f; i--) &#123;</div><div class="line">                    array[i + <span class="number">1</span>] = array[i];</div><div class="line">                &#125;</div><div class="line">                array[f] = temp;</div><div class="line">                m++</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                f++</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sort(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="external">Wikipedia</a></li><li><a href="http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科，自由的百科全书</a></li><li><a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/Sorting/mergeSort.htm" target="_blank" rel="external">Merge Sort</a></li><li><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.5.1.1.htm" target="_blank" rel="external">两路归并算法</a></li><li><a href="http://www.ee.ryerson.ca/~courses/coe428/sorting/mergesort.html" target="_blank" rel="external">MERGE SORT 动画演示</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;p&gt;归并排序（Merge Sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;分治法&lt;/a&gt;（Divide and Conquer）的一个非常典型的应用。&lt;/p&gt;
&lt;p&gt;归并操作(Merge)，也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。归并排序有多路归并排序、两路归并排序 , 可用于内排序，也可以用于外排序。这里仅对内排序的两路归并方法进行讨论。 &lt;/p&gt;
&lt;p&gt;算法思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把 n 个记录看成 n 个长度为 l 的有序子表&lt;/li&gt;
&lt;li&gt;进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表&lt;/li&gt;
&lt;li&gt;重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/merge-sort-animation.gif&quot; alt=&quot;图片来自维基百科&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Sort" scheme="http://bubkoo.com/tags/sort/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 - 希尔排序 (Shell Sort)</title>
    <link href="http://bubkoo.com/2014/01/15/sort-algorithm/shell-sort/"/>
    <id>http://bubkoo.com/2014/01/15/sort-algorithm/shell-sort/</id>
    <published>2014-01-15T00:54:59.000Z</published>
    <updated>2014-01-15T00:54:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="算法原理">算法原理</span></h2><p>希尔排序算法是按其设计者希尔（Donald Shell）的名字命名，该算法由1959年公布，是插入排序的一种更高效的改进版本。它的作法不是每次一个元素挨一个元素的比较。而是初期选用大跨步（增量较大）间隔比较，使记录跳跃式接近它的排序位置；然后增量缩小；最后增量为 1 ，这样记录移动次数大大减少，提高了排序效率。希尔排序对增量序列的选择没有严格规定。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位</li></ul><p>算法思路：</p><ol><li>先取一个正整数 d<sub>1</sub>(d<sub>1</sub> &lt; n)，把全部记录分成 d<sub>1</sub> 个组，所有距离为 d<sub>1</sub> 的倍数的记录看成一组，然后在各组内进行插入排序</li><li>然后取 d<sub>2</sub>(d<sub>2</sub> &lt; d<sub>1</sub>)</li><li>重复上述分组和排序操作；直到取 d<sub>i</sub> = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d<sub>1</sub> 约为 n/2，d<sub>2</sub> 为 d<sub>1</sub> /2， d<sub>3</sub> 为 d<sub>2</sub>/2 ，…， d<sub>i</sub> = 1。</li></ol><p><img src="http://bubkoo.qiniudn.com/shell-sort-animation.gif" alt="图片来自维基百科"></p><a id="more"></a><h2><span id="实例分析">实例分析</span></h2><p>假设有数组 array = [80, 93, 60, 12, 42, 30, 68, 85, 10]，首先取 d<sub>1</sub> = 4，将数组分为 4 组，如下图中相同颜色代表一组：</p><p><img src="http://bubkoo.qiniudn.com/shell-sort-step1.1.png" alt=""></p><p>然后分别对 4 个小组进行插入排序，排序后的结果为：</p><p><img src="http://bubkoo.qiniudn.com/shell-sort-step1.2.png" alt=""></p><p>然后，取 d<sub>2</sub> = 2，将原数组分为 2 小组，如下图：</p><p><img src="http://bubkoo.qiniudn.com/shell-sort-step2.1.png" alt=""></p><p>然后分别对 2 个小组进行插入排序，排序后的结果为：</p><p><img src="http://bubkoo.qiniudn.com/shell-sort-step2.2.png" alt=""></p><p>最后，取 d<sub>3</sub> = 1，进行插入排序后得到最终结果：</p><p><img src="http://bubkoo.qiniudn.com/shell-sort-step3.png" alt=""></p><h2><span id="javascript-语言实现">JavaScript 语言实现</span></h2><p>按照惯例，下面给出了 JavaScript 的算法实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, k</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> temp = array[i];</div><div class="line">        array[i] = array[k];</div><div class="line">        array[k] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> length = array.length,</div><div class="line">        gap = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i; <span class="number">0</span> &lt; j; j -= gap) &#123;</div><div class="line">                <span class="keyword">if</span> (array[j - gap] &gt; array[j]) &#123;</div><div class="line">                    swap(array, j - gap, j);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科，自由的百科全书</a></li><li><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.2.2.1.htm" target="_blank" rel="external">希尔排序基本思想</a></li><li><a href="http://notepad.yehyeh.net/Content/Algorithm/Sort/Shell/Shell.php" target="_blank" rel="external">[演算法] 希爾排序法(Shell Sort)</a></li><li><a href="http://www.cnblogs.com/huangxincheng/archive/2011/11/20/2255695.html" target="_blank" rel="external">算法系列15天速成——第三天 七大经典排序【下】</a></li><li><a href="http://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Shell_sort" target="_blank" rel="external">Algorithm Implementation/Sorting/Shell sort</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;p&gt;希尔排序算法是按其设计者希尔（Donald Shell）的名字命名，该算法由1959年公布，是插入排序的一种更高效的改进版本。它的作法不是每次一个元素挨一个元素的比较。而是初期选用大跨步（增量较大）间隔比较，使记录跳跃式接近它的排序位置；然后增量缩小；最后增量为 1 ，这样记录移动次数大大减少，提高了排序效率。希尔排序对增量序列的选择没有严格规定。&lt;/p&gt;
&lt;p&gt;希尔排序是基于插入排序的以下两点性质而提出改进方法的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率&lt;/li&gt;
&lt;li&gt;但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先取一个正整数 d&lt;sub&gt;1&lt;/sub&gt;(d&lt;sub&gt;1&lt;/sub&gt; &amp;lt; n)，把全部记录分成 d&lt;sub&gt;1&lt;/sub&gt; 个组，所有距离为 d&lt;sub&gt;1&lt;/sub&gt; 的倍数的记录看成一组，然后在各组内进行插入排序&lt;/li&gt;
&lt;li&gt;然后取 d&lt;sub&gt;2&lt;/sub&gt;(d&lt;sub&gt;2&lt;/sub&gt; &amp;lt; d&lt;sub&gt;1&lt;/sub&gt;)&lt;/li&gt;
&lt;li&gt;重复上述分组和排序操作；直到取 d&lt;sub&gt;i&lt;/sub&gt; = 1(i &amp;gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d&lt;sub&gt;1&lt;/sub&gt; 约为 n/2，d&lt;sub&gt;2&lt;/sub&gt; 为 d&lt;sub&gt;1&lt;/sub&gt; /2， d&lt;sub&gt;3&lt;/sub&gt; 为 d&lt;sub&gt;2&lt;/sub&gt;/2 ，…， d&lt;sub&gt;i&lt;/sub&gt; = 1。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/shell-sort-animation.gif&quot; alt=&quot;图片来自维基百科&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Sort" scheme="http://bubkoo.com/tags/sort/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 - 插入排序 (Insertion Sort)</title>
    <link href="http://bubkoo.com/2014/01/14/sort-algorithm/insertion-sort/"/>
    <id>http://bubkoo.com/2014/01/14/sort-algorithm/insertion-sort/</id>
    <published>2014-01-14T16:53:07.000Z</published>
    <updated>2014-01-14T16:53:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="算法原理">算法原理</span></h2><p>设有一组关键字｛K<sub>1</sub>， K<sub>2</sub>，…， K<sub>n</sub>｝；排序开始就认为 K<sub>1</sub> 是一个有序序列；让 K<sub>2</sub> 插入上述表长为 1 的有序序列，使之成为一个表长为 2 的有序序列；然后让 K<sub>3</sub> 插入上述表长为 2 的有序序列，使之成为一个表长为 3 的有序序列；依次类推，最后让 K<sub>n</sub> 插入上述表长为 n-1 的有序序列，得一个表长为 n 的有序序列。</p><p>具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤 2~5</li></ol><p>如果比较操作的代价比交换操作大的话，可以采用<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95" target="_blank" rel="external">二分查找法</a>来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为<strong>二分查找排序</strong>。</p><p>二分查找法，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><p><img src="http://bubkoo.qiniudn.com/Insertion_sort_animation.gif" alt="图片来自维基百科"></p><a id="more"></a><h2><span id="实例分析">实例分析</span></h2><p>现有一组数组 arr = [5, 6, 3, 1, 8, 7, 2, 4]，共有八个记录，排序过程如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[5]   6   3   1   8   7   2   4</div><div class="line">  ↑   │</div><div class="line">  └───┘</div><div class="line"></div><div class="line">[5, 6]   3   1   8   7   2   4</div><div class="line">↑        │</div><div class="line">└────────┘</div><div class="line"></div><div class="line">[3, 5, 6]  1   8   7   2   4</div><div class="line">↑          │</div><div class="line">└──────────┘</div><div class="line"></div><div class="line">[1, 3, 5, 6]  8   7   2   4</div><div class="line">           ↑  │</div><div class="line">           └──┘</div><div class="line"></div><div class="line">[1, 3, 5, 6, 8]  7   2   4</div><div class="line">            ↑    │</div><div class="line">            └────┘</div><div class="line"></div><div class="line">[1, 3, 5, 6, 7, 8]  2   4</div><div class="line">   ↑                │</div><div class="line">   └────────────────┘</div><div class="line"></div><div class="line">[1, 2, 3, 5, 6, 7, 8]  4</div><div class="line">         ↑             │</div><div class="line">         └─────────────┘</div><div class="line"> </div><div class="line">[1, 2, 3, 4, 5, 6, 7, 8]</div></pre></td></tr></table></figure><p>其中有一点比较有意思的是，在每次比较操作发现新元素小于等于已排序的元素时，可以将已排序的元素移到下一位置，然后再将新元素插入该位置，接着再与前面的已排序的元素进行比较，这样做交换操作代价比较大。还有一个做法是，将新元素取出，从左到右依次与已排序的元素比较，如果已排序的元素大于新元素，那么将该元素移动到下一个位置，接着再与前面的已排序的元素比较，直到找到已排序的元素小于等于新元素的位置，这时再将新元素插入进去，就像下面这样：</p><p><img src="http://bubkoo.qiniudn.com/Insertion-sort-example-300px.gif" alt="图片来自维基百科"></p><h2><span id="javascript-语言实现">JavaScript 语言实现</span></h2><p>直接插入排序 JavaScript 实现代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> temp = array[i];</div><div class="line">    array[i] = array[j];</div><div class="line">    array[j] = temp;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> length = array.length,</div><div class="line">      i,</div><div class="line">      j;</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>; j--) &#123;</div><div class="line">      <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; array[j]) &#123;</div><div class="line">        swap(array, j - <span class="number">1</span>, j);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面这种方式可以减少交换次数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> length = array.length,</div><div class="line">    i,</div><div class="line">    j,</div><div class="line">    temp;</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</div><div class="line">    temp = array[i];</div><div class="line">    <span class="keyword">for</span> (j = i; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">      <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; temp) &#123;</div><div class="line">        array[j] = array[j - <span class="number">1</span>];</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        array[j] = temp;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>利用二分查找法实现的插入排序，<strong>二分查找排序</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort2</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">array, start, end, temp</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> middle;</div><div class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</div><div class="line">      middle = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>);</div><div class="line">      <span class="keyword">if</span> (array[middle] &lt; temp) &#123;</div><div class="line">        <span class="keyword">if</span> (temp &lt;= array[middle + <span class="number">1</span>]) &#123;</div><div class="line">          <span class="keyword">return</span> middle + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          start = middle + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (end === <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          end = middle;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">binarySort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> length = array.length,</div><div class="line">        i,</div><div class="line">        j,</div><div class="line">        k,</div><div class="line">        temp;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</div><div class="line">      temp = array[i];</div><div class="line">      <span class="keyword">if</span> (array[i - <span class="number">1</span>] &lt;= temp) &#123;</div><div class="line">        k = i;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        k = binarySearch(array, <span class="number">0</span>, i - <span class="number">1</span>, temp);</div><div class="line">        <span class="keyword">for</span> (j = i; j &gt; k; j--) &#123;</div><div class="line">          array[j] = array[j - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      array[k] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> binarySort(array);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="external">Wikipedia</a></li><li><a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科 - 插入排序</a></li><li><a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95" target="_blank" rel="external">维基百科 - 二分查找法</a></li><li><a href="http://hualang.iteye.com/blog/1187110" target="_blank" rel="external">排序算法–折半插入排序（二分查找排序）</a></li><li><a href="http://sjjg.js.zwu.edu.cn/SFXX/paixu/paixu6.2.1.html" target="_blank" rel="external">直接插入排序</a></li><li><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.2.1.1.htm" target="_blank" rel="external">直接插入排序基本思想</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;p&gt;设有一组关键字｛K&lt;sub&gt;1&lt;/sub&gt;， K&lt;sub&gt;2&lt;/sub&gt;，…， K&lt;sub&gt;n&lt;/sub&gt;｝；排序开始就认为 K&lt;sub&gt;1&lt;/sub&gt; 是一个有序序列；让 K&lt;sub&gt;2&lt;/sub&gt; 插入上述表长为 1 的有序序列，使之成为一个表长为 2 的有序序列；然后让 K&lt;sub&gt;3&lt;/sub&gt; 插入上述表长为 2 的有序序列，使之成为一个表长为 3 的有序序列；依次类推，最后让 K&lt;sub&gt;n&lt;/sub&gt; 插入上述表长为 n-1 的有序序列，得一个表长为 n 的有序序列。&lt;/p&gt;
&lt;p&gt;具体算法描述如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从第一个元素开始，该元素可以认为已经被排序&lt;/li&gt;
&lt;li&gt;取出下一个元素，在已经排序的元素序列中从后向前扫描&lt;/li&gt;
&lt;li&gt;如果该元素（已排序）大于新元素，将该元素移到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置&lt;/li&gt;
&lt;li&gt;将新元素插入到该位置后&lt;/li&gt;
&lt;li&gt;重复步骤 2~5&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果比较操作的代价比交换操作大的话，可以采用&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;二分查找法&lt;/a&gt;来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为&lt;strong&gt;二分查找排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;二分查找法，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/Insertion_sort_animation.gif&quot; alt=&quot;图片来自维基百科&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Sort" scheme="http://bubkoo.com/tags/sort/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 - 堆排序 (Heap Sort)</title>
    <link href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/"/>
    <id>http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/</id>
    <published>2014-01-14T10:42:50.000Z</published>
    <updated>2014-01-14T10:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="算法原理">算法原理</span></h2><p>先上一张堆排序动画演示图片：</p><p><img src="http://bubkoo.qiniudn.com/Sorting_heapsort_anim.gif" alt="图片来自维基百科"></p><p><strong>1. 不得不说说二叉树</strong></p><p>要了解堆首先得了解一下<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">二叉树</a>，在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="external">二叉查找树</a>和<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E5%A0%86" target="_blank" rel="external">二叉堆</a>。</p><p>二叉树的每个结点至多只有二棵子树（不存在度大于 2 的结点），二叉树的子树有左右之分，次序不能颠倒。二叉树的第 i 层至多有 2<sup>i</sup> - 1 个结点；深度为 k 的二叉树至多有 2<sup>k</sup> - 1 个结点；对任何一棵二叉树 T，如果其终端结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则n<sub>0</sub> = n<sub>2</sub> + 1。</p><p>树和二叉树的三个主要差别：</p><ul><li>树的结点个数至少为 1，而二叉树的结点个数可以为 0</li><li>树中结点的最大度数没有限制，而二叉树结点的最大度数为 2</li><li>树的结点无左、右之分，而二叉树的结点有左、右之分</li></ul><p>二叉树又分为完全二叉树（complete binary tree）和满二叉树（full binary tree）</p><p>满二叉树：一棵深度为 k，且有 2<sup>k</sup> - 1 个节点称之为满二叉树</p><p><img src="http://bubkoo.qiniudn.com/full%C2%A0binary%C2%A0tree.png" alt="深度为 3 的满二叉树 full binary tree"></p><p>完全二叉树：深度为 k，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中序号为 1 至 n 的节点对应时，称之为完全二叉树</p><p><img src="http://bubkoo.qiniudn.com/complete%C2%A0binary%C2%A0tree.png" alt="深度为 3 的完全二叉树 complete binary tree"></p><a id="more"></a><p><strong>2. 什么是堆？</strong></p><p>堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p><p>如下图，是一个堆和数组的相互关系</p><p><img src="http://bubkoo.qiniudn.com/heap-and-array.png" alt="堆和数组的相互关系"></p><p>对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：</p><ul><li>Parent(i) = floor(i/2)，i 的父节点下标</li><li>Left(i) = 2i，i 的左子节点下标</li><li>Right(i) = 2i + 1，i 的右子节点下标</li></ul><p><img src="http://bubkoo.qiniudn.com/heap-and-array-parent-children.png" alt=""></p><p>二叉堆一般分为两种：最大堆和最小堆。</p><p>最大堆：</p><ul><li>最大堆中的最大元素值出现在根结点（堆顶）</li><li>堆中每个父节点的元素值都大于等于其孩子结点（如果存在）</li></ul><p><img src="http://bubkoo.qiniudn.com/max-heap.png" alt="最大堆"></p><p>最小堆：</p><ul><li>最小堆中的最小元素值出现在根结点（堆顶）</li><li>堆中每个父节点的元素值都小于等于其孩子结点（如果存在）</li></ul><p><img src="http://bubkoo.qiniudn.com/min-heap.png" alt="最小堆"></p><p><strong>3. 堆排序原理</strong></p><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p><ul><li>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆</li><li>堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p>继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变</p><p><img src="http://bubkoo.qiniudn.com/heap-and-array-zero-based.png" alt="Zero-Based"></p><p>相应的，几个计算公式也要作出相应调整：</p><ul><li>Parent(i) = floor((i-1)/2)，i 的父节点下标</li><li>Left(i) = 2i + 1，i 的左子节点下标</li><li>Right(i) = 2(i + 1)，i 的右子节点下标</li></ul><p>最大堆调整（MAX‐HEAPIFY）的作用是保持最大堆的性质，是创建最大堆的核心子程序，作用过程如图所示：</p><p><img src="http://bubkoo.qiniudn.com/MAX%E2%80%90HEAPIFY-Procedure.png" alt="Max-Heapify"></p><p>由于一次调整后，堆仍然违反堆性质，所以需要递归的测试，使得整个堆都满足堆性质，用 JavaScript 可以表示如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 从 index 开始检查并保持最大堆性质</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @array</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @index 检查的起始下标</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @heapSize 堆大小</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> **/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">array, index, heapSize</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> iMax = index,</div><div class="line">      iLeft = <span class="number">2</span> * index + <span class="number">1</span>,</div><div class="line">      iRight = <span class="number">2</span> * (index + <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123;</div><div class="line">    iMax = iLeft;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123;</div><div class="line">    iMax = iRight;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (iMax != index) &#123;</div><div class="line">    swap(array, iMax, index);</div><div class="line">    maxHeapify(array, iMax, heapSize); <span class="comment">// 递归调整</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> temp = array[i];</div><div class="line">  array[i] = array[j];</div><div class="line">  array[j] = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通常来说，递归主要用在分治法中，而这里并不需要分治。而且递归调用需要压栈/清栈，和迭代相比，性能上有略微的劣势。当然，按照20/80法则，这是可以忽略的。但是如果你觉得用递归会让自己心里过不去的话，也可以用迭代，比如下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 从 index 开始检查并保持最大堆性质</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @array</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @index 检查的起始下标</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @heapSize 堆大小</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> **/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">array, index, heapSize</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> iMax, iLeft, iRight;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    iMax = index;</div><div class="line">    iLeft = <span class="number">2</span> * index + <span class="number">1</span>;</div><div class="line">    iRight = <span class="number">2</span> * (index + <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123;</div><div class="line">      iMax = iLeft;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123;</div><div class="line">      iMax = iRight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (iMax != index) &#123;</div><div class="line">      swap(array, iMax, index);</div><div class="line">      index = iMax;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> temp = array[i];</div><div class="line">  array[i] = array[j];</div><div class="line">  array[j] = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>创建最大堆（Build-Max-Heap）的作用是将一个数组改造成一个最大堆，接受数组和堆大小两个参数，Build-Max-Heap 将自下而上的调用 Max-Heapify 来改造数组，建立最大堆。因为 Max-Heapify 能够保证下标 i 的结点之后结点都满足最大堆的性质，所以自下而上的调用 Max-Heapify 能够在改造过程中保持这一性质。如果最大堆的数量元素是 n，那么 Build-Max-Heap 从 Parent(n) 开始，往上依次调用 Max-Heapify。流程如下：</p><p><img src="http://bubkoo.qiniudn.com/building-a-heap.png" alt="Build-Max-Heap"></p><p>用 JavaScript 描述如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">array, heapSize</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> i,</div><div class="line">      iParent = <span class="built_in">Math</span>.floor((heapSize - <span class="number">1</span>) / <span class="number">2</span>);</div><div class="line">      </div><div class="line">  <span class="keyword">for</span> (i = iParent; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    maxHeapify(array, i, heapSize);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>堆排序（Heap-Sort）是堆排序的接口算法，Heap-Sort先调用Build-Max-Heap将数组改造为最大堆，然后将堆顶和堆底元素交换，之后将底部上升，最后重新调用Max-Heapify保持最大堆性质。由于堆顶元素必然是堆中最大的元素，所以一次操作之后，堆中存在的最大元素被分离出堆，重复n-1次之后，数组排列完毕。整个流程如下：</p><p><img src="http://bubkoo.qiniudn.com/HeapSort.png" alt="Heap-Sort"></p><p>用 JavaScript 描述如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array, heapSize</span>) </span>&#123;</div><div class="line"></div><div class="line">  buildMaxHeap(array, heapSize);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (int i = heapSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">    swap(array, <span class="number">0</span>, i);</div><div class="line">    maxHeapify(array, <span class="number">0</span>, i);</div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="javascript-语言实现">JavaScript 语言实现</span></h2><p>最后，把上面的整理为完整的 javascript 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> temp = array[i];</div><div class="line">    array[i] = array[j];</div><div class="line">    array[j] = temp;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">array, index, heapSize</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> iMax,</div><div class="line">      iLeft,</div><div class="line">      iRight;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">      iMax = index;</div><div class="line">      iLeft = <span class="number">2</span> * index + <span class="number">1</span>;</div><div class="line">      iRight = <span class="number">2</span> * (index + <span class="number">1</span>);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123;</div><div class="line">        iMax = iLeft;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123;</div><div class="line">        iMax = iRight;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (iMax != index) &#123;</div><div class="line">        swap(array, iMax, index);</div><div class="line">        index = iMax;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i,</div><div class="line">      iParent = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>) - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = iParent; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">      maxHeapify(array, i, array.length);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    buildMaxHeap(array);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">      swap(array, <span class="number">0</span>, i);</div><div class="line">      maxHeapify(array, <span class="number">0</span>, i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> sort(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="external">Wikipedia</a></li><li><a href="http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科，堆排序</a></li><li><a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">维基百科，二叉树</a></li><li><a href="http://ind.ntou.edu.tw/~litsnow/al98/pdf/Algorithm-Ch6-Heapsort.pdf" target="_blank" rel="external">Algorithms Chapter 6 Heapsort</a></li><li><a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/Sorting/heapSort.htm" target="_blank" rel="external">Heap Sort</a></li><li><a href="http://blog.kingsamchen.com/archives/547#viewSource" target="_blank" rel="external">堆与堆排序</a></li><li><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.4.2.1.htm" target="_blank" rel="external">堆排序</a></li><li><a href="http://www.nowamagic.net/algorithm/algorithm_HeapSortStudy.php" target="_blank" rel="external">堆排序(Heap Sort)算法学习</a></li><li><a href="http://www.sorting-algorithms.com/" target="_blank" rel="external">Sorting Algorithm Animations</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;p&gt;先上一张堆排序动画演示图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/Sorting_heapsort_anim.gif&quot; alt=&quot;图片来自维基百科&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 不得不说说二叉树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要了解堆首先得了解一下&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;二叉树&lt;/a&gt;，在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;二叉查找树&lt;/a&gt;和&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E5%A0%86&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;二叉堆&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;二叉树的每个结点至多只有二棵子树（不存在度大于 2 的结点），二叉树的子树有左右之分，次序不能颠倒。二叉树的第 i 层至多有 2&lt;sup&gt;i&lt;/sup&gt; - 1 个结点；深度为 k 的二叉树至多有 2&lt;sup&gt;k&lt;/sup&gt; - 1 个结点；对任何一棵二叉树 T，如果其终端结点数为 n&lt;sub&gt;0&lt;/sub&gt;，度为 2 的结点数为 n&lt;sub&gt;2&lt;/sub&gt;，则n&lt;sub&gt;0&lt;/sub&gt; = n&lt;sub&gt;2&lt;/sub&gt; + 1。&lt;/p&gt;
&lt;p&gt;树和二叉树的三个主要差别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树的结点个数至少为 1，而二叉树的结点个数可以为 0&lt;/li&gt;
&lt;li&gt;树中结点的最大度数没有限制，而二叉树结点的最大度数为 2&lt;/li&gt;
&lt;li&gt;树的结点无左、右之分，而二叉树的结点有左、右之分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二叉树又分为完全二叉树（complete binary tree）和满二叉树（full binary tree）&lt;/p&gt;
&lt;p&gt;满二叉树：一棵深度为 k，且有 2&lt;sup&gt;k&lt;/sup&gt; - 1 个节点称之为满二叉树&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/full%C2%A0binary%C2%A0tree.png&quot; alt=&quot;深度为 3 的满二叉树 full binary tree&quot;&gt;&lt;/p&gt;
&lt;p&gt;完全二叉树：深度为 k，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中序号为 1 至 n 的节点对应时，称之为完全二叉树&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/complete%C2%A0binary%C2%A0tree.png&quot; alt=&quot;深度为 3 的完全二叉树 complete binary tree&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Sort" scheme="http://bubkoo.com/tags/sort/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 - 选择排序 (Selection Sort)</title>
    <link href="http://bubkoo.com/2014/01/13/sort-algorithm/selection-sort/"/>
    <id>http://bubkoo.com/2014/01/13/sort-algorithm/selection-sort/</id>
    <published>2014-01-13T13:37:21.000Z</published>
    <updated>2014-01-13T13:37:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="算法原理">算法原理</span></h2><p>选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的序列进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><p><img src="http://bubkoo.qiniudn.com/selection_sort_animation.gif" alt="图片来源于维基百科"></p><a id="more"></a><h2><span id="实例分析">实例分析</span></h2><p>以数组 arr = [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 为例，先直观看一下每一步的变化，后面再介绍细节</p><p>第一次从数组 [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 中找到最小的数 0，放到数组的最前面（与第一个元素进行交换）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                               min</div><div class="line">                                ↓</div><div class="line">8   5   2   6   9   3   1   4   0   7</div><div class="line">↑                               ↑</div><div class="line">└───────────────────────────────┘</div></pre></td></tr></table></figure><p>交换后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0   5   2   6   9   3   1   4   8   7</div></pre></td></tr></table></figure><p>在剩余的序列中 [5, 2, 6, 9, 3, 1, 4, 8, 7] 中找到最小的数 1，与该序列的第一个个元素进行位置交换：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                       min</div><div class="line">                        ↓</div><div class="line">0   5   2   6   9   3   1   4   8   7</div><div class="line">    ↑                   ↑</div><div class="line">    └───────────────────┘</div></pre></td></tr></table></figure><p>交换后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0   1   2   6   9   3   5   4   8   7</div></pre></td></tr></table></figure><p>在剩余的序列中 [2, 6, 9, 3, 5, 4, 8, 7] 中找到最小的数 2，与该序列的第一个个元素进行位置交换（实际上不需要交换）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">       min</div><div class="line">        ↓</div><div class="line">0   1   2   6   9   3   5   4   8   7</div><div class="line">        ↑</div></pre></td></tr></table></figure><p>重复上述过程，直到最后一个元素就完成了排序。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">                   min</div><div class="line">                    ↓</div><div class="line">0   1   2   6   9   3   5   4   8   7</div><div class="line">            ↑       ↑</div><div class="line">            └───────┘</div><div class="line"></div><div class="line">                           min</div><div class="line">                            ↓</div><div class="line">0   1   2   3   9   6   5   4   8   7</div><div class="line">                ↑           ↑</div><div class="line">                └───────────┘</div><div class="line"></div><div class="line">                       min</div><div class="line">                        ↓</div><div class="line">0   1   2   3   4   6   5   9   8   7</div><div class="line">                    ↑   ↑</div><div class="line">                    └───┘</div><div class="line"></div><div class="line"></div><div class="line">                       min</div><div class="line">                        ↓</div><div class="line">0   1   2   3   4   5   6   9   8   7</div><div class="line">                        ↑   </div><div class="line"></div><div class="line">                                   min</div><div class="line">                                    ↓</div><div class="line">0   1   2   3   4   5   6   9   8   7</div><div class="line">                            ↑       ↑</div><div class="line">                            └───────┘  </div><div class="line"></div><div class="line">                               min</div><div class="line">                                ↓</div><div class="line">0   1   2   3   4   5   6   7   8   9</div><div class="line">                                ↑      </div><div class="line"></div><div class="line">                                   min</div><div class="line">                                    ↓</div><div class="line">0   1   2   3   4   5   6   7   8   9</div><div class="line">                                    ↑</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/Selection-Sort-Animation.gif" alt="图片来源于维基百科"></p><h2><span id="javascript-语言实现">JavaScript 语言实现</span></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length,</div><div class="line">      i,</div><div class="line">      j,</div><div class="line">      minIndex,</div><div class="line">      minValue,</div><div class="line">      temp;</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</div><div class="line">    minIndex = i;</div><div class="line">    minValue = array[minIndex];</div><div class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</div><div class="line">      <span class="keyword">if</span> (array[j] &lt; minValue) &#123;</div><div class="line">        minIndex = j;</div><div class="line">        minValue = array[minIndex];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 交换位置</span></div><div class="line">    temp = array[i];</div><div class="line">    array[i] = minValue;</div><div class="line">    array[minIndex] = temp;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> array</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="external">en.wikipedia.org</a></li><li><a href="http://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Selection_sort" target="_blank" rel="external">wikibooks</a></li><li><a href="http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科</a></li><li><a href="http://techblog.floorplanner.com/post/20528548241/selection-sort-in-javascript" target="_blank" rel="external">Selection sort in JavaScript</a></li><li><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.4.1.htm" target="_blank" rel="external">直接选择排序(Straight Selection Sort)</a></li><li><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260281.html" target="_blank" rel="external">经典排序算法 - 选择排序 Selection Sort</a></li><li><a href="http://sjjg.js.zwu.edu.cn/SFXX/paixu/paixu6.4.1.html" target="_blank" rel="external">选择排序算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;p&gt;选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&lt;/p&gt;
&lt;p&gt;选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的序列进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/selection_sort_animation.gif&quot; alt=&quot;图片来源于维基百科&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Sort" scheme="http://bubkoo.com/tags/sort/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 - 快速排序 (Quick Sort)</title>
    <link href="http://bubkoo.com/2014/01/12/sort-algorithm/quick-sort/"/>
    <id>http://bubkoo.com/2014/01/12/sort-algorithm/quick-sort/</id>
    <published>2014-01-12T20:55:42.000Z</published>
    <updated>2014-01-12T20:55:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="算法原理">算法原理</span></h2><p>快速排序是图灵奖得主<a href="http://zh.wikipedia.org/wiki/%E6%9D%B1%E5%B0%BC%C2%B7%E9%9C%8D%E7%88%BE" target="_blank" rel="external"> C. R. A. Hoare</a> 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为<a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="external">分治法(Divide-and-ConquerMethod)</a>。</p><p><img src="http://bubkoo.qiniudn.com/C.R.A.Hoare.jpg" alt="C. R. A. Hoare"></p><p>分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p><p>利用分治法可将快速排序的分为三步：</p><ol><li>在数据集之中，选择一个元素作为”基准”（pivot）。</li><li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为<a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="external">分区 (partition) 操作</a>，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li><li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。<br><img src="http://bubkoo.qiniudn.com/Sorting_quicksort_anim.gif" alt="图片来自维基百科"><a id="more"></a>分区是快速排序的主要内容，用伪代码可以表示如下：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">a, left, right, pivotIndex</span>)</span></div><div class="line">     pivotValue := a[pivotIndex]</div><div class="line">     swap(a[pivotIndex], a[right]) <span class="comment">// 把 pivot 移到結尾</span></div><div class="line">     storeIndex := left</div><div class="line">     <span class="keyword">for</span> i <span class="keyword">from</span> left to right<span class="number">-1</span></div><div class="line">         <span class="keyword">if</span> a[i] &lt; pivotValue</div><div class="line">             swap(a[storeIndex], a[i])</div><div class="line">             storeIndex := storeIndex + <span class="number">1</span></div><div class="line">     swap(a[right], a[storeIndex]) <span class="comment">// 把 pivot 移到它最後的地方</span></div><div class="line">     <span class="keyword">return</span> storeIndex <span class="comment">// 返回 pivot 的最终位置</span></div></pre></td></tr></table></figure><p>首先，把基准元素移到結尾（如果直接选择最后一个元素为基准元素，那就不用移动），然后从左到右（除了最后的基准元素），循环移动小于等于基准元素的元素到数组的开头，每次移动 storeIndex 自增 1，表示下一个小于基准元素将要移动到的位置。循环结束后 storeIndex 所代表的的位置就是基准元素的所有摆放的位置。所以最后将基准元素所在位置（这里是 right）与 storeIndex 所代表的的位置的元素交换位置。要注意的是，一个元素在到达它的最后位置前，可能会被交换很多次。</p><p>一旦我们有了这个分区算法，要写快速排列本身就很容易：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">procedure quicksort(a, left, right)</div><div class="line">    <span class="keyword">if</span> right &gt; left</div><div class="line">        select a pivot value a[pivotIndex]</div><div class="line">        pivotNewIndex := partition(a, left, right, pivotIndex)</div><div class="line">        quicksort(a, left, pivotNewIndex<span class="number">-1</span>)</div><div class="line">        quicksort(a, pivotNewIndex+<span class="number">1</span>, right)</div></pre></td></tr></table></figure><h2><span id="实例分析">实例分析</span></h2><p>举例来说，现有数组 arr = [3,7,8,5,2,1,9,5,4]，分区可以分解成以下步骤：</p><ol><li>首先选定一个基准元素，这里我们元素 5 为基准元素（基准元素可以任意选择）：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          pivot</div><div class="line">            ↓</div><div class="line">3   7   8   5   2   1   9   5   4</div></pre></td></tr></table></figure><ol><li>将基准元素与数组中最后一个元素交换位置，如果选择最后一个元素为基准元素可以省略该步：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">                              pivot</div><div class="line">                                ↓</div><div class="line">3   7   8   4   2   1   9   5   5</div></pre></td></tr></table></figure><ol><li><p>从左到右（除了最后的基准元素），循环移动小于基准元素 5 的所有元素到数组开头，留下大于等于基准元素的元素接在后面。在这个过程它也为基准元素找寻最后摆放的位置。循环流程如下：</p><p>循环 i == 0 时，storeIndex == 0，找到一个小于基准元素的元素 3，那么将其与 storeIndex 所在位置的元素交换位置，这里是 3 自身，交换后将 storeIndex 自增 1，storeIndex == 1：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                                pivot</div><div class="line">                                  ↓</div><div class="line">  3   7   8   4   2   1   9   5   5</div><div class="line">  ↑</div><div class="line">storeIndex</div></pre></td></tr></table></figure><p>循环 i == 3 时，storeIndex == 1，找到一个小于基准元素的元素 4：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     ┌───────┐                 pivot</div><div class="line">     ↓       ↓                   ↓</div><div class="line"> 3   7   8   4   2   1   9   5   5</div><div class="line">     ↑       ↑</div><div class="line">storeIndex   i</div></pre></td></tr></table></figure><p>交换位置后，storeIndex 自增 1，storeIndex == 2：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                              pivot</div><div class="line">                                ↓</div><div class="line">3   4   8   7   2   1   9   5   5</div><div class="line">        ↑           </div><div class="line">   storeIndex</div></pre></td></tr></table></figure><p>循环 i == 4 时，storeIndex == 2，找到一个小于基准元素的元素 2：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">        ┌───────┐             pivot</div><div class="line">        ↓       ↓               ↓</div><div class="line">3   4   8   7   2   1   9   5   5</div><div class="line">        ↑       ↑</div><div class="line">   storeIndex   i</div></pre></td></tr></table></figure><p>交换位置后，storeIndex 自增 1，storeIndex == 3：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                              pivot</div><div class="line">                                ↓</div><div class="line">3   4   2   7   8   1   9   5   5</div><div class="line">            ↑           </div><div class="line">       storeIndex</div></pre></td></tr></table></figure><p>循环 i == 5 时，storeIndex == 3，找到一个小于基准元素的元素 1：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">            ┌───────┐         pivot</div><div class="line">            ↓       ↓           ↓</div><div class="line">3   4   2   7   8   1   9   5   5</div><div class="line">            ↑       ↑</div><div class="line">       storeIndex   i</div></pre></td></tr></table></figure><p>交换后位置后，storeIndex 自增 1，storeIndex == 4：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                              pivot</div><div class="line">                                ↓</div><div class="line">3   4   2   1   8   7   9   5   5</div><div class="line">                ↑           </div><div class="line">           storeIndex</div></pre></td></tr></table></figure><p>循环 i == 7 时，storeIndex == 4，找到一个小于等于基准元素的元素 5：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                ┌───────────┐ pivot</div><div class="line">                ↓           ↓   ↓</div><div class="line">3   4   2   1   8   7   9   5   5</div><div class="line">                ↑           ↑</div><div class="line">           storeIndex       i</div></pre></td></tr></table></figure><p>交换后位置后，storeIndex 自增 1，storeIndex == 5：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                              pivot</div><div class="line">                                ↓</div><div class="line">3   4   2   1   5   7   9   8   5</div><div class="line">                    ↑           </div><div class="line">               storeIndex</div></pre></td></tr></table></figure></li><li><p>循环结束后交换基准元素和 storeIndex 位置的元素的位置：</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                  pivot</div><div class="line">                    ↓</div><div class="line">3   4   2   1   5   5   9   8   7</div><div class="line">                    ↑           </div><div class="line">               storeIndex</div></pre></td></tr></table></figure><p>  那么 storeIndex 的值就是基准元素的最终位置，这样整个分区过程就完成了。</p><p>  引用<a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="external">维基百科</a>上的一张图片：</p><p>  <img src="http://bubkoo.qiniudn.com/Partition_example.svg.png" alt="图片来自维基百科"></p><h2><span id="javascript-语言实现">JavaScript 语言实现</span></h2><p>查看了很多关于 JavaScript 实现快速排序方法的文章后，发现绝大多数实现方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;　　</div><div class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;　　</div><div class="line">    <span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);　　</div><div class="line">    <span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];　　</div><div class="line">    <span class="keyword">var</span> left = [];　　</div><div class="line">    <span class="keyword">var</span> right = [];　　</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;　　　　</div><div class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;　　　　　　</div><div class="line">            left.push(arr[i]);　　　　</div><div class="line">        &#125; <span class="keyword">else</span> &#123;　　　　　　</div><div class="line">            right.push(arr[i]);　　　　</div><div class="line">        &#125;　　</div><div class="line">    &#125;　　</div><div class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>上面简单版本的缺点是，它需要Ω(n)的额外存储空间，也就跟归并排序一样不好。额外需要的存储器空间配置，在实际上的实现，也会极度影响速度和高速缓存的性能。</p><p class="sign">摘自<a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="external">维基百科</a></p></blockquote><p>按照<a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="external">维基百科</a>中的原地(in-place)分区版本，实现快速排序方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"><span class="comment">// 交换元素位置</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, k</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> temp = array[i];</div><div class="line">array[i] = array[k];</div><div class="line">array[k] = temp;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 数组分区，左小右大</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array, left, right</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> storeIndex = left;        </div><div class="line"><span class="keyword">var</span> pivot = array[right]; <span class="comment">// 直接选最右边的元素为基准元素</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = left; i &lt; right; i++) &#123;</div><div class="line"><span class="keyword">if</span> (array[i] &lt; pivot) &#123;</div><div class="line">swap(array, storeIndex, i);</div><div class="line">storeIndex++; <span class="comment">// 交换位置后，storeIndex 自增 1，代表下一个可能要交换的位置</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">swap(array, right, storeIndex); <span class="comment">// 将基准元素放置到最后的正确位置上</span></div><div class="line"><span class="keyword">return</span> storeIndex;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array, left, right</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (left &gt; right) &#123;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> storeIndex = partition(array, left, right);</div><div class="line">sort(array, left, storeIndex - <span class="number">1</span>);</div><div class="line">sort(array, storeIndex + <span class="number">1</span>, right);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</div><div class="line"><span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另外一个版本，思路和上面的一样，代码逻辑没有上面的清晰</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, k</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> temp = arr[i];</div><div class="line">        arr[i] = arr[k];</div><div class="line">        arr[k] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr, start, end</span>) </span>&#123;</div><div class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, k</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> temp = arr[i];</div><div class="line">            arr[i] = arr[k];</div><div class="line">            arr[k] = temp;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr, start, end</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> pivot = arr[start],</div><div class="line">                i = start + <span class="number">1</span>,</div><div class="line">                k = end;</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">                <span class="keyword">while</span> (arr[i] &lt; pivot) &#123;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">while</span> (arr[k] &gt; pivot) &#123;</div><div class="line">                    k--;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (i &gt;= k) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                swap(arr, i, k);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            swap(arr, start, k);</div><div class="line">            sort(arr, start, <span class="built_in">Math</span>.max(<span class="number">0</span>, k - <span class="number">1</span>));</div><div class="line">            sort(arr, <span class="built_in">Math</span>.min(end, k + <span class="number">1</span>), end);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="external">wiki Quicksort</a></li><li><a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科 - 快速排序</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank" rel="external">快速排序（Quicksort）的Javascript实现</a></li><li><a href="http://www.cnblogs.com/ethanzheng/archive/2013/02/20/quicksort-in-javascript.html" target="_blank" rel="external">Quicksort in JavaScript</a></li><li><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260270.html" target="_blank" rel="external">经典排序算法 - 快速排序Quick sort</a></li><li><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.3.2.1.htm" target="_blank" rel="external">快速排序(QuickSort)</a></li><li><a href="http://jsdo.it/norahiko/oxIy/fullscreen" target="_blank" rel="external">ソートアルゴリズムを映像化してみた</a></li><li><a href="http://acatalept.com/blog/2008/10/28/stable-quicksort-in-javascript/" target="_blank" rel="external">Stable quicksort in Javascript</a></li><li><a href="http://www.stoimen.com/blog/2010/06/11/friday-algorithms-quicksort-difference-between-php-and-javascript/" target="_blank" rel="external">Friday Algorithms: Quicksort – Difference Between PHP and JavaScript</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;p&gt;快速排序是图灵奖得主&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%9D%B1%E5%B0%BC%C2%B7%E9%9C%8D%E7%88%BE&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; C. R. A. Hoare&lt;/a&gt; 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为&lt;a href=&quot;http://en.wikipedia.org/wiki/Quicksort&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;分治法(Divide-and-ConquerMethod)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/C.R.A.Hoare.jpg&quot; alt=&quot;C. R. A. Hoare&quot;&gt;&lt;/p&gt;
&lt;p&gt;分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。&lt;/p&gt;
&lt;p&gt;利用分治法可将快速排序的分为三步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在数据集之中，选择一个元素作为”基准”（pivot）。&lt;/li&gt;
&lt;li&gt;所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为&lt;a href=&quot;http://en.wikipedia.org/wiki/Quicksort&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;分区 (partition) 操作&lt;/a&gt;，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。&lt;/li&gt;
&lt;li&gt;对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。&lt;br&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/Sorting_quicksort_anim.gif&quot; alt=&quot;图片来自维基百科&quot;&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Sort" scheme="http://bubkoo.com/tags/sort/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法 - 冒泡排序 (Bubble Sort)</title>
    <link href="http://bubkoo.com/2014/01/12/sort-algorithm/bubble-sort/"/>
    <id>http://bubkoo.com/2014/01/12/sort-algorithm/bubble-sort/</id>
    <published>2014-01-12T20:00:16.000Z</published>
    <updated>2014-01-12T20:00:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="算法原理">算法原理</span></h2><p>冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>冒泡排序算法的流程如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p>由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。</p><p><img src="http://bubkoo.qiniudn.com/Bubble_sort_animation.gif" alt="图片来自维基百科"></p><a id="more"></a><h2><span id="实例分析">实例分析</span></h2><p>以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字：</p><p>第一次外循环</p><p>( <strong>5</strong> <strong>1</strong> 4 2 8 ) → ( <strong>1</strong> <strong>5</strong> 4 2 8 )， 5 &gt; 1 交换位置<br>( 1 <strong>5</strong> <strong>4</strong> 2 8 ) → ( 1 <strong>4</strong> <strong>5</strong> 2 8 )， 5 &gt; 4 交换位置<br>( 1 4 <strong>5</strong> <strong>2</strong> 8 ) → ( 1 4 <strong>2</strong> <strong>5</strong> 8 )， 5 &gt; 2 交换位置<br>( 1 4 2 <strong>5</strong> <strong>8</strong> ) → ( 1 4 2 <strong>5</strong> <strong>8</strong> )， 5 &lt; 8 位置不变</p><p>第二次外循环（除开最后一个元素8，对剩余的序列）</p><p>( <strong>1</strong> <strong>4</strong> 2 5 8 ) → ( <strong>1</strong> <strong>4</strong> 2 5 8 )， 1 &lt; 4 位置不变<br>( 1 <strong>4</strong> <strong>2</strong> 5 8 ) → ( 1 <strong>2</strong> <strong>4</strong> 5 8 )， 4 &gt; 2 交换位置<br>( 1 2 <strong>4</strong> <strong>5</strong> 8 ) → ( 1 2 <strong>4</strong> <strong>5</strong> 8 )， 4 &lt; 5 位置不变</p><p>第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1）</p><p>( <strong>1</strong> <strong>2</strong> 4 5 8 )  →  ( <strong>1</strong> <strong>2</strong> 4 5 8 )<br>( 1 <strong>2</strong> <strong>4</strong> 5 8 )  →  ( 1 <strong>2</strong> <strong>4</strong> 5 8 )</p><p>第四次外循环（最后一次）<br>( <strong>1</strong> <strong>2</strong> 4 5 8 )  →  ( <strong>1</strong> <strong>2</strong> 4 5 8 )</p><h2><span id="javascript-语言实现">JavaScript 语言实现</span></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> length = array.length,</div><div class="line">       i,</div><div class="line">       j,</div><div class="line">       temp;</div><div class="line">   <span class="keyword">for</span> (i = length - <span class="number">1</span>; <span class="number">0</span> &lt; i; i--) &#123;</div><div class="line">       <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">           <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</div><div class="line">               temp = array[j];</div><div class="line">               array[j] = array[j + <span class="number">1</span>];</div><div class="line">               array[j + <span class="number">1</span>] = temp;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="external">en.wikipedia.org</a></li><li><a href="http://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科，自由的百科全书</a></li><li><a href="http://www.sorting-algorithms.com/bubble-sort" target="_blank" rel="external">Bubble Sort</a></li><li><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260280.html" target="_blank" rel="external">经典排序算法 - 冒泡排序Bubble sort</a></li><li><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.3.1.1.htm" target="_blank" rel="external">冒泡排序</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;p&gt;冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;/p&gt;
&lt;p&gt;冒泡排序算法的流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换他们两个。&lt;/li&gt;
&lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个。&lt;/li&gt;
&lt;li&gt;持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/Bubble_sort_animation.gif&quot; alt=&quot;图片来自维基百科&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Sort" scheme="http://bubkoo.com/tags/sort/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 随机打乱数组 - 洗牌算法</title>
    <link href="http://bubkoo.com/2014/01/12/sort-algorithm/array-shuffle/"/>
    <id>http://bubkoo.com/2014/01/12/sort-algorithm/array-shuffle/</id>
    <published>2014-01-12T19:38:36.000Z</published>
    <updated>2014-01-12T19:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学习排序算法的时候，经常要用到随机数组，于是就写了一个生成随机数组的方法。算法来自网络，只是修改成了 JavaScript 版本。</p><p>基本原理是洗牌算法，首先从所有元素中随机选取一个与第一个元素进行交换，然后在第二个之后选择一个元素与第二个交换，直到最后一个元素。这样能确保每个元素在每个位置的概率都是1/n。</p><p>具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 生成从 1 到 length 之间的随机数组</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @length 随机数组的长度，如果未传递该参数，那么 length 为默认值 9</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomArray</span>(<span class="params">length</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i,</div><div class="line">        index,</div><div class="line">        temp,</div><div class="line">        arr = [length];</div><div class="line">    length = <span class="keyword">typeof</span>(length) === <span class="string">'undefined'</span> ? <span class="number">9</span> : length;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= length; i++) &#123;</div><div class="line">        arr[i - <span class="number">1</span>] = i;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 打乱数组</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= length; i++) &#123;</div><div class="line">        <span class="comment">// 产生从 i 到 length 之间的随机数</span></div><div class="line">        index = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (length - i)) + i;</div><div class="line">        <span class="keyword">if</span> (index != i) &#123;</div><div class="line">            temp = arr[i];</div><div class="line">            arr[i] = arr[index];</div><div class="line">            arr[index] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习排序算法的时候，经常要用到随机数组，于是就写了一个生成随机数组的方法。算法来自网络，只是修改成了 JavaScript 版本。&lt;/p&gt;
&lt;p&gt;基本原理是洗牌算法，首先从所有元素中随机选取一个与第一个元素进行交换，然后在第二个之后选择一个元素与第二个交换，直到最后一个元
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Algorithm" scheme="http://bubkoo.com/tags/algorithm/"/>
    
      <category term="Shuffle" scheme="http://bubkoo.com/tags/shuffle/"/>
    
  </entry>
  
  <entry>
    <title>浏览器背后的故事 - 浏览器内部工作原理</title>
    <link href="http://bubkoo.com/2014/01/06/how-browsers-work-behind-the-scenes-of-modern-web-browsers/"/>
    <id>http://bubkoo.com/2014/01/06/how-browsers-work-behind-the-scenes-of-modern-web-browsers/</id>
    <published>2014-01-06T20:04:21.000Z</published>
    <updated>2014-01-07T20:04:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="external">How Browsers Work: Behind the scenes of modern web browsers</a><br>原文日期：2011年8月5日</p><h2><span id="序言">序言</span></h2><p>这是一篇全面介绍基于 Webkit 和 Gecko 内核浏览器内部原理的入门文章，是以色列开发人员 <a href="http://www.html5rocks.com/profiles/#taligarsiel" target="_blank" rel="external">Tali Garsiel</a> 大量研究的成果。在过去的几年中，她查阅了所有公开发布的关于浏览器内部机制的数据（请参见<a href="#resources">参考资料</a>），并花了很多时间来研读网络浏览器的源代码。她这样写道：</p><blockquote><p>在 IE 占据 90% 市场份额的年代，我们除了把浏览器当成一个“黑盒”，什么也做不了。如今，开源浏览器拥有了过半的市场份额，因此，是时候来揭开神秘的面纱，一探网络浏览器的内幕了。呃，里面只有数以百万行计的 C++ 代码 …</p></blockquote><p><a href="http://www.html5rocks.com/profiles/#taligarsiel" target="_blank" rel="external">Tali Garsiel</a> 在<a href="http://taligarsiel.com/" target="_blank" rel="external">她的网站</a>上公布了自己的研究成果，但是我们觉得它值得让更多的人来了解，所以我们<a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="external">在此</a>重新整理并公布。</p><p>作为一名 Web 开发人员，<strong>学习浏览器的内部工作原理将有助于您作出更明智的决策，并理解那些最佳开发实践的个中缘由</strong>。尽管这是一篇相当长的文档，但是我们建议您多花一些时间来仔细阅读，读完之后，您肯定会觉得所费不虚。</p><p class="sign"><a href="http://www.html5rocks.com/profiles/#paulirish" target="_blank" rel="external">Paul Irish</a>，Chrome 浏览器开发人员事务部</p><a id="more"></a><h2><span id="简介">简介</span></h2><p>如今，浏览器已经是最广泛使用的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们将会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。</p><h3><span id="我们要讨论的浏览器">我们要讨论的浏览器</span></h3><p>目前在桌面端使用的主流浏览器有五个：Chrome、IE、Firefox、Safari 和 Opera。在手机端主要是安卓、iPhone、Opera Mini、Opera Mobile、UC、洛基亚的 S40/S60 浏览器和 Chrome，除了 Opera，他们都是基于 WebKit 内核。根据 <a href="http://gs.statcounter.com/" target="_blank" rel="external">StatCounter 浏览器统计数据</a>，目前（2013 年 6 月）Chrome、Firefox 和 Safari 在桌面浏览器中的总市场占有率将近 71%。在手机端，Android、iPhone 和 Chrome 总市场占有率将近 54%。由此可见，如今开源浏览器在浏览器市场中占据了非常坚实的地位。</p><p><strong>本文是基于开源浏览器展开叙述的，即 Firefox、Chrome 浏览器和 Safari（部分开源）。</strong></p><h3><span id="浏览器的主要功能">浏览器的主要功能</span></h3><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您请求的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用的 URI（统一资源标示符）指定。</p><p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（World Wide Web Consortium）进行维护。 多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展，这给 Web 开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</p><p>浏览器的用户界面有很多彼此相同的元素，其中包括：</p><ul><li>用来输入 URI 的地址栏</li><li>前进和后退按钮</li><li>书签</li><li>用于刷新页面和停止加载当前文档的刷新和停止按钮</li><li>用于返回主页的主页按钮</li></ul><p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</p><h3><span id="浏览器的高层结构-high-level-structure">浏览器的高层结构 (High Level Structure)</span></h3><p>浏览器的主要组件有 ( <a href="#1_1">1.1</a> )：</p><ol><li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li><li><strong>浏览器引擎</strong> - 在用户界面和渲染引擎之间传送指令。</li><li><strong>渲染引擎</strong> - 负责显示请求的内容。例如，如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li><li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li><li><strong>用户界面后端</strong> - 用于绘制基本的部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li><li><strong>JavaScript 解释器</strong> - 用于解析和执行 JavaScript 代码。</li><li><strong>数据存储</strong> - 这是持久层。浏览器可能需要在本地保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 中，浏览器也支持新的存储机制,如localStorage、IndexedDB、WebSQL和文件系统。</li></ol><p><img src="http://bubkoo.qiniudn.com/The%20browser&#39;s%20high%20level%20structure.png" alt="图 1 浏览器的主要组件"></p><p>需要注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个渲染引擎实例。每个标签页都是一个独立的进程。可以在任务管理器中看到有多个 Chrome 进程。</p><h2><span id="渲染引擎">渲染引擎</span></h2><p>渲染引擎的作用嘛…当然就是“渲染”了，也就是在浏览器的屏幕上显示请求的内容。</p><p>默认情况下，渲染引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其它类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 和图片。</p><h3><span id="浏览器内核">浏览器内核</span></h3><p>不同的浏览器使用不同的内核：IE 使用的是 Trident，Firefox 使用的是 Gecko，Safari 使用的是 WebKit，Chrome 和 Opera (V15+) 使用的是 Blink (WebKit的一个分支)。Webkit 是一个开源内核，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果和 Windows。有关详情，请参阅 <a href="http://webkit.org/" target="_blank" rel="external">webkit.org</a>。</p><h3><span id="主要流程">主要流程</span></h3><p>渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8kB 以内。然后进行如下所示的基本渲染流程：</p><p><img src="http://bubkoo.qiniudn.com/Rendering%20engine%20basic%20flow.png" alt="图 2 渲染引擎的基本流程"></p><p>渲染引擎开始解析 HTML 文档，并将各 HTML 标记逐个转化成“内容树”上的 [DOM 节点][#]。同时也会解析外部 CSS 文件以及元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：[呈现树][#]。</p><p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p><p>呈现树构建完毕之后，进入“[布局][#]”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是[绘制][#] - 渲染引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p><p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档都解析完毕，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会先将部分内容解析并显示出来。</p><p><em>主流程示例</em></p><p><img src="http://bubkoo.qiniudn.com/WebKit%20main%20flow.png" alt="图 3 Webkit 主流程"></p><p><img src="http://bubkoo.qiniudn.com/Mozilla&#39;s%20Gecko%20rendering%20engine%20main%20flow.png" alt="图 4 Mozilla 的 Gecko 呈现引擎主流程"></p><p>从图 3 和图 4 可以看出，虽然 Webkit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p><p>Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。Webkit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，Webkit 使用的术语是“布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，Webkit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。</p><p>接下来我们会逐一论述流程中的每一部分：</p><h3><span id="解析-综述">解析 - 综述</span></h3><p>解析是渲染引擎中非常重要的一个环节，因此我们要更深入地讲解。首先，来介绍一下解析。</p><p>解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。</p><p>例如 - 解析 2 + 3 - 1 这个表达式，会返回下面的树：</p><p><img src="http://bubkoo.qiniudn.com/mathematical%20expression%20tree%20node.png" alt="图 5 数学表达式树节点"></p><h3><span id="语法">语法</span></h3><p>解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为与[上下文无关的语法][]。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。</p><h3><span id="解析器和词法分析器的组合">解析器和词法分析器的组合</span></h3><p>解析的过程可以分成两个子过程：<strong>词法分析</strong>和<strong>语法分析</strong>。</p><p>词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的所有单词。</p><p>语法分析是应用语言的语法规则的过程。</p><p>解析器通常将解析工作分给以下两个组件来处理：<strong>词法分析器</strong>（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而<strong>解析器</strong>负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。</p><p><img src="http://bubkoo.qiniudn.com/from%20source%20document%20to%20parse%20trees.png" alt="图 6 从源文档到解析树"></p><p>解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。</p><p>如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。</p><h3><span id="翻译">翻译</span></h3><p>很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用的，而翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。</p><p><img src="http://bubkoo.qiniudn.com/compilation%20flow.png" alt="图 7 编译流程"></p><h3><span id="解析示例">解析示例</span></h3><p>在图 5 中，我们通过一个数学表达式建立了解析树。现在，让我们试着定义一个简单的数学语言，用来演示解析的过程。</p><p>词汇：我们用的语言可包含整数、加号和减号。</p><p>语法：</p><ol><li>构成语言的语法单位是表达式、项和运算符。</li><li>我们用的语言可以包含任意数量的表达式。</li><li>表达式的定义是：一个“项”接一个“运算符”，然后再接一个“项”。</li><li>运算符是加号或减号。</li><li>项是一个整数或一个表达式。</li></ol><p>让我们分析一下 <code>2 + 3 - 1</code></p><p>匹配语法规则的第一个子串是 <code>2</code>，而根据第 5 条语法规则，这是一个项。匹配语法规则的第二个子串是 <code>2 + 3</code>，而根据第 3 条规则（一个项接一个运算符，然后再接一个项），这是一个表达式。下一个匹配项已经到了输入的结束。<code>2 + 3 - 1</code> 是一个表达式，因为我们已经知道 <code>2 + 3</code> 是一个项，这样就符合“一个项接一个运算符，然后再接一个项”的规则。<code>2 + +</code> 不与任何规则匹配，因此是无效的输入。</p><h3><span id="词汇和语法的正式定义">词汇和语法的正式定义</span></h3><p>词汇通常用<a href="http://www.regular-expressions.info/" target="_blank" rel="external">正则表达式</a>表示。</p><p>例如，我们的示例语言可以定义如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">INTEGER :0|[1-9][0-9]*</div><div class="line">PLUS : +</div><div class="line">MINUS: -</div></pre></td></tr></table></figure><p>正如您所看到的，这里用正则表达式给出了整数的定义。</p><p>语法通常使用一种称为 <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form" target="_blank" rel="external">BNF</a> 的格式来定义。我们的示例语言可以定义如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">expression :=  term  operation  term</div><div class="line">operation :=  PLUS | MINUS</div><div class="line">term := INTEGER | expression</div></pre></td></tr></table></figure><p>之前我们说过，如果语言的语法是与上下文无关的语法，就可以由常规解析器进行解析。与上下文无关的语法的直观定义就是可以完全用 BNF 格式表达的语法。有关正式定义，请参阅<a href="http://en.wikipedia.org/wiki/Context-free_grammar" target="_blank" rel="external">关于与上下文无关的语法的维基百科文章</a>。</p><h3><span id="解析器类型">解析器类型</span></h3><p>有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。</p><p>让我们来看看这两种解析器会如何解析我们的示例：</p><p>自上而下的解析器会从高层的规则开始：首先将 2 + 3 标识为一个表达式，然后将 2 + 3 - 1 标识为一个表达式（标识表达式的过程涉及到匹配其他规则，但是起点是最高级别的规则）。</p><p>自下而上的解析器将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。</p><table><thead><tr><th>堆栈</th><th>输入</th></tr></thead><tbody><tr><td></td><td><code>2 + 3 - 1</code></td></tr><tr><td>项</td><td><code>+ 3 - 1</code></td></tr><tr><td>项运算</td><td><code>3 - 1</code></td></tr><tr><td>表达式</td><td><code>- 1</code></td></tr><tr><td>表达式运算符</td><td><code>1</code></td></tr><tr><td>表达式</td><td><code> </code></td></tr></tbody></table><p>这种自下而上的解析器称为移位归约解析器，因为输入在向右移位（设想有一个指针从输入内容的开头移动到结尾），并且逐渐归约到语法规则上。</p><h3><span id="自动生成解析器">自动生成解析器</span></h3><p>有一些工具可以帮助您生成解析器，它们称为解析器生成器。您只要向其提供您所用语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建优化的解析器并不是一件容易的事情，所以解析器生成器是非常实用的。</p><p>Webkit 使用了两种非常有名的解析器生成器：用于创建词法分析器的 <a href="http://en.wikipedia.org/wiki/Flex_lexical_analyser" target="_blank" rel="external">Flex</a> 以及用于创建解析器的 <a href="http://www.gnu.org/software/bison/" target="_blank" rel="external">Bison</a>（您也可能遇到 Lex 和 Yacc 这样的别名）。Flex 的输入是包含标记的正则表达式定义的文件。Bison 的输入是采用 BNF 格式的语言语法规则。</p><h3><span id="html-解析器">HTML 解析器</span></h3><p>HTML 解析器的任务是将 HTML 标记解析成解析树。</p><h4><span id="html-语法定义">HTML 语法定义</span></h4><p>HTML 的词汇和语法在 W3C 组织创建的[规范][]中进行了定义。当前的版本是 HTML4，HTML5 正在处理过程中（注：目前已经发布）。</p><h4><span id="非与上下文无关的语法">非与上下文无关的语法</span></h4><p>正如我们在解析过程的简介中已经了解到的，语法可以用 BNF 等格式进行正式定义。</p><p>很遗憾，所有的常规解析器都不适用于 HTML（我并不是开玩笑，它们可以用于解析 CSS 和 JavaScript）。HTML 并不能很容易地用解析器所需的与上下文无关的语法来定义。</p><p>有一种可以定义 HTML 的正规格式：DTD（Document Type Definition，文档类型定义），但它不是与上下文无关的语法。</p><p>这初看起来很奇怪：HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？</p><p>区别在于 HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。</p><p>显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是 HTML 如此流行的原因：它能包容您的错误，简化 Web 开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。</p><h4><span id="html-dtd">HTML DTD</span></h4><p>HTML 的定义采用了 DTD 格式。此格式可用于定义 <a href="http://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language" target="_blank" rel="external">SGML</a> 族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。如上文所述，HTML DTD 无法构成与上下文无关的语法。</p><p>DTD 存在一些变体。严格模式完全遵守 HTML 规范，而其他模式可支持以前的浏览器所使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。最新的严格模式 DTD 可以在这里找到：<a href="http://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="external">www.w3.org/TR/html4/strict.dtd</a></p><h4><span id="dom">DOM</span></h4><p>解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。 </p><p>解析树的根节点是“<a href="http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document" target="_blank" rel="external">Document</a>”对象。</p><p>DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">      Hello World</div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.png"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>可解析成如下的 DOM 树：</p><p><img src="http://bubkoo.qiniudn.com/DOM%20tree%20of%20the%20example%20markup.png" alt="图 8 示例标记的 DOM 树"></p><p>和 HTML 一样，DOM 也是由 W3C 组织指定的。请参见 <a href="http://www.w3.org/DOM/DOMTR" target="_blank" rel="external">www.w3.org/DOM/DOMTR</a>。这是关于文档操作的通用规范。其中一个特定模块描述针对 HTML 的元素。HTML 的定义可以在这里找到：<a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html" target="_blank" rel="external">www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html</a>。</p><p>我所说的树包含 DOM 节点，指的是树是由实现了某个 DOM 接口的元素构成的。浏览器所用的具体实现也会具有一些其他属性，供浏览器在内部使用。</p><h4><span id="解析算法">解析算法</span></h4><p>我们在之前章节已经说过，HTML 无法用常规的自上而下或自下而上的解析器进行解析。</p><p>原因在于：</p><ol><li>语言的宽容本质。</li><li>浏览器历来对一些常见的无效 HTML 用法采取包容态度。</li><li>解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容。</li></ol><p>由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html" target="_blank" rel="external">HTML5 规范详细地描述了解析算法</a>。此算法由两个阶段组成：标记化和树构建。</p><p>标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。</p><p>标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。</p><p><img src="http://bubkoo.qiniudn.com/HTML%20parsing%20flow.png" alt="图 9 HTML 解析流程（摘自 HTML5 规范）"></p><h4><span id="标记化算法">标记化算法</span></h4><p>该算法的输出结果是 HTML 标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法在此详述，所以我们通过一个简单的示例来帮助大家理解其原理。</p><p>基本示例 - 将下面的 HTML 代码标记化：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    Hello world</div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>初始状态是数据状态。遇到字符 <code>&lt;</code> 时，状态更改为<strong>“标记打开状态”</strong>。接收一个 a-z 字符会创建“起始标记”，状态更改为<strong>“标记名称状态”</strong>。这个状态会一直保持到接收 &gt; 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 html 标记。</p><p>遇到 <code>&gt;</code> 标记时，会发送当前的标记，状态改回“数据状态”。<code>&lt;body&gt;</code> 标记也会进行同样的处理。目前 html 和 body 标记均已发出。现在我们回到“数据状态”。接收到 Hello world 中的 H 字符时，将创建并发送字符标记，直到接收 <code>&lt;/body&gt;</code> 中的 <code>&lt;</code>。我们将为 Hello world 中的每个字符都发送一个字符标记。</p><p>现在我们回到“标记打开状态”。接收下一个输入字符 <code>/</code> 时，会创建 end tag token 并改为“标记名称状态”。我们会再次保持这个状态，直到接收 <code>&gt;</code>。然后将发送新的标记，并回到“数据状态”。<code>&lt;/html&gt;</code> 输入也会进行同样的处理。</p><p><img src="http://bubkoo.qiniudn.com/Tokenizing%20the%20example%20input.png" alt="图 10 对示例输入进行标记化"></p><h4><span id="树构建算法">树构建算法</span></h4><p>在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”。</p><p>让我们来看看示例输入的树构建过程：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    Hello world</div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是“<strong>initial mode</strong>”。接收 HTML 标记后转为“<strong>before html</strong>”模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。</p><p>然后状态将改为“<strong>before head</strong>”。此时我们接收“body”标记。即使我们的示例中没有“head”标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。</p><p>现在我们进入了“<strong>in head</strong>”模式，然后转入“<strong>after head</strong>”模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为“<strong>body</strong>”。</p><p>现在，接收由“Hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。</p><p>接收 body 结束标记会触发“<strong>after body</strong>”模式。现在我们将接收 HTML 结束标记，然后进入“<strong>after after body</strong>”模式。接收到文件结束标记后，解析过程就此结束。</p><p><img src="http://bubkoo.qiniudn.com/tree%20construction%20of%20example%20html.gif" alt="图 11 示例 HTML 的树构建"></p><h4><span id="解析结束后的操作">解析结束后的操作</span></h4><p>在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于“<strong>deferred</strong>”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件将随之触发。</p><p>您可以<a href="http://www.w3.org/TR/html5/syntax.html#html-parser" target="_blank" rel="external">在 HTML5 规范中查看标记化和树构建的完整算法</a></p><h4><span id="浏览器的容错机制">浏览器的容错机制</span></h4><p>您在浏览 HTML 网页时从来不会看到“语法无效”的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。</p><p>以下面的 HTML 代码为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">mytag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">mytag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    Really lousy HTML</div><div class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>在这里，我已经违反了很多语法规则（“mytag”不是标准的标记，“p”和“div”元素之间的嵌套有误等等），但是浏览器仍然会正确地显示这些内容，并且毫无怨言。因为有大量的解析器代码会纠正 HTML 网页作者的错误。</p><p>不同浏览器的错误处理机制相当一致，但令人称奇的是，这种机制并不是 HTML 当前规范的一部分。和书签管理以及前进/后退按钮一样，它也是浏览器在多年发展中的产物。很多网站都普遍存在着一些已知的无效 HTML 结构，每一种浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。</p><p>HTML5 规范定义了一部分这样的要求。Webkit 在 HTML 解析器类的开头注释中对此做了很好的概括。</p><blockquote><p>解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。<br>遗憾的是，我们不得不处理很多格式错误的 HTML 文档，所以解析器必须具备一定的容错性。<br>我们至少要能够处理以下错误情况：</p><ol><li>明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。</li><li>我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。</li><li>向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。</li><li>如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。</li></ol></blockquote><p>让我们看一些 Webkit 容错的示例：</p><p>使用了 <code>&lt;/br&gt;</code> 而不是 <code>&lt;br&gt;</code></p><p>有些网站使用了 <code>&lt;/br&gt;</code> 而不是 <code>&lt;br&gt;</code>。为了与 IE 和 Firefox 兼容，Webkit 将其与 <code>&lt;br&gt;</code> 做同样的处理。 </p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;</div><div class="line">     reportError(MalformedBRError);</div><div class="line">     t-&gt;beginTag = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>请注意，错误处理是在内部进行的，用户并不会看到这个过程。</p><h5><span id="离散表格">离散表格</span></h5><p>离散表格是指位于其他表格内容中，但又不在任何一个单元格内的表格。</p><p>比如以下的示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure><p>Webkit 会将其层次结构更改为两个同级表格：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (m_inStrayTableContent &amp;&amp; localName == tableTag)</div><div class="line">        popBlock(tableTag);</div></pre></td></tr></table></figure><p>Webkit 使用一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格。现在，这两个表格就变成了同级关系。</p><h5><span id="嵌套的表单元素">嵌套的表单元素</span></h5><p>如果用户在一个表单元素中又放入了另一个表单，那么第二个表单将被忽略。 </p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!m_currentFormElement) &#123;</div><div class="line">        m_currentFormElement = <span class="keyword">new</span> HTMLFormElement(formTag,    m_document);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5><span id="过于复杂的标记层次结构">过于复杂的标记层次结构</span></h5><p>代码的注释已经说得很清楚了。 </p><blockquote><p>示例网站 www.liceo.edu.mx 嵌套了约 1500 个标记，全都来自一堆 <code>&lt;b&gt;</code> 标记。我们只允许最多 20 层同类型标记的嵌套，如果再嵌套更多，就会全部忽略。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> HTMLParser::allowNestedRedundantTag(<span class="keyword">const</span> AtomicString&amp; tagName)</div><div class="line">&#123;</div><div class="line"></div><div class="line"><span class="keyword">unsigned</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (HTMLStackElem* curr = m_blockStack;</div><div class="line">         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName;</div><div class="line">     curr = curr-&gt;next, i++) &#123; &#125;</div><div class="line"><span class="keyword">return</span> i != cMaxRedundantTagDepth;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5><span id="放错位置的-html-或者-body-结束标记">放错位置的 html 或者 body 结束标记</span></h5><p>同样，代码的注释已经说得很清楚了。</p><blockquote><p>支持格式非常糟糕的 HTML 代码。我们从不关闭 body 标记，因为一些愚蠢的网页会在实际文档结束之前就关闭。我们通过调用 end() 来执行关闭操作。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag )</div><div class="line">        <span class="keyword">return</span>;</div></pre></td></tr></table></figure><p>所以网页作者需要注意，除非您想作为反面教材出现在 Webkit 容错代码段的示例中，否则还请编写格式正确的 HTML 代码。</p><h3><span id="css-解析">CSS 解析</span></h3><p>还记得简介中解析的概念吗？和 HTML 不同，CSS 是上下文无关的语法，可以使用简介中描述的各种解析器进行解析。事实上，<a href="http://www.w3.org/TR/CSS2/grammar.html" target="_blank" rel="external">CSS 规范定义了 CSS 的词法和语法</a>。</p><p>让我们来看一些示例： </p><p>词法语法（词汇）是针对各个标记用正则表达式定义的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">comment   \/\*[<span class="tag">&lt;<span class="name">sup</span>&gt;</span>*]*\*+([<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>/*][^*]*\*+)*\/</div><div class="line">num   [0-9]+|[0-9]*"."[0-9]+</div><div class="line">nonascii  [\200-\377]</div><div class="line">nmstart   [_a-z]|&#123;nonascii&#125;|&#123;escape&#125;</div><div class="line">nmchar    [_a-z0-9-]|&#123;nonascii&#125;|&#123;escape&#125;</div><div class="line">name    &#123;nmchar&#125;+</div><div class="line">ident   &#123;nmstart&#125;&#123;nmchar&#125;*</div></pre></td></tr></table></figure><p>“ident”是标识符 (identifier) 的缩写，比如类名。“name”是元素的 ID（通过“#”来引用）。</p><p>语法是采用 BNF 格式描述的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ruleset</span></div><div class="line">  : <span class="selector-tag">selector</span> <span class="selector-attr">[ ',' S* selector ]</span>*</div><div class="line">    '&#123;' S* declaration [ ';' S* declaration ]* '&#125;' S*</div><div class="line">  ;</div><div class="line"><span class="selector-tag">selector</span></div><div class="line">  : <span class="selector-tag">simple_selector</span> <span class="selector-attr">[ combinator selector | S+ [ combinator? selector ]</span>? ]?</div><div class="line">  ;</div><div class="line"><span class="selector-tag">simple_selector</span></div><div class="line">  : <span class="selector-tag">element_name</span> <span class="selector-attr">[ HASH | class | attrib | pseudo ]</span>*</div><div class="line">  | [ HASH | class | attrib | pseudo ]+</div><div class="line">  ;</div><div class="line"><span class="selector-tag">class</span></div><div class="line">  : '.' IDENT</div><div class="line">  ;</div><div class="line"><span class="selector-tag">element_name</span></div><div class="line">  : IDENT | '*'</div><div class="line">  ;</div><div class="line"><span class="selector-tag">attrib</span></div><div class="line">  : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*</div><div class="line">    [ IDENT | STRING ] S* ] ']'</div><div class="line">  ;</div><div class="line"><span class="selector-tag">pseudo</span></div><div class="line">  : ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ]</div><div class="line">  ;</div></pre></td></tr></table></figure><p>解释：这是一个规则集的结构：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-class">.error</span> , <span class="selector-tag">a</span><span class="selector-class">.error</span> &#123;</div><div class="line">  <span class="attribute">color</span>:red;</div><div class="line">  <span class="attribute">font-weight</span>:bold;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>div.error 和 a.error 是选择器。大括号内的部分包含了由此规则集应用的规则。此结构的正式定义是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ruleset</span></div><div class="line">  : <span class="selector-tag">selector</span> <span class="selector-attr">[ ',' S* selector ]</span>*</div><div class="line">    '&#123;' S* declaration [ ';' S* declaration ]* '&#125;' S*</div><div class="line">  ;</div></pre></td></tr></table></figure><p>这表示一个规则集就是一个选择器，或者由逗号和空格（S 表示空格）分隔的多个（数量可选）选择器。规则集包含了大括号，以及其中的一个或多个（数量可选）由分号分隔的声明。“声明”和“选择器”将由下面的 BNF 格式定义。</p><h4><span id="webkit-css-解析器">Webkit CSS 解析器</span></h4><p>Webkit 使用 <a href="">Flex 和 Bison</a> 解析器生成器，通过 CSS 语法文件自动创建解析器。正如我们之前在解析器简介中所说，Bison 会创建自下而上的移位归约解析器。Firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。</p><p><img src="http://bubkoo.qiniudn.com/parsing%20CSS.png" alt="图 12 解析 CSS"></p><h3><span id="处理脚本和样式表的顺序">处理脚本和样式表的顺序</span></h3><h4><span id="脚本">脚本</span></h4><p>网络的模型是同步的。网页作者希望解析器遇到 <code>&lt;script&gt;</code> 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。</p><h4><span id="预解析">预解析</span></h4><p>Webkit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p><h4><span id="样式表">样式表</span></h4><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 Webkit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p><h3><span id="呈现树构建">呈现树构建</span></h3><p>在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。</p><p>Firefox 将呈现树中的元素称为“框架”。Webkit 使用的术语是呈现器或呈现对象。</p><p>呈现器知道如何布局并将自身及其子元素绘制出来。 </p><p>Webkits RenderObject 类是所有呈现器的基类，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span>&#123;</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(PaintInfo)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> rect <span class="title">repaintRect</span><span class="params">()</span></span>;</div><div class="line">  Node* node;  <span class="comment">//the DOM node</span></div><div class="line">  RenderStyle* style;  <span class="comment">// the computed style</span></div><div class="line">  RenderLayer* containgLayer; <span class="comment">//the containing z-index layer</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>每一个呈现器都代表了一个矩形的区域，通常对应于相关节点的 CSS 框，这一点在 CSS2 规范中有所描述。它包含诸如宽度、高度和位置等几何信息。</p><p>框的类型会受到与节点相关的“display”样式属性的影响（请参阅<a href="">样式计算</a>章节）。下面这段 Webkit 代码描述了根据 display 属性的不同，针对同一个 DOM 节点应创建什么类型的呈现器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)</div><div class="line">&#123;</div><div class="line">    Document* doc = node-&gt;document();</div><div class="line">    RenderArena* arena = doc-&gt;renderArena();</div><div class="line">    ...</div><div class="line">    RenderObject* o = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (style-&gt;display()) &#123;</div><div class="line">        <span class="keyword">case</span> NONE:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> INLINE:</div><div class="line">            o = <span class="keyword">new</span> (arena) RenderInline(node);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BLOCK:</div><div class="line">            o = <span class="keyword">new</span> (arena) RenderBlock(node);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> INLINE_BLOCK:</div><div class="line">            o = <span class="keyword">new</span> (arena) RenderBlock(node);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> LIST_ITEM:</div><div class="line">            o = <span class="keyword">new</span> (arena) RenderListItem(node);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>元素类型也是考虑因素之一，例如表单控件和表格都对应特殊的框架。 </p><p>在 Webkit 中，如果一个元素需要创建特殊的呈现器，就会替换 createRenderer 方法。呈现器所指向的样式对象中包含了一些和几何无关的信息。</p><h4><span id="呈现树和-dom-树的关系">呈现树和 DOM 树的关系</span></h4><p>呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。</p><p>有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。</p><p>另一个关于多呈现器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。</p><p>有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。</p><p><img src="http://bubkoo.qiniudn.com/The%20render%20tree%20and%20the%20corresponding%20DOM%20tree.png" alt="图 13 呈现树及其对应的 DOM 树。初始容器 block 为“viewport”，而在 Webkit 中则为“RenderView”对象。"></p><h4><span id="构建呈现树的流程">构建呈现树的流程</span></h4><p>在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 FrameConstructor，由该构造器解析样式（请参阅<a href="">样式计算</a>）并创建框架。</p><p>在 Webkit 中，解析样式和创建呈现器的过程称为“附加”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点“attach”方法。</p><p>处理 html 和 body 标记就会构建呈现树根节点。这个根节点呈现对象对应于 CSS 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。Firefox 称之为 ViewPortFrame，而 Webkit 称之为 RenderView。这就是文档所指向的呈现对象。呈现树的其余部分以 DOM 树节点插入的形式来构建。</p><p>请参阅<a href="http://www.w3.org/TR/CSS21/intro.html#processing-model" target="_blank" rel="external">关于处理模型的 CSS2 规范</a>。</p><h4><span id="样式计算">样式计算</span></h4><p>构建呈现树时，需要计算每一个呈现对象的可视化属性。这是通过计算每个元素的样式属性来完成的。</p><p>样式包括来自各种来源的样式表、inline 样式元素和 HTML 中的可视化属性（例如“bgcolor”属性）。其中后者将经过转化以匹配 CSS 样式属性。</p><p>样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在“Firefox Profile”文件夹下）。</p><p>样式计算存在以下难点：</p><ol><li>样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。</li><li><p>如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。</p><p>例如下面这个组合选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> <span class="selector-tag">div</span> <span class="selector-tag">div</span> <span class="selector-tag">div</span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这意味着规则适用于作为 3 个 div 元素的子代的 <code>&lt;div&gt;</code>。如果您要检查规则是否适用于某个指定的 <code>&lt;div&gt;</code> 元素，应选择树上的一条向上路径进行检查。您可能需要向上遍历节点树，结果发现只有两个 div，而且规则并不适用。然后，您必须尝试树中的其他路径。</p></li><li><p>应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）。</p></li></ol><p>让我们来看看浏览器是如何处理这些问题的：</p><h5><span id="共享样式数据">共享样式数据</span></h5><p>Webkit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：</p><ol><li>这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）</li><li>任何元素都没有 ID</li><li>标记名称应匹配</li><li>类属性应匹配</li><li>映射属性的集合必须是完全相同的</li><li>链接状态必须匹配</li><li>焦点状态必须匹配</li><li>任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配</li><li>元素中不能有任何 inline 样式属性</li><li>不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。</li></ol><h5><span id="firefox-规则树">Firefox 规则树</span></h5><p>为了简化样式计算，Firefox 还采用了另外两种树：规则树和样式上下文树。Webkit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。</p><p><img src="http://bubkoo.qiniudn.com/Firefox%20style%20context%20tree.png" alt="图 14 Firefox 样式上下文树"></p><p>样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。例如，如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。</p><p>所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。</p><p>这个想法相当于将规则树路径视为词典中的单词。如果我们已经计算出如下的规则树：</p><p><img src="http://bubkoo.qiniudn.com/letter-tree.png" alt=""></p><p>假设我们需要为内容树中的另一个元素匹配规则，并且找到匹配路径是 B - E - I（按照此顺序）。由于我们在树中已经计算出了路径 A - B - E - I - L，因此就已经有了此路径，这就减少了现在所需的工作量。</p><p>让我们看看规则树如何帮助我们减少工作。</p><h5><span id="结构划分">结构划分</span></h5><p>样式上下文可分割成多个结构。这些结构体包含了特定类别（如 border 或 color）的样式信息。结构中的属性都是继承的或非继承的。继承属性如果未由元素定义，则继承自其父代。非继承属性（也称为“重置”属性）如果未进行定义，则使用默认值。</p><p>规则树通过缓存整个结构（包含计算出的端值）为我们提供帮助。这一想法假定底层节点没有提供结构的定义，则可使用上层节点中的缓存结构。</p><h5><span id="使用规则树计算样式上下文">使用规则树计算样式上下文</span></h5><p>在计算某个特定元素的样式上下文时，我们首先计算规则树中的对应路径，或者使用现有的路径。然后我们沿此路径应用规则，在新的样式上下文中填充结构。我们从路径中拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。如果该规则节点对于此结构没有任何规范，那么我们可以实现更好的优化：寻找路径更上层的节点，找到后指定完整的规范并指向相关节点即可。这是最好的优化方法，因为整个结构都能共享。这可以减少端值的计算量并节约内存。 </p><p>如果我们找到了部分定义，就会向上遍历规则树，直到结构填充完毕。</p><p>如果我们找不到结构的任何定义，那么假如该结构是“继承”类型，我们会在<strong>上下文树</strong>中指向父代的结构，这样也可以共享结构。如果是 <strong>reset</strong> 类型的结构，则会使用默认值。</p><p>如果最特殊的节点确实添加了值，那么我们需要另外进行一些计算，以便将这些值转化成实际值。然后我们将结果缓存在树节点中，供子代使用。</p><p>如果某个元素与其同级元素都指向同一个树节点，那么它们就可以共享<strong>整个样式上下文</strong>。</p><p>让我们来看一个例子，假设我们有如下 HTML 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"err"</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">        this is a <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span> big error <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        this is also a</div><div class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span> very  big  error<span class="tag">&lt;/<span class="name">span</span>&gt;</span> error</div><div class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"err"</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>another error<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>还有如下规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. <span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>;<span class="attribute">color</span>:black&#125;</div><div class="line">2. <span class="selector-class">.err</span> &#123;<span class="attribute">color</span>:red&#125;</div><div class="line">3. <span class="selector-class">.big</span> &#123;<span class="attribute">margin-top</span>:<span class="number">3px</span>&#125;</div><div class="line">4. <span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;<span class="attribute">margin-bottom</span>:<span class="number">4px</span>&#125;</div><div class="line">5. <span class="selector-id">#div1</span> &#123;<span class="attribute">color</span>:blue&#125;</div><div class="line">6. <span class="selector-id">#div2</span> &#123;<span class="attribute">color</span>:green&#125;</div></pre></td></tr></table></figure><p>为了简便起见，我们只需要填充两个结构：color 结构和 margin 结构。color 结构只包含一个成员（即“color”），而 margin 结构包含四条边。</p><p>形成的规则树如下图所示（节点的标记方式为“节点名 : 指向的规则序号”）：</p><p><img src="http://bubkoo.qiniudn.com/the%20rule%20tree.png" alt="图 15 规则树"></p><p>上下文树如下图所示（节点名 : 指向的规则节点）：</p><p><img src="http://bubkoo.qiniudn.com/the%20context%20tree.png" alt="图 16 上下文树"></p><p>假设我们解析 HTML 时遇到了第二个 <code>&lt;div&gt;</code> 标记，我们需要为此节点创建样式上下文，并填充其样式结构。 </p><p>经过规则匹配，我们发现该 <code>&lt;div&gt;</code> 的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 F 节点）。 <em>**</em></p><p>我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 F 节点。</p><p>现在我们需要填充样式结构。首先要填充的是 margin 结构。由于最后的规则节点 (F) 并没有添加到 margin 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 margin 规则的最上层节点（即 B 节点）上找到该结构。</p><p>我们已经有了 color 结构的定义，因此不能使用缓存的结构。由于 color 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 RGB 等）并在此节点上缓存经过计算的结构。</p><p>第二个 <code>&lt;span&gt;</code> 元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 span 一样指向规则 G。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 span 的上下文即可。</p><p>对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 color 属性是继承的，但是 Firefox 将其视为 reset 属性，并缓存到规则树上）。 </p><p>例如，如果我们在某个段落中添加 font 规则：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p &#123;font-family:Verdana;font size:10px;font-weight:bold&#125;</div></pre></td></tr></table></figure><p>那么，该段落元素作为上下文树中的 div 的子代，就会共享与其父代相同的 font 结构（前提是该段落没有指定 font 规则）。</p><p>在 Webkit 中没有规则树，因此会对匹配的声明遍历 4 次。首先应用非重要高优先级的属性（由于作为其他属性的依据而应首先应用的属性，例如 display），接着是高优先级重要规则，然后是普通优先级非重要规则，最后是普通优先级重要规则。这意味着多次出现的属性会根据正确的层叠顺序进行解析。最后出现的最终生效。 </p><p>因此概括来说，共享样式对象（整个对象或者对象中的部分结构）可以解决问题 <a href="">1</a> 和问题 <a href="">3</a>。Firefox 规则树还有助于按照正确的顺序应用属性。</p><h5><span id="对规则进行处理以简化匹配">对规则进行处理以简化匹配</span></h5><p>样式规则有一些来源：</p><ul><li><p>外部样式表或样式元素中的 CSS 规则</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue&#125;</div></pre></td></tr></table></figure></li><li><p>inline 样式属性及类似内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:blue"</span> /&gt;</span></div></pre></td></tr></table></figure></li><li><p>HTML 可视化属性（映射到相关的样式规则）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">bgcolor</span>=<span class="string">"blue"</span> /&gt;</span></div></pre></td></tr></table></figure></li></ul><p>后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。</p><p>我们之前在<a href="">第 2 个问题</a>中提到过，CSS 规则匹配可能比较棘手。为了解决这一难题，可以对 CSS 规则进行一些处理，以便访问。</p><p>样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 ID，规则就会添加到 ID 表中；如果选择器是类，规则就会添加到类表中，依此类推。 </p><p>这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则了 (<a href="">4.1</a>)。</p><p>我们以如下的样式规则为例：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-class">.error</span> &#123;<span class="attribute">color</span>:red&#125;</div><div class="line"><span class="selector-id">#messageDiv</span> &#123;<span class="attribute">height</span>:<span class="number">50px</span>&#125;</div><div class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>&#125;</div></pre></td></tr></table></figure><p>第一条规则将插入类表，第二条将插入 ID 表，而第三条将插入标记表。</p><p>对于下面的 HTML 代码段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>an error occurred <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">" messageDiv"</span>&gt;</span>this is a message<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>我们首先会为 p 元素寻找匹配的规则。类表中有一个“error”键，在下面可以找到“p.error”的规则。div 元素在 ID 表（键为 ID）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。</p><p>例如，如果 div 的对应规则如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">table</span> <span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>&#125;</div></pre></td></tr></table></figure><p>这条规则仍然会从标记表中提取出来，因为键是最右边的选择器，但这条规则并不匹配我们的 div 元素，因为 div 没有 table 祖先。</p><p>Webkit 和 Firefox 都进行了这一处理。</p><h5><span id="以正确的层叠顺序应用规则">以正确的层叠顺序应用规则</span></h5><p>样式对象具有每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。</p><p>如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。</p><h5><span id="样式表层叠顺序">样式表层叠顺序</span></h5><p>某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为“层叠”顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：</p><ol><li>浏览器声明</li><li>用户普通声明</li><li>作者普通声明</li><li>作者重要声明</li><li>用户重要声明</li></ol><p>浏览器声明是重要程度最低的，而用户只有将该声明标记为“重要”才可以替换网页作者的声明。同样顺序的声明会根据<a href="">特异性</a>进行排序，然后再是其指定顺序。HTML 可视化属性会转换成匹配的 CSS 声明。它们被视为低优先级的网页作者规则。</p><h5><span id="特异性">特异性</span></h5><p>选择器的特异性由 <a href="http://www.w3.org/TR/CSS2/cascade.html#specificity" target="_blank" rel="external">CSS2 规范</a>定义如下：</p><ul><li>如果声明来自于“style”属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)</li><li>记为选择器中 ID 属性的个数 (= b)</li><li>记为选择器中其他属性和伪类的个数 (= c)</li><li>记为选择器中元素名称和伪元素的个数 (= d)</li></ul><p>将四个数字按 a-b-c-d 这样连接起来（位于大数进制的数字系统中），构成特异性。</p><p>您使用的进制取决于上述类别中的最高计数。 </p><p>例如，如果 a=14，您可以使用十六进制。如果 a=17，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：html body div div p …（在选择器中出现了 17 个标记，这样的可能性极低）。</p><p>一些示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">*             &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span></div><div class="line"><span class="selector-tag">li</span>            &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span></div><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-line</span> &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span>         &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ol</span>+<span class="selector-tag">li</span>      &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span></div><div class="line"><span class="selector-tag">h1</span> + *<span class="selector-attr">[rel=up]</span>&#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span></div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span><span class="selector-class">.red</span>  &#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span></div><div class="line"><span class="selector-tag">li</span><span class="selector-class">.red</span><span class="selector-class">.level</span>  &#123;&#125;  <span class="comment">/* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span></div><div class="line"><span class="selector-id">#x34y</span>         &#123;&#125;  <span class="comment">/* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span></div><div class="line">style=""          /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</div></pre></td></tr></table></figure><h5><span id="规则排序">规则排序</span></h5><p>找到匹配的规则之后，应根据级联顺序将其排序。Webkit 对于较小的列表会使用冒泡排序，而对较大的列表则使用归并排序。对于以下规则，Webkit 通过替换“&gt;”运算符来实现排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> spec1 = r1.selector()-&gt;specificity();</div><div class="line">    <span class="keyword">int</span> spec2 = r2.selector()-&gt;specificity();</div><div class="line">    <span class="keyword">return</span> (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4><span id="渐进式处理">渐进式处理</span></h4><p>Webkit 使用一个标记来表示是否所有的顶级样式表（包括 @imports）均已加载完毕。如果在附加过程中尚未完全加载样式，则使用占位符，并在文档中进行标注，等样式表加载完毕后再重新计算。</p><h3><span id="布局">布局</span></h3><p>呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。</p><p>HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历 (<a href="">3.5</a>)。</p><p>坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。</p><p>布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 <html> 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。</html></p><p>根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。</p><p>所有的呈现器都有一个“laybout”或者“reflow”方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。</p><h4><span id="dirty-位系统">Dirty 位系统</span></h4><p>为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。</p><p>有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管呈现器自身没有变化，但它至少有一个子代需要布局。</p><h4><span id="全局布局和增量布局">全局布局和增量布局</span></h4><p>全局布局是指触发了整个呈现树范围的布局，触发原因可能包括：</p><ol><li>影响所有呈现器的全局样式更改，例如字体大小更改。</li><li>屏幕大小调整。</li></ol><p>布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。 </p><p>当呈现器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的呈现器附加到了呈现树中。</p><p><img src="http://bubkoo.qiniudn.com/Incremental%20layout%E2%80%93only%20dirty%20renderers%20and%20their%20children%20are%20laid%20out.png" alt="图 17 增量布局 - 只有 dirty 呈现器及其子代进行布局"></p><h4><span id="异步布局和同步布局">异步布局和同步布局</span></h4><p>增量布局是异步执行的。Firefox 将增量布局的“reflow 命令”加入队列，而调度程序会触发这些命令的批量执行。Webkit 也有用于执行增量布局的计时器：对呈现树进行遍历，并对 dirty 呈现器进行布局。 </p><p>请求样式信息（例如“offsetHeight”）的脚本可同步触发增量布局。 </p><p>全局布局往往是同步触发的。 </p><p>有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。</p><h4><span id="优化">优化</span></h4><p>如果布局是由“大小调整”或呈现器的位置（而非大小）改变而触发的，那么可以从缓存中获取呈现器的大小，而无需重新计算。 </p><p>在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。</p><h4><span id="布局处理">布局处理</span></h4><p>布局通常具有以下模式：</p><ol><li>父呈现器确定自己的宽度。</li><li>父呈现器依次处理子呈现器，并且：<br>2.1. 放置子呈现器（设置 x,y 坐标）。<br>2.2. 如果有必要，调用子呈现器的布局（如果子呈现器是 dirty 的，或者这是全局布局，或出于其他某些原因），这会计算子呈现器的高度。</li><li>父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用。</li><li>将其 dirty 位设置为 false。</li></ol><p>Firefox 使用“state”对象 (nsHTMLReflowState) 作为布局的参数（称为“reflow”），这其中包括了父呈现器的宽度。</p><p>Firefox 布局的输出为“metrics”对象 (nsHTMLReflowMetrics)，其包含计算得出的呈现器高度。</p><h4><span id="宽度计算">宽度计算</span></h4><p>呈现器宽度是根据容器块的宽度、呈现器样式中的“width”属性以及边距和边框计算得出的。 </p><p>例如以下 div 的宽度：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:30%"</span>/&gt;</span></div></pre></td></tr></table></figure><p>将由 Webkit 计算如下（BenderBox 类，calcWidth 方法）：</p><ul><li><p>容器的宽度取容器的 availableWidth 和 0 中的较大值。availableWidth 在本例中相当于 contentWidth，计算公式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clientWidth() - paddingLeft() - paddingRight()</div></pre></td></tr></table></figure><p>clientWidth 和 clientHeight 表示一个对象的内部（除去边框和滚动条）。</p></li><li>元素的宽度是“width”样式属性。它会根据容器宽度的百分比计算得出一个绝对值。</li><li>然后加上水平方向的边框和补白。</li></ul><p>现在计算得出的是“preferred width”。然后需要计算最小宽度和最大宽度。</p><p>如果首选宽度大于最大宽度，那么应使用最大宽度。如果首选宽度小于最小宽度（最小的不可破开单位），那么应使用最小宽度。</p><p>这些值会缓存起来，以用于需要布局而宽度不变的情况。</p><h4><span id="换行">换行</span></h4><p>如果呈现器在布局过程中需要换行，会立即停止布局，并告知其父代需要换行。父代会创建额外的呈现器，并对其调用布局。</p><h3><span id="绘制">绘制</span></h3><p>在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。</p><h4><span id="全局绘制和增量绘制">全局绘制和增量绘制</span></h4><p>和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。</p><h4><span id="绘制顺序">绘制顺序</span></h4><p><a href="http://www.w3.org/TR/CSS21/zindex.html" target="_blank" rel="external">CSS2 规范定义了绘制流程的顺序</a>。绘制的顺序其实就是元素进入<a href="">堆栈样式上下文</a>的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：</p><ol><li>背景颜色</li><li>背景图片</li><li>边框</li><li>子代</li><li>轮廓</li></ol><h4><span id="firefox-显示列表">Firefox 显示列表</span></h4><p>Firefox 遍历整个呈现树，为绘制的矩形建立一个显示列表。列表中按照正确的绘制顺序（先是呈现器的背景，然后是边框等等）包含了与矩形相关的呈现器。这样等到重新绘制的时候，只需遍历一次呈现树，而不用多次遍历（绘制所有背景，然后绘制所有图片，再绘制所有边框等等）。</p><p>Firefox 对此过程进行了优化，也就是不添加隐藏的元素，例如被不透明元素完全遮挡住的元素。</p><h4><span id="webkit-矩形存储">Webkit 矩形存储</span></h4><p>在重新绘制之前，Webkit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。 </p><h3><span id="动态变化">动态变化</span></h3><p>在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。</p><h3><span id="呈现引擎的线程">呈现引擎的线程</span></h3><p>呈现引擎采用了单线程。几乎所有操作（除了网络操作）都是在单线程中进行的。在 Firefox 和 Safari 中，该线程就是浏览器的主线程。而在 Chrome 浏览器中，该线程是标签进程的主线程。 </p><p>网络操作可由多个并行线程执行。并行连接数是有限的（通常为 2 至 6 个，以 Firefox 3 为例是 6 个）。</p><h3><span id="事件循环">事件循环</span></h3><p>浏览器的主线程是事件循环。它是一个无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。这是 Firefox 中关于主事件循环的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (!mExiting)</div><div class="line">    NS_ProcessNextEvent(thread);</div></pre></td></tr></table></figure><h2><span id="css2-可视化模型">CSS2 可视化模型</span></h2><h3><span id="画布">画布</span></h3><p>根据 <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model" target="_blank" rel="external">CSS2 规范</a>，“画布”这一术语是指“用来呈现格式化结构的空间”，也就是供浏览器绘制内容的区域。画布的空间尺寸大小是无限的，但是浏览器会根据视口的尺寸选择一个初始宽度。</p><p>根据 <a href="http://www.w3.org/TR/CSS2/zindex.html" target="_blank" rel="external">www.w3.org/TR/CSS2/zindex.html</a>，画布如果包含在其他画布内，就是透明的；否则会由浏览器指定一种颜色。</p><h3><span id="css-框模型">CSS 框模型</span></h3><p><a href="http://www.w3.org/TR/CSS2/box.html" target="_blank" rel="external">CSS 框模型</a>描述的是针对文档树中的元素而生成，并根据可视化格式模型进行布局的矩形框。 </p><p>每个框都有一个内容区域（例如文本、图片等），还有可选的周围补白、边框和边距区域。</p><p><img src="http://bubkoo.qiniudn.com/CSS2%20box%20model.jpg" alt="图 18 CSS2 框模型"></p><p>每一个节点都会生成 0..n 个这样的框。 </p><p>所有元素都有一个“display”属性，决定了它们所对应生成的框类型。示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">block  - generates a block box.</div><div class="line"><span class="keyword">inline</span> - generates one <span class="keyword">or</span> more <span class="keyword">inline</span> boxes.</div><div class="line">none - no box is generated.</div></pre></td></tr></table></figure><p>默认值是 inline，但是浏览器样式表设置了其他默认值。例如，“div”元素的 display 属性默认值是 block。</p><p>您可以在这里找到默认样式表示例：<a href="http://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="external">www.w3.org/TR/CSS2/sample.html</a></p><h3><span id="定位方案">定位方案</span></h3><p>有三种定位方案：</p><ol><li>普通：根据对象在文档中的位置进行定位，也就是说对象在呈现树中的位置和它在 DOM 树中的位置相似，并根据其框类型和尺寸进行布局。</li><li>浮动：对象先按照普通流进行布局，然后尽可能地向左或向右移动。</li><li>绝对：对象在呈现树中的位置和它在 DOM 树中的位置不同。</li></ol><p>定位方案是由“position”属性和“loat”属性设置的。</p><ul><li>如果值是 static 和 relative，就是普通流</li><li>如果值是 absolute 和 fixed，就是绝对定位</li></ul><p>static 定位无需定义位置，而是使用默认定位。对于其他方案，网页作者需要指定位置：top、bottom、left、right。</p><p>框的布局方式是由以下因素决定的：</p><ul><li>框类型</li><li>框尺寸</li><li>定位方案</li><li>外部信息，例如图片大小和屏幕大小</li></ul><h3><span id="框类型">框类型</span></h3><p>block 框：形成一个 block，在浏览器窗口中拥有其自己的矩形区域。</p><p><img src="http://bubkoo.qiniudn.com/Block%20box.png" alt="图 19 block 框"></p><p>inline 框：没有自己的 block，但是位于容器 block 内。</p><p><img src="http://bubkoo.qiniudn.com/Inline%20boxes.png" alt="图 20 inline 框"></p><p>block 采用的是一个接一个的垂直格式，而 inline 采用的是水平格式。</p><p><img src="http://bubkoo.qiniudn.com/Block%20and%20Inline%20formatting.png" alt="图 21 block 和 inline 格式"></p><p>inline 框放置在行中或“行框”中。这些行至少和最高的框一样高，还可以更高，当框根据“底线”对齐时，这意味着元素的底部需要根据其他框中非底部的位置对齐。如果容器的宽度不够，inline 元素就会分为多行放置。在段落中经常发生这种情况。</p><p><img src="http://bubkoo.qiniudn.com/Lines.png" alt="图 22 行"></p><h3><span id="定位">定位</span></h3><h4><span id="相对">相对</span></h4><p>相对定位：先按照普通方式定位，然后根据所需偏移量进行移动。</p><p><img src="http://bubkoo.qiniudn.com/Relative%20positioning.png" alt="图 23 相对定位"></p><h4><span id="浮动">浮动</span></h4><p>浮动框会移动到行的左边或右边。有趣的特征在于，其他框会浮动在它的周围。下面这段 HTML 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"float:right"</span> <span class="attr">src</span>=<span class="string">"images/image.gif"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></div><div class="line">  Lorem ipsum dolor sit amet, consectetuer...</div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure><p>显示效果如下：</p><p><img src="http://bubkoo.qiniudn.com/Float.png" alt="图 24 浮动"></p><h4><span id="绝对定位和固定定位">绝对定位和固定定位</span></h4><p>这种布局是准确定义的，与普通流无关。元素不参与普通流。尺寸是相对于容器而言的。在固定定位中，容器就是可视区域。</p><p><img src="http://bubkoo.qiniudn.com/Fixed%20positioning.png" alt="图 25 固定定位"></p><p>请注意，即使在文档滚动时，固定框也不会移动。</p><h3><span id="分层展示">分层展示</span></h3><p>这是由 z-index CSS 属性指定的。它代表了框的第三个维度，也就是沿“z 轴”方向的位置。</p><p>这些框分散到多个堆栈（称为堆栈上下文）中。在每一个堆栈中，会首先绘制后面的元素，然后在顶部绘制前面的元素，以便更靠近用户。如果出现重叠，新绘制的元素就会覆盖之前的元素。 </p><p>堆栈是按照 z-index 属性进行排序的。具有“z-index”属性的框形成了本地堆栈。视口具有外部堆栈。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">      div &#123;</span></div><div class="line"><span class="undefined">        position: absolute;</span></div><div class="line"><span class="undefined">        left: 2in;</span></div><div class="line"><span class="undefined">        top: 2in;</span></div><div class="line"><span class="undefined">      &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span></span></div><div class="line"><span class="tag">         <span class="attr">style</span>=<span class="string">"z-index: 3;background-color:red; width: 1in; height: 1in; "</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span></span></div><div class="line"><span class="tag">         <span class="attr">style</span>=<span class="string">"z-index: 1;background-color:green;width: 2in; height: 2in;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure><p>结果如下：</p><p><img src="http://bubkoo.qiniudn.com/Layered%20representation.png" alt="图 26 分层显示"></p><p>虽然红色 div 在标记中的位置比绿色 div 靠前（按理应该在常规流程中优先绘制），但是 z-index 属性的优先级更高，因此它移动到了根框所保持的堆栈中更靠前的位置。</p><p><a name="resources"></a></p><h2><span id="参考资料">参考资料</span></h2><p>浏览器架构<br>  <a name="1_1"></a></p><ol><li>Grosskurth, Alan. <a href="http://grosskurth.ca/papers/browser-refarch.pdf" target="_blank" rel="external">A Reference Architecture for Web Browsers (pdf)</a></li><li>Gupta, Vineet. <a href="http://www.vineetgupta.com/2010/11/how-browsers-work-part-1-architecture/" target="_blank" rel="external">How Browsers Work - Part 1 - Architecture</a></li></ol><p>解析</p><ol><li>Aho, Sethi, Ullman, Compilers: Principles, Techniques, and Tools（即“Dragon book”）, Addison-Wesley, 1986</li><li>Rick Jelliffe. <a href="http://broadcast.oreilly.com/2009/05/the-bold-and-the-beautiful-two.html" target="_blank" rel="external">The Bold and the Beautiful: two new drafts for HTML 5.</a></li></ol><p>Firefox</p><ol><li>L. David Baron, <a href="http://dbaron.org/talks/2008-11-12-faster-html-and-css/slide-6.xhtml" target="_blank" rel="external">Faster HTML and CSS: Layout Engine Internals for Web Developers.</a></li><li>L. David Baron, <a href="http://www.youtube.com/watch?v=a2_6bGNZ7bA" target="_blank" rel="external">Faster HTML and CSS: Layout Engine Internals for Web Developers（Google 技术访谈视频）</a></li><li>L. David Baron, <a href="http://www.mozilla.org/newlayout/doc/layout-2006-07-12/slide-6.xhtml" target="_blank" rel="external">Mozilla’s Layout Engine</a></li><li>L. David Baron, <a href="http://www.mozilla.org/newlayout/doc/style-system.html" target="_blank" rel="external">Mozilla Style System Documentation</a></li><li>Chris Waterson, <a href="http://www.mozilla.org/newlayout/doc/reflow.html" target="_blank" rel="external">Notes on HTML Reflow</a></li><li>Chris Waterson, <a href="http://www.mozilla.org/newlayout/doc/gecko-overview.htm" target="_blank" rel="external">Gecko Overview</a></li><li>Alexander Larsson, <a href="https://developer.mozilla.org/en/The_life_of_an_HTML_HTTP_request" target="_blank" rel="external">The life of an HTML HTTP request</a></li></ol><p>Webkit</p><ol><li>David Hyatt, <a href="http://weblogs.mozillazine.org/hyatt/archives/cat_safari.html" target="_blank" rel="external">Implementing CSS（第一部分）</a></li><li>David Hyatt, <a href="http://weblogs.mozillazine.org/hyatt/WebCore/chapter2.html" target="_blank" rel="external">An Overview of WebCore</a></li><li>David Hyatt, <a href="http://webkit.org/blog/114/" target="_blank" rel="external">WebCore Rendering</a></li><li>David Hyatt, <a href="http://webkit.org/blog/66/the-fouc-problem/" target="_blank" rel="external">The FOUC Problem</a></li></ol><p>W3C 规范</p><ol><li><a href="http://www.w3.org/TR/html4/" target="_blank" rel="external">HTML 4.01 规范</a></li><li><a href="http://dev.w3.org/html5/spec/Overview.html" target="_blank" rel="external">W3C HTML5 规范</a></li><li><a href="http://www.w3.org/TR/CSS2/" target="_blank" rel="external">层叠样式表第 2 级第 1 次修改 (CSS 2.1) 规范</a></li></ol><p>浏览器构建说明</p><ol><li>Firefox. <a href="https://developer.mozilla.org/en/Build_Documentation" target="_blank" rel="external">https://developer.mozilla.org/en/Build_Documentation</a></li><li>Webkit. <a href="http://webkit.org/building/build.html" target="_blank" rel="external">http://webkit.org/building/build.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How Browsers Work: Behind the scenes of modern web browsers&lt;/a&gt;&lt;br&gt;原文日期：2011年8月5日&lt;/p&gt;
&lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;这是一篇全面介绍基于 Webkit 和 Gecko 内核浏览器内部原理的入门文章，是以色列开发人员 &lt;a href=&quot;http://www.html5rocks.com/profiles/#taligarsiel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tali Garsiel&lt;/a&gt; 大量研究的成果。在过去的几年中，她查阅了所有公开发布的关于浏览器内部机制的数据（请参见&lt;a href=&quot;#resources&quot;&gt;参考资料&lt;/a&gt;），并花了很多时间来研读网络浏览器的源代码。她这样写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 IE 占据 90% 市场份额的年代，我们除了把浏览器当成一个“黑盒”，什么也做不了。如今，开源浏览器拥有了过半的市场份额，因此，是时候来揭开神秘的面纱，一探网络浏览器的内幕了。呃，里面只有数以百万行计的 C++ 代码 …&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.html5rocks.com/profiles/#taligarsiel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tali Garsiel&lt;/a&gt; 在&lt;a href=&quot;http://taligarsiel.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;她的网站&lt;/a&gt;上公布了自己的研究成果，但是我们觉得它值得让更多的人来了解，所以我们&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在此&lt;/a&gt;重新整理并公布。&lt;/p&gt;
&lt;p&gt;作为一名 Web 开发人员，&lt;strong&gt;学习浏览器的内部工作原理将有助于您作出更明智的决策，并理解那些最佳开发实践的个中缘由&lt;/strong&gt;。尽管这是一篇相当长的文档，但是我们建议您多花一些时间来仔细阅读，读完之后，您肯定会觉得所费不虚。&lt;/p&gt;
&lt;p class=&quot;sign&quot;&gt;&lt;a href=&quot;http://www.html5rocks.com/profiles/#paulirish&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Paul Irish&lt;/a&gt;，Chrome 浏览器开发人员事务部&lt;/p&gt;
    
    </summary>
    
    
      <category term="Browsers" scheme="http://bubkoo.com/tags/browsers/"/>
    
  </entry>
  
  <entry>
    <title>Generate and Debug with Source Map</title>
    <link href="http://bubkoo.com/2014/01/06/generate-and-debug-with-source-map/"/>
    <id>http://bubkoo.com/2014/01/06/generate-and-debug-with-source-map/</id>
    <published>2014-01-06T20:00:05.000Z</published>
    <updated>2014-01-06T20:00:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://bubkoo.com/2014/01/05/source-map/introduction-to-javascript-source-maps/">上一篇文章</a>简单介绍了 Source Map，接下来我们来看看如何利用各种工具来生成 Source Map。</p><h2><span id="什么是-source-map">什么是 Source Map？</span></h2><blockquote><p>Source Map 提供了一个与语言无关的方式，来将生产环境中的代码映射回开发环境中的原始代码。</p></blockquote><p>在现代的开发流程中，我们的开发环境和实际线上环境的代码通常都不一样。在应用上线部署前，我们通常都要对我们的代码进行编译、合并、压缩或者其他方面的优化，这使得我们非常困难来准确定位会原始代码。但是，在生成过程中，Source Map 文件储存了这些位置信息，因此，当我们查找一行中的某个位置时，Source Map 文件可以准确定位到原始文件中的位置。这使得我们线上环境中的代码变得可读，甚至可调试，为开发者提供了极大的便利。这就是 Source Map 的用武之地。</p><p>在这篇介绍性的教程中，我们利用一个非常简单的 JavaScript 和 SASS 代码，通过各种编译器运行它们，然后在 Source Map 的帮助下，在浏览器中查看我们的原始文件。文中示例代码可以在这里【<a href="https://github.com/NETTUTS/Source-Maps-101" target="_blank" rel="external">下载</a>】。<br><a id="more"></a></p><h2><span id="source-map-文件包含的信息">Source Map 文件包含的信息</span></h2><p>Source Map 文件包含了从优化后的文件到原始文件的映射信息，Source Map 文件的结构通常是JSON格式的，使用 <a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?hl=en_US&amp;pli=1&amp;pli=1" target="_blank" rel="external">V3 规范</a>。它通常包含以下属性：</p><ol><li>version：Source Map 的版本号，通常是 3 </li><li>file：优化文件的文件名</li><li>sources：原始文件的文件名</li><li>names：映射所需要的符号</li><li>mappings：映射数据</li></ol><p><img src="http://bubkoo.qiniudn.com/source-maps-file.png" alt=""></p><h2><span id="浏览器支持">浏览器支持</span></h2><p><a href="https://www.google.com/intl/en/chrome/browser/" target="_blank" rel="external">Chrome</a> 或 WebKit 内核浏览器已经支持 <a href="http://addyosmani.com/blog/the-breakpoint-episode-3-source-maps-shortcut-secrets-and-jsrun/" target="_blank" rel="external">JavaScript Source Maps</a>，Chrome 甚至支持 <a href="http://addyosmani.com/blog/the-breakpoint-episode-2-sass-source-maps-feature-inspection-and-more/" target="_blank" rel="external">SASS Source Maps</a>。<a href="https://wiki.mozilla.org/DevTools/Features/SourceMap" target="_blank" rel="external">Firefox 23</a> 以及以上的版本的开发者工具中默认开启了 Source Maps 功能。下面图片中 Firefox 默认开启了对 Source Map 的支持。</p><p><img src="http://bubkoo.qiniudn.com/source-map-in-firefox.png" alt=""></p><p>本文中以 Chrome 为调试浏览器，通过下面步骤来开启你的开发者工具对 Source Map 的支持：</p><ul><li>打开 Chrome 的开发人员工具：菜单 -&gt; 工具 -&gt; 开发者工具 或者直接按 F12</li><li>点击右下角的“设置”齿轮</li><li>选择“General”，并选择“Enable source maps”</li></ul><p><img src="http://bubkoo.qiniudn.com/source-maps-in-chromn.png" alt=""></p><h2><span id="下载并运行示例">下载并运行示例</span></h2><p>从【<a href="https://github.com/NETTUTS/Source-Maps-101" target="_blank" rel="external">这里</a>】下载示例，解压后打开“start”目录，里面的文件和目录结构非常清晰，有一些简单的 JavaScript 文件，例如 <code>scripts/script.js</code>，用 Chrome 打开<code>index.html</code>，可以在文本框中输入一些CSS颜色名称或十六进制颜色值来修改背景颜色。</p><p><img src="http://bubkoo.qiniudn.com/source-maps-demo.png" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ start 目录结构</div><div class="line">.</div><div class="line">├── index.html</div><div class="line">├── scripts</div><div class="line">│   ├── jquery.d.ts</div><div class="line">│   ├── script.coffee.coffee</div><div class="line">│   ├── script.js</div><div class="line">│   └── script.typescript.ts</div><div class="line">└── styles</div><div class="line">    ├── style.css</div><div class="line">    └── style.sass</div></pre></td></tr></table></figure><p>用你常用的编辑器，快速预览一下文件夹中的纯JavaScript、TypeScript 和 CoffeeScript 文件。我们将创建一个生产版本，以及生成相应的 Source Map。</p><p>接下来，我将用五种不同的方式来生成一个编译和压缩后的<code>script.js</code>，同时生成对应的 Source Map 文件。你可以选择测试所有的方法，或者选择一个你已经熟悉的方法。这五种方法包括：</p><ul><li><a href="https://developers.google.com/closure/compiler/" target="_blank" rel="external">Closure Compiler</a></li><li><a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a> 的插件 <a href="https://github.com/twolfson/grunt-jsmin-sourcemap" target="_blank" rel="external">JSMin</a></li><li><a href="http://lisperator.net/uglifyjs/" target="_blank" rel="external">Uglifyjs 2</a></li><li><a href="http://coffeescript.org/" target="_blank" rel="external">CoffeeScript</a> 和 <a href="https://github.com/michaelficarra/CoffeeScriptRedux" target="_blank" rel="external">Redux</a></li><li><a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a></li></ul><h2><span id="使用-closure-compiler">使用 Closure Compiler</span></h2><p><a href="https://developers.google.com/closure/compiler/" target="_blank" rel="external">Closure Compiler</a> 是Google推出优化 JavaScript 的一个工具，它通过分析代码，删除无关的部分，然后将剩余部分压缩，除那以外，它也可以<a href="http://code.google.com/p/closure-compiler/wiki/SourceMaps" target="_blank" rel="external">生成 Source Map 文件</a>。</p><p>我们可以使用 Closure compiler 按照以下步骤来生成优化后的 <code>script.js</code>：</p><ol><li><a href="http://code.google.com/p/closure-compiler/downloads/detail?name=compiler-latest.zip" target="_blank" rel="external">点击这里</a>下载最新版本的 Closure compiler</li><li>负责下载的 compiler.jar 文件到 <code>/start/scripts/</code> 目录</li><li><p>在 <code>/start/scripts/</code> 目录中，按住 Shift 点击右键，在弹出菜单中选择“在此处打开命令窗口”，输入下面的命令并执行，这样就创建了一个优化后的 <code>script.closure.js</code> 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java -jar compiler.jar</div><div class="line">　　　   --js script.js</div><div class="line">　　　   --js_output_file script.closure.js</div></pre></td></tr></table></figure></li><li><p>在编辑器中打开 index.html 文件，修改引用的 JavaScript 文件为刚刚创建的 <code>scripts/script.closure.js</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"scripts/script.jsmin-grunt.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></li></ol><p>简单说明：<code>--js</code> 表示需要优化的 JavaScript 文件，<code>--js_output_file</code> 表示输出文件名，这里是 script.closure.js 。</p><p><img src="http://bubkoo.qiniudn.com/source-maps-closure.png" alt=""></p><p>在 Chrome 中打开 index.html，然后开打开发者工具，选择 Sources 选项卡，可以看到 index.html 只引用了优化后的 <code>script.closure.js</code>，我们没有办法看到我们最初创建的有适当的缩进 JavaScript 文件。接下来我们在 <code>/start/scripts/</code> 目录中执行下面的命令来创建 Source Map 文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">java -jar compiler.jar</div><div class="line">      --js script.js </div><div class="line">      --create_source_map script.closure.js.map </div><div class="line">      --source_map_format=V3 </div><div class="line">      --js_output_file script.closure.js</div></pre></td></tr></table></figure><p>注意 Closure Compiler 中的新增的两个设置项，<code>--create_source_map</code> 代表要创建的Source Map 文件的文件名，这里是：<code>script.closure.js.map</code>，<code>--source_map_format</code> 代表 Source Map 的版本是 V3。然后在 script.closure.js 文件的末尾添加 Source Map 文件的 URL，这样优化后的 JavaScript 就包含了 Source Map 的位置信息，添加 Source Map 文件的 URL 代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//@ sourceMappingURL=script.closure.js.map</div></pre></td></tr></table></figure><p>刷新页面，在开发者工具中我们可以看到 “scripts” 目录下包含我们的原始代码文件 “script.js” 和优化后的文件 “script.closure.js” ，但浏览器实际运行的是在 index.html 中我们引用的优化后的文件，这样 Source Map 就为我们建立了一个指向源文件的连接。</p><p>同时，你也可以尝试在源文件中断点来调试代码，需要注意的是 “计算表达式” 和 “变量” 在 Source Map 中是不可用的，希望将来他们也被支持。</p><p><img src="http://bubkoo.qiniudn.com/source-maps-closure-map.png" alt=""></p><h2><span id="使用-grunt-的插件-jsmin">使用 Grunt 的插件 JSMin</span></h2><p>如果你已经在使用 <a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a> 来构建项目，那么使用 Grunt 的插件 <a href="https://github.com/twolfson/grunt-jsmin-sourcemap" target="_blank" rel="external">JSMin source maps</a> 对你来说就是信手拈来的事。这个插件不仅会优化你的代码，而且也会生成 Source Map 文件。</p><p>下面将演示如何利用 JSMin 来压缩你的 script.js 文件：</p><ol><li>打开控制台窗口，运行 <code>npm install -g grunt</code> 命令来安装 Grunt</li><li>在 <code>/start/</code> 目录下执行 <code>npm install grunt-jsmin-sourcemap</code> 命令来安装 Grunt 的插件 <a href="https://github.com/twolfson/grunt-jsmin-sourcemap" target="_blank" rel="external">grunt-jsmin-sourcemap</a></li><li><p>编辑新创建的 grunt.js 文件，为了简便我们只创建了 jsmin-sourcemap 这一个任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</div><div class="line">  grunt.loadNpmTasks(<span class="string">'grunt-jsmin-sourcemap'</span>);</div><div class="line">  grunt.initConfig(&#123;</div><div class="line">    <span class="string">'jsmin-sourcemap'</span>: &#123;</div><div class="line">      all: &#123;</div><div class="line">        src: [<span class="string">'scripts/script.js'</span>],</div><div class="line">        dest: <span class="string">'scripts/script.jsmin-grunt.js'</span>,</div><div class="line">        destMap: <span class="string">'scripts/script.jsmin-grunt.js.map'</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  grunt.registerTask(<span class="string">'default'</span>, <span class="string">'jsmin-sourcemap'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>返回控制台，运行 <code>grunt</code> 命令，这将默认运行 jsmin-sourcemap 这个任务，因为在上一步的配置中我们将 jsmin-sourcemap 设置成了默认任务</p></li><li>打开新创建的 script.grunt-jsmin.js.map 文件，可以查看到源文件是 <code>&quot;sources&quot;:[&quot;script.js&quot;]</code></li><li><p>在编辑器中打开 index.html 文件，修改引用的 JavaScript 文件为刚刚创建的 <code>script.grunt-jsmin.js</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"scripts/script.jsmin-grunt.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p>刷新，在浏览器中查看效果</p></li></ol><p>利用 Grunt 和它的插件 jsmin-sourcemap 创建了压缩后的文件：script.jsmin-grunt.js 和 Source Map 文件：script.jsmin-grunt.js.map。</p><p><img src="http://bubkoo.qiniudn.com/source-maps-gruntjsmin.png" alt=""></p><h2><span id="使用-uglifyjs">使用 UglifyJS</span></h2><p><a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="external">UglifyJS2</a> 是另一个压缩 JavaScript 的工具，和上面的两个工具一样，UglifyJS2 将创建压缩后的文件，同时在文件末尾加上 Source Map 文件的 URL，同时也创建了 Source Map 文件。在 /start/ 目录中执行下面的命令来使用 UglifyJS2:</p><ol><li><p>安装 UglifyJS2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install uglify-js</div></pre></td></tr></table></figure></li><li><p>在 /start/scripts/ 目录中执行以下命令来压缩原文件，同时创建 Source Map 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">uglifyjs --source-map script.uglify.js.map --output script.uglify.js script.js</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">3. 在编辑器中打开 index.html 文件，修改引用的 JavaScript 文件为刚刚创建的 `</span>script.uglify.js<span class="string">`</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span> html</div><div class="line">&lt;script src=<span class="string">"scripts/script.uglify.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></li></ol><p><img src="http://bubkoo.qiniudn.com/source-maps-uglify.png" alt=""></p><h2><span id="使用-coffeescript-redux">使用 CoffeeScript Redux</span></h2><p>前面的例子中我们只进行了压缩这样一步操作，但是，对于 <a href="http://coffeescript.org/" target="_blank" rel="external">CoffeeScript</a> 这样的语言，我们需要两步操作：CoffeeScript -&gt; JavaScript -&gt; 压缩后 JavaScript。这一部分，我将介绍怎么样通过 CoffeeScript Redux 来创建 <a href="http://www.thecssninja.com/javascript/multi-level-sourcemaps" target="_blank" rel="external">Multi-Level Source Maps</a>。</p><p><strong>步骤一：从 CoffeeScript 到纯 JavaScript</strong></p><ol><li><p><a href="https://npmjs.org/package/coffee-script" target="_blank" rel="external">全局安装</a> CoffeeScript:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">npm install -g coffee-script</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">2. 使用下面命令编译 CoffeeScript 文件：script.coffee.coffee，生成纯 JavaScript 代码:</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span> javascript</div><div class="line">coffee -c scripts/script.coffee.coffee</div></pre></td></tr></table></figure></li><li><p>安装 <a href="https://github.com/michaelficarra/CoffeeScriptRedux" target="_blank" rel="external">CoffeeScript Redux</a>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git clone https:<span class="comment">//github.com/michaelficarra/CoffeeScriptRedux.git coffee-redux</span></div><div class="line">cd coffee-redux</div><div class="line">npm install</div><div class="line">make -j test</div><div class="line">cd ..</div></pre></td></tr></table></figure></li><li><p>接下来，创建 Source Map 文件：script.coffee.js.map，这个文件包含从生成的纯 JavaScript 到原始的 CoffeeScript 文件的位置信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">coffee-redux/bin/coffee --source-map -i scripts/script.coffee.coffee &gt; scripts/script.coffee.js.map</div></pre></td></tr></table></figure></li><li><p>查看生成的 script.coffee.js 文件，确保文件末尾包含 Source Map 信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@ sourceMappingURL=script.coffee.js.map</span></div></pre></td></tr></table></figure></li><li><p>查看 script.coffee.js.map 文件，确保引用文件是：”file”:”script.coffee.coffee”,源文件是：”sources”:[“script.coffee.coffee”]</p></li></ol><p><strong>步骤二：从纯 JavaScript 文件到压缩的 JavaScript 文件</strong></p><ol><li><p>我们再一次使用 UglifyJS 来压缩 JavaScript 文件和生成 Source Map 文件，这一次我们需要指定一个 Source Map 文件来确保可以回到原始的 CoffeeScript 文件，在 /start/script/目录下执行下面命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd scripts/</div><div class="line">uglifyjs script.coffee.js -o script.coffee.min.js --source-map script.coffee.min.js.map --<span class="keyword">in</span>-source-map script.coffee.js.map</div></pre></td></tr></table></figure></li><li><p>打开 script.coffee.min.js.map 文件，确保里面包含正确的引用文件：”file”:”script.coffee.min.js”，和正确的源文件：”sources”:[“script.coffee.coffee”]。</p></li></ol><p><img src="http://bubkoo.qiniudn.com/source-maps-coffee.png" alt=""></p><h2><span id="使用-typescript">使用 TypeScript</span></h2><p>和 CoffeeScript 一样，TypeScript 也需要两步操作：TypeScript -&gt; JavaScript -&gt; 压缩的 JavaScript。由于使用的是 jQuery 插件，我们需要两个 TypeScript 文件：script.typescript.ts 和 jquery.d.ts。这两个文件在示例中 /complete/scripts/目录下。</p><p><strong>步骤一：从 TypeScript 文件到纯 JavaScript 文件</strong><br>  在 /start/scripts/ 文件夹下执行下面命令，这将创建一个新的 JavaScript 文件：script.typescript.js，文件末尾包含 Source Map 信息：<code>//@ sourceMappingURL=script.typescript.js.map</code>，执行这个命令的同时也创建了 Source Map 文件：script.typescript.js.map。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tsc script.typescript.ts -sourcemap</div></pre></td></tr></table></figure><p><strong>步骤二：从纯 JavaScript 文件到压缩的 JavaScript 文件</strong><br>和 CoffeeScript 的例子一样，我们使用 UglifyJS 来压缩 JavaScript 文件</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uglifyjs script.typescript.js -o script.typescript.min.js --source-map script.typescript.min.js.map --<span class="keyword">in</span>-source-map script.typescript.js.map</div></pre></td></tr></table></figure><p>最后，在编辑器中打开 index.html 文件，修改引用的 JavaScript 文件为刚刚创建的 <code>scripts/script.typescript.min.js</code></p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"scripts/scripts/script.typescript.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/source-maps-typescript.png" alt=""></p><h2><span id="在-sass-中使用-source-map">在 SASS 中使用 Source Map</span></h2><p>除了 JavaScript，Chrome 还支持 SASS 和 SCSS 的 Source Map，为了演示 SASS 的 Source Map 功能，我们需要修改一下 Chrome 的设置，然后将 SASS 编译为带条件参数的 CSS 文件：</p><ol><li><p>在修改任何设置前，在开发人员工具中监视一个元素，这将只显示 CSS 文件的引用。对于 SASS 来说意义并不是很大。</p><p><img src="http://bubkoo.qiniudn.com/source-maps-onlycss.png" alt=""></p></li><li><p>打开 <a href="chrome://flags/" target="_blank" rel="external">chrome://flags/</a>，启用开发者工具实验，重启 Chrome（最新版本的Chrome 无需设置，直接跳过）</p><p><img src="http://bubkoo.qiniudn.com/source-maps-devtoolsexp.png" alt=""></p></li><li><p>开发者工具 &gt; 设置 &gt; Experiments &gt; 选中 “Support for SASS” （最新版本的Chrome 无需设置，直接跳过）</p><p><img src="http://bubkoo.qiniudn.com/dev-tools-experiments.png" alt=""></p></li><li><p>开发者工具 &gt; 设置 &gt; General &gt; 选中 “Enable source maps” 和 “Auto-reload CSS upon Sass save”</p><p><img src="http://bubkoo.qiniudn.com/sass-support-dev-tools.png" alt=""></p></li><li><p>安装 SASS 预览版：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install sass --version 3.3.0.alpha.243</div></pre></td></tr></table></figure></li><li><p>在 /start/styles/ 目录下运行以下命令来编译 SASS 文件，同时生成一个 Source Map 文件，“–watch” 表示监视 SASS 文件的变化，然后自动生成 CSS 文件和对应的 Source Map 文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sass --watch --sourcemap sass/styles.scss:styles.css</div></pre></td></tr></table></figure></li><li><p>重启开发者工具并刷新页面</p><p><img src="http://bubkoo.qiniudn.com/source-maps-onlysass.png" alt=""></p></li></ol><p>除了可以在浏览器中查看到 SASS 文件之外，如果你正在使用 <a href="http://livereload.com/" target="_blank" rel="external">LiveReload</a>，任何对 SASS 文件的修改将立刻显示到浏览器中。</p><h2><span id="参考资源">参考资源</span></h2><p>Source Map 目前仍在迅速发展，网络上已经有一些很好的资源。如果你想了解更多信息，请参考以下链接。</p><ul><li><a href="http://net.tutsplus.com/tutorials/tools-and-tips/source-maps-101/" target="_blank" rel="external">An Introduction to Source Maps</a></li><li><a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" target="_blank" rel="external">Introduction to JavaScript Source Maps</a> by Ryan Seddon, HTML5 Rocks</li><li><a href="http://addyosmani.com/blog/the-breakpoint-episode-3-source-maps-shortcut-secrets-and-jsrun/" target="_blank" rel="external">The Breakpoint Episode 3: JavaScript Source Maps</a> by the Google Developer Team</li><li><a href="http://addyosmani.com/blog/the-breakpoint-episode-2-sass-source-maps-feature-inspection-and-more/" target="_blank" rel="external">The Breakpoint Episode 2: SASS Source Maps</a> by the Google Developer Team</li><li><a href="https://github.com/ryanseddon/source-map/wiki/Source-maps%3A-languages%2C-tools-and-other-info" target="_blank" rel="external">Source Maps wiki</a> on languages, tools, articles on Source Maps</li><li><a href="http://www.thecssninja.com/JavaScript/multi-level-sourcemaps" target="_blank" rel="external">Multi Level Source Maps</a> with CoffeeScript and TypeScript by Ryan Seddon</li><li><a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?hl=en_US&amp;pli=1&amp;pli=1" target="_blank" rel="external">Source Maps Version 3 proposal</a></li><li><a href="http://globaldev.co.uk/2013/01/happy-debugging-with-javascript-source-maps/" target="_blank" rel="external">Happy debugging with JavaScript source maps</a></li><li><a href="http://blog.mascaraengine.com/news/2012/4/16/sourcemap-support-in-chrome-greatly-improves-debugging.html" target="_blank" rel="external">Sourcemap support in Chrome greatly improves debugging</a></li><li><a href="introduction-to-javascript-source-maps">JavaScript Source Map 介绍</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="external">JavaScript Source Map 详解</a></li><li><a href="https://developers.google.com/chrome-developer-tools/docs/css-preprocessors#toc-enabling-css-source-maps" target="_blank" rel="external">Working with CSS Preprocessors</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://bubkoo.com/2014/01/05/source-map/introduction-to-javascript-source-maps/&quot;&gt;上一篇文章&lt;/a&gt;简单介绍了 Source Map，接下来我们来看看如何利用各种工具来生成 Source Map。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Source-Map？&quot;&gt;&lt;a href=&quot;#什么是-Source-Map？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Source Map？&quot;&gt;&lt;/a&gt;什么是 Source Map？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Source Map 提供了一个与语言无关的方式，来将生产环境中的代码映射回开发环境中的原始代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在现代的开发流程中，我们的开发环境和实际线上环境的代码通常都不一样。在应用上线部署前，我们通常都要对我们的代码进行编译、合并、压缩或者其他方面的优化，这使得我们非常困难来准确定位会原始代码。但是，在生成过程中，Source Map 文件储存了这些位置信息，因此，当我们查找一行中的某个位置时，Source Map 文件可以准确定位到原始文件中的位置。这使得我们线上环境中的代码变得可读，甚至可调试，为开发者提供了极大的便利。这就是 Source Map 的用武之地。&lt;/p&gt;
&lt;p&gt;在这篇介绍性的教程中，我们利用一个非常简单的 JavaScript 和 SASS 代码，通过各种编译器运行它们，然后在 Source Map 的帮助下，在浏览器中查看我们的原始文件。文中示例代码可以在这里【&lt;a href=&quot;https://github.com/NETTUTS/Source-Maps-101&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载&lt;/a&gt;】。&lt;br&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="http://bubkoo.com/tags/tools/"/>
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Source Map" scheme="http://bubkoo.com/tags/source-map/"/>
    
      <category term="SASS" scheme="http://bubkoo.com/tags/sass/"/>
    
      <category term="Debug" scheme="http://bubkoo.com/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Source Map 介绍</title>
    <link href="http://bubkoo.com/2014/01/05/introduction-to-javascript-source-maps/"/>
    <id>http://bubkoo.com/2014/01/05/introduction-to-javascript-source-maps/</id>
    <published>2014-01-05T16:56:36.000Z</published>
    <updated>2014-01-05T16:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自：<a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/?redirect_from_locale=zh" target="_blank" rel="external">Introduction to JavaScript Source Maps</a></p><p>水平有限，有表达错误和不准确的地方，可以在回复中直接指出来，英语水平高的同学可以直接看上面的原文。</p><p>下面开始正文。</p><p>你有没有希望保持你的客户端代码可读性，更重要的是可调式性，即使你合并和压缩过代码，同时又不影响性能？现在你可以通过 <a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?hl=en_US&amp;pli=1&amp;pli=1#heading=h.1ce2c87bpj24" target="_blank" rel="external">Source Maps</a> 的魔力来实现。</p><p>从根本上说，这是一种将合并/压缩后的文件映射回未构建状态的方式。当构建产品，合并和压缩你的 JavaScript 文件的同时，生成一个包含源文件信息的 Source Maps 文件。当你查询生成后的文件中某一行号和列号的位置时，你可以通过 Source Maps 来返回它所对应的原始位置。开发人员工具（WebKit 最新版，Google Chrome，Firefox 23+）可以自动解析 Source Maps，使得看起来好像你在运行未压缩和合并的文件。</p><p><a href="http://www.thecssninja.com/demo/source_mapping/" target="_blank" rel="external">Demo: Get original location</a></p><p>打开上面示例的连接，在包含生成后文件的文本区域的任何地方点击鼠标右键，选择 “Get original location”，将通过生成后的文件的行号和列号查询 Source Maps，并返回原始代码的位置。确保你的控制台是打开的，这样你就可以看到输出。</p><p><img src="http://bubkoo.qiniudn.com/source-map-demo.png" alt=""><br><a id="more"></a></p><h2><span id="真实环境">真实环境</span></h2><p>在查看下面真实环境中 Source Maps 的执行情况之前，确保你的 Chrome 或 WebKit 浏览器已经开启了 Source Maps 功能，可以通过点击开发人员工具面板中的设置此轮，并且选中 “Enable source maps” 选项，如下图：</p><p><img src="http://bubkoo.qiniudn.com/enable-source-maps.png" alt=""></p><p>Firefox 23 以及以上的版本的开发人员工具中默认开启了 Source Maps 功能，请看下面图片。</p><p><img src="http://bubkoo.qiniudn.com/enable-source-maps_ff.png" alt=""></p><p>上面例子中 Source Maps 查询演示的确非常酷，但实际用例呢？在 Chrome Canary， WebKit nightly 或 Firefox 23+ 中打开 <a href="http://dev.fontdragr.com/" target="_blank" rel="external">dev.fontdragr.com</a>，确保已经开启了 Source Maps 功能，您会注意到 JavaScript 并不是编译后的，并且可以查看到所有单独的 JavaScript 文件引用。这就利用了 Source Maps 功能，但实际上在幕后运行的是编译后的代码。任何错误、日志和断点将映射到的开发版代码，非常方便调试！实际上它会让你产生你在运行开发版的网站的错觉。</p><p><a href="http://dev.fontdragr.com/" target="_blank" rel="external">Demo: View scripts panel (with source maps) on fontdragr.com</a></p><h2><span id="为什么我要关心-source-maps">为什么我要关心 Source Maps</span></h2><p>目前，Source Maps 只支持将合并/压缩后的 JavaScript 文件映射回未合并/压缩的文件，但对于 CoffeeScript 这种编译为 JavaScript 的语言，甚至像 SASS 和 LESS 这种 CSS 预编译语言来说，前景是光明的。</p><p>在未来我们可以很容易地使用几乎任何语言的 Source Maps 功能，仿佛它是浏览器原生支持的一样：</p><ul><li>CoffeeScript</li><li>ECMAScript 6 以及以上</li><li>SASS/LESS 和其他</li><li>几乎可以编译成 JavaScript 的任何语言</li></ul><p>下面视频（来自YouTube，自行翻墙）演示了如何在 Firefox 控制台中调试 CoffeeScript 代码。</p><iframe width="609" height="339" src="http://www.youtube.com/embed/2aQw1dSIYko?start=625" frameborder="0" allowfullscreen></iframe><p>Google Web Toolkit (GWT) 最近增加了 Source Maps 支持，GWT 团队中的 Ray Cromwell 录制了一个视频（来自YouTube，自行翻墙）来展示在 GWT 中使用 Source Maps 功能。</p><iframe width="640" height="360" src="//www.youtube.com/embed/-xJl22Kvgjg?feature=player_embedded" frameborder="0" allowfullscreen></iframe><p>另一个例子我结合谷歌 Traceur 库，该库允许你编写 ES6(ECMAScript 6 或下)然后将其编译成 ES3 的兼容代码。Traceur 库也生成了一个 Source Map。请看这个<a href="http://www.thecssninja.com/demo/source_mapping/ES6/" target="_blank" rel="external">示例</a>，ES6 的特性和类的使用就像浏览器原生支持的一样，这要感谢 Source Map。在示例中的文本框中，容许你书写 ES6 特性的代码，然后被动态编译成与 ES3 等价的代码，同时也会生成一个 Source Map。</p><p><img src="http://bubkoo.qiniudn.com/source-map-es6.png" alt=""></p><p><a href="http://www.thecssninja.com/demo/source_mapping/ES6/" target="_blank" rel="external">Demo: Write ES6, debug it, view source mapping in action</a></p><h2><span id="source-map-是如何工作的呢">Source Map 是如何工作的呢？</span></h2><p>由于 Source Map 是由 <a href="https://developers.google.com/closure/compiler/" target="_blank" rel="external">Closure compiler</a>（本文后面将解释怎么样使用该编译器）生成的，所以，目前仅支持合并/压缩的 JavaScript。一旦你合并/压缩 JavaScript 代码，与它将存在一个 sourcemap 文件。目前，编译器并不会在合并/压缩的文件末尾添加注释来让浏览器开发者工具知道有 可用的 source map，该注释如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//# sourceMappingURL=/path/to/file.js.map</span></div></pre></td></tr></table></figure><p>这使开发人员工具可以将调用映射回他们在原始文件中的位置。之前，注释是这样写的：<code>//@</code>，但由于一些问题和 IE 条件注释（和 IE 条件注释什么关系，不懂<sub></sub>），最终决定修改为 <code>//#</code>。目前，Chrome Canary、 WebKit Nightly 和 Firefox 24+ 都支持新的注释语法，这个语法的改变也影响到了 sourceURL。</p><p>如果你不喜欢这样奇怪的注释，你可以选择使用设置一个特殊的文件头在你编译的 JavaScript 文件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X-SourceMap: <span class="regexp">/path/</span>to/file.js.map</div></pre></td></tr></table></figure><p>就像注释中的内容那样，这将告诉 Source Map 的使用者到哪里去寻找和一个 JavaScript 文件关联的 Source Map 文件。使用文件头的方式也解决了那些不支持注释的语言引用 Source Map 文件的问题。</p><p><img src="http://bubkoo.qiniudn.com/sourcemap-on-off.png" alt=""></p><p>只有当你打开开发者工具并且开启了 Source Map 功能时 source map 文件才会被下载。你还需要上传你的原始文件到你的web服务器，开发工具才可以应用，并在必要时显示它们。</p><h2><span id="如何生成-source-map-文件">如何生成 Source Map 文件</span></h2><p>就像我在上面提到过的那样，你需要使用 <a href="https://developers.google.com/closure/compiler/" target="_blank" rel="external">Closure compiler</a> 来合并、压缩并为你的 JavaScript 文件生成一个 Source Map 文件。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">java -jar compiler.jar \</div><div class="line">     --js script.js \</div><div class="line">     --create_source_map ./script-min.js.map \</div><div class="line">     --source_map_format=V3 \</div><div class="line">     --js_output_file script-min.js</div></pre></td></tr></table></figure><p>两个重要的命令标志：<code>--create_source_map</code> 和 <code>--source_map_format</code>。<code>--source_map_format</code>的默认值是 V2，这里我们设置为 V3。</p><h2><span id="source-map-文件剖析">Source Map 文件剖析</span></h2><p>为了更好地理解 Source Map 文件，我将举一个小例子，在例子中我将用 <a href="https://developers.google.com/closure/compiler/" target="_blank" rel="external">Closure compiler</a> 来生成一个 Source Map 文件，并深入分析“映射”部分是如何工作的。下面示例是从官方 <a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?hl=en_US&amp;pli=1&amp;pli=1" target="_blank" rel="external">V3 spec</a> 示例微小改变来的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    version : <span class="number">3</span>,</div><div class="line">    file: <span class="string">"out.js"</span>,</div><div class="line">    sourceRoot : <span class="string">""</span>,</div><div class="line">    sources: [<span class="string">"foo.js"</span>, <span class="string">"bar.js"</span>],</div><div class="line">    names: [<span class="string">"src"</span>, <span class="string">"maps"</span>, <span class="string">"are"</span>, <span class="string">"fun"</span>],</div><div class="line">    mappings: <span class="string">"AAgBC,SAAQ,CAAEA"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上面可以看出，Source Map 文件是一个包含大量信息的字面量对象：</p><ul><li>version： Source Map 版本号</li><li>file：生成后的文件名称（合并/压缩后的文件名）</li><li>sourceRoot：转换前的文件所在的目录 - 这是一种减少文件大小的技术</li><li>sources：所有被合并的文件</li><li>names：包含所有转换前在代码中出现过的变量和方法名</li><li>mappings：使用 Base64 VLQ 值，这正是神奇的地方，真正的减少文件大小是在这里完成。</li></ul><h2><span id="使用-base64-vlq-编码来减小-source-map-文件的大小">使用 Base64 VLQ 编码来减小 Source Map 文件的大小</span></h2><p>最初 Source Map 规范对所有映射有一个非常详细的输出，结果导致 Source Map 文件是生成的代码文件大小的10倍左右，版本 2 降低了 50%，版本 3 又在版本 2 的基础上再降了 50%，所以对于一个 133kb 的文件最终将生成一个大约 300kb 的 Source Map 文件。那么，他们是如何减少文件大小，同时仍然维持复杂的映射呢？</p><p>使用 <a href="http://en.wikipedia.org/wiki/Variable-length_quantity" target="_blank" rel="external">VLQ</a> (Variable Length Quantity)编码 和 Base64 编码一起来编码。mappings 属性是一个超级大的字符串，字符串中的分号（;）对应转换后源码的一行，字符串中的逗号（,）对应转换后源码的一个位置，字符串中的每一个部分是 1、4 或 5 的可变长度字段。有些可能会很长，但是包含连续位，每一个部分都是基于前一个部分生成的，这有助于减少文件大小，因为每个位都是相对于其先前的部分。</p><p><img src="http://bubkoo.qiniudn.com/source-map-segment.png" alt=""></p><p>正如前面我提到的那样，每一段可以1、4或5可变长度，上图中是可变长度的四位与一个连续位（g），我将拆分这个段，然后向你展示 Source Map 如何映射回原始位置。上面所示的值是纯粹的 Base64 解码值，需要进一步处理才能得到它的真实值，每一个段落通常包含 5 个位置信息：</p><ul><li>生成后的代码的第几列</li><li>该段对应的原始文件</li><li>转换前代码的第几行</li><li>转换前代码的第几列</li><li>如果存在的话，属于 names 属性中的哪一个变量</li></ul><p>并不是每一段都有对应的变量名或者方法名，所以段的长度就是 4 位或者 5 位。上图中的 g 位就是所谓的连续位，这允许在Base64 和 VLQ 解码阶段进行进一步优化，连续位是基于一个段来构建的，这样就可以用来储存一个大数值而不必真正储存大数值本身，这是一个起源于 midi 格式，非常聪明的节约储存空间的技术。</p><p>上图中的 <code>AAgBC</code> 经过进一步的处理将返回 <code>0, 0, 32, 16, 1</code> ，<code>&quot;32&quot;</code>就是连续位，帮助生成后面一位的值<code>&quot;16&quot;</code>，B 经过 Base64 解码是 1，所以将使用的重要值是：<code>0, 0, 16, 1</code>，这样我们就知道，生成后的文件的第 0 列，对应于第 0 个原始文件中的第 16 行的第 1 列。</p><p>为了演示解码过程，我将引用 Mozilla 的 <a href="https://github.com/mozilla/source-map/" target="_blank" rel="external">Source Map JavaScript library</a>，你也可以看看 WebKit 开发人员工具 <a href="http://code.google.com/codesearch#OAMlx_jo-ck/src/third_party/WebKit/Source/WebCore/inspector/front-end/CompilerSourceMapping.js" target="_blank" rel="external">Source Map 代码</a>，也是用 JavaScript 编写的。</p><p>为了正确理解我们如何从 B 得到值 16，我们需要对位操作符和映射规范的原理有一个基本的了解。通过使用按位与(&amp;)算子与 32 和 <a href="https://github.com/mozilla/source-map/blob/master/lib/source-map/base64-vlq.js#L32" target="_blank" rel="external">VLQ_CONTINUATION_BIT</a>(二进制的 100000 或 32)进行对比，将前面的数字 g 标记为连续位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">32</span> &amp; <span class="number">32</span> = <span class="number">32</span></div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="number">100000</span></div><div class="line">|</div><div class="line">|</div><div class="line">V</div><div class="line"><span class="number">100000</span></div></pre></td></tr></table></figure><p>如果按位与的两个位都是 1 将返回 1，所以 Base64 解码 33 &amp; 32 将返回 32。这就为每一个继续位通过位移运算，增加 5 位，上面例子中只移动了一次 5 位，像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> &lt;&lt; <span class="number">5</span> <span class="comment">// 32</span></div><div class="line"></div><div class="line"><span class="comment">// Shift the bit by 5 spots</span></div><div class="line">______</div><div class="line">|    |</div><div class="line">V    V</div><div class="line"><span class="number">100001</span> = <span class="number">100000</span> = <span class="number">32</span></div></pre></td></tr></table></figure><p>然后将该值进行转换，通过将其将 VLQ 签名的值右移一位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">32</span> &gt;&gt; <span class="number">1</span> <span class="comment">// 16</span></div><div class="line"><span class="comment">//or</span></div><div class="line"><span class="number">100000</span></div><div class="line">|</div><div class="line"> |</div><div class="line"> V</div><div class="line"><span class="number">010000</span> = <span class="number">16</span></div></pre></td></tr></table></figure><p>这就将 1 转换到了 16，这似乎是一个复杂的过程，但是一旦转换的数开始数量更大的时候就更有意义。</p><h2><span id="潜在的-xssi-问题">潜在的 XSSI 问题</span></h2><p>规范中提到使用 Source Map 可能带来跨站脚本问题。为了减小这个问题，建议在 Source Map 文件的第一行前面加上<code>&quot;)]}&quot;</code>来故意使 JavaScript 抛出一个语法错误。WebKit 开发人员工具已经可以处理这个问题了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (response.slice(<span class="number">0</span>, <span class="number">3</span>) === <span class="string">")]&#125;"</span>) &#123;</div><div class="line">    response = response.substring(response.indexOf(<span class="string">'\n'</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>像上面这样，如果 Source Map 文件中有语法错误，并且首行以<code>&quot;)]}&quot;</code>三个字符开始，则将首行中<code>\n</code>前面所有的字符删去。</p><h2><span id="sourceurl-and-displayname-in-action-eval-and-anonymous-functions">sourceURL and displayName in action: Eval and anonymous functions</span></h2><p>以下两个预定，虽然不是 Source Map 规范的一部分，但是对于处理 Eval 和匿名函数非常方便。</p><p>第一个约定看起来非常像 sourceMappingURL 属性中的 <code>&quot;//#&quot;</code>，事实上这个约定在 Source Map V3 规范中也有提及。通过在你的代码中加入以下特殊注释，注释中的内容将被执行，你可以给 eval 命名使他们以更加有意义的名称出现在你的开发者工具中。请看以下用 CoffeeScript 编译的示例：<br><a href="http://www.thecssninja.com/demo/source_mapping/compile.html" target="_blank" rel="external">Demo: See <code>eval()</code>‘d code show as a script via sourceURL</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//# sourceURL=sqrt.coffee</span></div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/source-map-source-url.png" alt=""></p><p>另一个约定可以让你对匿名函数命名，通过在当前匿名函数的上下文中使用 displayName 属性。看下面的示例中可以看到 displayName 属性是如何工作的。</p><p><a href="http://www.thecssninja.com/demo/source_mapping/displayName.html" target="_blank" rel="external">Demo: Named anon functions via displayName (Webkit Nightly only)</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">btns[<span class="number">0</span>].addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"You clicked button number: 1"</span>);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    fn.displayName = <span class="string">"Anonymous function of button 1"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fn();</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure><p><img src="http://bubkoo.qiniudn.com/source-map-display-name.png" alt=""></p><p>当在开发人员工具中分析你的代码，displayName 属性将显示，而不是像显示一个 anonymous。然而 Chrome 中 displayName 属性将不会显示，但并不是所有的希望都破灭了，已经有一个被称为 <a href="http://code.google.com/p/chromium/issues/detail?id=116220" target="_blank" rel="external">debugName</a> 的更好的建议。</p><p>因此，eval 命名是在 Firefox 和 WebKit 浏览器中有效，displayName 属性只在 WebKit nightlies 中有效。</p><h2><span id="lets-rally-together">Let’s rally together</span></h2><p>目前，有非常多的讨论关于 Source Map 已经支持 CoffeeScript，去看看这个讨论并对你的 CoffeeScript 编译器添加 Source Map 支持，这对 CoffeeScript 及其拥趸将是一个巨大的胜利。</p><p>UglifyJS 也有一些关于 <a href="https://github.com/mishoo/UglifyJS/issues/315" target="_blank" rel="external">Source Map 的问题</a>，你也应该去看看。</p><p>很多的<a href="https://github.com/ryanseddon/source-map/wiki/Source-maps%3A-languages,-tools-and-other-info" target="_blank" rel="external">工具</a>生成 Source Map，包括coffeescript编译器。我现在认为这是一个有争议的问题。</p><p>更多的工具可以生成 Source Map，对我们来说意味着更好，所以赶紧去给你的开源项目加上 Source Map 支持吧。</p><h2><span id="source-map-并不完美its-not-perfect">Source Map 并不完美（It’s not perfect）</span></h2><p>目前，Source Maps 对于表达式的支持并不是那么好。问题在于，在当前执行上下文中检查一个参数或变量名将不会返回任何值，因为它并不存在。这需要某种反向映射机制来查询你想检查的参数/变量的真实名称，而不是直接使用编译后的 JavaScript 文件中的参数/变量名。</p><p>这当然是一个可以解决的问题，更多的关注关于 Source Map，我们可以开始看到一些惊人的特性和更好的稳定性。</p><h2><span id="问题-issues">问题 Issues</span></h2><p>最近，<a href="http://blog.jquery.com/2013/01/15/jquery-1-9-final-jquery-2-0-beta-migrate-final-released/" target="_blank" rel="external">jQuery 1.9</a> 添加了对 Source Map 的支持，并且支出了在 IE 中的一个<a href="http://bugs.jquery.com/ticket/13274#comment:6" target="_blank" rel="external">奇怪错误</a>，IE 会在 jQuery 加载完成之前编译其中的注释(<code>//@cc_on</code>)。已经有<a href="https://github.com/jquery/jquery/commit/487b703521e63188102c73e8ce6ce203d28f260b" target="_blank" rel="external">提议</a>使用多行注释来包裹 sourceMappingURL 属性来减少这个错误的发生。可以学习使用不用条件注释的方式。</p><p>关于语法改变为<code>//#</code>可以到<a href="https://groups.google.com/forum/#!topic/mozilla.dev.js-sourcemap/4uo7Z5nTfUY" target="_blank" rel="external">这里</a>查看。</p><h2><span id="工具和资源">工具和资源</span></h2><p>这里有更多的资源和工具，你可以看看：</p><ul><li>Nick Fitzgerald 有一个分支的 <a href="https://github.com/fitzgen/UglifyJS/tree/source-maps" target="_blank" rel="external">UglifyJS</a> 已经支持 Source Map</li><li>Paul Irish 有一个<a href="http://dl.dropbox.com/u/39519/sourcemapapp/index.html" target="_blank" rel="external">小例子</a>来演示 Source Map</li><li>查看 WebKit 的<a href="http://trac.webkit.org/changeset/103541" target="_blank" rel="external">变更集</a></li><li>变更集中有一个 <a href="http://trac.webkit.org/export/105549/trunk/LayoutTests/http/tests/inspector/compiler-source-mapping-debug.html" target="_blank" rel="external">layout test</a>，这也是本文开始提到的那个例子</li><li>Mozilla 有一个 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=670002" target="_blank" rel="external">bug</a>，你应该在控制台中跟踪 Source Map 的状态</li><li>Conrad Irwin 为所有 Ruby 用户写了一个超级有用的 <a href="https://github.com/ConradIrwin/ruby-source_map" target="_blank" rel="external">source map gem</a></li><li>进一步阅读关于 <a href="http://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/" target="_blank" rel="external">eval naming</a> 和 <a href="http://www.alertdebugging.com/2009/04/29/building-a-better-javascript-profiler-with-webkit/" target="_blank" rel="external">displayName property</a></li><li>关于创建 Source Map，你可以阅读 <a href="http://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/SourceMapGeneratorV3.java" target="_blank" rel="external">Closure Compilers source</a></li><li>这里有一些截图和支持关于 <a href="https://plus.google.com/110412141990454266397/posts/iqXo5AyHkyd" target="_blank" rel="external">GWT source maps</a></li></ul><p>Source Map 在开发人员工具中是一个非常有用的工具。它是超级有用的，能够让您的 Web 应用程序的瘦小但也容易调试。对新的开发人员来说，这也是一个非常强大的学习工具，来查看有经验的开发者的程序结构和写他们的应用程序代码，而无需通过阅读压缩/合并后的这样可读性不高的代码。你还在等什么？开始给你的应用添加 Source Map 支持吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自：&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/?redirect_from_locale=zh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introduction to JavaScript Source Maps&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;水平有限，有表达错误和不准确的地方，可以在回复中直接指出来，英语水平高的同学可以直接看上面的原文。&lt;/p&gt;
&lt;p&gt;下面开始正文。&lt;/p&gt;
&lt;p&gt;你有没有希望保持你的客户端代码可读性，更重要的是可调式性，即使你合并和压缩过代码，同时又不影响性能？现在你可以通过 &lt;a href=&quot;https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?hl=en_US&amp;amp;pli=1&amp;amp;pli=1#heading=h.1ce2c87bpj24&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Source Maps&lt;/a&gt; 的魔力来实现。&lt;/p&gt;
&lt;p&gt;从根本上说，这是一种将合并/压缩后的文件映射回未构建状态的方式。当构建产品，合并和压缩你的 JavaScript 文件的同时，生成一个包含源文件信息的 Source Maps 文件。当你查询生成后的文件中某一行号和列号的位置时，你可以通过 Source Maps 来返回它所对应的原始位置。开发人员工具（WebKit 最新版，Google Chrome，Firefox 23+）可以自动解析 Source Maps，使得看起来好像你在运行未压缩和合并的文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.thecssninja.com/demo/source_mapping/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo: Get original location&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;打开上面示例的连接，在包含生成后文件的文本区域的任何地方点击鼠标右键，选择 “Get original location”，将通过生成后的文件的行号和列号查询 Source Maps，并返回原始代码的位置。确保你的控制台是打开的，这样你就可以看到输出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/source-map-demo.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://bubkoo.com/tags/javascript/"/>
    
      <category term="Source Map" scheme="http://bubkoo.com/tags/source-map/"/>
    
      <category term="Debug" scheme="http://bubkoo.com/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>那些年我使用过的 Sublime Text 3 插件</title>
    <link href="http://bubkoo.com/2014/01/04/sublime-text-3-plugins/"/>
    <id>http://bubkoo.com/2014/01/04/sublime-text-3-plugins/</id>
    <published>2014-01-04T18:56:32.000Z</published>
    <updated>2014-01-04T18:56:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实，我最开始接触到的是 Sublime Text 2，被其轻量、简洁以及漂亮的配色所瞬间征服，后来升级为 <a href="http://www.sublimetext.com/" target="_blank" rel="external">Sublime Text 3</a>，使用过程中有一些需要设置的地方，还有一些常用插件的安装和设置技巧等，有时候会忘记某些设置方法或者快捷键，然后不得不上网查。恰逢周末，其中的一些东西记录下来，一方面加深自己的印象，同时方便查阅。</p><p><img src="http://bubkoo.qiniudn.com/sublime-text-2-logo.jpg" alt=""><br><a id="more"></a></p><h2><span id="安装-sublime-text-3-插件的方法">安装 Sublime Text 3 插件的方法</span></h2><p><strong>1. 直接安装</strong></p><p>安装 Sublime text 3 插件很方便，可以直接下载安装包解压缩到 Packages 目录（菜单-&gt;Preferences-&gt;Packages）。</p><p><strong>2. 使用 Package Control 组件安装</strong></p><p>新安装的 Sublime text 3 默认没有  Package Control 组件，怎么样安装呢？可以按照以下步骤：</p><ol><li>按 Ctrl + ` 打开控制台，粘贴以下代码到底部命令行并回车：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request,os; pf = <span class="string">'Package Control.sublime-package'</span>; ipp =   sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), <span class="string">'wb'</span>).write(urllib.request.urlopen( <span class="string">'http://sublime.wbond.net/'</span> + pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).read())</div></pre></td></tr></table></figure><ol><li>重启 Sublime Text 3</li><li>在 Perferences-&gt;Package Settings 中看到 Package Control，则表示安装成功</li></ol><p><strong>用Package Control安装插件的方法：</strong></p><ol><li>在 Package Control 中选择 Install package 或者按 Ctrl+Shift+P，打开命令板</li><li>输入 pci 然后选择 Install Package</li><li>搜索需要的插件名称，点击就可以自动完成安装。</li></ol><h2><span id="那些插件">那些插件</span></h2><p>按照我的插件安装列表的顺序</p><h3><span id="alignment-等号对齐">Alignment 等号对齐</span></h3><p>按 <strong>Ctrl+Alt+A</strong>，可以将凌乱的代码以等号为准左右对其，网上说这个插件适合有代码洁癖的同学，好吧，我确实有代码洁癖，因为我经常使用。</p><p><img src="http://bubkoo.qiniudn.com/sublime-plugin-alignment.gif" alt=""></p><p>插件下载：<a href="https://github.com/kevinsperrine/sublime_alignment/tree/python3" target="_blank" rel="external">https://github.com/kevinsperrine/sublime_alignment/tree/python3</a></p><h3><span id="brackethighlighter-高亮显示匹配的括号-引号和标签">BracketHighlighter 高亮显示匹配的括号、引号和标签</span></h3><p>BracketHighlighter 这个插件能在左侧高亮显示匹配的括号、引号和标签，能匹配的 [], (), {}, “”, ‘’,  <tag></tag> 等甚至是自定义的标签，当看到密密麻麻的代码分不清标签之间包容嵌套的关系时，这款插件就能很好地帮你理清楚代码结构，快速定位括号，引号和标签内的范围。</p><p><img src="http://bubkoo.qiniudn.com/sublime-plugin-brackethighlighter.png" alt=""></p><p>插件下载：<a href="https://github.com/facelessuser/BracketHighlighter/tree/BH2ST3" target="_blank" rel="external">https://github.com/facelessuser/BracketHighlighter/tree/BH2ST3</a></p><h3><span id="emmet-htmlcss快速编辑原名zen-coding">Emmet html/CSS快速编辑（原名Zen Coding）</span></h3><p>Zen Coding估计大家都不会陌生，前不久改名为Emmet了，虽然用Emmet编辑html很快，但是要用好用快它需要付出不小的学习成本，<a href="emmet-a-toolkit-for-improving-html-css-workflow">这里</a>有我的一篇学习教程，可以作为参考。</p><p><img src="http://bubkoo.qiniudn.com/sublime-plugin-emmet.png" alt=""></p><p>插件下载：<a href="https://github.com/sergeche/emmet-sublime" target="_blank" rel="external">https://github.com/sergeche/emmet-sublime</a></p><h3><span id="jsformat-javascript格式化">JsFormat JavaScript格式化</span></h3><p>按快捷键 <strong>Ctrl+Alt+F</strong> 即可格式化当前的 js 文件。平时书写代码用的非常多，或者下载格式化别人压缩过的代码。</p><p>插件下载：<a href="https://github.com/jdc0589/JsFormat" target="_blank" rel="external">https://github.com/jdc0589/JsFormat</a></p><h3><span id="sublimetmpl-快速生成文件模板">SublimeTmpl 快速生成文件模板</span></h3><p>SublimeTmpl 能新建 html、css、javascript、php、python、ruby 六种类型的文件模板，所有的文件模板都在插件目录的templates文件夹里，可以自定义编辑文件模板。</p><p>SublimeTmpl默认的快捷键</p><ul><li>ctrl+alt+h → html</li><li>ctrl+alt+j → javascript</li><li>ctrl+alt+c → css</li><li>ctrl+alt+p → php</li><li>ctrl+alt+r → ruby</li><li>ctrl+alt+shift+p → python</li></ul><p>如果想要新建其他类型的文件模板的话，先自定义文件模板方在 templates 文件夹里，再分别打开 Default (Windows).sublime-keymap、Default.sublime-commands、Main.sublime-menu、SublimeTmpl.sublime-settings 这四个文件照着里面的格式自定义想要新建的类型~</p><p>插件下载：<a href="https://github.com/kairyou/SublimeTmpl" target="_blank" rel="external">https://github.com/kairyou/SublimeTmpl</a></p><h3><span id="tag-html格式化">Tag Html格式化</span></h3><p>右键菜单 Auto-Format Tags on Ducument，或者选中需要格式化的部分，使用快捷键 <strong>Ctrl+Alt+F</strong>。</p><p>插件下载：<a href="https://github.com/kairyou/SublimeTmpl" target="_blank" rel="external">https://github.com/kairyou/SublimeTmpl</a></p><h3><span id="trailingspacer-高亮显示多余的空格和-tab">TrailingSpacer 高亮显示多余的空格和 Tab</span></h3><p>我有代码洁癖，我爱 TrailingSpacer，TrailingSpacer这款插件能高亮显示多余的空格和Tab，并可以一键删除它们。</p><p><img src="http://bubkoo.qiniudn.com/sublime-plugin-trailingspacer.jpg" alt=""></p><p>注意，在 github 上下载的插件缺少了一个设置快捷键的文件，可以新建一个名字和后缀为 Default (Windows).sublime-keymap 的文件，添加以下代码，即可设置“删除多余空格”和“是否开启TrailingSpacer ”的快捷键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123; <span class="string">"keys"</span>: [<span class="string">"ctrl+alt+d"</span>], <span class="string">"command"</span>: <span class="string">"delete_trailing_spaces"</span> &#125;,</div><div class="line"> </div><div class="line">    &#123; <span class="string">"keys"</span>: [<span class="string">"ctrl+alt+o"</span>], <span class="string">"command"</span>: <span class="string">"toggle_trailing_spaces"</span> &#125;</div><div class="line">]</div></pre></td></tr></table></figure><p>插件下载：<a href="https://github.com/SublimeText/TrailingSpaces" target="_blank" rel="external">https://github.com/SublimeText/TrailingSpaces</a></p><h3><span id="csscomb-css属性排序">CSScomb CSS属性排序</span></h3><p>CSScomb 可以按照一定的 CSS 属性排序规则，将杂乱无章的 CSS 属性进行重新排序。选中要排序的 CSS 代码，按 Ctrl+Shift+C，即可对 CSS 属性重新排序了，代码从此简洁有序易维护，如果不款选代码则插件将排序文件中所有的 CSS 属性。当然，可以自己自定义 CSS 属性排序规则，打开插件目录里的 CSScomb.sublime-settings 文件，更改里面的 CSS 属性顺序就行了。因为这个插件使用 PHP 写的，要使他工作需要在环境变量中添加 PHP 的路径，具体请看 <a href="https://github.com/csscomb/CSScomb/wiki/Requirements" target="_blank" rel="external">github</a> 上的说明。</p><p><img src="http://bubkoo.qiniudn.com/sublime-plugin-csscomb.jpg" alt=""></p><p>插件下载：<a href="https://github.com/csscomb/CSScomb-for-Sublime" target="_blank" rel="external">https://github.com/csscomb/CSScomb-for-Sublime</a></p><h2><span id="快捷键">快捷键</span></h2><p>Ctrl+Shift+P：打开命令面板<br>Ctrl+P：搜索项目中的文件<br>Ctrl+G：跳转到第几行<br>Ctrl+W：关闭当前打开文件<br>Ctrl+Shift+W：关闭所有打开文件<br>Ctrl+Shift+V：粘贴并格式化<br>Ctrl+D：选择单词，重复可增加选择下一个相同的单词<br>Ctrl+L：选择行，重复可依次增加选择下一行<br>Ctrl+Shift+L：选择多行<br>Ctrl+Shift+Enter：在当前行前插入新行<br>Ctrl+X：删除当前行<br>Ctrl+M：跳转到对应括号<br>Ctrl+U：软撤销，撤销光标位置<br>Ctrl+J：选择标签内容<br>Ctrl+F：查找内容<br>Ctrl+Shift+F：查找并替换<br>Ctrl+H：替换<br>Ctrl+R：前往 method<br>Ctrl+N：新建窗口<br>Ctrl+K+B：开关侧栏<br>Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身<br>Ctrl+F2：设置/删除标记<br>Ctrl+/：注释当前行<br>Ctrl+Shift+/：当前位置插入注释<br>Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的<br>Ctrl+Shift+A：选择当前标签前后，修改标签用的<br>F11：全屏<br>Shift+F11：全屏免打扰模式，只编辑当前文件<br>Alt+F3：选择所有相同的词<br>Alt+.：闭合标签<br>Alt+Shift+数字：分屏显示<br>Alt+数字：切换打开第N个文件<br>Shift+右键拖动：光标多不，用来更改或插入列内容<br>Ctrl+依次左键点击或选取，可需要编辑的多个位置<br>Ctrl+Shift+上下键：替换行</p><h2><span id="参考文章">参考文章</span></h2><ul><li><a href="http://dengo.org/archives/923" target="_blank" rel="external">Sublime Text 3 能用支持的插件推荐</a></li><li><a href="http://dengo.org/archives/594" target="_blank" rel="external">Sublime Text 3 如何安装 Package Control 办法</a></li><li><a href="http://www.opcnz.com/kai-fa-gong-ju/332.shtml" target="_blank" rel="external">Sublime Text 3 介绍与常用插件推荐</a></li><li><a href="http://www.appinn.com/sublime-text-2/" target="_blank" rel="external">Sublime Text 2 非常强大的跨平台编辑器</a></li><li><a href="http://www.qianduan.net/essential-to-sublime-the-text-2-plugins.html" target="_blank" rel="external">一些必不可少的 Sublime Text 2 插件</a></li><li><a href="http://lucifr.com/139225/sublime-text-2-tricks-and-tips/" target="_blank" rel="external">Sublime Text 2 入门及技巧</a></li><li><a href="http://www.appinn.com/zen-coding/" target="_blank" rel="external">Zen Coding – 超快地写网页代码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实，我最开始接触到的是 Sublime Text 2，被其轻量、简洁以及漂亮的配色所瞬间征服，后来升级为 &lt;a href=&quot;http://www.sublimetext.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sublime Text 3&lt;/a&gt;，使用过程中有一些需要设置的地方，还有一些常用插件的安装和设置技巧等，有时候会忘记某些设置方法或者快捷键，然后不得不上网查。恰逢周末，其中的一些东西记录下来，一方面加深自己的印象，同时方便查阅。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/sublime-text-2-logo.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="http://bubkoo.com/tags/tools/"/>
    
      <category term="Sublime Text" scheme="http://bubkoo.com/tags/sublime-text/"/>
    
  </entry>
  
  <entry>
    <title>HTML/CSS 速写神器：Emmet</title>
    <link href="http://bubkoo.com/2014/01/04/emmet-a-toolkit-for-improving-html-css-workflow/"/>
    <id>http://bubkoo.com/2014/01/04/emmet-a-toolkit-for-improving-html-css-workflow/</id>
    <published>2014-01-04T13:21:12.000Z</published>
    <updated>2014-01-04T13:21:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发的过程中，一个最繁琐的工作就是写 HTML、CSS 代码。数量繁多的标签、属性、尖括号、标签闭合等，让前端们甚是苦恼。于是，我向大家推荐 <a href="http://emmet.io/" target="_blank" rel="external">Emmet</a>，它提供了一套非常简单的语法规则，书写起来非常爽快，然后只需要敲一个快捷键就立刻生成对应的 HTML 或 CSS 代码，极大提高了代码书写效率。</p><a id="more"></a><p><a href="http://emmet.io/" target="_blank" rel="external">Emmet</a> 的前身是大名鼎鼎的 <strong>Zen coding</strong>，它是一个编辑器插件，需要基于指定的编辑器使用，官方网站提供<a href="http://emmet.io/download/" target="_blank" rel="external">多编辑器支持</a>，目前它支持的编辑器如下：</p><ul><li><a href="https://github.com/sergeche/emmet-sublime#readme" target="_blank" rel="external">Sublime Text</a></li><li><a href="https://github.com/emmetio/emmet-eclipse#readme" target="_blank" rel="external">Eclipse/Aptana</a></li><li><a href="https://github.com/emmetio/Emmet.tmplugin#readme" target="_blank" rel="external">TextMate</a></li><li><a href="https://github.com/emmetio/Emmet.codaplugin#readme" target="_blank" rel="external">Coda</a></li><li><a href="https://github.com/emmetio/Emmet.sugar#readme" target="_blank" rel="external">Espresso</a></li><li><a href="https://github.com/sergeche/emmet.chocmixin#readme" target="_blank" rel="external">Chocolat</a></li><li><a href="http://community.activestate.com/xpi/zen-coding" target="_blank" rel="external">Komodo Edit</a></li><li><a href="https://github.com/emmetio/npp#readme" target="_blank" rel="external">Notepad++</a></li><li><a href="https://github.com/emmetio/pspad" target="_blank" rel="external">PSPad</a></li><li><a href="https://github.com/emmetio/textarea" target="_blank" rel="external">textarea</a></li><li><a href="https://github.com/emmetio/codemirror#readme" target="_blank" rel="external">CodeMirror</a></li><li><a href="https://github.com/emmetio/brackets-emmet#readme" target="_blank" rel="external">Brackets</a></li><li><a href="https://github.com/emmetio/netbeans#readme" target="_blank" rel="external">NetBeans</a></li><li><a href="https://github.com/emmetio/dreamweaver#readme" target="_blank" rel="external">Adobe Dreamweaver</a></li></ul><p>请参照上面列表安装对应的编辑器插件，我一般使用 <a href="http://www.sublimetext.com/" target="_blank" rel="external">Sublime Text 3</a>，下面就以 <a href="https://github.com/sergeche/emmet-sublime#readme" target="_blank" rel="external">Sublime Text 3 插件</a> 为例，讲解 Emmet 的安装、基础语法。</p><h2><span id="在-sublime-text-3-中安装-emmet">在 Sublime text 3 中安装 Emmet</span></h2><p>目前，Emmet 已经可以通过 Package Control 安装了。如果你的 Sublime Text 3 还没有安装 Package Control，请参照以下方法安装，已经安装的童鞋请自行跳过。</p><p><strong>为 Sublime Text 3 安装 Package Control 组件：</strong></p><ol><li>按 Ctrl + ` 打开控制台，粘贴以下代码到底部命令行并回车：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request,os; pf = <span class="string">'Package Control.sublime-package'</span>; ipp =   sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), <span class="string">'wb'</span>).write(urllib.request.urlopen( <span class="string">'http://sublime.wbond.net/'</span> + pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).read())</div></pre></td></tr></table></figure><ol><li>重启 Sublime Text 3</li><li>在 Perferences-&gt;Package Settings 中看到 Package Control，则表示安装成功</li></ol><p><strong>使用 Package Control 安装 Emmet 插件：</strong></p><ol><li>在 Package Control 中选择 Install package 或者按 Ctrl+Shift+P，打开命令板</li><li>输入 pci 然后选择 Install Package</li><li>搜索输入 emmet 找到 Emmet Css Snippets，点击就可以自动完成安装。</li></ol><h2><span id="快速体验-emmet">快速体验 Emmet</span></h2><p>Emmet 可以快速的编写 HTML、CSS 以及实现其他的功能。它根据当前文件的<strong>解析模式</strong>来判断要使用 HTML 语法还是 CSS 语法来解析。例如当前文件的后缀为 .html 那 Sublime text 3 就会用 HTML 的解析模式来解析高亮这个文件，Emmet 遇到里面的指令就会根据 HTML 的语法把它编译成 HTML 结构。如果是在一个 .c 的 C 语言文件中，你写出来的用于编译 HTML 指令就不会被 Emmet 识别编译。</p><p>此外，在没有后缀的文件中，你可以按下<code>shift + ctrl + p</code>呼出面板，输入<code>seth</code>就可以设置当前文件的解析模式为 HTML 。了解这些之后，下面我们来见证强大的 Emmet。</p><p>如果让你编写下面的这个 HTML 结构，你需要多长时间？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"page"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"navigation"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>Item 5<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>然而，这一切你只需要编写下面这一句按照 Emmet 语法写出来的语句，然后用 Emmet 编译一下，就可以生成了！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#page&gt;div.logo+ul#navigation&gt;li*5&gt;a&#123;Item $&#125;</div></pre></td></tr></table></figure><p>我们把它复制到 Sublime text 3 中已经打开的 HTML 文件中，这时候紧跟着敲击一下 TAB 键，见证奇迹的时刻到来了。</p><p>怎么样？很神奇吧，仅仅写一行代码，就可以生成这么一个复杂的 HTML 结构，而且还可以生成对应的 class 、id 和有序号的内容。而且 Emmet 的语法很简单，虽然你现在可能还看不懂，后面的系列教程会详细讲解它的语法，你现在只需要知道 Emmet 的工作流程：</p><blockquote><p><strong>打开 HTML 或 CSS 文件-&gt;按语法编写指令-&gt;按下 TAB 键-&gt;生成</strong></p></blockquote><h2><span id="快速编写html代码">快速编写HTML代码</span></h2><h3><span id="生成-html-文档初始结构"><strong>生成 HTML 文档初始结构</strong></span></h3><p>HTML文档需要包含一些固定的标签，比如 doctype、html、head、body 以及 meta 等等，现在你只需要1秒钟就可以输入这些标签。比如输入<code>!</code>或<code>html:5</code>，然后按 Tab 键： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt; <span class="attr">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>这就是一个 HTML5 的标准结构，也是默认的 HTML 结构。如果你想生成 HTML4 的过渡型结构，那么输入指令 html:xt 即可生成如下结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span> <span class="attr">xml:lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt; <span class="attr">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>Emmet 会自动把 doctype 给你补全了，怎么样，这样的功能会不会让你动心？</p><p>简单总结一下常用的 HTML 结构指令：</p><ul><li><strong>html:5</strong> 或者 <strong>!</strong> 生成 HTML5 结构</li><li><strong>html:xt</strong> 生成 HTML4 过渡型</li><li><strong>html:4s</strong> 生成 HTML4 严格型</li></ul><h3><span id="生成带有-id-class-的-html-标签"><strong>生成带有 id 、class 的 HTML 标签</strong></span></h3><p>Emmet 默认的标签为 div，如果我们不给出标签名称的话，默认就生成 div 标签。生成 id 为 page 的 div 标签，我们只需要编写下面指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div#page</div></pre></td></tr></table></figure><p>或者使用默认标签的方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#page</div></pre></td></tr></table></figure><p>如果编写一个 class 为 content 的 p 标签，我们需要编写下面指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.content</div></pre></td></tr></table></figure><p>同时指定标签的 id 和 class，如生成 id 为 navigation，class 为 nav 的 ul 标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ul#navigation.nav</div></pre></td></tr></table></figure><p>指定多个 class，如上例中还需要给 ul 指定一个 class 为 dropdown：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ul#navigation.nav.dropdown</div></pre></td></tr></table></figure><p>生成的 HTML 结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"navigation"</span> <span class="attr">class</span>=<span class="string">"nav dropdown"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="兄弟"><strong>兄弟：+</strong></span></h3><p>生成标签的兄弟标签，即平级元素，使用指令<strong> + </strong>，例如下面指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div+ul+bq</div></pre></td></tr></table></figure><p>生成的 HTML 结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="后代gt"><strong>后代：&gt;</strong></span></h3><p><strong>&gt;</strong> 表示后面要生成的内容是当前标签的后代。例如我要生成一个无序列表，而且被 class 为 nav 的 div 包裹，那么可以使用下面指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div.nav&gt;ul&gt;li</div></pre></td></tr></table></figure><p>生成的 HTML 结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="上级元素"><strong>上级元素：^</strong></span></h3><p>上级 （Climb-up）元素是什么意思呢？前面咱们说过了生成下级元素的符号<strong>“&gt;”</strong>，当使用 <code>div&gt;ul&gt;li</code> 的指令之后，再继续写下去，那么后续内容都是在 li 下级的。如果我想编写一个跟 ul 平级的 span 标签，那么我需要先用 <strong>“^”</strong> 提升一下层次。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div.nav&gt;ul&gt;li^span</div></pre></td></tr></table></figure><p>就会生成如下结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>  <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>如果我想相对与 div 生成一个平级元素，那么就再上升一个层次，多用一个 <strong>“^”</strong> 符号：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div.nav&gt;ul&gt;li<span class="tag">&lt;<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">sup</span>&gt;</span>span</div></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>  <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span>    </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="重复多份"><strong>重复多份：* </strong></span></h3><p>特别是一个无序列表，ul 下面的 li 肯定不只是一份，通常要生成很多个 li 标签。那么我们可以直接在 li 后面 * 上一些数字：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ul&gt;li*5</div></pre></td></tr></table></figure><p>这样就直接生成五个项目的无序列表了。如果想要生成多份其他结构，方法类似。</p><h3><span id="分组"><strong>分组：()</strong></span></h3><p>用括号进行分组，表示一个代码块，分组内部的嵌套和层级关系和分组外部无关，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p</div></pre></td></tr></table></figure><p>生成结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>可以看出整个分组成为 div 的后代，并且分组与 footer 平级。此外，分组还可以很方便的结合上面说的 <strong>“*”</strong> 符号生成重复结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(div&gt;dl&gt;(dt+dd)*3)+footer&gt;p</div></pre></td></tr></table></figure><p>生成结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dl</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="属性attr"><strong>属性：[attr]</strong></span></h3><p>a 标签中往往需要附带 href 属性和 title 属性，如果我们想生成一个 href 为 “<a href="http://bubkoo.com”" target="_blank" rel="external">http://bubkoo.com”</a> ，title 为“bubkoo’s blog”的 a 标签，可以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[href="http://bubkoo.com" title="bubkoo's blog"]</div></pre></td></tr></table></figure><p>此外，也可以生成一些自定义属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div[data-title="bubkoo's blog" data-content="CUCKOO USHERS SPRING IN"]</div></pre></td></tr></table></figure><p>就会生成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-title</span>=<span class="string">"bubkoo's blog"</span> <span class="attr">data-content</span>=<span class="string">"CUCKOO USHERS SPRING IN"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="编号"><strong>编号：$</strong></span></h3><p>例如无序列表，我想为五个个 li 增加一个 class 属性值 item1 ，然后依次递增从 1-5，那么就需要使用 <strong>$</strong> 符号：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ul&gt;li.item$*5</div></pre></td></tr></table></figure><p>结构是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item4"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item5"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>$ </strong>表示一位数字，只出现一个的话，就从 1 开始，如果出现多个，就从 0 开始。<br>如果我想生成三位数的序号，那么要写三个<strong> $</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ul&gt;li.item$$$*5</div></pre></td></tr></table></figure><p>输出：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item001"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item002"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item003"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item004"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item005"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>此外，也可以在<strong> $ </strong>后面增加<strong> @- </strong>来实现倒序排列：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ul&gt;li.item$@-*5</div></pre></td></tr></table></figure><p>输出：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item5"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item4"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>同时，还可以使用 @N 指定开始的序号：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ul&gt;li.item$@3*5</div></pre></td></tr></table></figure><p>那么输出：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item4"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item5"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item6"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item7"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>配合上面倒序输出，可以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ul&gt;li.item$@-3*5</div></pre></td></tr></table></figure><p>就可以生成以 3 为底倒序列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item7"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item6"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item5"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item4"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="文本内容"><strong>文本内容：{}</strong></span></h3><p>生成超链接一般要加上可点击的文本内容，如上面的连接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[href="http://bubkoo.com" title="bubkoo's blog"]&#123;猛击这里&#125;</div></pre></td></tr></table></figure><p>就会生成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://bubkoo.com"</span> <span class="attr">title</span>=<span class="string">"bubkoo's blog"</span>&gt;</span>猛击这里<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><p>另外，在生成内容的时候，特别要注意前后的符号关系，虽然 a&gt;{Click me} 和 a{Click me} 生成的结构是相同的，但是加上其他的内容就不一定了，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- a&#123;click&#125;+b&#123;here&#125; --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>click<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>here<span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- a&gt;&#123;click&#125;+b&#123;here&#125; --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>click<span class="tag">&lt;<span class="name">b</span>&gt;</span>here<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="隐式标签"><strong>隐式标签</strong></span></h3><p>隐式标签表示 Emmet 可以省略某些标签名，例如，声明一个带类的div，只需输入<code>.item</code>，就会生成<code>&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</code>。另外，Emmet 还会根据父标签进行判定，例如，在中输入<code>ul&gt;.item$*5</code>，就可以生成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item4"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item5"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>下面是所有的隐式标签名称：</p><ul><li>li：用于 ul 和 ol 中</li><li>tr：用于 table、tbody、thead 和 tfoot 中</li><li>td：用于 tr 中</li><li>option：用于 select 和 optgroup 中</li></ul><h3><span id="不要有空格"><strong>不要有空格</strong></span></h3><p>在写指令的时候，你可能为了代码的可读性，使用一些空格什么的排版一下。这就会导致代码无法使用。例如下面这句：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- a&#123;click&#125;+b&#123;here&#125; --&gt;</span></div><div class="line">(header &gt; ul.nav &gt; li*5) + footer</div></pre></td></tr></table></figure><p>执行结果会不是你所希望的那样，所以，<strong>指令之间不要有空格</strong>。</p><h3><span id="html-简写规则简单总结"><strong>HTML 简写规则简单总结</strong></span></h3><p>　　1. E 代表HTML标签。<br>　　2. E#id 代表id属性。<br>　　3. E.class 代表class属性。<br>　　4. E[attr=foo] 代表某一个特定属性。<br>　　5. E{foo} 代表标签包含的内容是foo。<br>　　6. E&gt;N 代表N是E的子元素。<br>　　7. E+N 代表N是E的同级元素。<br>　　8. E^N 代表N是E的上级元素。</p><h2><span id="飞一般的-css-书写">飞一般的 CSS 书写</span></h2><p>首先，<a href="http://www.sublimetext.com/" target="_blank" rel="external">Sublime Text 3</a> 已经提供了比较强大的 CSS 样式所写方法来提高 CSS 编写效率。例如编写 position: absolute; 这一个属性，我们只需要输入 posa 这四个字母即可。可以在平时书写过程中，留意一下 ST3 提供了哪些属性的缩写方法，这样就可以提高一定的效率了。但是 Emmet 提供了更多的功能，请往下看。</p><h3><span id="简写属性和属性值"><strong>简写属性和属性值</strong></span></h3><p>比如要定义元素的宽度，只需输入w100，即可生成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">width</span>: 100<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure><p>Emmet 的默认设置 w 是 width 的缩写，后面紧跟的数字就是属性值。默认的属性值单位是 px ，你可以在值的后面紧跟字符生成单位，可以是任意字符。例如，w100foo 会生成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">width</span><span class="selector-pseudo">:100foo</span>;</div></pre></td></tr></table></figure><p>同样也可以简写属性单位，如果你紧跟属性值后面的字符是 p，那么将会生成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</div></pre></td></tr></table></figure><p>下面是单位别名列表：</p><ul><li>p 表示%</li><li>e 表示 em</li><li>x 表示 ex</li></ul><p>像 margin 这样的属性，可能并不是一个属性值，生成多个属性值需要用横杠（-）连接两个属性值，因为 Emmet 的指令中是不允许空格的。例如使用 m10-20 可以生成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">margin</span>: 10<span class="selector-tag">px</span> 20<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure><p>如果你想生成负值，多加一条横杠即可。例如：m10–20 可以生成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">margin</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">-20px</span>;</div></pre></td></tr></table></figure><p>需要注意的是，如果你对每个属性都指定了单位，那么不需要使用横杠分割。例如使用 m10e20e 可以生成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">margin</span>: 10<span class="selector-tag">em</span> 20<span class="selector-tag">em</span>;</div></pre></td></tr></table></figure><p>如果使用了横杠分割，那么属性值就变成负值了。例如使用 m10e-20e 就生成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">margin</span>: 10<span class="selector-tag">em</span> <span class="selector-tag">-20em</span>;</div></pre></td></tr></table></figure><p>如果你想一次生成多条语句，可以使用 <strong>“+”</strong> 连接两条语句，例如使用 h10p+m5e 可以生成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">height</span>: 10%;</div><div class="line"><span class="selector-tag">margin</span>: 5<span class="selector-tag">em</span>;</div></pre></td></tr></table></figure><p>颜色值也是可以快速生成的，例如 <code>c#3</code> 生成 <code>color: #333;</code>，更复杂一点的，使用 <code>bd5#0s</code> 可以生成 <code>border: 5px #000 solid;</code>。</p><p>下面是颜色值生成规则：</p><ul><li>‘#1’ → #111111</li><li>‘#e0’ → #e0e0e0</li><li>‘#fc0’ → #ffcc00</li></ul><p>生成 <code>!important</code> 这条语句也当然很简单，只需要一个 <strong>“!”</strong> 就可以了。</p><h3><span id="附加属性"><strong>附加属性</strong></span></h3><p>使用 @f 即可生成 CSS3 中的 font-face 的代码结构：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">font-face</span> &#123;</div><div class="line"><span class="attribute">font-family</span>:;</div><div class="line"><span class="attribute">src</span>:<span class="built_in">url</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是这个结构太简单，不包含一些其他的 font-face 的属性，诸如 background-image、 border-radius、 font、@font-face、 text-outline、 text-shadow 等属性，我们可以在生成的时候输入 <strong>“+”</strong> 生成增强的结构，例如我们可以输入 <code>@f+</code> 命令，即可输出选项增强版的 font-face 结构：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">font-face</span> &#123;</div><div class="line"><span class="attribute">font-family</span>: <span class="string">'FontName'</span>;</div><div class="line"><span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'FileName.eot'</span>);</div><div class="line"><span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'FileName.eot?#iefix'</span>) <span class="built_in">format</span>(<span class="string">'embedded-opentype'</span>),</div><div class="line"> <span class="built_in">url</span>(<span class="string">'FileName.woff'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),</div><div class="line"> <span class="built_in">url</span>(<span class="string">'FileName.ttf'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>),</div><div class="line"> <span class="built_in">url</span>(<span class="string">'FileName.svg#FontName'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>);</div><div class="line"><span class="attribute">font-style</span>: normal;</div><div class="line"><span class="attribute">font-weight</span>: normal;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="模糊匹配"><strong>模糊匹配</strong></span></h3><p>如果有些缩写你拿不准，Emmet 会根据你的输入内容匹配最接近的语法，比如输入 ov:h、ov-h、ovh 和 oh，生成的代码是相同的： </p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</div></pre></td></tr></table></figure><h3><span id="供应商前缀"><strong>供应商前缀</strong></span></h3><p>CSS3 等现在还没有出正式的 W3C 规范，但是很多浏览器已经实现了对应的功能，仅作为测试只用，所以在属性前面加上自己独特的供应商前缀，不同的浏览器只会识别带有自己规定前缀的样式。然而为了实现兼容性，我们不得不编写大量的冗余代码，而且要加上对应的前缀。使用 Emmet 可以快速生成带有前缀的 CSS3 属性。</p><p>在任意字符前面加上一条横杠（-），即可生成该属性的带前缀代码，例如输入 -foo-css，会生成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-webkit-foo-css</span>: ;</div><div class="line"><span class="selector-tag">-moz-foo-css</span>: ;</div><div class="line"><span class="selector-tag">-ms-foo-css</span>: ;</div><div class="line"><span class="selector-tag">-o-foo-css</span>: ;</div><div class="line"><span class="selector-tag">foo-css</span>: ;</div></pre></td></tr></table></figure><p>虽然 foo-css 并不是什么属性，但是照样可以生成。此外，你还可以详细的控制具体生成哪几个浏览器前缀或者先后顺序，使用 -wm-trf 即可生成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-webkit-transform</span>: ;</div><div class="line"><span class="selector-tag">-moz-transform</span>: ;</div><div class="line"><span class="selector-tag">transform</span>: ;</div></pre></td></tr></table></figure><p>可想而知，w 就是 webkit 前缀的缩写，m 是 moz 前缀缩写，s 是 ms 前缀缩写，o 就是 opera 浏览器前缀的缩写。如果使用 -osmw-abc 即可生成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-o-abc</span>: ;</div><div class="line"><span class="selector-tag">-ms-abc</span>: ;</div><div class="line"><span class="selector-tag">-moz-abc</span>: ;</div><div class="line"><span class="selector-tag">-webkit-abc</span>: ;</div><div class="line"><span class="selector-tag">abc</span>: ;</div></pre></td></tr></table></figure><h3><span id="渐变背景"><strong>渐变背景</strong></span></h3><p>CSS3 中新增加了一条属性 linear-gradient 使用这个属性可以直接制作出渐变的效果。但是这个属性的参数比较复杂，而且需要添加实验性前缀，无疑需要生成大量代码。而在 Emmet 中使用 lg() 指令即可快速生成，例如：使用 lg(left, #fff 50%, #000) 可以直接生成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">-webkit-gradient</span>(<span class="selector-tag">linear</span>, 0 0, 100% 0, <span class="selector-tag">color-stop</span>(0<span class="selector-class">.5</span>, <span class="selector-id">#fff</span>), <span class="selector-tag">to</span>(<span class="selector-id">#000</span>));</div><div class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">-webkit-linear-gradient</span>(<span class="selector-tag">left</span>, <span class="selector-id">#fff</span> 50%, <span class="selector-id">#000</span>);</div><div class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">-moz-linear-gradient</span>(<span class="selector-tag">left</span>, <span class="selector-id">#fff</span> 50%, <span class="selector-id">#000</span>);</div><div class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">-o-linear-gradient</span>(<span class="selector-tag">left</span>, <span class="selector-id">#fff</span> 50%, <span class="selector-id">#000</span>);</div><div class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">left</span>, <span class="selector-id">#fff</span> 50%, <span class="selector-id">#000</span>);</div></pre></td></tr></table></figure><h2><span id="附加功能">附加功能</span></h2><h3><span id="生成lorem-ipsum文本"><strong>生成Lorem ipsum文本</strong></span></h3><p>Lorem ipsum 指一篇常用于排版设计领域的拉丁文文章，主要目的是测试文章或文字在不同字型、版型下看起来的效果。通过 Emmet，你只需输入 <strong>lorem</strong> 或 <strong>lipsum</strong> 即可生成这些文字。还可以指定文字的个数，比如 <strong>lorem10</strong>，将生成：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="selector-tag">Lorem</span> <span class="selector-tag">ipsum</span> <span class="selector-tag">dolor</span> <span class="selector-tag">sit</span> <span class="selector-tag">amet</span>, <span class="selector-tag">consectetur</span> <span class="selector-tag">adipisicing</span> <span class="selector-tag">elit</span>. <span class="selector-tag">Explicabo</span>, <span class="selector-tag">esse</span>, <span class="selector-tag">provident</span>, <span class="selector-tag">nihil</span> <span class="selector-tag">laudantium</span> <span class="selector-tag">vitae</span> <span class="selector-tag">quam</span> <span class="selector-tag">natus</span> <span class="selector-tag">a</span> <span class="selector-tag">earum</span> <span class="selector-tag">assumenda</span> <span class="selector-tag">ex</span> <span class="selector-tag">vel</span> <span class="selector-tag">consectetur</span> <span class="selector-tag">fugiat</span> <span class="selector-tag">eveniet</span> <span class="selector-tag">minima</span> <span class="selector-tag">veritatis</span> <span class="selector-tag">blanditiis</span> <span class="selector-tag">molestiae</span> <span class="selector-tag">harum</span> <span class="selector-tag">est</span>!</div></pre></td></tr></table></figure></p><h3><span id="定制"><strong>定制</strong></span></h3><p>你还可以定制Emmet插件：</p><ul><li>添加新缩写或更新现有缩写，可修改 <a href="http://docs.emmet.io/customization/snippets/" target="_blank" rel="external">snippets.json</a> 文件</li><li>更改Emmet过滤器和操作的行为，可修改 <a href="http://docs.emmet.io/customization/preferences/" target="_blank" rel="external">preferences.json</a> 文件</li><li>定义如何生成HTML或XML代码，可修改 <a href="http://docs.emmet.io/customization/syntax-profiles/" target="_blank" rel="external">syntaxProfiles.json</a> 文件</li></ul><h3><span id="快捷键">快捷键</span></h3><ul><li><p>Ctrl+,<br>展开缩写</p></li><li><p>Ctrl+M<br>匹配对</p></li><li><p>Ctrl+H<br>使用缩写包括</p></li><li><p>Shift+Ctrl+M<br>合并行</p></li><li><p>Ctrl+Shift+?<br>上一个编辑点</p></li><li><p>Ctrl+Shift+?<br>下一个编辑点</p></li><li><p>Ctrl+Shift+?<br>定位匹配对</p></li></ul><h2><span id="最后">最后</span></h2><p>Emmet 的官方 API 列表<a href="http://docs.emmet.io/cheat-sheet/" target="_blank" rel="external">在这里</a>，有一个图片版本可以【<a href="http://bubkoo.qiniudn.com/emmet-api.jpg" target="_blank" rel="external">点此下载</a>】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前端开发的过程中，一个最繁琐的工作就是写 HTML、CSS 代码。数量繁多的标签、属性、尖括号、标签闭合等，让前端们甚是苦恼。于是，我向大家推荐 &lt;a href=&quot;http://emmet.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Emmet&lt;/a&gt;，它提供了一套非常简单的语法规则，书写起来非常爽快，然后只需要敲一个快捷键就立刻生成对应的 HTML 或 CSS 代码，极大提高了代码书写效率。&lt;/p&gt;
    
    </summary>
    
      <category term="前端工具" scheme="http://bubkoo.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="CSS" scheme="http://bubkoo.com/tags/css/"/>
    
      <category term="HTML" scheme="http://bubkoo.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>修改 Hexo 源码实现默认主题的 CSS 文件自动压缩</title>
    <link href="http://bubkoo.com/2014/01/03/compress-hexo&#39;s-default-css/"/>
    <id>http://bubkoo.com/2014/01/03/compress-hexo&#39;s-default-css/</id>
    <published>2014-01-03T03:18:03.000Z</published>
    <updated>2014-01-03T03:18:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>开始使用 <a href="http://zespia.tw/hexo/?utm_source=feedly" target="_blank" rel="external">HEXO</a> 时就发现默认主题 <strong>light</strong> 的 <strong>style.css</strong> 文件是没有经过压缩的，虽然文件本身不大，对博客加载速度不会有太大影响，但是作为喜欢折腾的程序猿，同时为了提升自身博客那么一点点的完美性，一直想去解决这个问题，由于工作比较忙，这个就一直压在心里，直到昨天写完博客，又开始折腾起来。下面记录了具体的修改方式，有需要的同学可以试试。</p><p>PS：本博的主题是基于默认主题稍作修改后的样式。</p><p>最开始想使用 <a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a> 来压缩，但是这样只能在博客文件目录内引入 Grunt 插件。这就使得文件结构不那么清晰，作为比较追求完美的我，最后还是放弃了该方式。什么？你还不知道 Grunt，那么你 out 很久了，简单的说 Grunt 就是前端自动化构建工具，实现 JS、CSS 文件合并和压缩什么的，飞一般的赶脚啊，有木有。。还有什么 CSS 预编译，JS 单元测试，都可以轻松搞定，如果你在前端开发过程中还在不停按 F5 刷新页面（另外有个工具叫 <a href="http://getf5.com/" target="_blank" rel="external"><strong>F5</strong></a>，不推荐使用，免费版每十分钟的弹窗太揪心了），推荐使用 Grunt 的 <strong>watch</strong> 和 <strong>livereload</strong> 插件，监视文件自动刷新，用起来太爽了，个人非常感谢 NodeJS 和 Grunt 给前端带来的便利。</p><p><img src="http://bubkoo.qiniudn.com/grunt-logo.png" alt="" title="牛逼的Grunt，LOGO也这么牛叉"><a id="more"></a></p><p>继续折腾吧，放弃了使用 Grunt，只能修改 HEXO 的源码了，由于 HEXO 是基于 NodeJS 的，所以可以直接修改其源码。首先找到 HEXO 安装位置，以Windows 平台为例，通过 <code>npm install hexo -g</code>安装 HEXO 的源码位置在<code>\AppData\Roaming\npm\node_modules\hexo</code>目录下，目录下面的<code>lib</code>文件夹就是 HEXO 的源代码。在目录下面探索了半天，终于找到 HEXO 编译 <a href="http://learnboost.github.io/stylus/" target="_blank" rel="external">Stylus</a> 文件的一些端倪，在源码中<code>\AppData\Roaming\npm\node_modules\hexo\lib\plugins\renderer\stylus.js</code>是编译 Stylus 的位置，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">data, options, callback</span>)</span>&#123;</div><div class="line">  stylus(data.text)</div><div class="line">    .use(nib())</div><div class="line">    .use(defineConfig)</div><div class="line">    .set(<span class="string">'filename'</span>, data.path)</div><div class="line">    .render(callback);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>通过 <a href="http://learnboost.github.io/stylus/docs/js.html" target="_blank" rel="external">Stylus官网</a> 了解到编译 Stylus 时是可以指定压缩选项的，知道了这个顿然兴奋（现在已经是凌晨1:30），好了我们在源码中加入设置压缩选项的代码<code>.set(&#39;compress&#39;, true)</code>，修改后如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">data, options, callback</span>) </span>&#123;</div><div class="line">  stylus(data.text)</div><div class="line">    .use(nib())</div><div class="line">    .use(defineConfig)</div><div class="line">    .set(<span class="string">'filename'</span>, data.path)</div><div class="line">    .set(<span class="string">'compress'</span>, <span class="literal">true</span>)</div><div class="line">    .render(callback);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>迫不及待，马上<code>hexo generate</code>，打开编译后的 CSS 文件一看</p><p><img src="http://bubkoo.qiniudn.com/hexo-css-compress.png" alt=""></p><p>虽然 CSS 确实被压缩了，但是不是我想要的那种压缩成一行的样子，SO，GO ON.</p><p>通过看源码，想到像引入编译 Stylus 插件一样，引入一个压缩 CSS 的插件，可以选择使用 <a href="https://github.com/yui/yuicompressor" target="_blank" rel="external">yuicompressor</a> 和 <a href="https://github.com/GoalSmashers/clean-css" target="_blank" rel="external">clean-css</a>，两个的使用方式基本相同。首先，在刚才的文件中引入 clean-css 插件：<code>var cleanCSS = require(&#39;clean-css&#39;);</code>，再修改源代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">data, options, callback</span>) </span>&#123;</div><div class="line">  stylus(data.text)</div><div class="line">    .use(nib())</div><div class="line">    .use(defineConfig)</div><div class="line">    .set(<span class="string">'filename'</span>, data.path)</div><div class="line">    .set(<span class="string">'compress'</span>, <span class="literal">true</span>)</div><div class="line">    .render(<span class="function"><span class="keyword">function</span>(<span class="params">err, css</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> compressed = <span class="keyword">new</span> cleanCSS().minify(css);</div><div class="line">      <span class="keyword">if</span> (callback) &#123;</div><div class="line">        callback.apply(<span class="literal">null</span>, [err, compressed]);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>简单分析一下，查看 Stylus 官方文档可知，<code>render</code>的调用方法是<code>render(function(err, css) {})</code>，该方法接受一个回调函数，在修改之前的 HEXO 源码中 render 传入了一个在其他模块设置好的<code>callback</code>方法，该方法成为<code>render</code>的回调函数，源码中的<code>callback</code>完成将编译后的 CSS 字符串写入到目标文件中，所以我们可以在写入文件之前，调用压缩 CCS 的方法<code>var compressed = new cleanCSS().minify(css);</code>，再将压缩后的 CSS 字符串作为参数传给预设的<code>callback</code>方法，最后调用<code>callback</code>写入目标文件。</p><p>好了，经测试该方法有效，可以查看本博<a href="http://bubkoo.com/css/style.css">源码</a>，其中的 <code>style.css</code> 就是压缩之后的。</p><p>最后，感谢 <a href="http://zespia.tw/hexo/?utm_source=feedly" target="_blank" rel="external">HEXO</a> 提供这么优秀的博客框架，感谢开源社区丰富的资源，希望他们越做越好，晚安啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始使用 &lt;a href=&quot;http://zespia.tw/hexo/?utm_source=feedly&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HEXO&lt;/a&gt; 时就发现默认主题 &lt;strong&gt;light&lt;/strong&gt; 的 &lt;strong&gt;style.css&lt;/strong&gt; 文件是没有经过压缩的，虽然文件本身不大，对博客加载速度不会有太大影响，但是作为喜欢折腾的程序猿，同时为了提升自身博客那么一点点的完美性，一直想去解决这个问题，由于工作比较忙，这个就一直压在心里，直到昨天写完博客，又开始折腾起来。下面记录了具体的修改方式，有需要的同学可以试试。&lt;/p&gt;
&lt;p&gt;PS：本博的主题是基于默认主题稍作修改后的样式。&lt;/p&gt;
&lt;p&gt;最开始想使用 &lt;a href=&quot;http://gruntjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Grunt&lt;/a&gt; 来压缩，但是这样只能在博客文件目录内引入 Grunt 插件。这就使得文件结构不那么清晰，作为比较追求完美的我，最后还是放弃了该方式。什么？你还不知道 Grunt，那么你 out 很久了，简单的说 Grunt 就是前端自动化构建工具，实现 JS、CSS 文件合并和压缩什么的，飞一般的赶脚啊，有木有。。还有什么 CSS 预编译，JS 单元测试，都可以轻松搞定，如果你在前端开发过程中还在不停按 F5 刷新页面（另外有个工具叫 &lt;a href=&quot;http://getf5.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;F5&lt;/strong&gt;&lt;/a&gt;，不推荐使用，免费版每十分钟的弹窗太揪心了），推荐使用 Grunt 的 &lt;strong&gt;watch&lt;/strong&gt; 和 &lt;strong&gt;livereload&lt;/strong&gt; 插件，监视文件自动刷新，用起来太爽了，个人非常感谢 NodeJS 和 Grunt 给前端带来的便利。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/grunt-logo.png&quot; alt=&quot;&quot; title=&quot;牛逼的Grunt，LOGO也这么牛叉&quot;&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://bubkoo.com/tags/hexo/"/>
    
      <category term="CSS" scheme="http://bubkoo.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>学习 ui-router 系列文章索引</title>
    <link href="http://bubkoo.com/2014/01/02/angular/ui-router/guide/index/"/>
    <id>http://bubkoo.com/2014/01/02/angular/ui-router/guide/index/</id>
    <published>2014-01-02T03:00:12.000Z</published>
    <updated>2014-01-02T03:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://angular-ui.github.io/" target="_blank" rel="external">Angular-Ui</a> 对于 <a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 开发者来说是一个非常重要的工具，其中 <a href="https://github.com/angular-ui/ui-router" target="_blank" rel="external">UI-Router</a> 又是重中之重。<a href="https://github.com/angular-ui/ui-router" target="_blank" rel="external">UI-Router</a> 插件提供了“嵌套作用域等规则”等有用的特性，对于复杂项目开发非常实用，最近在项目中开始使用 <a href="https://github.com/angular-ui/ui-router" target="_blank" rel="external">UI-Router</a> ，于是决定好好把它学习一遍，这些文章都来源于 <a href="https://github.com/angular-ui/ui-router/wiki" target="_blank" rel="external">UI-Router 的 github</a>，由于能力有限，有些地方没有看懂，另外还有一些地方只能意译出来，希望大家在参观的过程中指出其中的错误。</p><ol><li><a href="/2014/01/01/angular/ui-router/guide/state-manager/">学习 ui-router - 管理状态</a></li><li><a href="/2014/01/01/angular/ui-router/guide/nested-states%20&amp;%20nested-views/">学习 ui-router - 状态嵌套和视图嵌套</a></li><li><a href="/2014/01/01/angular/ui-router/guide/multiple-named-views/">学习 ui-router - 多个命名的视图</a></li><li><a href="/2014/01/02/angular/ui-router/guide/url-routing/">学习 ui-router - 路由控制</a></li><li><a href="/2014/01/02/angular/ui-router/guide/the-components/">学习 ui-router - 组件</a></li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://angular-ui.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Angular-Ui&lt;/a&gt; 对于 &lt;a href=&quot;http://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt; 开发者来说是一个非常重要的工具，其中 &lt;a href=&quot;https://github.com/angular-ui/ui-router&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UI-Router&lt;/a&gt; 又是重中之重。&lt;a href=&quot;https://github.com/angular-ui/ui-router&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UI-Router&lt;/a&gt; 插件提供了“嵌套作用域等规则”等有用的特性，对于复杂项目开发非常实用，最近在项目中开始使用 &lt;a href=&quot;https://github.com/angular-ui/ui-router&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UI-Router&lt;/a&gt; ，于是决定好好把它学习一遍，这些文章都来源于 &lt;a href=&quot;https://github.com/angular-ui/ui-router/wiki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UI-Router 的 github&lt;/a&gt;，由于能力有限，有些地方没有看懂，另外还有一些地方只能意译出来，希望大家在参观的过程中指出其中的错误。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/2014/01/01/angular/ui-router/guide/state-manager/&quot;&gt;学习 ui-router - 管理状态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2014/01/01/angular/ui-router/guide/nested-states%20&amp;amp;%20nested-views/&quot;&gt;学习 ui-router - 状态嵌套和视图嵌套&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2014/01/01/angular/ui-router/guide/multiple-named-views/&quot;&gt;学习 ui-router - 多个命名的视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2014/01/02/angular/ui-router/guide/url-routing/&quot;&gt;学习 ui-router - 路由控制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2014/01/02/angular/ui-router/guide/the-components/&quot;&gt;学习 ui-router - 组件&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://bubkoo.com/tags/angularjs/"/>
    
      <category term="Archives" scheme="http://bubkoo.com/tags/archives/"/>
    
      <category term="ui-router" scheme="http://bubkoo.com/tags/ui-router/"/>
    
  </entry>
  
  <entry>
    <title>学习 ui-router - 组件</title>
    <link href="http://bubkoo.com/2014/01/02/angular/ui-router/guide/the-components/"/>
    <id>http://bubkoo.com/2014/01/02/angular/ui-router/guide/the-components/</id>
    <published>2014-01-02T02:32:32.000Z</published>
    <updated>2014-01-02T02:32:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考原文：<a href="https://github.com/angular-ui/ui-router/wiki/The-Components" target="_blank" rel="external">https://github.com/angular-ui/ui-router/wiki/The-Components</a></p><ul><li><p><strong>$state / $stateProvider</strong>：管理状态定义、当前状态和状态转换。包含触发状态转换的事件和回调函数，异步解决目标状态的任何依赖项，更新<code>$location</code>到当前状态。由于状态包含关联的 url，通过$urlRouterProvider生成一个路由规则来执行转换的状态。</p></li><li><p><strong>ui-view</strong>指示器：渲染状态中定义的视图，是状态中定义的视图的一个占位符。</p></li><li><p><strong>$urlRouter / $urlRouterProvider</strong>：管理了一套路由规则列表来处理当<code>$location</code>发生变化时如何跳转。最低级的方式是，规则可以是任意函数，来检查<code>$location</code>，并在处理完成时候返回<code>true</code>。支持正则表达式规则和通过<code>$urlMatcherFactory</code>编译的<code>UrlMatcher</code>对象的 url 占位符规则。</p></li><li><p><strong>$urlMatcherFactory</strong>：将 url和占位符编译为<code>UrlMatcher</code>对象。除了<code>$routeProvider</code>支持的占位符语法之外，它还支持扩展语法，允许一个正则表达式指定占位符，并且能够提取命名参数和查询url的一部分。</p></li><li><p><strong>$templateFactory</strong> - 通过<code>$http</code> / <code>$templateCache</code>来加载模板，供状态配置中使用。</p><a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考原文：&lt;a href=&quot;https://github.com/angular-ui/ui-router/wiki/The-Components&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/angular-ui/ui-router/wiki/The-Components&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;$state / $stateProvider&lt;/strong&gt;：管理状态定义、当前状态和状态转换。包含触发状态转换的事件和回调函数，异步解决目标状态的任何依赖项，更新&lt;code&gt;$location&lt;/code&gt;到当前状态。由于状态包含关联的 url，通过$urlRouterProvider生成一个路由规则来执行转换的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ui-view&lt;/strong&gt;指示器：渲染状态中定义的视图，是状态中定义的视图的一个占位符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;$urlRouter / $urlRouterProvider&lt;/strong&gt;：管理了一套路由规则列表来处理当&lt;code&gt;$location&lt;/code&gt;发生变化时如何跳转。最低级的方式是，规则可以是任意函数，来检查&lt;code&gt;$location&lt;/code&gt;，并在处理完成时候返回&lt;code&gt;true&lt;/code&gt;。支持正则表达式规则和通过&lt;code&gt;$urlMatcherFactory&lt;/code&gt;编译的&lt;code&gt;UrlMatcher&lt;/code&gt;对象的 url 占位符规则。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;$urlMatcherFactory&lt;/strong&gt;：将 url和占位符编译为&lt;code&gt;UrlMatcher&lt;/code&gt;对象。除了&lt;code&gt;$routeProvider&lt;/code&gt;支持的占位符语法之外，它还支持扩展语法，允许一个正则表达式指定占位符，并且能够提取命名参数和查询url的一部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;$templateFactory&lt;/strong&gt; - 通过&lt;code&gt;$http&lt;/code&gt; / &lt;code&gt;$templateCache&lt;/code&gt;来加载模板，供状态配置中使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://bubkoo.com/tags/angularjs/"/>
    
      <category term="ui-router" scheme="http://bubkoo.com/tags/ui-router/"/>
    
  </entry>
  
  <entry>
    <title>学习 ui-router - 路由控制</title>
    <link href="http://bubkoo.com/2014/01/02/angular/ui-router/guide/url-routing/"/>
    <id>http://bubkoo.com/2014/01/02/angular/ui-router/guide/url-routing/</id>
    <published>2014-01-02T00:39:20.000Z</published>
    <updated>2014-01-02T00:39:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考原文：<a href="https://github.com/angular-ui/ui-router/wiki/URL-Routing" target="_blank" rel="external">https://github.com/angular-ui/ui-router/wiki/URL-Routing</a></p><p>在你的应用中大多数状态都有与其相关联的 url，路由控制不是设计完成 state 之后的事后想法，而是开始开发时就应该考虑的问题。</p><p>这里是如何设置一个基本url。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">    .state(<span class="string">'contacts'</span>, &#123;</div><div class="line">        url: <span class="string">"/contacts"</span>,</div><div class="line">        templateUrl: <span class="string">'contacts.html'</span></div><div class="line">    &#125;)</div></pre></td></tr></table></figure><p>当我们访问<code>index.html/contacts</code>时， <code>&#39;contacts&#39;</code>状态将被激活，同时<code>index.html</code>中的<code>ui-view</code>将被<code>&#39;contacts.html&#39;</code>填充。或者，通过<code>transitionTo(&#39;contacts&#39;)</code>方法将状态转变到<code>&#39;contacts&#39;</code>状态，同时 url 将更新为<code>index.html/contacts</code>。<br><a id="more"></a></p><h2><span id="url参数">URL参数</span></h2><h3><span id="基本参数">基本参数</span></h3><p>通常，url动态部分被称为参数，有几个选项用于指定参数。基本参数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">    .state(<span class="string">'contacts.detail'</span>, &#123;</div><div class="line">        <span class="comment">// 这里设置了url参数</span></div><div class="line">        url: <span class="string">"/contacts/:contactId"</span>,</div><div class="line">        templateUrl: <span class="string">'contacts.detail.html'</span>,</div><div class="line">        controller: <span class="function"><span class="keyword">function</span> (<span class="params">$stateParams</span>) </span>&#123;</div><div class="line">            <span class="comment">// If we got here from a url of /contacts/42</span></div><div class="line">            expect($stateParams).toBe(&#123;<span class="attr">contactId</span>: <span class="number">42</span>&#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;)</div></pre></td></tr></table></figure><p>或者，你也可以使用花括号的方式来指定参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 与前面的设置方法等效</span></div><div class="line">url: <span class="string">"/contacts/&#123;contactId&#125;"</span></div></pre></td></tr></table></figure><p><strong>示例：</strong></p><ul><li><code>&#39;/hello/&#39;</code> - 只匹配<code>&#39;/hello/&#39;</code>路径，没有对斜杠进行特殊处理，这种模式将匹配整个路径，而不仅仅是一个前缀。</li><li><code>&#39;/user/:id&#39;</code> - 匹配<code>&#39;/user/bob&#39;</code>、<code>&#39;/user/1234!!!&#39;</code>，甚至还匹配 <code>&#39;/user/&#39;</code>，但是不匹配<code>&#39;/user&#39;</code>和<code>&#39;/user/bob/details&#39;</code>。第二个路径段将被捕获作为参数<code>&quot;id&quot;</code>。</li><li><code>&#39;/user/{id}&#39;</code> - 与前面的示例相同,但使用花括号语法。</li></ul><h3><span id="含正则表达式的参数">含正则表达式的参数</span></h3><p>使用花括号的方式可以设置一个正则表达式规则的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只会匹配 contactId 为1到8位的数字</span></div><div class="line">url: <span class="string">"/contacts/&#123;contactId:[0-9]&#123;1,8&#125;&#125;"</span></div></pre></td></tr></table></figure><p><strong>示例：</strong></p><ul><li><code>&#39;/user/{id:[^/]*}&#39;</code> - 与<code>&#39;/user/{id}&#39;</code>相同</li><li><code>&#39;/user/{id:[0-9a-fA-F]{1,8}}&#39;</code> - 与前面的示例相似，但只匹配1到8为的数字和字符</li><li><code>&#39;/files/{path:.*}&#39;</code> - 匹配任何以<code>&#39;/files/&#39;</code>开始的URL路径，并且捕获剩余路径到参数<code>&#39;path&#39;</code>中。</li><li><code>&#39;/files/*path&#39;</code> - 与前面相同，捕获所有特殊的语法。</li></ul><p><strong>警告：</strong>不要把捕获圆括号写进正则表达式，ui-router 的 UrlMatcher 将为整个正则表达式添加捕获。</p><h3><span id="query-parameters">Query Parameters</span></h3><p>可以通过<code>?</code>来指定参数作为查询参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">url: <span class="string">"/contacts?myParam"</span></div><div class="line"><span class="comment">// 匹配 "/contacts?myParam=value"</span></div></pre></td></tr></table></figure><p>如果你需要不止一个查询参数，请用<code>&amp;</code>分隔：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">url: <span class="string">"/contacts?myParam1&amp;myParam2"</span></div><div class="line"><span class="comment">// 匹配 "/contacts?myParam1=value1&amp;myParam2=wowcool"</span></div></pre></td></tr></table></figure></p><h2><span id="嵌套状态的路由控制">嵌套状态的路由控制</span></h2><h3><span id="附加的方式默认">附加的方式（默认）</span></h3><p>在嵌套状态的路由控制中，默认方式是子状态的 url 附加到父状态的 url 之后。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">  .state(<span class="string">'contacts'</span>, &#123;</div><div class="line">     url: <span class="string">'/contacts'</span>,</div><div class="line">     ...</div><div class="line">  &#125;)</div><div class="line">  .state(<span class="string">'contacts.list'</span>, &#123;</div><div class="line">     url: <span class="string">'/list'</span>,</div><div class="line">     ...</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>路由将成为：</p><ul><li><code>&#39;contacts&#39;</code>状态将匹配<code>&quot;/contacts&quot;</code></li><li><code>&#39;contacts.list&#39;</code>状态将匹配<code>&quot;/contacts/list&quot;</code>。子状态的url是附在父状态的url之后的。</li></ul><h3><span id="绝对路由">绝对路由（^）</span></h3><p>如果你使用绝对 url 匹配的方式，那么你需要给你的url字符串加上特殊符号<code>&quot;^&quot;</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">  .state(<span class="string">'contacts'</span>, &#123;</div><div class="line">     url: <span class="string">'/contacts'</span>,</div><div class="line">     ...</div><div class="line">  &#125;)</div><div class="line">  .state(<span class="string">'contacts.list'</span>, &#123;</div><div class="line">     url: <span class="string">'^/list'</span>,</div><div class="line">     ...</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>路由将成为：</p><ul><li><code>&#39;contacts&#39;</code>状态将匹配<code>&quot;/contacts&quot;</code></li><li><code>&#39;contacts.list&#39;</code>状态将匹配<code>&quot;/list&quot;</code>。子状态的url没有附在父状态的url之后的，因为使用了<code>^</code>。</li></ul><h2><span id="stateparams-服务">$stateParams 服务</span></h2><p>之前看到的<code>$stateParams</code>服务是一个对象，包含 url 中每个参数的键/值。<code>$stateParams</code>可以为控制器或者服务提供 url 的各个部分。<br><strong>注意：</strong><code>$stateParams</code>服务必须与一个控制器相关，并且<code>$stateParams</code>中的“键/值”也必须事先在那个控制器的<code>url</code>属性中有定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果状态中 url 属性是：</span></div><div class="line">url: <span class="string">'/users/:id/details/&#123;type&#125;/&#123;repeat:[0-9]+&#125;?from&amp;to'</span></div><div class="line"></div><div class="line"><span class="comment">// 当浏览</span></div><div class="line"><span class="string">'/users/123/details//0'</span></div><div class="line"></div><div class="line"><span class="comment">// $stateParams 对象将是</span></div><div class="line">&#123; <span class="attr">id</span>:<span class="string">'123'</span>, <span class="attr">type</span>:<span class="string">''</span>, <span class="attr">repeat</span>:<span class="string">'0'</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 当浏览</span></div><div class="line"><span class="string">'/users/123/details/default/0?from=there&amp;to=here'</span></div><div class="line"></div><div class="line"><span class="comment">// $stateParams 对象将是</span></div><div class="line">&#123; <span class="attr">id</span>:<span class="string">'123'</span>, <span class="attr">type</span>:<span class="string">'default'</span>, <span class="attr">repeat</span>:<span class="string">'0'</span>, <span class="attr">from</span>:<span class="string">'there'</span>, <span class="attr">to</span>:<span class="string">'here'</span> &#125;</div></pre></td></tr></table></figure><h3><span id="使用stateparams的两个陷阱">使用<code>$stateParams</code>的两个陷阱</span></h3><ul><li>只有当状态被激活并且状态的所有依赖项都被注入时，<code>$stateParams</code>对象才存在。这代表你不能再状态的<code>resolve</code>函数中使用<code>$stateParams</code>对象，可以使用<code>$state.current.params</code>来代替。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'contacts.detail'</span>, &#123;  </div><div class="line">   resolve: &#123; </div><div class="line">      someResolve: <span class="function"><span class="keyword">function</span>(<span class="params">$state</span>)</span>&#123; </div><div class="line">         <span class="comment">//*** 不能在这里使用 $stateParams , the service is not ready ***//</span></div><div class="line">         <span class="comment">//*** 使用 $state.current.params 来代替 ***//</span></div><div class="line">         <span class="keyword">return</span> $state.current.params.contactId + <span class="string">"!"</span> </div><div class="line">      &#125;; </div><div class="line">   &#125;,</div><div class="line">   <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><ul><li>在状态控制器中，<code>$stateParams</code>对象只包含那些在状态中定义的参数，因此你不能访问在其他状态或者祖先状态中定义的参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'contacts.detail'</span>, &#123;</div><div class="line">   url: <span class="string">'/contacts/:contactId'</span>,   </div><div class="line">   controller: <span class="function"><span class="keyword">function</span>(<span class="params">$stateParams</span>)</span>&#123;</div><div class="line">      $stateParams.contactId  <span class="comment">//*** Exists! ***//</span></div><div class="line">   &#125;</div><div class="line">&#125;).state(<span class="string">'contacts.detail.subitem'</span>, &#123;</div><div class="line">   url: <span class="string">'/item/:itemId'</span>, </div><div class="line">   controller: <span class="function"><span class="keyword">function</span>(<span class="params">$stateParams</span>)</span>&#123;</div><div class="line">      $stateParams.contactId <span class="comment">//*** 注意! DOESN'T EXIST!! ***//</span></div><div class="line">      $stateParams.itemId <span class="comment">//*** Exists! ***//  </span></div><div class="line">   &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2><span id="urlrouterprovider">$urlRouterProvider</span></h2><p><code>$urlRouterProvider</code>负责处理在状态配置中指定的url路由方式之外的 url 请求的路由方式。<code>$urlRouterProvider</code>负责监视<code>$location</code>，当<code>$location</code>改变后，<code>$urlRouterProvider</code>将从一个列表，一个接一个查找匹配项，直到找到。所有 url 都编译成一个<code>UrlMatcher</code>对象。</p><p><code>$urlRouterProvider</code>有一些实用的方法，可以在<code>module.config</code>中直接使用。</p><p><strong><code>when()</code> for redirection 重定向</strong></p><p>参数：</p><ul><li><code>what</code> <strong>String | RegExp | UrlMatcher</strong>，你想重定向的传入路径</li><li><code>handler</code> <strong>String | Function</strong> 将要重定向到的路径</li></ul><p><code>handler</code> 作为 <strong>String</strong><br>如果<code>handler</code>是字符串，它被视为一个重定向，并且根据匹配语法决定重定向的地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.config(<span class="function"><span class="keyword">function</span>(<span class="params">$urlRouterProvider</span>)</span>&#123;</div><div class="line">    <span class="comment">// when there is an empty route, redirect to /index   </span></div><div class="line">    $urlRouterProvider.when(<span class="string">''</span>, <span class="string">'/index'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// You can also use regex for the match parameter</span></div><div class="line">    $urlRouterProvider.when(<span class="string">'/aspx/i'</span>, <span class="string">'/index'</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><code>handler</code> 作为 <strong>Function</strong><br>如果<code>handler</code>是一个函数，这个函数是注入一些服务的。如果<code>$location</code>匹配成功，函数将被调用。你可以选择性注入<code>$match</code>。</p><p>函数可以返回：</p><ul><li><strong>falsy</strong> 表明规则不匹配，<code>$urlRouter</code>将试图寻找另一个匹配</li><li><strong>String</strong> 该字符串作为重定向地址并且作为参数传递给<code>$location.url()</code></li><li><strong>nothing</strong>或者任何为真的值，告诉<code>$urlRouter</code>url 已经被处理</li></ul><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$urlRouterProvider.when(state.url, [<span class="string">'$match'</span>, <span class="string">'$stateParams'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$match, $stateParams</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) &#123;</div><div class="line">        $state.transitionTo(state, $match, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;]);</div></pre></td></tr></table></figure><p><strong><code>otherwise()</code> 无效路由</strong></p><p>参数：</p><ul><li><code>path</code> <strong>String | Function</strong> 你想重定向url路径或者一个函数返回url路径。函数可以包含<code>$injector</code>和<code>$location</code>两个参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">app.config(<span class="function"><span class="keyword">function</span>(<span class="params">$urlRouterProvider</span>)</span>&#123;</div><div class="line">    <span class="comment">// 在配置（状态配置和when()方法）中没有找到url的任何匹配</span></div><div class="line">    <span class="comment">// otherwise will take care of routing the user to the specified url</span></div><div class="line">    $urlRouterProvider.otherwise(<span class="string">'/index'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Example of using function rule as param</span></div><div class="line">    $urlRouterProvider.otherwise(<span class="function"><span class="keyword">function</span>(<span class="params">$injector, $location</span>)</span>&#123;</div><div class="line">        ... some advanced code...</div><div class="line">    &#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><strong><code>rule()</code> 自定义url处理</strong></p><p>参数：</p><ul><li><code>handler</code> <strong>Function</strong> 一个函数，包含<code>$injector</code>和<code>$location</code>两个服务作为参数，函数负责返回一个有效的路径的字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.config(<span class="function"><span class="keyword">function</span>(<span class="params">$urlRouterProvider</span>)</span>&#123;</div><div class="line">    <span class="comment">// Here's an example of how you might allow case insensitive urls</span></div><div class="line">    $urlRouterProvider.rule(<span class="function"><span class="keyword">function</span> (<span class="params">$injector, $location</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> path = $location.path(), normalized = path.toLowerCase();</div><div class="line">        <span class="keyword">if</span> (path != normalized) <span class="keyword">return</span> normalized;</div><div class="line">    &#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2><span id="urlmatcherfactory-和-urlmatchers">$urlMatcherFactory 和 UrlMatchers</span></h2><p>定义了url模式和参数占位符的语法。<code>$urlMatcherFactory</code>是在幕后被<code>$urlRouterProvider</code>调用，来缓存编译后的<code>UrlMatcher</code>对象，而不必在每次 location 改变后重新解析url。大多数用户不需要直接使用<code>$urlMatcherFactory</code>方法，但是在状态配置中非常实用，可以使用<code>$urlMatcherFactory</code>方法来生成一个<code>UrlMatcher</code>对象，并在状态配置中使用该对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> urlMatcher = $urlMatcherFactory.compile(<span class="string">"/home/:id?param1"</span>);</div><div class="line">$stateProvider.state(<span class="string">'myState'</span>, &#123;</div><div class="line">    url: urlMatcher </div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考原文：&lt;a href=&quot;https://github.com/angular-ui/ui-router/wiki/URL-Routing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/angular-ui/ui-router/wiki/URL-Routing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在你的应用中大多数状态都有与其相关联的 url，路由控制不是设计完成 state 之后的事后想法，而是开始开发时就应该考虑的问题。&lt;/p&gt;
&lt;p&gt;这里是如何设置一个基本url。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$stateProvider&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .state(&lt;span class=&quot;string&quot;&gt;&#39;contacts&#39;&lt;/span&gt;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        url: &lt;span class=&quot;string&quot;&gt;&quot;/contacts&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        templateUrl: &lt;span class=&quot;string&quot;&gt;&#39;contacts.html&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当我们访问&lt;code&gt;index.html/contacts&lt;/code&gt;时， &lt;code&gt;&amp;#39;contacts&amp;#39;&lt;/code&gt;状态将被激活，同时&lt;code&gt;index.html&lt;/code&gt;中的&lt;code&gt;ui-view&lt;/code&gt;将被&lt;code&gt;&amp;#39;contacts.html&amp;#39;&lt;/code&gt;填充。或者，通过&lt;code&gt;transitionTo(&amp;#39;contacts&amp;#39;)&lt;/code&gt;方法将状态转变到&lt;code&gt;&amp;#39;contacts&amp;#39;&lt;/code&gt;状态，同时 url 将更新为&lt;code&gt;index.html/contacts&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://bubkoo.com/tags/angularjs/"/>
    
      <category term="ui-router" scheme="http://bubkoo.com/tags/ui-router/"/>
    
  </entry>
  
  <entry>
    <title>学习 ui-router - 多个命名的视图</title>
    <link href="http://bubkoo.com/2014/01/01/angular/ui-router/guide/multiple-named-views/"/>
    <id>http://bubkoo.com/2014/01/01/angular/ui-router/guide/multiple-named-views/</id>
    <published>2014-01-01T23:01:44.000Z</published>
    <updated>2014-01-01T23:01:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考原文：<a href="https://github.com/angular-ui/ui-router/wiki/Multiple-Named-Views" target="_blank" rel="external">https://github.com/angular-ui/ui-router/wiki/Multiple-Named-Views</a></p><p>可以给<code>ui-view</code>指定名称，这样一个模板中就可以有多个<code>ui-view</code>。假设您有一个应用，需要动态填充<code>graph</code>、<code>table data</code>和<code>filters</code>，像下面这样：</p><p><img src="http://bubkoo.qiniudn.com/MultipleNamedViewsExample.png" alt=""></p><p>当您需要使用多视图时，需要用到状态的<code>views</code>属性，<code>views</code>属性值是一个对象。</p><a id="more"></a><h2><span id="设置views属性将覆盖覆盖的template属性">设置<code>views</code>属性将覆盖覆盖的<code>template</code>属性</span></h2><p>如果在状态中定义了<code>views</code>属性，那么状态中的<code>templateUrl</code>、<code>template</code> 和 <code>templateProvider</code>属性将被忽略。</p><h3><span id="示例-名称匹配">示例 - 名称匹配</span></h3><p><code>views</code>的属性<code>key</code>应该对应的<code>ui-view</code>的名称、像下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"filters"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"tabledata"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"graph"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">  .state(<span class="string">'report'</span>, &#123;</div><div class="line">    views: &#123;</div><div class="line">      <span class="string">'filters'</span>: &#123; ... templates and/or controllers ... &#125;,</div><div class="line">      <span class="string">'tabledata'</span>: &#123;&#125;,</div><div class="line">      <span class="string">'graph'</span>: &#123;&#125;,</div><div class="line">    &#125;</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p>然后<code>views</code>中的每一个 view 都可以设置自身的模板属性（<code>template</code>，<code>templateUrl</code>，<code>templateProvider</code>） 和控制器属性（<code>controller</code>，<code>controllerProvider</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">  .state(<span class="string">'report'</span>,&#123;</div><div class="line">    views: &#123;</div><div class="line">      <span class="string">'filters'</span>: &#123;</div><div class="line">        templateUrl: <span class="string">'report-filters.html'</span>,</div><div class="line">        controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123; ... controller stuff just <span class="keyword">for</span> filters view ... &#125;</div><div class="line">      &#125;,</div><div class="line">      <span class="string">'tabledata'</span>: &#123;</div><div class="line">        templateUrl: <span class="string">'report-table.html'</span>,</div><div class="line">        controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123; ... controller stuff just <span class="keyword">for</span> tabledata view ... &#125;</div><div class="line">      &#125;,</div><div class="line">      <span class="string">'graph'</span>: &#123;</div><div class="line">        templateUrl: <span class="string">'report-graph.html'</span>,</div><div class="line">        controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123; ... controller stuff just <span class="keyword">for</span> graph view ... &#125;</div><div class="line">      &#125;,</div><div class="line">    &#125;</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><h2><span id="视图名称-相对命名与绝对命名">视图名称 - 相对命名与绝对命名</span></h2><p>在定义<code>views</code>属性时，如果视图名称中包含<code>@</code>，那么视图名称就是绝对命名的方式，否则就是相对命名的方式。相对命名的意思是相对于父模板中的<code>ui-view</code>，而绝对命名则指定了相对于哪个状态的模板。</p><p>在 ui-router 内部，<code>views</code>属性中的每个视图都被按照<code>viewname@statename</code>的方式分配为绝对名称，<code>viewname</code>是目标模板中的<code>ui-view</code>对应的名称，<code>statename</code>是状态的名称，状态名称对应于一个目标模板。<code>@</code>前面部分为空表示未命名的<code>ui-view</code>，<code>@</code>后面为空则表示相对于根模板，通常是 index.html。</p><p>例如，上面的例子可以写成如下方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.state(<span class="string">'report'</span>,&#123;</div><div class="line">  views: &#123;</div><div class="line">    <span class="string">'filters@'</span>: &#123; &#125;,</div><div class="line">    <span class="string">'tabledata@'</span>: &#123; &#125;,</div><div class="line">    <span class="string">'graph@'</span>: &#123; &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>注意，这样的写法，视图的名称指定为绝对的名字，而不是相对的名字。这样 ‘filters’，’tabledata’和’graph’三个视图将加载到根视图的模板中(由于没有父状态，则根模板就是index.html)。</p><p>绝对命名的方式可以让我们完成一些强大的功能，让我们假设我们有几个模板设置（这里仅仅作为实例演示，有些不现实的地方），像下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html (root unnamed template) --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-app</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- contacts.html plugs in here --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"status"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- contacts.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My Contacts<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"detail"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- contacts.detail.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Contacts Details<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"info"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>让我们来看看在<code>contacts.detail</code>状态中，相对命名和绝对命名的各种使用方式，请注意，一旦使用了<code>@</code>则表示绝对命名的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">  .state(<span class="string">'contacts'</span>, &#123;</div><div class="line">    <span class="comment">// 根状态，对应的父模板则是index.html</span></div><div class="line">    <span class="comment">// 所以 contacts.html 将被加载到 index.html 中未命名的 ui-view 中</span></div><div class="line">    templateUrl: <span class="string">'contacts.html'</span>   </div><div class="line">  &#125;)</div><div class="line">  .state(<span class="string">'contacts.detail'</span>, &#123;</div><div class="line">    views: &#123;</div><div class="line">        <span class="comment">// 嵌套状态，对应的父模板是 contacts.html</span></div><div class="line"></div><div class="line">        <span class="comment">// 相对命名</span></div><div class="line">        <span class="comment">// contacts.html 中 &lt;div ui-view='detail'/&gt; 将对应下面</span></div><div class="line">        <span class="string">"detail"</span> : &#123; &#125;,   </div><div class="line">         </div><div class="line">        <span class="comment">// 相对命名</span></div><div class="line">        <span class="comment">// 对应 contacts.html 中的未命名 ui-view &lt;div ui-view/&gt;</span></div><div class="line">        <span class="string">""</span> : &#123; &#125;, </div><div class="line"></div><div class="line">        <span class="comment">// 绝对命名</span></div><div class="line">        <span class="comment">// 对应 contacts.detail.html 中 &lt;div ui-view='info'/&gt;</span></div><div class="line">        <span class="string">"info@contacts.detail"</span> : &#123; &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 绝对命名</span></div><div class="line">        <span class="comment">// 对应 contacts.html 中 &lt;div ui-view='detail'/&gt;</span></div><div class="line">        <span class="string">"detail@contacts"</span> : &#123; &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 绝对命名</span></div><div class="line">        <span class="comment">// 对应 contacts.html 中的未命名 ui-view &lt;div ui-view/&gt;</span></div><div class="line">        <span class="string">"@contacts"</span> : &#123; &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 绝对命名</span></div><div class="line">        <span class="comment">// 对应 index.html 中 &lt;div ui-view='status'/&gt; </span></div><div class="line">        <span class="string">"status@"</span> : &#123; &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 绝对命名</span></div><div class="line">        <span class="comment">// 对应 index.html 中 &lt;div ui-view/&gt;</span></div><div class="line">        <span class="string">"@"</span> : &#123; &#125; </div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>你将发现，不仅仅可以在同一状态设置多个视图，而且祖先状态可以由开发者自由控制:)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考原文：&lt;a href=&quot;https://github.com/angular-ui/ui-router/wiki/Multiple-Named-Views&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/angular-ui/ui-router/wiki/Multiple-Named-Views&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以给&lt;code&gt;ui-view&lt;/code&gt;指定名称，这样一个模板中就可以有多个&lt;code&gt;ui-view&lt;/code&gt;。假设您有一个应用，需要动态填充&lt;code&gt;graph&lt;/code&gt;、&lt;code&gt;table data&lt;/code&gt;和&lt;code&gt;filters&lt;/code&gt;，像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bubkoo.qiniudn.com/MultipleNamedViewsExample.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当您需要使用多视图时，需要用到状态的&lt;code&gt;views&lt;/code&gt;属性，&lt;code&gt;views&lt;/code&gt;属性值是一个对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://bubkoo.com/tags/angularjs/"/>
    
      <category term="ui-router" scheme="http://bubkoo.com/tags/ui-router/"/>
    
  </entry>
  
  <entry>
    <title>学习 ui-router - 状态嵌套和视图嵌套</title>
    <link href="http://bubkoo.com/2014/01/01/angular/ui-router/guide/nested-states%20&amp;%20nested-views/"/>
    <id>http://bubkoo.com/2014/01/01/angular/ui-router/guide/nested-states &amp; nested-views/</id>
    <published>2014-01-01T20:55:08.000Z</published>
    <updated>2014-01-01T20:55:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考原文：<a href="https://github.com/angular-ui/ui-router/wiki/Nested-States-%26-Nested-Views" target="_blank" rel="external">https://github.com/angular-ui/ui-router/wiki/Nested-States-%26-Nested-Views</a></p><h2><span id="状态嵌套的方法">状态嵌套的方法</span></h2><p>状态可以相互嵌套。有三个嵌套的方法：</p><ol><li>使用“点标记法”，例如：<code>.state(&#39;contacts.list&#39;, {})</code></li><li>使用<code>parent</code>属性，指定一个父状态的名称字符串，例如：<code>parent: &#39;contacts&#39;</code></li><li>使用<code>parent</code>属性，指定一个父状态对象，例如：<code>parent: contacts</code>（contacts 是一个状态对象）</li></ol><a id="more"></a><h3><span id="点标记法">点标记法</span></h3><p>在<code>$stateProvider</code>中可以使用点语法来表示层次结构，下面，<code>contacts.list</code>是<code>contacts</code>的子状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">  .state(<span class="string">'contacts'</span>, &#123;&#125;)</div><div class="line">  .state(<span class="string">'contacts.list'</span>, &#123;&#125;);</div></pre></td></tr></table></figure><h3><span id="使用parent属性指定一个父状态的名称字符串">使用<code>parent</code>属性，指定一个父状态的名称字符串</span></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">  .state(<span class="string">'contacts'</span>, &#123;&#125;)</div><div class="line">  .state(<span class="string">'list'</span>, &#123;</div><div class="line">    parent: <span class="string">'contacts'</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure><h3><span id="基于对象的状态">基于对象的状态</span></h3><p>如果你不喜欢使用基于字符串的状态，您还可以使用基于对象的状态。<code>name</code>属性将在状态对象内部设置，在所有的子状态对象中设置<code>parent</code>属性为父状态对象，像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> contacts = &#123; </div><div class="line">    name: <span class="string">'contacts'</span>,  <span class="comment">//mandatory</span></div><div class="line">    templateUrl: <span class="string">'contacts.html'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> contactsList = &#123; </div><div class="line">    name: <span class="string">'list'</span>,      <span class="comment">//mandatory</span></div><div class="line">    parent: contacts,  <span class="comment">//mandatory</span></div><div class="line">    templateUrl: <span class="string">'contacts.list.html'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">$stateProvider</div><div class="line">  .state(contacts)</div><div class="line">  .state(contactsList)</div></pre></td></tr></table></figure><p>在方法调用和属性比较时可以直接引用状态对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$state.transitionTo(states.contacts);</div><div class="line">$state.current === states.contacts;</div><div class="line">$state.includes(states.contacts)</div></pre></td></tr></table></figure><h2><span id="注册状态的顺序">注册状态的顺序</span></h2><p>可以以<strong>任何顺序</strong>和<strong>跨模块</strong>注册状态，也可以在父状态存在之前注册子状态。一旦父状态被注册，将触发自动排序，然后注册子状态。</p><h2><span id="状态命名">状态命名</span></h2><p>状态不允许重名，当使用“点标记法”，<code>parent</code>属性被推测出来，但这并不会改变状态的名字；当不使用“点标记法”时，<code>parent</code>属性必须明确指定，但你仍然不能让任何两个状态有相同的名称，例如你不能有两个不同的状态命名为”edit”，即使他们有不同的父状态。</p><h2><span id="嵌套状态和视图">嵌套状态和视图</span></h2><p>当应用程序在一个特定的状态 - 当一个状态是活动状态时 - 其所有的父状态都将成为活跃状态。下面例子中，当”contacts.list”是活跃状态时，”contacts”也将隐性成为活跃状态，因为他是”contacts.list”的父状态。</p><p>子状态将把其对应的模板加载到父状态对应模板的<code>ui-view</code>中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">  .state(<span class="string">'contacts'</span>, &#123;</div><div class="line">    templateUrl: <span class="string">'contacts.html'</span>,</div><div class="line">    controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123;</div><div class="line">      $scope.contacts = [&#123; <span class="attr">name</span>: <span class="string">'Alice'</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'Bob'</span> &#125;];</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  .state(<span class="string">'contacts.list'</span>, &#123;</div><div class="line">    templateUrl: <span class="string">'contacts.list.html'</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MainCtrl</span>(<span class="params">$state</span>)</span>&#123;</div><div class="line">  $state.transitionTo(<span class="string">'contacts.list'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-controller</span>=<span class="string">"MainCtrl"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- contacts.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My Contacts<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- contacts.list.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"contact in contacts"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>&#123;&#123;contact.name&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="子状态将从父状态继承哪些属性">子状态将从父状态继承哪些属性？</span></h3><p>子状态将从父母继承以下属性：</p><ul><li>通过解决器解决的依赖注入项</li><li>自定义的<code>data</code>属性<br>除了这些，没有其他属性继承下来（比如<code>controllers</code>、<code>templates</code>和<code>url</code>等）</li></ul><h4><span id="继承解决的依赖项">继承解决的依赖项</span></h4><p>版本 v0.2.0 的新特性</p><p>子状态将从父状态继承通过解决器解决的依赖注入项，并且可以重写（overwrite）依赖项，可以将解决依赖项注入子状态的控制器和解决函数中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'parent'</span>, &#123;</div><div class="line">      resolve:&#123;</div><div class="line">         resA:  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> &#123;<span class="string">'value'</span>: <span class="string">'A'</span>&#125;;</div><div class="line">         &#125;</div><div class="line">      &#125;,</div><div class="line">      controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope, resA</span>)</span>&#123;</div><div class="line">          $scope.resA = resA.value;</div><div class="line">      &#125;</div><div class="line">   &#125;)</div><div class="line">   .state(<span class="string">'parent.child'</span>, &#123;</div><div class="line">      resolve:&#123;</div><div class="line">         <span class="comment">// 将父状态的解决依赖项注入到子状态的解决函数中</span></div><div class="line">         resB: <span class="function"><span class="keyword">function</span>(<span class="params">resA</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> &#123;<span class="string">'value'</span>: resA.value + <span class="string">'B'</span>&#125;;</div><div class="line">         &#125;</div><div class="line">      &#125;,</div><div class="line">      <span class="comment">// 将父状态的解决依赖项注入到子状态的控制器中</span></div><div class="line">      controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope, resA, resB</span>)</span>&#123;</div><div class="line">          $scope.resA2 = resA.value;</div><div class="line">          $scope.resB = resB.value;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p><h4><span id="继承自定义data属性值">继承自定义<code>data</code>属性值</span></h4><p>子状态将从父状态继承自定义<code>data</code>属性值，并且可以重写（overwrite）<code>data</code>属性值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'parent'</span>, &#123;</div><div class="line">      data:&#123;</div><div class="line">         customData1:  <span class="string">"Hello"</span>,</div><div class="line">         customData2:  <span class="string">"World!"</span></div><div class="line">      &#125;</div><div class="line">   &#125;)</div><div class="line">   .state(<span class="string">'parent.child'</span>, &#123;</div><div class="line">      data:&#123;</div><div class="line">         <span class="comment">// customData1 inherited from 'parent'</span></div><div class="line">         <span class="comment">// 覆盖了 customData2 的值</span></div><div class="line">         customData2:  <span class="string">"UI-Router!"</span></div><div class="line">      &#125;</div><div class="line">   &#125;);</div><div class="line"></div><div class="line">$rootScope.$on(<span class="string">'$stateChangeStart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event, toState</span>)</span>&#123; </div><div class="line">    <span class="keyword">var</span> greeting = toState.data.customData1 + <span class="string">" "</span> + toState.data.customData2;</div><div class="line">    <span class="built_in">console</span>.log(greeting);</div><div class="line"></div><div class="line">    <span class="comment">// 'parent'被激活时，输出 "Hello World!"</span></div><div class="line">    <span class="comment">// 'parent.child'被激活时，输出 "Hello UI-Router!"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h2><span id="abstract-states-抽象状态">Abstract States 抽象状态</span></h2><p>一个抽象的状态可以有子状态但不能显式激活，它将被隐性激活当其子状态被激活时。</p><p>下面是一些你将可能会使用到抽象状态的示例：</p><ul><li>为所有子状态预提供一个<strong>基url</strong></li><li>在父状态中设置<code>template</code>属性，子状态对应的模板将插入到父状态模板中的<code>ui-view(s)</code>中</li><li>通过<code>resolve</code>属性，为所有子状态提供解决依赖项</li><li>通过<code>data</code>属性，为所有子状态或者事件监听函数提供自定义数据</li><li>运行<code>onEnter</code>或<code>onExit</code>函数，这些函数可能在以某种方式修改应用程序。</li><li>上面场景的任意组合</li></ul><p><strong>请记住：</strong>抽象的状态模板仍然需要<code>&lt;ui-view/&gt;</code>，来让自己的子状态模板插入其中。因此，如果您使用抽象状态只是为了预提供<strong>基url</strong>、提供解决依赖项或者自定义data、运行onEnter/Exit函数，你任然需要设置<code>template: &quot;&lt;ui-view/&gt;&quot;</code>。</p><h3><span id="抽象状态使用示例">抽象状态使用示例：</span></h3><p><strong>为子状态提供一个基url，子状态的url是相对父状态的</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">    .state(<span class="string">'contacts'</span>, &#123;</div><div class="line">        abstract: <span class="literal">true</span>, </div><div class="line">url: <span class="string">'/contacts'</span>,</div><div class="line"></div><div class="line">        <span class="comment">// Note: abstract still needs a ui-view for its children to populate.</span></div><div class="line">        <span class="comment">// You can simply add it inline here.</span></div><div class="line">        template: <span class="string">'&lt;ui-view/&gt;'</span></div><div class="line">    &#125;)</div><div class="line">    .state(<span class="string">'contacts.list'</span>, &#123;</div><div class="line"><span class="comment">// url will become '/contacts/list'</span></div><div class="line">        url: <span class="string">'/list'</span></div><div class="line"><span class="comment">//...more</span></div><div class="line">    &#125;)</div><div class="line">    .state(<span class="string">'contacts.detail'</span>, &#123;</div><div class="line"><span class="comment">// url will become '/contacts/detail'</span></div><div class="line">        url: <span class="string">'/detail'</span>,</div><div class="line"><span class="comment">//...more</span></div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p><p><strong>将之状态模板插入到父状态指定的<code>ui-view</code>中</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">    .state(<span class="string">'contacts'</span>, &#123;</div><div class="line">        abstract: <span class="literal">true</span>,</div><div class="line">        templateURL: <span class="string">'contacts.html'</span></div><div class="line">    )</div><div class="line">    .state(<span class="string">'contacts.list'</span>, &#123;</div><div class="line">        <span class="comment">// loaded into ui-view of parent's template</span></div><div class="line">        templateUrl: <span class="string">'contacts.list.html'</span></div><div class="line">    &#125;)</div><div class="line">    .state(<span class="string">'contacts.detail'</span>, &#123;</div><div class="line">        <span class="comment">// loaded into ui-view of parent's template</span></div><div class="line">        templateUrl: <span class="string">'contacts.detail.html'</span></div><div class="line">    &#125;)</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- contacts.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Contacts Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>组合使用示例</strong></p><p>完整示例：<a href="http://plnkr.co/edit/gmtcE2?p=preview" target="_blank" rel="external">http://plnkr.co/edit/gmtcE2?p=preview</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">    .state(<span class="string">'contacts'</span>, &#123;</div><div class="line">        abstract: <span class="literal">true</span>,</div><div class="line">        url: <span class="string">'/contacts'</span>,</div><div class="line">        templateUrl: <span class="string">'contacts.html'</span>,</div><div class="line">        controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123;</div><div class="line">            $scope.contacts = [&#123; <span class="attr">id</span>:<span class="number">0</span>, <span class="attr">name</span>: <span class="string">"Alice"</span> &#125;, &#123; <span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>: <span class="string">"Bob"</span> &#125;];</div><div class="line">        &#125;    </div><div class="line">    &#125;)</div><div class="line">    .state(<span class="string">'contacts.list'</span>, &#123;</div><div class="line">        url: <span class="string">'/list'</span>,</div><div class="line">        templateUrl: <span class="string">'contacts.list.html'</span></div><div class="line">    &#125;)</div><div class="line">    .state(<span class="string">'contacts.detail'</span>, &#123;</div><div class="line">        url: <span class="string">'/:id'</span>,</div><div class="line">        templateUrl: <span class="string">'contacts.detail.html'</span>,</div><div class="line">        controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope, $stateParams</span>)</span>&#123;</div><div class="line">          $scope.person = $scope.contacts[$stateParams.id];</div><div class="line">        &#125;</div><div class="line">    &#125;)</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- contacts.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Contacts Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- contacts.list.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"person in contacts"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">ng-href</span>=<span class="string">"#/contacts/&#123;&#123;person.id&#125;&#125;"</span>&gt;</span>&#123;&#123;person.name&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- contacts.detail.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; person.name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考原文：&lt;a href=&quot;https://github.com/angular-ui/ui-router/wiki/Nested-States-%26-Nested-Views&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/angular-ui/ui-router/wiki/Nested-States-%26-Nested-Views&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;状态嵌套的方法&quot;&gt;&lt;a href=&quot;#状态嵌套的方法&quot; class=&quot;headerlink&quot; title=&quot;状态嵌套的方法&quot;&gt;&lt;/a&gt;状态嵌套的方法&lt;/h2&gt;&lt;p&gt;状态可以相互嵌套。有三个嵌套的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用“点标记法”，例如：&lt;code&gt;.state(&amp;#39;contacts.list&amp;#39;, {})&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;parent&lt;/code&gt;属性，指定一个父状态的名称字符串，例如：&lt;code&gt;parent: &amp;#39;contacts&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;parent&lt;/code&gt;属性，指定一个父状态对象，例如：&lt;code&gt;parent: contacts&lt;/code&gt;（contacts 是一个状态对象）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://bubkoo.com/tags/angularjs/"/>
    
      <category term="ui-router" scheme="http://bubkoo.com/tags/ui-router/"/>
    
  </entry>
  
  <entry>
    <title>学习 ui-router - 管理状态</title>
    <link href="http://bubkoo.com/2014/01/01/angular/ui-router/guide/state-manager/"/>
    <id>http://bubkoo.com/2014/01/01/angular/ui-router/guide/state-manager/</id>
    <published>2014-01-01T16:31:40.000Z</published>
    <updated>2014-01-01T16:31:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考原文：<a href="https://github.com/angular-ui/ui-router/wiki" target="_blank" rel="external">https://github.com/angular-ui/ui-router/wiki</a></p><p>ui-router 的工作原理非常类似于 Angular 的路由控制器，但它只关注状态。</p><ul><li>在应用程序的整个用户界面和导航中，一个状态对应于一个页面位置</li><li>通过定义<code>controller</code>、<code>template</code>和<code>view</code>等属性，来定义指定位置的用户界面和界面行为</li><li>通过嵌套的方式来解决页面中的一些重复出现的部位</li></ul><h2><span id="最简单的形式">最简单的形式</span></h2><p>模板可以通过下面这种最简单的方式来指定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- in index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-controller</span>=<span class="string">"MainCtrl"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in app-states.js (or whatever you want to name it)</span></div><div class="line">$stateProvider.state(<span class="string">'contacts'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;h1&gt;My Contacts&lt;/h1&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><a id="more"></a><h3><span id="模板将被插入哪里">模板将被插入哪里?</span></h3><p>状态被激活时，它的模板会自动插入到父状态对应的模板中包含<code>ui-view</code>属性的元素内部。如果是顶层的状态，那么它的父模板就是<code>index.html</code>。</p><h3><span id="激活状态">激活状态</span></h3><p>有三种方法来激活状态：</p><ol><li>调用<code>$state.go()</code>方法，这是一个高级的便利方法；</li><li>点击包含<code>ui-sref</code>指令的链接；</li><li>导航到与状态相关联的 url。</li></ol><h2><span id="templates-模板">Templates 模板</span></h2><p>可以通过下面几种方法来配置一个状态的模板。</p><p>方法一：配置<code>template</code>属性，指定一段 HTML 字符串，这人是设置模板的最简单的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'contacts'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;h1&gt;My Contacts&lt;/h1&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>方法二：配置<code>templateUrl</code>属性，来加载指定位置的模板，<strong>这是设置模板的常用方法。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'contacts'</span>, &#123;</div><div class="line">  templateUrl: <span class="string">'contacts.html'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><code>templateUrl</code>的值也可以是一个函数返回的url，函数带一个预设参数<code>stateParams</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'contacts'</span>, &#123;</div><div class="line">  templateUrl: <span class="function"><span class="keyword">function</span> (<span class="params">stateParams</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'/partials/contacts.'</span> + stateParams.filterBy + <span class="string">'.html'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>方法三：通过<code>templateProvider</code>函数返回模板的 HTML。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'contacts'</span>, &#123;</div><div class="line">  templateProvider: <span class="function"><span class="keyword">function</span> (<span class="params">$timeout, $stateParams</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> $timeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'&lt;h1&gt;'</span> + $stateParams.contactId + <span class="string">'&lt;/h1&gt;'</span></div><div class="line">    &#125;, <span class="number">100</span>);</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>如果想在状态被激活前，让<code>&lt;ui-view&gt;</code>有一些默认的内容，当状态被激活之后默认内容将被状态对应的模板替换。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ui-view</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">i</span>&gt;</span>Some content will load here!<span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ui-view</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><h2><span id="controllers-控制器">Controllers 控制器</span></h2><p>可以为模板指定一个控制器（controller）。<strong>警告</strong>：控制器不会被实例化如果模板没有定义。</p><p>设置控制器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'contacts'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;'</span>,</div><div class="line">  controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123;</div><div class="line">    $scope.title = <span class="string">'My Contacts'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>如果在模块中已经定义了一个控制器，只需要指定控制器的名称即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'contacts'</span>, &#123;</div><div class="line">  template: ...,</div><div class="line">  controller: <span class="string">'ContactsCtrl'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>使用<code>controllerAs</code>语法：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'contacts'</span>, &#123;</div><div class="line">  template: ...,</div><div class="line">  controller: <span class="string">'ContactsCtrl as contact'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>对于更高级的需要，可以使用<code>controllerProvider</code>来动态返回一个控制器函数或字符串：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'contacts'</span>, &#123;</div><div class="line">  template: ...,</div><div class="line">  controllerProvider: <span class="function"><span class="keyword">function</span>(<span class="params">$stateParams</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ctrlName = $stateParams.type + <span class="string">"Controller"</span>;</div><div class="line">      <span class="keyword">return</span> ctrlName;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>控制器可以使用<code>$scope.on()</code>方法来监听事件状态转换。</p><p>控制器可以根据需要实例化，当相应的<code>scope</code>被创建时。例如，当用户点击一个url手动导航一个状态时，<code>$stateProvider</code>将加载对应的模板到视图中，并且将控制器和模板的<code>scope</code>绑定在一起。</p><h2><span id="解决器-resolve">解决器 Resolve</span></h2><p>可以使用<code>resolve</code>为控制器提供可选的依赖注入项。</p><p><code>resolve</code>配置项是一个由<code>key/value</code>构成的对象。</p><ul><li>key – {string}：注入控制器的依赖项名称。</li><li>factory - {string|function}：<ul><li>string：一个服务的别名</li><li>function：函数的返回值将作为依赖注入项，如果函数是一个耗时的操作，那么控制器必须等待该函数执行完成（be resolved）才会被实例化。</li></ul></li></ul><h3><span id="例子">例子</span></h3><p>在<code>controller</code>实例化之前，<code>resolve</code>中的每一个对象都必须 be resolved，请注意每个 resolved object 是怎样作为参数注入到控制器中的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'myState'</span>, &#123;</div><div class="line">      resolve:&#123;</div><div class="line"></div><div class="line">         <span class="comment">// Example using function with simple return value.</span></div><div class="line">         <span class="comment">// Since it's not a promise, it resolves immediately.</span></div><div class="line">         simpleObj:  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="string">'simple!'</span>&#125;;</div><div class="line">         &#125;,</div><div class="line"></div><div class="line">         <span class="comment">// Example using function with returned promise.</span></div><div class="line">         <span class="comment">// 这是一种典型使用方式</span></div><div class="line">         <span class="comment">// 请给函数注入任何想要的服务依赖，例如 $http</span></div><div class="line">         promiseObj:  <span class="function"><span class="keyword">function</span>(<span class="params">$http</span>)</span>&#123;</div><div class="line">            <span class="comment">// $http returns a promise for the url data</span></div><div class="line">            <span class="keyword">return</span> $http(&#123;<span class="attr">method</span>: <span class="string">'GET'</span>, <span class="attr">url</span>: <span class="string">'/someUrl'</span>&#125;);</div><div class="line">         &#125;,</div><div class="line"></div><div class="line">         <span class="comment">// Another promise example. </span></div><div class="line">         <span class="comment">// 如果想对返回结果进行处理， 可以使用 .then 方法</span></div><div class="line">         <span class="comment">// 这是另一种典型使用方式</span></div><div class="line">         promiseObj2:  <span class="function"><span class="keyword">function</span>(<span class="params">$http</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> $http(&#123;<span class="attr">method</span>: <span class="string">'GET'</span>, <span class="attr">url</span>: <span class="string">'/someUrl'</span>&#125;)</div><div class="line">               .then (<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">                   <span class="keyword">return</span> doSomeStuffFirst(data);</div><div class="line">               &#125;);</div><div class="line">         &#125;,        </div><div class="line"></div><div class="line">         <span class="comment">// 使用服务名的例子，这将在模块中查找名称为 'translations' 的服务，并返回该服务 </span></div><div class="line">         <span class="comment">// Note: The service could return a promise and</span></div><div class="line">         <span class="comment">// it would work just like the example above</span></div><div class="line">         translations: <span class="string">"translations"</span>,</div><div class="line"></div><div class="line">         <span class="comment">// 将服务模块作为解决函数的依赖项，通过参数传入</span></div><div class="line">         <span class="comment">// 提示：依赖项 $stateParams 代表 url 中的参数</span></div><div class="line">         translations2: <span class="function"><span class="keyword">function</span>(<span class="params">translations, $stateParams</span>)</span>&#123;</div><div class="line">             <span class="comment">// Assume that getLang is a service method</span></div><div class="line">             <span class="comment">// that uses $http to fetch some translations.</span></div><div class="line">             <span class="comment">// Also assume our url was "/:lang/home".</span></div><div class="line">             translations.getLang($stateParams.lang);</div><div class="line">         &#125;,</div><div class="line"></div><div class="line">         <span class="comment">// Example showing returning of custom made promise</span></div><div class="line">         greeting: <span class="function"><span class="keyword">function</span>(<span class="params">$q, $timeout</span>)</span>&#123;</div><div class="line">             <span class="keyword">var</span> deferred = $q.defer();</div><div class="line">             $timeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                 deferred.resolve(<span class="string">'Hello!'</span>);</div><div class="line">             &#125;, <span class="number">1000</span>);</div><div class="line">             <span class="keyword">return</span> deferred.promise;</div><div class="line">         &#125;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      <span class="comment">// 控制器将等待上面的解决项都被解决后才被实例化</span></div><div class="line">      controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope, simpleObj, promiseObj, promiseObj2, translations, translations2, greeting</span>)</span>&#123;</div><div class="line">          </div><div class="line">          $scope.simple = simpleObj.value;</div><div class="line"></div><div class="line">          <span class="comment">// 这里可以放心使用 promiseObj 中的对象</span></div><div class="line">          $scope.items = promiseObj.items;</div><div class="line">          $scope.items = promiseObj2.items;</div><div class="line"></div><div class="line">          $scope.title = translations.getLang(<span class="string">"english"</span>).title;</div><div class="line">          $scope.title = translations2.title;</div><div class="line"></div><div class="line">          $scope.greeting = greeting;</div><div class="line">      &#125;</div><div class="line">   &#125;)</div></pre></td></tr></table></figure><h2><span id="为-state-对象提供自定义数据">为 $state 对象提供自定义数据</span></h2><p>可以给 $state 对象提供自定义数据（建议使用<code>data</code>属性，以免冲突）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 基于对象和基于字符串定义 state 的例子</span></div><div class="line"><span class="keyword">var</span> contacts = &#123; </div><div class="line">    name: <span class="string">'contacts'</span>,</div><div class="line">    templateUrl: <span class="string">'contacts.html'</span>,</div><div class="line">    data: &#123;</div><div class="line">        customData1: <span class="number">5</span>,</div><div class="line">        customData2: <span class="string">"blue"</span></div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line">$stateProvider</div><div class="line">  .state(contacts)</div><div class="line">  .state(<span class="string">'contacts.list'</span>, &#123;</div><div class="line">    templateUrl: <span class="string">'contacts.list.html'</span>,</div><div class="line">    data: &#123;</div><div class="line">        customData1: <span class="number">44</span>,</div><div class="line">        customData2: <span class="string">"red"</span></div><div class="line">    &#125; </div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p>可以通过下面的方式来访问上面定义的数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ctrl</span>(<span class="params">$state</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log($state.current.data.customData1) <span class="comment">// 输出 5;</span></div><div class="line">    <span class="built_in">console</span>.log($state.current.data.customData2) <span class="comment">// 输出 "blue";</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="onenter-和-onexit-回调函数">onEnter 和 onExit 回调函数</span></h2><p><code>onEnter</code>和<code>onExit</code>回调函数是可选配置项，分别称为当一个状态变得活跃的和不活跃的时候触发。回调函数也可以访问所有解决依赖项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">"contacts"</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;'</span>,</div><div class="line">  resolve: &#123; <span class="attr">title</span>: <span class="string">'My Contacts'</span> &#125;,</div><div class="line">  controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope, title</span>)</span>&#123;</div><div class="line">    $scope.title = <span class="string">'My Contacts'</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// title 是解决依赖项，这里也是可以使用解决依赖项的</span></div><div class="line">  onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">title</span>)</span>&#123; </div><div class="line">    <span class="keyword">if</span>(title)&#123; ... do something ... &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// title 是解决依赖项，这里也是可以使用解决依赖项的</span></div><div class="line">  onExit: <span class="function"><span class="keyword">function</span>(<span class="params">title</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(title)&#123; ... do something ... &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2><span id="state-change-events-状态改变事件">State Change Events 状态改变事件</span></h2><p>所有这些事件都是在<code>$rootScope</code>作用域触发</p><ul><li><strong>$stateChangeStart</strong> - 当模板开始解析之前触发</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$rootScope.$on(<span class="string">'$stateChangeStart'</span>, </div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">event, toState, toParams, fromState, fromParams</span>)</span>&#123; ... &#125;)</div></pre></td></tr></table></figure><p>注意：使用<code>event.preventDefault()</code>可以阻止模板解析的发生<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$rootScope.$on(<span class="string">'$stateChangeStart'</span>, </div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">event, toState, toParams, fromState, fromParams</span>)</span>&#123; </div><div class="line">    event.preventDefault(); </div><div class="line">    <span class="comment">// transitionTo() promise will be rejected with </span></div><div class="line">    <span class="comment">// a 'transition prevented' error</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><ul><li><strong>$stateNotFound</strong> - <code>v0.3.0</code> - 在 transition 时通过状态名查找状态，当状态无法找到时发生。该事件在 scope 链上广播，只允许一次处理错误的机会。<code>unfoundState</code>将作为参数传入事件监听函数，下面例子中可以看到<code>unfoundState</code>的三个属性。使用 <code>event.preventDefault()</code> 来阻止模板解析，</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// somewhere, assume lazy.state has not been defined</span></div><div class="line">$state.go(<span class="string">"lazy.state"</span>, &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">inherit</span>:<span class="literal">false</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">// somewhere else</span></div><div class="line">$scope.$on(<span class="string">'$stateNotFound'</span>, </div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">event, unfoundState, fromState, fromParams</span>)</span>&#123; </div><div class="line">    <span class="built_in">console</span>.log(unfoundState.to); <span class="comment">// "lazy.state"</span></div><div class="line">    <span class="built_in">console</span>.log(unfoundState.toParams); <span class="comment">// &#123;a:1, b:2&#125;</span></div><div class="line">    <span class="built_in">console</span>.log(unfoundState.options); <span class="comment">// &#123;inherit:false&#125; + default options</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><ul><li><strong>$stateChangeSuccess</strong> - 当模板解析完成后触发</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$rootScope.$on(<span class="string">'$stateChangeSuccess'</span>, </div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">event, toState, toParams, fromState, fromParams</span>)</span>&#123; ... &#125;)</div></pre></td></tr></table></figure><ul><li><strong>$stateChangeError</strong> - 当模板解析过程中发生错误时触发</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$rootScope.$on(<span class="string">'$stateChangeError'</span>, </div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">event, toState, toParams, fromState, fromParams, error</span>)</span>&#123; ... &#125;)</div></pre></td></tr></table></figure><h2><span id="view-load-events-视图加载事件">View Load Events 视图加载事件</span></h2><ul><li><strong>$viewContentLoading</strong> - 当视图开始加载，DOM渲染完成之前触发，该事件将在<code>$scope</code>链上广播此事件。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$scope.$on(<span class="string">'$viewContentLoading'</span>, </div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">event, viewConfig</span>)</span>&#123; </div><div class="line">    <span class="comment">// Access to all the view config properties.</span></div><div class="line">    <span class="comment">// and one special property 'targetView'</span></div><div class="line">    <span class="comment">// viewConfig.targetView </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><ul><li><strong>$viewContentLoaded</strong> - 当视图加载完成，DOM渲染完成之后触发，视图所在的<code>$scope</code>发出该事件。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$scope.$on(<span class="string">'$viewContentLoading'</span>, </div><div class="line">$scope.$on(<span class="string">'$viewContentLoaded'</span>, </div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123; ... &#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考原文：&lt;a href=&quot;https://github.com/angular-ui/ui-router/wiki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/angular-ui/ui-router/wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ui-router 的工作原理非常类似于 Angular 的路由控制器，但它只关注状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在应用程序的整个用户界面和导航中，一个状态对应于一个页面位置&lt;/li&gt;
&lt;li&gt;通过定义&lt;code&gt;controller&lt;/code&gt;、&lt;code&gt;template&lt;/code&gt;和&lt;code&gt;view&lt;/code&gt;等属性，来定义指定位置的用户界面和界面行为&lt;/li&gt;
&lt;li&gt;通过嵌套的方式来解决页面中的一些重复出现的部位&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;最简单的形式&quot;&gt;&lt;a href=&quot;#最简单的形式&quot; class=&quot;headerlink&quot; title=&quot;最简单的形式&quot;&gt;&lt;/a&gt;最简单的形式&lt;/h2&gt;&lt;p&gt;模板可以通过下面这种最简单的方式来指定&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- in index.html --&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-controller&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;MainCtrl&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ui-view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;section&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// in app-states.js (or whatever you want to name it)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$stateProvider.state(&lt;span class=&quot;string&quot;&gt;&#39;contacts&#39;&lt;/span&gt;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  template: &lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;h1&amp;gt;My Contacts&amp;lt;/h1&amp;gt;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://bubkoo.com/tags/angularjs/"/>
    
      <category term="ui-router" scheme="http://bubkoo.com/tags/ui-router/"/>
    
  </entry>
  
  <entry>
    <title>AngualrJS 使用笔记</title>
    <link href="http://bubkoo.com/2014/01/01/angular/AngualrJS-notes/"/>
    <id>http://bubkoo.com/2014/01/01/angular/AngualrJS-notes/</id>
    <published>2014-01-01T14:05:13.000Z</published>
    <updated>2014-01-01T14:05:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>元旦放假一天，由于太宅，于是有了新年第一个产出。主题来源于这一周在项目中使用 <a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 所遇到的问题，在此做一个使用笔记，以加深对 <a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 的理解。本人文笔不行，如文章被有幸浏览到，还请各位童鞋多多提意见。</p><h2><span id="augularjs-简单介绍">AugularJS 简单介绍</span></h2><p><a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 由 Google 倾力打造的前端 JavaScript 工具。这里只说它是“工具”，没说它是完整的“框架”，是因为它并不是定位于去完成一套框架要做的事。更重要的，是它给我们提供了一种新的应用组织与开发方式。与其他许多模版系统最大的不同在于，他直接扩展了现有的 HTML 架构，透过声明式语言 (Directives Syntax)直接赋予 HTML 新的功能，让许多 <a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 自定义的 HTML 属性自然而然地融入 HTML 之中，并且赋予其意义。这是大多数模版系统不敢做的尝试。</p><p>另外，在其他模版系统当中，都会实作所谓的模板引擎(Template Engine)，它们通常都通过模版字符串与数据进行连接，生成最终的 HTML 字符串，并将结果通过<code>innerHTML</code>属性插入 DOM 树中。这意味着任何数据发生改变时，都需要重新将数据、模版合并成字符串，然后当作<code>innerHTML</code>插入 DOM 树中，所以存在一些从字符串转换成 HTML 的隐性成本。但是 <a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 是与众不同的，<a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 通过自身的编译引擎将 HTML 和自定义的 HTML 语法(Directives)，解析成 DOM 结构之后，<a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 会直接将原生的 DOM 当作网页片段模板，然后直接对 DOM 进行操作，大幅减少了转换成本，当然绑定效率可见比其他模板要高很多。</p><p><strong>没有银弹</strong>，与其他所有的模版系统一样，这个世界没有银弹，不会有任何一套框架可以解决所有问题，<a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 也不例外。所以，要能理解 <a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 所擅长与不擅长的领域，可以有助于你评估与理解是否要采用 <a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 当作你未来的开发框架。<a id="more"></a></p><p>下面是我学习过程中收集的一些比较不错的文章，排序不分先后，有需要的童鞋可以通过这些文章快速学习。</p><ul><li><a href="http://angularjs.org/" target="_blank" rel="external">AngularJS 官网</a></li><li><a href="http://angularjs.cn/tag/AngularJS" target="_blank" rel="external">AngularJS 中文社区</a></li><li><a href="http://www.gbin1.com/technology/javascript/20120717-AugularJS-features/" target="_blank" rel="external">AngularJS 的五个超酷特性</a></li><li><a href="http://developer.51cto.com/art/201302/380661.htm" target="_blank" rel="external">现在就开始使用 AngularJS 的三个重要原因</a></li><li><a href="http://www.csdn.net/article/2013-10-08/2817118-AngularJS-Framework-Google" target="_blank" rel="external">专访 AngularJS 框架创始人 Misko Hevery：让 Web 开发更便捷</a></li><li><a href="http://www.zhihu.com/question/21497720" target="_blank" rel="external">知乎专栏使用 AngularJS 框架有什么经验心得？</a></li><li><a href="http://www.cnblogs.com/lcllao/archive/2012/10/18/2728787.html" target="_blank" rel="external">Angular Developer Guide 中文翻译系列</a></li><li><a href="http://zouyesheng.com/angular.html" target="_blank" rel="external">AngularJS 学习笔记</a></li><li><a href="http://damoqiongqiu.iteye.com/category/287942" target="_blank" rel="external">大漠穷秋的 AngularJS 系列文章</a></li><li><a href="http://www.cnblogs.com/whitewolf/category/404298.html" target="_blank" rel="external">破狼的 AngularJS 系列文章</a></li><li><a href="http://ngot.iteye.com/category/291820" target="_blank" rel="external">ngot AngularJS 系列文章</a></li><li><a href="http://blog.fens.me/series-angular/" target="_blank" rel="external">AngularJS 体验式编程系列文章</a></li></ul><p>废话了这么多，接下来还是进入本文主题，看看我在使用过程中遇到过哪些问题。</p><h2><span id="angularjs-项目的目录结构">AngularJS 项目的目录结构</span></h2><p>怎样组织代码文件和目录？这恐怕是初学者一开始就会遇到的问题。下面推荐两种目录划分方式，开发者可以根据项目复杂程度选择采取一种。</p><p><strong>按业务逻辑划分</strong>，就像下面这样：</p><ul><li>controllers/<ul><li>LoginController.js</li><li>RegistrationController.js</li><li>ProductDetailController.js</li><li>SearchResultsController.js</li></ul></li><li>directives.js</li><li>filters.js</li><li>models/<ul><li>CartModel.js</li><li>ProductModel.js</li><li>SearchResultsModel.js</li><li>UserModel.js</li></ul></li><li>services/<ul><li>CartService.js</li><li>UserService.js</li><li>ProductService.js</li></ul></li></ul><p>这种结构把不同的业务功能拆分为独立的文件，条理清晰，<strong>适用于项目较简单的应用</strong>。一旦项目复杂度较高，controllers, models, servers 三个目录下的文件数量就会随着项目复杂度增加we增加，想要找到对应模块的代码文件比较麻烦，如果项目比较复杂推荐采用下面的方式来划分目录结构。</p><p><strong>按功能模块划分</strong>，就像下面这样：</p><ul><li>cart/<ul><li>CartModel.js</li><li>CartService.js</li></ul></li><li>common/<ul><li>directives.js</li><li>filters.js</li></ul></li><li>product/<ul><li>search/<ul><li>SearchResultsController.js</li><li>SearchResultsModel.js  </li></ul></li><li>ProductDetailController.js</li><li>ProductModel.js</li><li>ProductService.js</li></ul></li><li>user/<ul><li>LoginController.js</li><li>RegistrationController.js</li><li>UserModel.js</li><li>UserService.js</li></ul></li></ul><p>另外有一个 AngularJS 应用开发的官方入门项目 <a href="https://github.com/angular/angular-seed" target="_blank" rel="external">angular-seed</a>，推荐只作为练习使用，为了不误导大家，其目录结构就不在此列举出来，有需要的同学可以自行<a href="https://github.com/angular/angular-seed" target="_blank" rel="external">下载</a>学习。</p><h2><span id="angularjs-中使用-httpjsonp">AngularJs 中使用 $http.jsonp</span></h2><p>在开发过程中使用到了 jsonp，问题出现于，之前用 jQuery 的 ajax 方法，换成 AngularJs 的 $http.jsonp 方法后，拿不到数据，打开 Console 一看发现 Angular 抛出异常了。</p><p>jQuery 使用 jsonp 的方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax(&#123;</div><div class="line">    url: <span class="string">'http://'</span> + config.hostname + <span class="string">':'</span> + config.port + <span class="string">'/trace/app?callback=?'</span>,</div><div class="line">    dataType: <span class="string">'jsonp'</span>,</div><div class="line">    global: <span class="literal">false</span>,</div><div class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>换成 AngularJs 的 $http.jsonp 的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$http.jsonp(<span class="string">'http://'</span> + config.hostname + <span class="string">':'</span> + config.port + <span class="string">'/trace/apps?callback=?'</span>)</div><div class="line">    .success(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line"></div><div class="line">    &#125;);</div></pre></td></tr></table></figure><p>好的，现在打开页面，页面上什么数据都没有获取到，这是什么原因呢？</p><p>好吧，打开强大的 Google 找到如下几篇文章：</p><ul><li><a href="http://docs.angularjs.org/api/ng.$http#methods_jsonp" target="_blank" rel="external">官方文档中的 $http.jsonp</a></li><li><a href="http://stackoverflow.com/questions/12066002/parsing-jsonp-http-jsonp-response-in-angular-js" target="_blank" rel="external">parsing JSONP $http.jsonp() response in angular.js</a></li><li><a href="http://xunmengsj.iteye.com/blog/1881008" target="_blank" rel="external">详解Jquery和AngularJs中jsonp解决跨域问题</a></li></ul><p>最后解决问题，总计如下：</p><ol><li>url中必须指定callback和回调函数名，函数名为JSON_CALLBACK时，才会调用success回调函数，JSON_CALLBACK<strong>必须全为大写</strong>。</li><li>也可以指定其它回调函数，但必须是定义在window下的全局函数。</li><li>当callback为JSON_CALLBACK时，只会调用success，即使window中有JSON_CALLBACK函数，也不会调用该函数。</li></ol><p>所以，修改后的代码是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$http.jsonp(<span class="string">'http://'</span> + config.hostname + <span class="string">':'</span> + config.port + <span class="string">'/trace/apps?callback=JSON_CALLBACK'</span>)</div><div class="line">    .success(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line"></div><div class="line">    &#125;);</div></pre></td></tr></table></figure><h2><span id="文章推荐">文章推荐</span></h2><ul><li><a href="http://www.cnblogs.com/whitewolf/archive/2013/03/24/2979344.html" target="_blank" rel="external">Angularjs开发一些经验总结</a></li><li><a href="http://www.lovelucy.info/angularjs-best-practices.html" target="_blank" rel="external">AngularJS 最佳实践</a></li><li><a href="http://damoqiongqiu.iteye.com/blog/1971204" target="_blank" rel="external">AngularJS：何时应该使用Directive、Controller、Service？</a></li><li><a href="http://damoqiongqiu.iteye.com/blog/1917971" target="_blank" rel="external">《AngularJS》5个实例详解Directive（指令）机制</a></li><li><a href="http://angularjs.cn/A00T" target="_blank" rel="external">如何使用AngularJS构建大型Web应用</a></li><li><a href="http://angularjs.cn/A08q" target="_blank" rel="external">AngularJs项目实战01：模块划分和目录组织</a></li><li><a href="http://angularjs.cn/A0d9" target="_blank" rel="external">AngularJs项目实战02：前端的页面分解与组装</a></li><li><a href="http://angularjs.cn/A0fG" target="_blank" rel="external">angularJs项目实战03：angularjs与其他类库的协作</a></li><li><a href="http://angularjs.cn/A0gy" target="_blank" rel="external">AngularJs项目实战04：angularjs的性能问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元旦放假一天，由于太宅，于是有了新年第一个产出。主题来源于这一周在项目中使用 &lt;a href=&quot;http://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt; 所遇到的问题，在此做一个使用笔记，以加深对 &lt;a href=&quot;http://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt; 的理解。本人文笔不行，如文章被有幸浏览到，还请各位童鞋多多提意见。&lt;/p&gt;
&lt;h2 id=&quot;AugularJS-简单介绍&quot;&gt;&lt;a href=&quot;#AugularJS-简单介绍&quot; class=&quot;headerlink&quot; title=&quot;AugularJS 简单介绍&quot;&gt;&lt;/a&gt;AugularJS 简单介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt; 由 Google 倾力打造的前端 JavaScript 工具。这里只说它是“工具”，没说它是完整的“框架”，是因为它并不是定位于去完成一套框架要做的事。更重要的，是它给我们提供了一种新的应用组织与开发方式。与其他许多模版系统最大的不同在于，他直接扩展了现有的 HTML 架构，透过声明式语言 (Directives Syntax)直接赋予 HTML 新的功能，让许多 &lt;a href=&quot;http://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt; 自定义的 HTML 属性自然而然地融入 HTML 之中，并且赋予其意义。这是大多数模版系统不敢做的尝试。&lt;/p&gt;
&lt;p&gt;另外，在其他模版系统当中，都会实作所谓的模板引擎(Template Engine)，它们通常都通过模版字符串与数据进行连接，生成最终的 HTML 字符串，并将结果通过&lt;code&gt;innerHTML&lt;/code&gt;属性插入 DOM 树中。这意味着任何数据发生改变时，都需要重新将数据、模版合并成字符串，然后当作&lt;code&gt;innerHTML&lt;/code&gt;插入 DOM 树中，所以存在一些从字符串转换成 HTML 的隐性成本。但是 &lt;a href=&quot;http://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt; 是与众不同的，&lt;a href=&quot;http://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt; 通过自身的编译引擎将 HTML 和自定义的 HTML 语法(Directives)，解析成 DOM 结构之后，&lt;a href=&quot;http://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt; 会直接将原生的 DOM 当作网页片段模板，然后直接对 DOM 进行操作，大幅减少了转换成本，当然绑定效率可见比其他模板要高很多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有银弹&lt;/strong&gt;，与其他所有的模版系统一样，这个世界没有银弹，不会有任何一套框架可以解决所有问题，&lt;a href=&quot;http://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt; 也不例外。所以，要能理解 &lt;a href=&quot;http://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt; 所擅长与不擅长的领域，可以有助于你评估与理解是否要采用 &lt;a href=&quot;http://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AngularJS&lt;/a&gt; 当作你未来的开发框架。
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://bubkoo.com/tags/angularjs/"/>
    
      <category term="MVC" scheme="http://bubkoo.com/tags/mvc/"/>
    
  </entry>
  
  <entry>
    <title>关于 Hexo 的若干问题</title>
    <link href="http://bubkoo.com/2013/12/16/hexo-issure/"/>
    <id>http://bubkoo.com/2013/12/16/hexo-issure/</id>
    <published>2013-12-16T19:02:24.000Z</published>
    <updated>2013-12-17T11:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天折腾了一下<a href="http://zespia.tw/hexo/" target="_blank" rel="external">Hexo</a>，遇到一些问题，解决方案大都来自Google和<a href="http://zespia.tw/hexo/docs/" target="_blank" rel="external">Hexo官方文档</a>，现在把这些问题汇总在这里，并附上解决方案，或者抛出自己遇到的问题，渴求解决方案。</p><p>后续会陆续更新我在使用过程中遇到的问题和使用心得。</p><p>注：这里不涉及Hexo的安装方法，具体的安装和使用可以参照下面教程：</p><ul><li><a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">Hexo系列教程 - Zippera’s blog</a></li><li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客 - ibruce</a></li><li><a href="http://blog.jimliu.net/2013/09/08/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">使用hexo搭建静态博客 - Jim Liu’s Blog</a></li><li><a href="http://beiyuu.com/github-pages/" target="_blank" rel="external">使用Github Pages建独立博客 - BeiYuu</a></li><li><a href="http://yangjian.me/workspace/building-blog-with-hexo/" target="_blank" rel="external">使用hexo搭建博客 - Alimon’s blog</a></li><li><a href="http://blog.ishgo.cn/2013/09/15/ishgohexo%E5%9B%A2%E9%98%9F%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/" target="_blank" rel="external">用Hexo快速打造静态博客 - iShgo 团队博客</a></li><li><a href="http://sys.la/2013/09/07/hexo/" target="_blank" rel="external">hexo教程 - Sys.La</a></li><li><a href="http://blog.gfdsa.net/2013/04/09/hexo/hexolessontwo/" target="_blank" rel="external">Hexo主题制作 - youxiachai</a></li></ul><h2><span id="给文章添加多个tag或category">给文章添加多个tag或category</span></h2><p>第一次写Hexo的时候发现，如果这样写<code>tags:前端,Hexo,HTML,JavaScript</code>，tag显示不是按照逗号分隔的方式显示，而是整个显示为一个tag，这显然不是我们需要的，经过研究可以采用如下两种方式给文章添加多tag，对于添加category同样适用。<a id="more"></a></p><p>方式一：仿照Hexo配置文件中的写法</p><figure class="highlight md"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">title: page title</div><div class="line">date: page date</div><div class="line">tag:</div><div class="line">  - 前端</div><div class="line">  - Hexo</div><div class="line">  - HTML</div><div class="line">  - JavaScript</div><div class="line">categories: Hexo</div><div class="line">---</div><div class="line">page content</div></pre></td></tr></table></figure><p>方式二：<strong>伪</strong>JavaScript数组写法</p><figure class="highlight md"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">title: page title</div><div class="line">date: page date</div><div class="line">tag: [前端,Hexo,HTML,JavaScript]</div><div class="line">categories: Hexo</div><div class="line">---</div><div class="line">page content</div></pre></td></tr></table></figure><h2><span id="给hexo添加上一篇-下一篇导航">给Hexo添加“上一篇”、“下一篇”导航</span></h2><p>我使用的是Hexo的默认主题light，该主题的文章页面没有提供“上一篇”和“下一篇”导航功能，而我又非常喜欢默认主题的清爽简洁，只能自己折腾了。</p><p>在<a href="http://zespia.tw/hexo/docs/" target="_blank" rel="external">Hexo官方文档</a>中<a href="http://zespia.tw/hexo/docs/variables.html" target="_blank" rel="external">变量说明</a>部分我们可以知道，在 Article (post, page, …) 中<code>page.prev</code>和<code>page.next</code>分别代表上一篇和下一篇文章，这两个变量都是一个page对象，所以通过<code>page.prev.path</code>和<code>page.prev.title</code>就可以获取到上一篇文章的相对路径和标题，然后通过修改<code>/themes/light/layout/</code>文件夹中的文件来实现我们的功能。</p><p>首先，在<code>/themes/light/layout/_partial/post/</code>文件夹中新建<code>prev_next.ejs</code>文件。</p><figure class="highlight plain"><figcaption><span>prev_next.ejs</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;% if (page.prev || page.next)&#123; %&gt;</div><div class="line">&lt;div class=&quot;prev_next clearfix&quot;&gt;</div><div class="line">  &lt;% if (page.prev)&#123; %&gt;</div><div class="line">    &lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- page.prev.path %&gt;&quot; class=&quot;alignleft prev&quot; title=&quot;&lt;%= page.prev.title %&gt;&quot;&gt;&lt;%= page.prev.title %&gt;&lt;/a&gt;</div><div class="line">  &lt;% &#125; %&gt;</div><div class="line">  &lt;% if (page.next)&#123; %&gt;</div><div class="line">    &lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- page.next.path %&gt;&quot; class=&quot;alignright next&quot; title=&quot;&lt;%= page.next.title %&gt;&quot;&gt;&lt;%= page.next.title %&gt;&lt;/a&gt;</div><div class="line">  &lt;% &#125; %&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure><p>然后，修改<code>/themes/light/layout/_partial/article.ejs</code>文章模板，找到需要加入“上一篇”和“下一篇”导航功能的位置，加上<code>&lt;%- partial(&#39;post/prev_next&#39;) %&gt;</code>，比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">      &lt;% &#125; else &#123; %&gt;</div><div class="line">        &lt;%- partial(&apos;post/category&apos;) %&gt;</div><div class="line">        &lt;%- partial(&apos;post/tag&apos;) %&gt;</div><div class="line">        &lt;%- partial(&apos;post/share&apos;) %&gt;</div><div class="line">        &lt;%- partial(&apos;post/prev_next&apos;) %&gt;</div><div class="line">      &lt;% &#125; %&gt;</div><div class="line">      &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;/footer&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/article&gt;</div><div class="line"></div><div class="line">&lt;%- partial(&apos;comment&apos;) %&gt;</div></pre></td></tr></table></figure><p>最后，在<code>/themes/light/source/css/_partial/article.styl</code>文件末尾添加上相应的CSS。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.prev_next</span></div><div class="line">  <span class="selector-tag">margin</span> 1<span class="selector-tag">em</span> 0</div><div class="line">  <span class="selector-tag">clear</span> <span class="selector-tag">both</span></div><div class="line">  <span class="selector-tag">overflow</span> <span class="selector-tag">hidden</span></div><div class="line">  <span class="selector-tag">a</span></div><div class="line">    <span class="selector-tag">display</span> <span class="selector-tag">block</span></div><div class="line">    <span class="selector-tag">float</span> <span class="selector-tag">left</span></div><div class="line">    <span class="selector-tag">width</span> 50%</div><div class="line">    <span class="selector-tag">background</span> <span class="selector-id">#dbdbdb</span></div><div class="line">    <span class="selector-tag">text-align</span> <span class="selector-tag">center</span></div><div class="line">    <span class="selector-tag">padding</span> 0<span class="selector-class">.4em</span> 0</div><div class="line">    <span class="selector-tag">color</span> <span class="selector-id">#1ba1e2</span></div><div class="line">    <span class="selector-tag">transition</span> <span class="selector-tag">background</span> <span class="selector-class">.45s</span> <span class="selector-tag">color</span> <span class="selector-class">.45s</span></div><div class="line">    &amp;<span class="selector-pseudo">:hover</span></div><div class="line">      <span class="selector-tag">color</span> <span class="selector-id">#fafafa</span></div><div class="line">      <span class="selector-tag">background</span> <span class="selector-id">#717171</span></div><div class="line">    &amp;<span class="selector-class">.prev</span><span class="selector-pseudo">::before</span></div><div class="line">      <span class="selector-tag">content</span> "上一篇："</div><div class="line">      <span class="selector-tag">padding-right</span> 0<span class="selector-class">.5em</span></div><div class="line">    &amp;<span class="selector-class">.next</span><span class="selector-pseudo">::before</span></div><div class="line">      <span class="selector-tag">content</span> "下一篇："</div><div class="line">      <span class="selector-tag">padding-right</span> 0<span class="selector-class">.5em</span></div></pre></td></tr></table></figure><h2><span id="给博客和文章添加keywords">给博客和文章添加keywords</span></h2><p>默认情况下博客和文章是没有关键字的，可以安装如下方法修改。</p><p>首先，在博客配置文件<code>/Hexo/_config.yml</code>中添加<code>keywords:</code>字段，关键字以英文<code>,</code>分割，如下:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Site</span></div><div class="line"><span class="attr">title:</span> <span class="string">typeof</span> <span class="string">this</span>  <span class="comment">#站点名</span></div><div class="line"><span class="attr">subtitle:</span>    <span class="comment"># 副标题</span></div><div class="line"><span class="attr">description:</span> <span class="comment"># 站点描述，搜索引擎</span></div><div class="line"><span class="attr">author:</span> <span class="string">typeof</span></div><div class="line"><span class="attr">email:</span> <span class="string">JeffreyPee@163.com</span></div><div class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></div><div class="line"><span class="attr">keywords:</span> <span class="string">Web,前端,JavaScript,html5,css3</span> <span class="comment"># 博客关键字</span></div></pre></td></tr></table></figure><p>然后，修改模板文件，我用的是light模板，修改<code>/themes/light/layout/_partial/head.ejs</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#删除下面这行</div><div class="line">&lt;% if (page.keywords)&#123; %&gt;&lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= page.keywords %&gt;&quot;&gt;&lt;% &#125; %&gt;</div><div class="line">#增加以下内容</div><div class="line">&lt;% if (page.keywords)&#123; %&gt;</div><div class="line">&lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= page.keywords %&gt;,&lt;%= config.keywords %&gt;&quot;&gt;</div><div class="line">&lt;% &#125; else if (config.keywords)&#123; %&gt;</div><div class="line">&lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= config.keywords %&gt;&quot;&gt;</div><div class="line">&lt;%&#125; %&gt;</div></pre></td></tr></table></figure><p>简单说明一下：如果页面有关键字，则用页面的关键字加上配置文件里面的关键字，如果没有关键字，则用配置文件的关键字。</p><p>要给文章添加关键字，只需要在文章里面加入<code>keywords:</code>即可。也可以直接修改创建文章的模板<code>/scaffolds/post.md</code>，在最下面添加<code>keywords:</code>，如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">title:</span> <span class="string">&#123;&#123;</span> <span class="string">title</span> <span class="string">&#125;&#125;</span></div><div class="line"><span class="attr">date:</span> <span class="string">&#123;&#123;</span> <span class="string">date</span> <span class="string">&#125;&#125;</span></div><div class="line"><span class="attr">updated:</span> <span class="string">&#123;&#123;</span> <span class="string">date</span> <span class="string">&#125;&#125;</span></div><div class="line"><span class="attr">tags:</span></div><div class="line"><span class="attr">categories:</span></div><div class="line"><span class="attr">keywords:</span></div><div class="line"><span class="meta">---</span></div></pre></td></tr></table></figure><h2><span id="添加自定义widget">添加自定义widget</span></h2><p>添加widget的方法很简单，首先在<code>/themes/light/layout/_widget/</code>文件夹中创建widget文件<code>your_widget.ejs</code>，然后在主题配置文件中加载你的widget，下面通过创建一个友情链的widget来看看具体操作。</p><p>友情链接包含<code>连接名称</code>和<code>连接地址</code>两个属性，看到有的<a href="http://zipperary.com/2013/05/30/hexo-guide-4/" target="_blank" rel="external">教程中</a>把友情连接直接静态地写在widget中，修改起来不方便，所以要借助主题配置文件<code>_config.yml</code>和Hexo提供的访问配置文件的对象<code>theme</code>。</p><p>首先，在<code>/themes/flight/_config.yml</code>文件中添加如下节。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">blogrolls:</span> <span class="comment">#友情链接</span></div><div class="line"><span class="attr">  - Hexo:</span> <span class="attr">http://zespia.tw/hexo/</span></div><div class="line"><span class="bullet">  -</span> <span class="string">Hexo</span> <span class="attr">Document:</span> <span class="attr">http://zespia.tw/hexo/docs/</span></div><div class="line"><span class="attr">  - github:</span> <span class="attr">https://github.com/</span></div><div class="line"><span class="attr">  - jQuery:</span> <span class="attr">http://jquery.com/</span></div></pre></td></tr></table></figure><p>然后，在<code>/themes/light/layout/_widget/</code>文件夹中创建友情连接widget文件<code>blogroll.ejs</code>，内容可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;% if (theme.blogrolls &amp;&amp; theme.blogrolls.length &gt; 0) &#123; %&gt;</div><div class="line">&lt;div class=&quot;widget tag&quot;&gt;</div><div class="line">  &lt;h3 class=&quot;title&quot;&gt;&lt;%= __(&apos;blogroll&apos;) %&gt;&lt;/h3&gt;</div><div class="line">  &lt;ul class=&quot;entry&quot;&gt;</div><div class="line">  &lt;% theme.blogrolls.forEach(function(item)&#123; %&gt;</div><div class="line">    &lt;%</div><div class="line">      var description, linkURL</div><div class="line">      for (var tmp in item) &#123;</div><div class="line">        description = tmp;</div><div class="line">        linkURL = item[tmp];</div><div class="line">      &#125;</div><div class="line">    %&gt;</div><div class="line">    &lt;li&gt;&lt;a href=&quot;&lt;%- linkURL %&gt;&quot; target=&quot;_blank&quot;&gt;&lt;%= description %&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">  &lt;% &#125;); %&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure><p>最后，修改主题配置文件<code>/themes/flight/_config.yml</code>，在<code>widgets</code>下增加<code>blogroll</code>。如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">widgets:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">category</span></div><div class="line"><span class="bullet">  -</span> <span class="string">tag</span></div><div class="line"><span class="bullet">  -</span> <span class="string">recent_posts</span></div><div class="line"><span class="bullet">  -</span> <span class="string">blogroll</span></div></pre></td></tr></table></figure><p>友情连接widget就创建好了，<code>hexo server</code>，在本地<code>http://localhost:4000/</code>查看效果吧！同样，我们可以使用此方法添加<code>个人说明</code>，<code>微博秀</code>等widget。</p><h2><span id="添加最新评论widget">添加最新评论widget</span></h2><p>首先需要声明的是本屌用的是多说评论系统，所以最新评论widget也是利用多说提供的API来实现，上一节已经分享了怎么创建自定义的widget，现在我们按照上面的方法来一步一步实现该widget。</p><p>在<code>/themes/light/layout/_widget/</code>文件夹下创建最新评论小挂件<code>recent_comments.ejs</code>，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;% if (theme.duoshuo)&#123; %&gt;</div><div class="line">&lt;div class=&quot;widget recent_comments&quot;&gt;</div><div class="line">  &lt;h3 class=&quot;title&quot;&gt;&lt;%= __(&apos;recent_comments&apos;) %&gt;&lt;/h3&gt;</div><div class="line">  &lt;ul class=&quot;entry ds-recent-comments&quot; data-num-items=&quot;5&quot; data-show-avatars=&quot;0&quot; data-show-title=&quot;1&quot; data-show-time=&quot;1&quot;&gt;&lt;/ul&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">  if(typeof duoshuoQuery === &apos;undefined&apos;)&#123;</div><div class="line">    var duoshuoQuery = &#123;short_name:&quot;&lt;%- theme.duoshuo %&gt;&quot;&#125;;</div><div class="line">    (function() &#123;</div><div class="line">      var ds = document.createElement(&apos;script&apos;);</div><div class="line">      ds.type = &apos;text/javascript&apos;;ds.async = true;</div><div class="line">      ds.src = &apos;http://static.duoshuo.com/embed.js&apos;;</div><div class="line">      ds.charset = &apos;UTF-8&apos;;</div><div class="line">      (document.getElementsByTagName(&apos;head&apos;)[0]</div><div class="line">      || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds);</div><div class="line">    &#125;)();</div><div class="line">  &#125;</div><div class="line">  &lt;/script&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure><p>简单说明，在每个页面中，如果使用多个多说控件，只需要添加一次多说js，所以这里有这样的判断<code>if(typeof duoshuoQuery===&#39;undefined&#39;)</code>，在需要用到多说的位置都加上这个判断，避免多次加载js文件；另外多说评论相关的参数：<code>data-num-items</code>显示的评论条数，<code>data-show-avatars</code>是否显示用户头像，<code>data-show-title</code>是否显示文章标题，<code>data-show-time</code>是否显示评论时间，具体参数说明可以参考多说<a href="http://dev.duoshuo.com/docs/4ff28d95552860f21f000010" target="_blank" rel="external">官方说明文档</a>，按照官方文档还可以添加多说<a href="http://dev.duoshuo.com/docs/4ff28d6f552860f21f00000c" target="_blank" rel="external">最近访客</a>小部件和<a href="http://dev.duoshuo.com/threads/5020f288e759c1107f00000c" target="_blank" rel="external">热评文章</a>小部件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天折腾了一下&lt;a href=&quot;http://zespia.tw/hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;，遇到一些问题，解决方案大都来自Google和&lt;a href=&quot;http://zespia.tw/hexo/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo官方文档&lt;/a&gt;，现在把这些问题汇总在这里，并附上解决方案，或者抛出自己遇到的问题，渴求解决方案。&lt;/p&gt;
&lt;p&gt;后续会陆续更新我在使用过程中遇到的问题和使用心得。&lt;/p&gt;
&lt;p&gt;注：这里不涉及Hexo的安装方法，具体的安装和使用可以参照下面教程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zipperary.com/categories/hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo系列教程 - Zippera’s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ibruce.info/2013/11/22/hexo-your-blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo你的博客 - ibruce&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jimliu.net/2013/09/08/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用hexo搭建静态博客 - Jim Liu’s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://beiyuu.com/github-pages/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用Github Pages建独立博客 - BeiYuu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yangjian.me/workspace/building-blog-with-hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用hexo搭建博客 - Alimon’s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.ishgo.cn/2013/09/15/ishgohexo%E5%9B%A2%E9%98%9F%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用Hexo快速打造静态博客 - iShgo 团队博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sys.la/2013/09/07/hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo教程 - Sys.La&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.gfdsa.net/2013/04/09/hexo/hexolessontwo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo主题制作 - youxiachai&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;给文章添加多个tag或category&quot;&gt;&lt;a href=&quot;#给文章添加多个tag或category&quot; class=&quot;headerlink&quot; title=&quot;给文章添加多个tag或category&quot;&gt;&lt;/a&gt;给文章添加多个tag或category&lt;/h2&gt;&lt;p&gt;第一次写Hexo的时候发现，如果这样写&lt;code&gt;tags:前端,Hexo,HTML,JavaScript&lt;/code&gt;，tag显示不是按照逗号分隔的方式显示，而是整个显示为一个tag，这显然不是我们需要的，经过研究可以采用如下两种方式给文章添加多tag，对于添加category同样适用。
    
    </summary>
    
    
      <category term="Hexo" scheme="http://bubkoo.com/tags/hexo/"/>
    
  </entry>
  
</feed>
